{"meta":{"title":"SwiftUI训练营","subtitle":"","description":"","author":"林克","url":"http://xuebusi.gitee.io","root":"/"},"pages":[{"title":"","date":"2024-03-25T11:19:25.705Z","updated":"2023-11-08T10:48:45.843Z","comments":false,"path":"categories/index.html","permalink":"http://xuebusi.gitee.io/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2023-11-08T07:21:58.000Z","updated":"2023-11-08T07:23:10.829Z","comments":false,"path":"about/index.html","permalink":"http://xuebusi.gitee.io/about/index.html","excerpt":"","text":"大家好，我是林克！"},{"title":"","date":"2024-03-25T11:19:25.705Z","updated":"2023-11-08T10:48:19.666Z","comments":false,"path":"tags/index.html","permalink":"http://xuebusi.gitee.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"macOS查看环境变量","slug":"macOS查看环境变量","date":"2024-03-22T07:30:58.000Z","updated":"2024-03-22T07:31:45.933Z","comments":true,"path":"2024/03/22/macOS查看环境变量/","permalink":"http://xuebusi.gitee.io/2024/03/22/macOS%E6%9F%A5%E7%9C%8B%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/","excerpt":"","text":"在macOS中，您可以通过终端查看和设置环境变量。以下是查看环境变量的方法： 打开终端。 输入 echo $PATH 来查看PATH变量，它通常包含执行的程序的路径。 要查看所有环境变量，可以使用 env 命令。 如果您想查看特定的环境变量，可以直接输入变量名，例如 echo $HOME 将显示当前用户的主目录。 以下是实际的命令示例： 查看PATH变量1echo $PATH 查看所有环境变量1env 查看特定的环境变量，例如HOME目录1echo $HOME 这些命令将在终端中输出相应的环境变量信息。","categories":[],"tags":[]},{"title":"DockerCompose脚本一键部署wordpress","slug":"DockerCompose一键部署wordpress","date":"2024-03-21T07:57:06.000Z","updated":"2024-03-21T08:23:51.928Z","comments":true,"path":"2024/03/21/DockerCompose一键部署wordpress/","permalink":"http://xuebusi.gitee.io/2024/03/21/DockerCompose%E4%B8%80%E9%94%AE%E9%83%A8%E7%BD%B2wordpress/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637version: &quot;3&quot; # Defines which compose version to useservices: # Services line define which Docker images to run. In this case, it will be MySQL server and WordPress image. docker-mysql: image: mysql:latest # image: mysql:latest indicates the MySQL database container image from Docker Hub used in this installation. restart: always ports: - &quot;3306:3306&quot; volumes: [&quot;./wordpress-mysql-data:/var/lib/mysql&quot;] environment: MYSQL_ROOT_PASSWORD: your_db_passwrod MYSQL_DATABASE: wordpress MYSQL_USER: your_db_user MYSQL_PASSWORD: your_db_passwrod # Previous four lines define the main variables needed for the MySQL container to work: database, database username, database user password, and the MySQL root password. wordpress: depends_on: - docker-mysql image: wordpress:latest restart: always # Restart line controls the restart mode, meaning if the container stops running for any reason, it will restart the process immediately. ports: - &quot;8000:80&quot; # The previous line defines the port that the WordPress container will use. After successful installation, the full path will look like this: http://localhost:8000 environment: WORDPRESS_DB_HOST: docker-mysql:3306 WORDPRESS_DB_USER: your_db_user WORDPRESS_DB_PASSWORD: your_db_passwrod WORDPRESS_DB_NAME: wordpress# Similar to MySQL image variables, the last four lines define the main variables needed for the WordPress container to work properly with the MySQL container. volumes: [&quot;./wordpress-html:/var/www/html&quot;]volumes: mysql: &#123;&#125;","categories":[],"tags":[]},{"title":"使用JavaNIO编写一个HelloWorld程序","slug":"使用JavaNIO编写一个HelloWorld程序","date":"2024-03-17T02:52:45.000Z","updated":"2024-03-17T02:53:00.142Z","comments":true,"path":"2024/03/17/使用JavaNIO编写一个HelloWorld程序/","permalink":"http://xuebusi.gitee.io/2024/03/17/%E4%BD%BF%E7%94%A8JavaNIO%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AAHelloWorld%E7%A8%8B%E5%BA%8F/","excerpt":"","text":"以下是一个简单的 Java NIO 客户端和服务端的 “Hello World” 程序： 服务端程序（Server.java）： 123456789101112131415161718192021222324252627282930313233343536373839import java.io.IOException;import java.net.InetSocketAddress;import java.nio.ByteBuffer;import java.nio.channels.ServerSocketChannel;import java.nio.channels.SocketChannel;public class Server &#123; public static void main(String[] args) &#123; try &#123; // 创建 ServerSocketChannel ServerSocketChannel serverSocketChannel = ServerSocketChannel.open(); // 绑定端口 serverSocketChannel.bind(new InetSocketAddress(9999)); System.out.println(&quot;Server started, listening on port 9999...&quot;); while (true) &#123; // 接受客户端连接 SocketChannel socketChannel = serverSocketChannel.accept(); // 读取数据 ByteBuffer buffer = ByteBuffer.allocate(1024); socketChannel.read(buffer); buffer.flip(); System.out.println(&quot;Received message from client: &quot; + new String(buffer.array()).trim()); // 发送响应 String response = &quot;Hello Client!&quot;; ByteBuffer responseBuffer = ByteBuffer.wrap(response.getBytes()); socketChannel.write(responseBuffer); // 关闭连接 socketChannel.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 客户端程序（Client.java）： 123456789101112131415161718192021222324252627282930313233import java.io.IOException;import java.net.InetSocketAddress;import java.nio.ByteBuffer;import java.nio.channels.SocketChannel;public class Client &#123; public static void main(String[] args) &#123; try &#123; // 创建 SocketChannel SocketChannel socketChannel = SocketChannel.open(); // 连接到服务器 socketChannel.connect(new InetSocketAddress(&quot;localhost&quot;, 9999)); System.out.println(&quot;Connected to server...&quot;); // 发送数据 String message = &quot;Hello Server!&quot;; ByteBuffer buffer = ByteBuffer.wrap(message.getBytes()); socketChannel.write(buffer); // 接收响应 ByteBuffer responseBuffer = ByteBuffer.allocate(1024); socketChannel.read(responseBuffer); responseBuffer.flip(); System.out.println(&quot;Received response from server: &quot; + new String(responseBuffer.array()).trim()); // 关闭连接 socketChannel.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 这个程序包括一个简单的客户端和服务器端。服务器监听端口9999，并在接收到客户端消息后，返回 “Hello Client!”。客户端连接到服务器，发送消息 “Hello Server!”，并打印出从服务器接收到的响应。","categories":[],"tags":[]},{"title":"Docker部署xxl-job步骤","slug":"Docker部署xxl-job-admin步骤","date":"2024-03-14T05:09:17.000Z","updated":"2024-03-14T05:23:58.635Z","comments":true,"path":"2024/03/14/Docker部署xxl-job-admin步骤/","permalink":"http://xuebusi.gitee.io/2024/03/14/Docker%E9%83%A8%E7%BD%B2xxl-job-admin%E6%AD%A5%E9%AA%A4/","excerpt":"","text":"使用Docker命令创建自定义网络1docker network create hdzl_net 使用Docker命令启动MySQL容器12345docker run -p 3306:3306 \\--name mysql \\-e MYSQL_ROOT_PASSWORD=qq490983587 \\--network hdzl_net \\-d mysql 在MySQL数据库中执行xxl-job数据库脚本在宿主机上使用连接mysql执行xxl-job-admin项目中提供的tables_xxl_job.sql脚本 1234主机地址：localhost端口：3306用户名：root密码：qq490983587 使用Docker命令启动xxl-job-admin1234567docker run \\-e PARAMS=&quot;--spring.datasource.url=jdbc:mysql://mysql:3306/xxl_job?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai --spring.datasource.username=root --spring.datasource.password=qq490983587&quot; \\-p 8080:8080 \\-v /Users/shiyanjun/logs:/data/applogs \\--network=hdzl_net \\--name xxl-job-admin \\-d xuxueli/xxl-job-admin:2.4.0 浏览器访问xxl-job-admin打开浏览器访问：http://localhost:8080/xxl-job-admin/登录用户名：admin登录密码：123456","categories":[],"tags":[]},{"title":"在Mac上如何终止某个端口所在的进程？","slug":"在Mac上如何终止某个端口所在的进程？","date":"2023-11-12T03:31:14.000Z","updated":"2023-11-12T03:32:14.994Z","comments":true,"path":"2023/11/12/在Mac上如何终止某个端口所在的进程？/","permalink":"http://xuebusi.gitee.io/2023/11/12/%E5%9C%A8Mac%E4%B8%8A%E5%A6%82%E4%BD%95%E7%BB%88%E6%AD%A2%E6%9F%90%E4%B8%AA%E7%AB%AF%E5%8F%A3%E6%89%80%E5%9C%A8%E7%9A%84%E8%BF%9B%E7%A8%8B%EF%BC%9F/","excerpt":"","text":"在Mac上终止占用特定端口的进程可以通过以下步骤来完成： 查找占用端口的进程：打开终端（Terminal），然后使用lsof命令来查找占用特定端口的进程。例如，如果你想查找占用端口8080的进程，可以使用以下命令： 1lsof -i :8080 这将列出所有占用端口8080的进程。输出中通常会包含进程ID（PID），这是一个数字。 终止进程：一旦你知道了进程ID，可以使用kill命令来终止该进程。例如，如果进程ID是1234，可以使用以下命令： 1kill 1234 如果进程拒绝终止，你可以使用更强制的方式，比如kill -9命令： 1kill -9 1234 这将强制终止该进程。 请注意，在使用这些命令时要小心，确保你终止的是正确的进程，因为错误地终止进程可能会影响系统的稳定性或其他应用的运行。","categories":[],"tags":[{"name":"Mac","slug":"Mac","permalink":"http://xuebusi.gitee.io/tags/Mac/"}]},{"title":"Java实现两台计算机之间长连接通信","slug":"Java实现两台计算机之间长连接通信","date":"2023-11-09T12:54:10.000Z","updated":"2023-11-09T12:55:57.056Z","comments":true,"path":"2023/11/09/Java实现两台计算机之间长连接通信/","permalink":"http://xuebusi.gitee.io/2023/11/09/Java%E5%AE%9E%E7%8E%B0%E4%B8%A4%E5%8F%B0%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E9%97%B4%E9%95%BF%E8%BF%9E%E6%8E%A5%E9%80%9A%E4%BF%A1/","excerpt":"","text":"要实现客户端和服务器端的长连接，即一直保持连接直到程序显式关闭，你可以在客户端和服务器端都使用循环来持续地发送和接收消息。下面是相应的代码示例： 服务器端（B计算机）服务器端持续监听客户端发送的消息。使用while(true)确保服务器始终在运行，等待和处理客户端的消息。 1234567891011121314151617181920212223import java.net.*;import java.io.*;public class Server &#123; public static void main(String[] args) throws IOException &#123; int port = 1234; ServerSocket serverSocket = new ServerSocket(port); System.out.println(&quot;等待连接...&quot;); Socket clientSocket = serverSocket.accept(); System.out.println(&quot;连接成功！&quot;); BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream())); String inputLine; while (true) &#123; // 一直保持监听状态 inputLine = in.readLine(); if (inputLine != null) &#123; System.out.println(&quot;收到: &quot; + inputLine); &#125; &#125; // 注意：实际应用中需要添加适当的退出条件和异常处理 &#125;&#125; 客户端（A计算机）客户端持续发送消息到服务器。在这个例子中，我们仅以发送时间作为消息的示例。 12345678910111213141516171819import java.net.*;import java.io.*;import java.util.Date;public class Client &#123; public static void main(String[] args) throws IOException, InterruptedException &#123; String serverAddress = &quot;服务器的IP地址&quot;; // 替换为B计算机的IP地址 int port = 1234; Socket socket = new Socket(serverAddress, port); PrintWriter out = new PrintWriter(socket.getOutputStream(), true); while (true) &#123; // 一直发送消息 out.println(&quot;当前时间: &quot; + new Date()); Thread.sleep(1000); // 每秒发送一次 &#125; // 注意：实际应用中需要添加适当的退出条件和异常处理 &#125;&#125; 在这两个示例中，我没有添加退出条件和异常处理，但这在实际应用中是非常重要的。你需要确保代码能够优雅地处理网络异常、I&#x2F;O异常以及如何安全地关闭连接。记住，长时间保持连接会增加资源消耗，确保服务器有足够的资源来处理这些长连接。","categories":[{"name":"Java","slug":"Java","permalink":"http://xuebusi.gitee.io/categories/Java/"}],"tags":[{"name":"Socket","slug":"Socket","permalink":"http://xuebusi.gitee.io/tags/Socket/"},{"name":"ServerSocket","slug":"ServerSocket","permalink":"http://xuebusi.gitee.io/tags/ServerSocket/"},{"name":"BufferedReader","slug":"BufferedReader","permalink":"http://xuebusi.gitee.io/tags/BufferedReader/"},{"name":"InputStreamReader","slug":"InputStreamReader","permalink":"http://xuebusi.gitee.io/tags/InputStreamReader/"},{"name":"PrintWriter","slug":"PrintWriter","permalink":"http://xuebusi.gitee.io/tags/PrintWriter/"}]},{"title":"Java实现两台计算机之间的简单通信","slug":"Java实现两台计算机之间的简单通信","date":"2023-11-09T12:41:22.000Z","updated":"2023-11-09T12:43:07.664Z","comments":true,"path":"2023/11/09/Java实现两台计算机之间的简单通信/","permalink":"http://xuebusi.gitee.io/2023/11/09/Java%E5%AE%9E%E7%8E%B0%E4%B8%A4%E5%8F%B0%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E9%97%B4%E7%9A%84%E7%AE%80%E5%8D%95%E9%80%9A%E4%BF%A1/","excerpt":"","text":"要在Java中实现从一台计算机（A）向另一台计算机（B）发送数据，你可以使用Java的套接字编程。这通常涉及到创建服务器端和客户端程序。服务器在B计算机上运行，监听一个端口等待连接；客户端运行在A计算机上，连接到服务器并发送数据。 这里是一个简单的示例： 服务器端（在B计算机上运行） 创建ServerSocket对象并指定一个端口。 调用accept方法等待客户端连接。 通过建立的连接读取数据。 关闭连接。 1234567891011121314151617181920212223import java.net.*;import java.io.*;public class Server &#123; public static void main(String[] args) throws IOException &#123; int port = 1234; // 选择一个端口 ServerSocket serverSocket = new ServerSocket(port); System.out.println(&quot;等待连接...&quot;); Socket clientSocket = serverSocket.accept(); System.out.println(&quot;连接成功！&quot;); BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream())); String inputLine; while ((inputLine = in.readLine()) != null) &#123; System.out.println(&quot;收到: &quot; + inputLine); &#125; in.close(); clientSocket.close(); serverSocket.close(); &#125;&#125; 客户端（在A计算机上运行） 创建Socket对象，指定服务器地址和端口。 获取输出流并发送数据。 关闭连接。 12345678910111213141516import java.net.*;import java.io.*;public class Client &#123; public static void main(String[] args) throws IOException &#123; String serverAddress = &quot;服务器的IP地址&quot;; // 替换为B计算机的IP地址 int port = 1234; Socket socket = new Socket(serverAddress, port); PrintWriter out = new PrintWriter(socket.getOutputStream(), true); out.println(&quot;你好，服务器！&quot;); out.close(); socket.close(); &#125;&#125; 注意： 请确保服务器和客户端使用相同的端口号。 需要处理网络异常和I&#x2F;O异常。 根据你的网络设置，你可能需要配置防火墙允许这些端口的通信。 在实际应用中，还需要考虑安全性和效率等问题。","categories":[{"name":"Java","slug":"Java","permalink":"http://xuebusi.gitee.io/categories/Java/"}],"tags":[{"name":"Socket","slug":"Socket","permalink":"http://xuebusi.gitee.io/tags/Socket/"},{"name":"ServerSocket","slug":"ServerSocket","permalink":"http://xuebusi.gitee.io/tags/ServerSocket/"}]},{"title":"使用Vapor编写用户信息CRUD的API接口","slug":"使用Vapor编写用户信息CRUD的API接口","date":"2023-11-09T00:49:10.000Z","updated":"2023-11-09T00:49:57.368Z","comments":true,"path":"2023/11/09/使用Vapor编写用户信息CRUD的API接口/","permalink":"http://xuebusi.gitee.io/2023/11/09/%E4%BD%BF%E7%94%A8Vapor%E7%BC%96%E5%86%99%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AFCRUD%E7%9A%84API%E6%8E%A5%E5%8F%A3/","excerpt":"","text":"很高兴你对Vapor框架感兴趣！Vapor 是一个用 Swift 编写的 Web 框架，非常适合于构建快速、可靠的服务端应用程序。接下来我会引导你如何使用 Vapor 创建一个简单的用户信息 CRUD（创建、读取、更新、删除）API。 环境准备首先，确保你的电脑上安装了以下软件： Swift: Vapor 是基于 Swift 的，所以你需要安装 Swift。 Vapor Toolbox: 这是一个命令行工具，用于简化 Vapor 项目的创建和管理。 创建新项目 打开终端。 使用 Vapor Toolbox 创建一个新项目：vapor new UserCRUDAPI。 进入项目目录：cd UserCRUDAPI。 设定模型和数据库为了简单起见，我们将使用内存数据库（SQLite），这样就不需要额外安装数据库软件。 定义用户模型：在 Sources/App/Models 目录下创建一个新的 Swift 文件 User.swift。 1234567891011121314151617181920212223import Vaporimport Fluentfinal class User: Model, Content &#123; static let schema = &quot;users&quot; @ID(key: .id) var id: UUID? @Field(key: &quot;name&quot;) var name: String @Field(key: &quot;email&quot;) var email: String init() &#123; &#125; init(id: UUID? = nil, name: String, email: String) &#123; self.id = id self.name = name self.email = email &#125;&#125; 配置数据库：在 Sources/App/configure.swift 文件中配置数据库。 1234567891011import Fluentimport FluentSQLiteDriverimport Vaporpublic func configure(_ app: Application) throws &#123; app.databases.use(.sqlite(.memory), as: .sqlite) app.migrations.add(CreateUser()) try app.autoMigrate().wait() // 其他配置...&#125; 创建数据库迁移：创建一个新的 Swift 文件 CreateUser.swift 在 Sources/App/Migrations。 123456789101112131415import Fluentstruct CreateUser: Migration &#123; func prepare(on database: Database) -&gt; EventLoopFuture&lt;Void&gt; &#123; database.schema(&quot;users&quot;) .id() .field(&quot;name&quot;, .string, .required) .field(&quot;email&quot;, .string, .required) .create() &#125; func revert(on database: Database) -&gt; EventLoopFuture&lt;Void&gt; &#123; database.schema(&quot;users&quot;).delete() &#125;&#125; 编写 CRUD 接口 创建路由：在 Sources/App/routes.swift 文件中定义路由和相应的处理函数。 123456789101112import Vaporfunc routes(_ app: Application) throws &#123; let userController = UserController() app.get(&quot;users&quot;, use: userController.index) app.post(&quot;users&quot;, use: userController.create) app.group(&quot;users&quot;) &#123; users in users.get(&quot;:userID&quot;, use: userController.show) users.put(&quot;:userID&quot;, use: userController.update) users.delete(&quot;:userID&quot;, use: userController.delete) &#125;&#125; 实现控制器：创建一个新的 Swift 文件 UserController.swift 在 Sources/App/Controllers。 123456789101112131415161718192021222324252627282930313233343536import Vaporstruct UserController &#123; func index(req: Request) throws -&gt; EventLoopFuture&lt;[User]&gt; &#123; return User.query(on: req.db).all() &#125; func create(req: Request) throws -&gt; EventLoopFuture&lt;User&gt; &#123; let user = try req.content.decode(User.self) return user.save(on: req.db).map &#123; user &#125; &#125; func show(req: Request) throws -&gt; EventLoopFuture&lt;User&gt; &#123; User.find(req.parameters.get(&quot;userID&quot;), on: req.db) .unwrap(or: Abort(.notFound)) &#125; func update(req: Request) throws -&gt; EventLoopFuture&lt;User&gt; &#123; let updatedUser = try req.content.decode(User.self) return User.find(req.parameters.get(&quot;userID&quot;), on: req.db) .unwrap(or: Abort(.notFound)).flatMap &#123; user in user.name = updatedUser.name user.email = updatedUser.email return user.save(on: req.db).map &#123; user &#125; &#125; &#125; func delete(req: Request) throws -&gt; EventLoopFuture&lt;HTTPStatus&gt; &#123; User.find(req.parameters.get(&quot;userID&quot;), on: req.db) .unwrap(or: Abort(.notFound)) .flatMap &#123; user in user.delete(on: req.db) .transform(to: .ok) &#125; &#125;&#125; 运行和测试 启动服务器：在项目根目录下运行 vapor run。 测试 API：使用 Postman 或任何 HTTP 客户端工具测试你的 API。 创建用户：POST /users，带上 JSON 请求体，比如 &#123;&quot;name&quot;: &quot;Alice&quot;, &quot;email&quot;: &quot;alice@example.com&quot;&#125;。 列出所有用户：GET /users。 获取单个用户：GET /users/:userID。 更新用户信息：PUT /users/:userID。 删除用户：DELETE /users/:userID。 总结在这个简单的示例中，我们创建了一个使用 Swift 和 Vapor 框架的 RESTful API，它可以处理基本的用户信息 CRUD 操作。这个示例使用了内存中的 SQLite 数据库，因此在服务器重启时，所有数据都会丢失。在实际应用中，你可能会使用 PostgreSQL 或 MySQL 等持久化的数据库。希望这对你学习 Vapor 有所帮助！","categories":[],"tags":[]},{"title":"SwiftUI核心技术第15章构建一个聊天APP","slug":"SwiftUI核心技术第15章构建一个聊天APP","date":"2023-11-08T02:24:42.000Z","updated":"2024-03-17T06:12:04.584Z","comments":true,"path":"2023/11/08/SwiftUI核心技术第15章构建一个聊天APP/","permalink":"http://xuebusi.gitee.io/2023/11/08/SwiftUI%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC15%E7%AB%A0%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%81%8A%E5%A4%A9APP/","excerpt":"","text":"第1小节：应用结构规划 在开发一个新的应用时，规划应用的结构是成功的关键。一个良好设计的应用结构可以提高代码的可维护性和扩展性，并使团队合作变得更加高效。本小节我们将讨论如何为我们的聊天应用进行结构规划。 应用概览我们的聊天应用将具备以下基本功能： 用户注册与登录 好友列表管理 实时消息传递 个人与群组聊天 消息通知 架构模式首先，我们需要选择一个适合于聊天应用的架构模式。考虑到SwiftUI的特性，我们选择MVVM（Model-View-ViewModel）作为主要架构，因为它能够很好地与SwiftUI的声明式UI和数据流工作模式配合。 分层设计我们的应用将分为以下几层： 视图层（View）：负责展示用户界面，捕获用户输入。 视图模型层（ViewModel）：处理视图逻辑，响应用户输入，与模型层通信。 模型层（Model）：定义数据结构和业务逻辑。 网络层：处理所有网络通信，例如发送和接收消息。 数据库层：负责数据持久化，存储历史消息和用户数据。 目录结构为了支持这种分层设计，我们的项目目录将如下组织： 12345678910111213141516171819202122232425ChatApp/├── Views/│ ├── LoginView.swift│ ├── ChatListView.swift│ ├── ChatView.swift│ └── ...├── ViewModels/│ ├── LoginViewModel.swift│ ├── ChatListViewModel.swift│ ├── ChatViewModel.swift│ └── ...├── Models/│ ├── User.swift│ ├── Message.swift│ ├── Conversation.swift│ └── ...├── Services/│ ├── AuthenticationService.swift│ ├── ChatService.swift│ ├── NotificationService.swift│ └── ...└── Utilities/ ├── Constants.swift ├── Extensions.swift └── ... 功能模块划分接下来，我们将应用分解为几个核心模块： 用户认证模块：包括用户注册、登录和验证。 联系人模块：用户的好友列表，添加和删除联系人。 聊天模块：展示消息历史，发送新消息，消息推送。 设置模块：用户可以修改个人信息，设置应用选项等。 数据流规划由于聊天应用需要实时的数据更新，我们将使用Combine框架来处理数据的发布和订阅，以确保用户界面能够响应数据的变化。 使用@Published属性包装器来自动管理数据的发布。 ViewModels将订阅Models的变化，并更新视图状态。 视图将绑定到视图模型的发布者，以获得数据变更的通知。 安全和隐私聊天应用需要格外注意安全和隐私： 采用安全的认证机制，如OAuth 2.0。 传输层加密，确保数据传输的安全。 数据库加密存储敏感信息。 用户体验（UX）用户体验是聊天应用成功的关键，我们需要确保： 界面简洁明了，易于导航。 消息即时传送，无明显延迟。 有声音和震动的通知反馈。 通过仔细规 划应用结构，我们为聊天应用的开发奠定了坚实的基础。后续小节中，我们将深入每个模块，开始具体的设计和编码工作。 第2小节：用户界面设计 用户界面（UI）设计是创建聊天应用的重要组成部分。一个直观、易用且美观的UI将极大地提升用户体验。在这一小节，我们将概述聊天应用的用户界面设计过程，包括布局、组件选择、颜色和动画的应用等方面。 UI设计原则在设计界面之前，我们首先确定几个核心设计原则： 一致性：整个应用的设计风格保持一致，包括按钮样式、字体、颜色等。 简洁性：避免不必要的元素，使用户可以集中于聊天功能。 直观性：确保用户能够直观地理解如何使用应用，无需额外学习。 响应式：界面应该能够适应不同设备和屏幕大小。 布局设计布局是UI设计的基础，我们将采用如下布局策略： 导航栏：位于屏幕顶部，包含用户的状态和导航控件。 消息列表：主屏幕显示消息列表，一览无余。 输入区：屏幕底部为消息输入区，包括文本输入框和发送按钮。 设置菜单：通过导航栏访问，包括个人资料编辑和应用设置。 组件设计我们将使用SwiftUI来构建以下组件： CustomButton：自定义按钮，用于登录、发送消息等。 ChatBubble：聊天气泡，区分自己和他人的消息。 UserAvatar：用户头像，显示在消息旁边和好友列表中。 TextField：自定义文本输入框，支持多行文本输入和表情。 颜色和主题颜色方案将支持暗黑模式和光亮模式，我们将定义一组基础颜色： 主色调：定义应用的主题颜色，如蓝色或绿色。 辅助色：用于强调按钮或重要信息。 背景色：分为深色和浅色变体，适应不同模式。 文字色：确保在任何背景色上都清晰可见。 图标和图形应用中的图标和图形将采用矢量图形，以确保在不同分辨率下都能清晰显示。我们将为每个主要功能选择直观的图标。 动画为了提升用户体验，我们将在以下方面应用动画： 页面切换：平滑过渡，增强用户操作的连贯感。 消息发送：消息框飞入聊天区域的动画。 加载指示器：在等待网络响应时提供动态反馈。 响应式设计我们的UI设计将采用响应式方法，以适应不同的设备和屏幕尺寸： 自适应布局：使用Stacks、Grids和Flexible Spaces确保组件在不同屏幕上都能正确布局。 动态字体大小：支持系统字体大小设置，适应用户的阅读需求。 交互设计最后，交互设计也是我们关注的重点： 触控反馈：按钮和可交互元素将提供触觉反馈。 滑动删除：在消息列表中轻松 滑动来删除消息或撤回。 通过上述设计，我们将创建一个美观、直观且功能强大的聊天应用用户界面。接下来，我们将在小节中进一步详细说明每个组件和功能的实现过程。 第3小节：应用逻辑实现 构建一个聊天应用不仅仅是设计外观上的美观与实用，应用的核心在于其逻辑实现。在本小节，我们将探讨如何在SwiftUI框架下实现聊天应用的基本逻辑，包括消息的发送与接收、状态管理以及实时更新等功能。 基础逻辑构建首先，我们需要建立应用的数据模型和业务逻辑层，这通常涉及以下几个关键部分： 用户模型（User Model）：定义用户的基本信息，如用户名、头像、状态等。 消息模型（Message Model）：定义消息的数据结构，包含发送者、接收者、消息内容、发送时间等。 会话列表（Conversations List）：存储用户的聊天会话，每个会话包含多条消息。 数据管理器（Data Manager）：负责处理数据的存取、更新以及同步。 消息发送与接收聊天的核心功能是消息的发送与接收，我们将通过以下步骤来实现： 输入与发送： 使用TextField或TextView获取用户输入的消息文本。 当用户点击发送按钮时，通过数据管理器将消息对象保存到会话列表中。 消息展示： 使用ScrollView和LazyVStack展示消息列表。 对于每条消息，使用ChatBubble视图来展示，根据发送者是自己还是对方来调整样式和位置。 实时更新： 通过Combine框架监听数据变化，实现消息的实时更新。 当有新消息时，更新UI以展示新消息。 状态管理在SwiftUI中，状态管理是一个重要的概念，它确保UI的正确性和数据的同步。我们将使用@State、@Binding、@ObservedObject等属性包装器来管理状态： 用户状态：使用@State管理用户的在线状态，比如在线、离开、忙碌等。 消息状态：使用@ObservedObject监控消息的发送和接收状态。 实时更新和同步为了实现聊天应用中的实时互动，我们将使用WebSocket或者Apple的CloudKit来进行网络通信，实现消息的即时推送： WebSocket连接：建立WebSocket连接来监听服务器发来的新消息。 CloudKit同步：如果使用CloudKit，则设置相应的记录类型和订阅，以便于新消息到来时可以立即更新。 聊天功能拓展除了基础的文本消息，我们还可以实现以下几个功能： 图片和视频发送：允许用户发送媒体文件，并在聊天气泡中预览。 消息状态标记：如已读、已发送等状态的标记。 通知与提醒：通过本地通知或推送通知，告知用户新消息的到来。 异常处理在实现聊天逻辑时，还需要考虑异常情况的处理： 网络异常：当网络不稳定或断开时，给用户适当的反馈，并尝试重新连接。 数据持久化：确保消息在本地被保存，即使应用关闭后也能恢复历史消息。 测试开发过程中，持续进行单元测试和集成测试来确保各个功能的可靠性，包括： 逻辑测试：对数据管理器和业务逻辑层进行测试。 UI测试：确保消息正确显示， 用户交互按预期工作。 总结在本小节中，我们详细探讨了构建聊天应用的应用逻辑实现。从用户界面的交互到后端的数据处理，每一步都是为了提供流畅而可靠的用户体验。通过上述步骤的实现，我们的聊天应用将能够处理实时的消息交流，拥有健壮的逻辑处理能力以及优雅的错误处理机制。接下来的小节，我们将继续深入探讨应用的其他关键功能和实现细节。 第4小节：数据持久化 在聊天应用中，数据持久化是保证用户信息、消息历史以及应用状态在不同会话间能够得到保存和恢复的关键技术。不仅仅是为了增强用户体验，数据持久化同样是数据安全和隐私的重要组成部分。在本小节中，我们将讨论在SwiftUI应用中实现数据持久化的策略和技术。 持久化选项SwiftUI应用中，我们可以选择多种方式来实现数据持久化： UserDefaults：适合存储少量的用户偏好设置或简单的应用状态。 文件系统：适合存储大量数据，如日志文件或者用户生成的内容。 SQLite数据库：适合复杂的数据结构和大量数据的管理。 Core Data：苹果推荐的解决方案，集成了SQLite，并提供了丰富的数据管理功能。 CloudKit：允许数据在设备间同步，同时保留在iCloud上。 Core Data集成我们将以Core Data为例，探讨如何在SwiftUI聊天应用中实现数据持久化。 设置Core Data堆栈：这包括了NSPersistentContainer的创建和配置，它将负责管理数据模型和协调数据存储。 定义数据模型：在.xcdatamodeld文件中定义实体（Entity），包括User和Message等，并设置好它们的属性和关系。 管理上下文（Context）：使用NSManagedObjectContext来管理对象的生命周期，实现数据的增删改查操作。 数据存储和检索 存储消息：当用户发送消息时，创建Message的实例，并通过上下文将其插入到持久化存储中。 读取会话：加载聊天会话时，从Core Data中检索相关联的Message实例，根据时间戳排序后显示在界面上。 同步和更新 监听数据变化：利用NSFetchedResultsController监听Core Data模型的变化，当新消息被插入时，自动刷新UI。 后台更新：通过performBackgroundTask方法在后台线程上进行数据更新操作，以避免阻塞UI线程。 错误处理 处理Core Data错误：在进行数据操作时，正确处理NSManagedObjectContext的保存（save）操作可能出现的错误。 数据迁移：为了应对未来数据模型的变化，实现Core Data的数据迁移策略。 测试与维护 单元测试：为数据模型的创建、更新、删除编写单元测试，确保数据层逻辑的正确性。 数据清理：实现数据清理策略，比如删除过旧的消息，避免数据库不断增大。 总结数据持久化不仅能提高用户体验，同时对于保证数据的安全性和完整性也至关重要。通过使用Core Data，我们可以为聊天应用提供一个强大、灵活且易于维护的数据存储方案。在聊天应用中实现了数据持久化之后，无论用户何时回到应用，都能够立即接入到他们离开时的状态，保持流畅的聊天体验。在下一小节中，我们将进一步探讨如何将我们的聊天应用与云服务（如CloudKit）整合，实现跨设备的数据同步功能。 第5小节：网络请求和数据处理 当我们在构建一个现代的聊天应用时，网络请求成为了一个核心部分，它负责从远程服务器获取数据以及将数据推送到服务器。在本小节中，我们将介绍如何在聊天应用中处理网络请求和数据。 设计API接口在开始编写代码之前，我们需要设计我们聊天应用所需的API接口。这些接口应包括： 用户注册与登录 消息发送与接收 用户状态更新 好友列表和消息历史获取 API设计应该遵循RESTful原则或者使用更现代的GraphQL。 使用Swift的网络框架Swift提供了多种网络请求的方法，如URLSession，它是一个强大且灵活的网络通信框架。 创建网络请求：使用URLRequest构建请求，包括URL、HTTP方法（如GET、POST）、请求头和请求体。 发送请求和接收响应：利用URLSession发起请求，并通过URLSessionDataTask处理回调。 解析JSON数据：使用JSONDecoder将服务器返回的JSON数据解析成Swift的结构体。 异步和等待SwiftUI 与 Swift 5.5 引入的 async&#x2F;await 一起，可以大大简化异步网络请求的处理。 异步函数：定义异步函数来发起网络请求，使用await关键字等待响应。 错误处理：使用do-catch语句捕获并处理网络请求或数据解析中可能发生的错误。 数据模型和解析定义数据模型来对应API返回的数据格式。 12345678910111213struct User: Codable &#123; var id: String var name: String // ...&#125;struct Message: Codable &#123; var senderId: String var receiverId: String var content: String var timestamp: Date // ...&#125; 使用Codable协议自动将JSON数据和模型进行映射。 实时聊天功能对于聊天应用来说，实时通讯是必不可少的。WebSocket 是一种在单个TCP连接上进行全双工通讯的协议。 使用WebSocket：通过URLSessionWebSocketTask来与服务器建立WebSocket连接。 接收消息：监听WebSocket的消息事件来实时接收新消息。 发送消息：发送消息通过WebSocket实时传递给其他用户。 网络状态监听考虑到网络状态可能时常变化，应用应能响应网络状态的改变。 使用Reachability：检测网络连接状态，根据网络状况提示用户或执行重连策略。 网络指示器：提供用户界面反馈，例如当应用正在进行网络请求时显示加载指示器。 安全性安全性是聊天应用中一个重要的议题。 使用HTTPS：确保所有的网络请求都通过安全的HTTP连接进行。 身份验证：使用OAuth、JWT等机制来管理和验证用户身份。 数据加密：对敏感数据进行加密，确保即使在传输过程中数据被截获也无法被解读。 测试网络请求的测试至关重要。 单元测试：为网络请求编写单元测试，使用Mock对象来模拟网络响应。 集成测试：确保网络请求与应用其他部分的整合运行无误。 总结网络请求和数据处理是构建聊天应用的核心部分。利用Swift的现代编程特性和网络框架，我们可以有效地发送请求、接收响应、处理数据，并保证用户信息的安全性。在下一小节中，我们将讨论如何 实现跨平台的消息推送通知，这是提升用户体验的另一个关键点。 第6小节：应用测试和发布准备 在开发完一个应用后，进行彻底的测试并做好发布前的各种准备工作是至关重要的。这一步骤确保了你的应用能够在广泛发布之前，满足质量标准，减少可能的错误或问题，为最终用户提供良好的体验。 应用测试单元测试：为应用的每一个独立模块编写单元测试，验证逻辑的正确性。在聊天应用中，需要确保消息处理、用户认证、数据解析等核心功能的准确无误。 1234567891011import XCTest@testable import ChatAppclass ChatAppTests: XCTestCase &#123; func testMessageParsing() &#123; let json = &quot;&#123; \\&quot;senderId\\&quot;: \\&quot;1\\&quot;, \\&quot;receiverId\\&quot;: \\&quot;2\\&quot;, \\&quot;content\\&quot;: \\&quot;Hello\\&quot; &#125;&quot; let data = Data(json.utf8) let message = try? JSONDecoder().decode(Message.self, from: data) XCTAssertNotNil(message) &#125;&#125; 集成测试：检查应用中各个模块之间的交互是否正确。这包括用户界面流程的测试，确保视图控制器和视图模型间的交互按预期工作。 性能测试：确保应用的性能达标。例如，消息加载和发送的速度要快，内存消耗要低。 安全性测试：验证应用的安全措施，包括数据加密和身份验证流程。 用户界面测试UI测试：自动化测试用户界面，确保用户的交互行为如点击、滚动、输入等能够产生预期的结果。 12345678910111213141516171819import XCTestclass ChatAppUITests: XCTestCase &#123; func testChatFlow() &#123; let app = XCUIApplication() app.launch() let messageTextField = app.textFields[&quot;messageTextField&quot;] messageTextField.tap() messageTextField.typeText(&quot;Hello, World!&quot;) let sendButton = app.buttons[&quot;sendButton&quot;] sendButton.tap() // 验证消息是否显示在聊天界面上 let chatBubble = app.staticTexts[&quot;Hello, World!&quot;] XCTAssertTrue(chatBubble.exists) &#125;&#125; 可访问性测试：确保应用支持VoiceOver等辅助功能，使得所有用户都能使用你的应用。 发布前的准备Beta测试：通过TestFlight或类似的服务，发布应用的测试版本，邀请用户参与beta测试。 性能优化：回顾代码，查找并优化可能的性能瓶颈，如减少不必要的网络请求，优化图片加载。 本地化：确保应用支持多语言，包括界面文本和用户内容的适当本地化。 应用商店优化（ASO）：为了在应用商店中获得更好的曝光，优化应用的标题、描述、关键字和截图。 隐私政策和用户协议：准备并审核应用的隐私政策和用户协议文档，确保符合法律法规和应用商店的要求。 备份和恢复策略：确保应用支持数据备份和恢复功能，以便用户更换设备后可以恢复数据。 总结确保你的聊天应用在发布前通过了各种形式的测试，这包括了功能、性能、安全性和用户界面的测试。同时，完成发布前的各项准备工作，确保你的应用在上架后能够吸引用户并且避免法律风险。","categories":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"http://xuebusi.gitee.io/categories/SwiftUI/"}],"tags":[]},{"title":"SwiftUI核心技术第14章测试与调试","slug":"SwiftUI核心技术第14章测试与调试","date":"2023-11-08T01:49:07.000Z","updated":"2024-03-17T06:12:01.380Z","comments":true,"path":"2023/11/08/SwiftUI核心技术第14章测试与调试/","permalink":"http://xuebusi.gitee.io/2023/11/08/SwiftUI%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC14%E7%AB%A0%E6%B5%8B%E8%AF%95%E4%B8%8E%E8%B0%83%E8%AF%95/","excerpt":"","text":"第1小节：单元测试和UI测试 在软件开发过程中，测试是确保应用质量的关键步骤。SwiftUI应用的测试主要分为单元测试和UI测试两种。单元测试确保代码逻辑的正确性，而UI测试确保用户界面的行为与期望一致。本节将详细介绍如何在SwiftUI中实施有效的单元测试和UI测试策略。 单元测试单元测试是在最小的代码单位级别上验证功能正确性的测试。在Swift中，单元测试通常是针对独立的函数或对象进行的。 设计可测试的代码 解耦和模块化：确保代码是松耦合和高内聚的，这样更容易编写测试。 依赖注入：通过依赖注入可以在测试时替换实际的依赖，以实现更精确的测试。 使用协议和Mock对象：定义接口并在测试中使用Mock对象来模拟真实对象。 编写单元测试 XCTest框架：使用Xcode集成的XCTest框架编写测试用例。 Assert函数：使用assert函数（如XCTAssertTrue, XCTAssertEqual等）验证预期结果。 测试边界条件：确保测试边界情况和异常情况。 UI测试UI测试模拟用户与应用界面的交互，验证UI元素的存在性、状态和应用的响应性。 配置UI测试环境 使用XCTestUI框架：XCTestUI提供了一套工具用于编写UI测试。 Accessibility标识：给UI元素设置Accessibility标识，以便测试脚本可以准确地定位它们。 编写UI测试脚本 记录UI交互：Xcode提供了UI测试录制功能，可以自动生成用户交互的基本代码。 编写测试用例：基于录制的代码，编写完整的测试用例来验证特定的UI行为。 断言验证：使用断言来验证UI状态是否符合预期。 测试最佳实践 持续集成（CI）：将测试集成到持续集成流程中，确保每次提交都通过测试。 代码覆盖率：监控代码覆盖率，尽量使之覆盖所有的代码路径。 性能测试：包含性能测试来验证关键功能的响应时间。 定期回归测试：每次代码更新后进行回归测试，确保新改动没有引入新的错误。 通过遵循上述方法，您可以为SwiftUI应用实施一套全面的测试策略，显著提高应用的质量和可靠性。记得，测试是一个持续的过程，应随着应用的迭代而不断更新和完善。 第2小节：使用Xcode调试 调试是发现、定位并修正编程错误过程。Xcode提供了强大的调试工具，它们可以帮助开发者理解代码在运行时的行为，并有效地找到并解决问题。在这一小节中，我们将深入探讨如何使用Xcode来调试SwiftUI应用。 断点（Breakpoints）断点是调试中的一个核心概念，它允许你在特定的代码行暂停代码执行，以便你可以检查此时的变量状态和应用逻辑。 设置断点 标准断点：点击Xcode编辑器左侧的边栏，即可在代码行旁设置断点。 条件断点：断点可设置条件，使之仅在满足特定条件时才触发。 动作断点：在触发断点时自动执行一个特定的动作，如打印一条日志信息。 调试面板当代码在断点处停止时，Xcode的调试面板会提供多种工具来帮助你理解代码的状态。 变量查看器：显示当前作用域内所有变量的值。 调用堆栈查看器：查看函数调用堆栈，了解当前代码执行的路径。 内存检查器：检查应用的内存使用情况，发现潜在的内存泄露。 控制流使用调试面板的控件来控制应用的执行流。 继续执行（Continue）：继续执行代码直到下一个断点。 逐步执行（Step Over）：执行当前行，并在下一行停止。 深入执行（Step Into）：如果当前行调用了一个函数，进入该函数内部。 跳出执行（Step Out）：从当前函数跳出，回到上一层函数。 LLDB调试器LLDB是Xcode使用的底层调试器。你可以使用LLDB控制台来执行更复杂的调试命令。 打印变量：使用po命令打印变量的描述。 设置变量值：直接在调试会话中修改变量的值。 执行表达式：使用expr命令执行代码表达式。 性能分析Xcode的Instrument工具可以用来分析应用的性能问题。 时间分析器：查看CPU的使用情况以及代码执行的时间。 内存分析器：分析应用的内存使用模式和潜在的内存泄露。 网络分析器：检查应用的网络请求和响应。 Xcode调试技巧 视图调试（View Debugging）：可视化地检查UI元素的布局和属性。 条件表达式：使用条件表达式来精确控制断点的触发时机。 符号断点：在特定的系统函数或方法调用时触发断点。 通过熟练使用Xcode的调试工具，你将能够更快地发现问题所在，并对SwiftUI应用进行高效的故障排查。记得，耐心和细心是调试过程中的良师益友，不断实践将使你成为更高效的开发者。 第3小节：预览与条件编译 SwiftUI 的预览功能是其最具革命性的特点之一，它允许开发者在不运行整个应用的情况下快速迭代和测试其视图。条件编译则是一种控制代码在不同环境下如何编译的方法。在这一小节中，我们将讨论如何使用这两个强大的功能来提高开发效率和代码质量。 使用SwiftUI预览SwiftUI的Canvas视图提供了一个实时预览，它显示了你的用户界面组件在实际应用中的外观和表现。以下是如何高效使用SwiftUI预览的指南： 基本预览：每个SwiftUI视图都可以有一个或多个预览。通过创建PreviewProvider的实现，你可以快速看到你的UI更改的效果。 多设备预览：在预览提供者中，你可以设置多个预览设备和配置，同时查看在不同设备和方向上的界面表现。 动态预览：通过添加预览参数，如不同的字体大小、颜色主题（包括Dark Mode）和辅助功能设置，你可以查看你的视图在不同用户设置下的表现。 交互式预览：你可以在Canvas中与UI交互，例如点击按钮或切换开关，这有助于测试视图的响应性。 实时数据预览：将模型对象注入到预览中，使你可以用实际数据来展示和测试视图。 条件编译在Swift中，可以使用编译配置来为不同的编译目标提供不同的代码路径。这对于处理开发和生产环境的差异至关重要。 编译标志：使用#if、#elseif和#endif指令来控制哪些代码块应被编译。这常用于开发和生产环境的日志记录和配置。 平台特定代码：可以检查os(macOS)、os(iOS)等条件，来编写只在特定操作系统上编译的代码。 功能特性检查：使用canImport(module)来确定是否可以导入一个特定的模块，这在跨多个Swift版本或平台时很有用。 调试与发布区分：使用DEBUG标识符来保证某些代码仅在调试构建中编译，而在发布构建中不会包含这些代码。 组合预览与条件编译将SwiftUI预览和条件编译相结合，可以创建更为强大和灵活的开发环境。 预览特定配置：为不同的预览目标配置不同的环境变量或者模拟数据。 隐藏调试UI：使用条件编译隐藏调试时用到的UI元素，以免它们出现在生产版本的应用中。 通过利用这些工具，你可以确保在开发过程中，你的应用表现出色，并且在上线前能有效地去除所有不必要的测试代码。这样的实践不仅可以提高代码的质量，也能显著减少调试和测试时的工作量。预览和条件编译应当成为每一个SwiftUI开发者工具箱中的核心部分。","categories":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"http://xuebusi.gitee.io/categories/SwiftUI/"}],"tags":[]},{"title":"SwiftUI核心技术第13章性能优化","slug":"SwiftUI核心技术第13章性能优化","date":"2023-11-08T01:43:56.000Z","updated":"2024-03-17T06:11:58.265Z","comments":true,"path":"2023/11/08/SwiftUI核心技术第13章性能优化/","permalink":"http://xuebusi.gitee.io/2023/11/08/SwiftUI%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC13%E7%AB%A0%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/","excerpt":"","text":"第13章：性能优化 第1小节：诊断和解决性能问题 性能优化是软件开发中的关键步骤，特别是对于那些要求快速响应和流畅体验的应用。性能问题可能是由许多因素造成的，包括但不限于内存泄漏、过度渲染、网络延迟或者不高效的数据结构和算法。有效的性能优化往往从准确诊断问题开始。 1. 性能评估在深入代码优化之前，首先要进行一个全面的性能评估。使用Xcode自带的Instrument工具可以帮助检测应用的CPU使用率、内存泄漏、能耗和网络性能等。 2. 识别瓶颈在性能评估之后，需要确定应用中的性能瓶颈。通过分析Instruments的报告，可以识别出CPU和内存的高消耗区域。对于图形密集型的应用，可能还需要检查GPU的使用情况。 3. 代码分析与调优一旦确定了瓶颈，就可以开始针对性的代码优化了。这可能包括： 优化算法和数据结构：改进或替换那些复杂度高的算法和数据结构。 减少计算量：避免不必要的计算，特别是在渲染和布局的过程中。 异步执行：使用异步编程模式来避免UI线程阻塞。 资源优化：优化图像和资源的加载，确保它们是压缩的且以正确的尺寸使用。 4. 内存管理内存问题，尤其是内存泄漏，是性能问题的常见原因。使用ARC（自动引用计数）应该是管理内存的首选方法，但开发者仍需避免循环引用，及时释放不再使用的对象。 5. 网络优化应用的响应时间很大程度上受网络状况的影响。通过优化API调用，使用缓存和数据预加载技术，可以显著提高性能。 6. 测试与监控 单元测试：编写单元测试来确保代码的效率。 性能测试：模拟高负载情况下应用的表现。 监控：发布应用后，继续监控其性能，并根据用户反馈和数据进行调整。 7. 优化策略 延迟加载：只有当需要时才加载数据或执行计算。 预计算和缓存：预计算重复计算的结果并进行缓存。 复用和回收：在可能的情况下复用对象和视图。 8. 持续优化性能优化不是一次性的任务，而是一个持续的过程。随着应用的发展和用户基础的增长，应持续关注性能指标，并进行相应的优化。 通过遵循上述步骤，开发者可以诊断出性能问题的根本原因，并采取相应的措施来解决问题。从用户体验的角度出发，提升应用的性能将直接影响到应用的成功与否。 第2小节：延迟加载和内存管理 在移动应用开发中，高效的内存使用是至关重要的。用户设备的内存资源有限，如果应用消耗过多内存，会影响用户体验，并可能导致应用被系统终止。延迟加载（Lazy Loading）和精心的内存管理是优化应用性能的关键策略。 延迟加载（Lazy Loading）延迟加载是一种在需要时才加载数据或对象到内存的策略。这种方法可以减少应用的启动时间，降低内存消耗，提高整体性能。 实施延迟加载的策略： 按需实例化：仅当确实需要显示或处理某个对象时，才创建该对象的实例。 视图渲染优化：对于列表和滚动视图，可以使用如SwiftUI的LazyVStack和LazyHStack，这些组件能确保只有那些在屏幕上的视图才会被加载和渲染。 数据获取：对于网络请求，可以实现预加载和按页面分段加载数据，避免一次性加载大量数据。 资源管理：对图像和视频等大型文件进行按需加载，并考虑实现缓存机制。 内存管理良好的内存管理可以避免内存泄漏和过度消耗，从而提高应用性能。 内存管理的关键点： 自动引用计数（ARC）：理解并正确使用ARC是必要的，避免循环引用和内存泄漏。 弱引用和无主引用：在闭包和委托模式中使用weak和unowned关键字来避免强引用循环。 资源释放：及时释放不再需要的对象，特别是在处理大型对象和文件时。 内存警告处理：正确处理内存警告，释放可以释放的资源，避免应用被系统终止。 内存分析工具：使用Xcode的Memory Graph Debugger和Leaks工具定期检查内存问题。 实施内存管理的技术： 使用deinit进行清理：当对象被销毁时，确保释放它持有的资源。 缓存策略：智能地实施缓存策略，既要提高数据访问的效率，又要避免过度消耗内存。 内存池：对于频繁创建和销毁的小对象，可以使用内存池来管理。 对象复用：例如，在UITableView中复用cell，而不是每次都创建新的cell。 通过延迟加载和内存管理，开发者可以显著提高应用的性能和用户体验。理解和正确实现这些概念将使应用在不同设备和操作系统上更加稳定和流畅。 第3小节：视图更新效率优化 在现代移动应用中，保持流畅的用户界面至关重要。在SwiftUI中，视图更新的效率直接影响到用户体验。这一小节将探讨如何优化视图更新的效率。 理解视图更新机制首先，我们需要理解SwiftUI是如何处理视图更新的。SwiftUI视图是声明式的，这意味着你定义的是视图的期望状态，而非状态变化的过程。当视图的状态发生变化时，SwiftUI会重新计算视图的body属性。 管理状态变化 最小化状态变化：确保只有真正需要更新的视图状态时才进行更改。 精确的观察：使用@State、@Binding、@ObservedObject和@EnvironmentObject智能地观察模型的变化。 避免不必要的视图更新不必要的视图重建会浪费资源并降低性能。 实现策略： **合理使用Equatable**：对于自定义视图，实现Equatable协议并在shouldUpdate中提供差异对比，以避免相同状态时的重建。 条件式视图更新：通过逻辑判断确保只有当状态确实改变时才更新视图。 局部更新：使用.id()修饰符或其他方式来提示SwiftUI哪些部分的视图是稳定的，不需要重建。 高效的数据流数据流向视图的方式也影响更新效率。 优化数据流的方法： 使用@State进行本地状态管理：对于视图私有的状态，使用@State来进行本地化管理。 利用@ObservedObject和@EnvironmentObject共享状态：对于需要在多个视图间共享的状态，可以使用这些属性包装器。 性能分析工具使用Xcode提供的性能分析工具来查找性能瓶颈。 分析方法： 时间分析器：利用Xcode的时间分析器查看哪些部分的代码耗时最多。 SwiftUI预览性能检查：在SwiftUI预览中测试视图更新，观察是否有延迟。 最佳实践 延迟复杂计算：对于复杂的视图计算，可以考虑将其推迟到视图显示之后的背景线程。 异步图片加载：对于图片和其他媒体资源，使用异步加载以避免阻塞UI线程。 智能组件分割：将复杂视图拆分成更小的、可以独立更新的组件。 通过以上策略，可以确保SwiftUI应用中的视图更新是高效的，从而提供流畅的用户体验。记住，性能调优是一个持续的过程，定期的性能评测和分析是非常必要的。","categories":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"http://xuebusi.gitee.io/categories/SwiftUI/"}],"tags":[]},{"title":"SwiftUI核心技术第12章Dark Mode和Accessibility","slug":"SwiftUI核心技术第12章Dark-Mode和Accessibility","date":"2023-11-08T01:33:25.000Z","updated":"2024-03-17T06:11:54.398Z","comments":true,"path":"2023/11/08/SwiftUI核心技术第12章Dark-Mode和Accessibility/","permalink":"http://xuebusi.gitee.io/2023/11/08/SwiftUI%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC12%E7%AB%A0Dark-Mode%E5%92%8CAccessibility/","excerpt":"","text":"第12章：Dark Mode和Accessibility 第1小节：支持暗黑模式 随着用户对于在不同光照条件下使用设备的需求增加，暗黑模式（Dark Mode）成为了现代应用设计不可或缺的一部分。它不仅有助于减少在低光环境下使用设备时的眼睛疲劳，还能为电池续航带来好处，特别是在OLED屏幕上。此外，暗黑模式还能为用户提供一个更为集中和减少分心的视觉环境。 理解暗黑模式 色彩转换 - 暗黑模式不仅仅是将背景设置为黑色和文本设置为白色那么简单。它涉及到色彩配色的整体调整，以确保可读性、可访问性和品牌一致性。 图层和深度 - 暗色背景提升了颜色对比，这意味着阴影和高亮可以用来模拟层次感和深度。 用户控制 - 用户应当能够选择在明亮或暗黑模式下使用应用，或让应用跟随系统设置自动切换。 设计指南 颜色主题 - 定义一套色彩主题，包括在暗黑模式下使用的色彩。应使用较亮的色调和透明度来增加层次感，同时避免使用纯白色，以减少对比度导致的刺眼感。 组件和控件 - 确保所有UI组件和控件在暗黑模式下都是可见的，并且它们的状态（如激活、禁用）在两种模式下都清晰。 图片和媒体 - 对于暗黑模式，应考虑使用较暗的图片和插图，或者为图片添加蒙版或过滤器，以适应暗背景。 文本对比度 - 文本应当足够对比，以确保在暗背景下的可读性。对于文本阴影和轮廓也应进行调整。 技术实现 Asset Catalogs - 在Xcode的Asset Catalogs中，可以为每种颜色定义亮色和暗色两个版本。 CSS支持 - 在Web内容中，可以使用CSS的prefers-color-scheme查询来为网页添加暗黑模式支持。 SwiftUI - 在SwiftUI中，可以通过.environment(\\.colorScheme, .dark)为预览添加暗黑模式的支持。对于动态颜色，可以使用Color结构体内置的暗黑模式适配。 UIKit - 在UIKit中，可以使用traitCollection.userInterfaceStyle来检查当前的界面风格，并在需要时调整UI元素的样式。 最佳实践 测试 - 在两种模式下都对应用进行全面的测试，确保UI元素的可见性和功能的可用性。 用户设置 - 提供设置选项，允许用户根据个人喜好切换模式。 跟随系统 - 默认情况下，应用应当跟随系统的暗黑模式设置，以保持用户体验的一致性。 节能考量 - 利用暗黑模式的节能优势，在OLED屏幕上通过使用更多真正的黑色来减少能耗。 无障碍 - 确保暗黑模 式下的色彩对比满足无障碍标准，以便色弱和视力障碍用户也能舒适使用。 通过以上的设计和技术实现指南，开发者可以为其应用成功地集成暗黑模式，不仅提高了应用的美观性，同时也照顾到了用户的实际使用需求和舒适度。 第2小节：辅助功能的最佳实践 辅助功能（Accessibility）是确保所有用户，包括那些有视力、听力、运动或学习障碍的人，能够有效使用你的应用的关键组成部分。对于应用开发者来说，这不仅仅是一项法律义务或道德责任，更是一种设计上的优秀实践，它能够扩大应用的潜在用户群体，并提升用户体验。 认识辅助功能的范畴 多感官接入 - 保证信息的传递不仅限于一种感官，例如，对于视觉信息，提供文本描述或声音解释。 易用性 - 确保应用的操作简单明了，尤其是对于运动障碍用户，考虑到触摸目标的大小和屏幕的可达性。 可见性 - 包含字体大小的调整、高对比度模式以及颜色不是传达重要信息的唯一方式。 认知考虑 - 设计简洁、一致的界面，减少认知负担，特别是为了那些有认知障碍的用户。 设计指南 文本可读性 - 提供文本大小调整的功能，支持系统级别的“辅助功能”设置。 高对比度 - 提供高对比度主题或模式，辅以清晰的字体，帮助视觉障碍用户更好地识别内容。 颜色盲友好 - 设计UI时不要完全依赖颜色来区分元素或传达信息，使用图形符号或标签作为辅助。 标签和说明 - 所有的交互控件都应该有清晰的标签，辅以适当的声音或触觉反馈。 语音控制 - 支持通过语音命令进行控制，为那些无法使用传统输入设备的用户提供便利。 技术实现 VoiceOver&#x2F;Speak Screen - 确保SwiftUI或UIKit组件正确实现了辅助功能标签和行为，以便VoiceOver能够读取屏幕上的内容。 动态字体大小 - 使用UIFont.preferredFont(forTextStyle:)和SwiftUI中的.font(.system(size:))来响应用户的字体大小设置。 UIAccessibility协议 - 通过实现相关的UIAccessibility协议来自定义非标准UI组件的辅助功能行为。 辅助功能快捷方式 - 通过设置快捷方式让用户能够快速访问常用的辅助功能。 最佳实践 持续测试 - 在开发过程中，经常使用辅助功能进行测试，确保所有用户在使用应用时的体验一致。 社群参与 - 与残障社群合作，获取真实的反馈，并根据这些反馈改进产品。 遵循标准 - 遵循WCAG（Web Content Accessibility Guidelines）等国际标准来设计和开发应用。 教育和文档 - 提供有关如何使用应用中辅助功能的文档或视频教程。 UI测试和自动化 - 利用自动化测试框架来验证辅助功能的实现，确保在应用更新后功能依然可用。 通过实施这些最 佳实践，开发者不仅能够提供一个包容性更强的应用体验，同时也能满足日益增长的多样化用户需求，构建起更加广泛的用户基础。 第3小节：动态字体与国际化 设计一个能够轻松适应不同语言和区域设置的用户界面，以及支持动态字体大小调整，是为了确保应用能够覆盖更广泛的用户群体，特别是那些有特定阅读需求的用户。 动态字体的重要性动态字体允许用户根据自己的视力需求来调整字体的大小。这对于那些需要辅助设备阅读的用户尤为重要。 实现动态字体 使用系统字体尺寸 - 利用系统提供的字体大小，如在SwiftUI中使用.font(.system(size:))。 响应用户设置 - 应用应该能够响应并遵循用户的辅助功能设置，比如“更大字体”选项。 字体可伸缩性 - 保证应用的布局可以适应不同的字体大小而不会破坏界面设计。 自定义字体的辅助功能 - 如果使用自定义字体，确保它们能够与系统的辅助功能设置兼容，如使用UIFontMetrics来调整。 国际化的挑战国际化不仅仅是将文本翻译成不同的语言，还需要考虑到文化差异、布局方向（例如从右到左的语言）、日期和时间格式以及货币单位。 实现国际化 本地化字符串 - 使用本地化字符串文件（.strings）和键值对来管理应用中的文本。 自适应布局 - 确保UI能够适应不同的文本长度和布局方向。 日期和数字格式 - 使用DateFormatter和NumberFormatter来处理日期和数字的本地化格式。 资源的国际化 - 包括图像等资源的国际化，确保它们在不同文化中同样适用。 最佳实践 全面测试 - 在不同的语言和辅助功能设置下测试应用，确保所有功能正常工作。 持续的本地化和国际化 - 让本地化和国际化成为开发流程的一部分，不断更新和完善。 伪本地化测试 - 使用伪本地化来测试应用的布局是否能够适应文字长度的变化。 文化敏感性 - 在设计和开发应用时，考虑到不同文化背景下的用户需求和习俗。 动态字体和布局测试 - 使用Xcode中的辅助功能检查器来预览应用在不同字体大小下的表现。 通过实施这些策略，开发者可以确保他们的应用不仅在不同地区和文化中使用无障碍，而且可以为所有用户提供一个更加个性化和易于使用的体验。","categories":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"http://xuebusi.gitee.io/categories/SwiftUI/"}],"tags":[]},{"title":"SwiftUI核心技术第11章适配多平台","slug":"SwiftUI核心技术第11章适配多平台","date":"2023-11-08T01:31:14.000Z","updated":"2024-03-17T06:11:51.180Z","comments":true,"path":"2023/11/08/SwiftUI核心技术第11章适配多平台/","permalink":"http://xuebusi.gitee.io/2023/11/08/SwiftUI%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC11%E7%AB%A0%E9%80%82%E9%85%8D%E5%A4%9A%E5%B9%B3%E5%8F%B0/","excerpt":"","text":"第11章：适配多平台 第1小节：Catalyst：从iOS到macOS 随着Apple推出Project Catalyst，现在开发者可以更加轻松地将iOS应用带到macOS平台。这一技术允许一个单一的代码库运行在iPad和Mac上，极大地简化了多平台支持的开发过程。在这一小节，我们将讨论如何使用Catalyst来适配你的iOS应用到macOS。 Catalyst基础Catalyst是Apple提供的一套工具和API，使得开发者可以用几乎同样的代码在Mac上运行iPad应用。这不仅减少了开发和维护成本，同时也保持了用户在iOS和macOS平台间的一致体验。 启用Catalyst在Xcode项目中启用Catalyst非常简单。首先打开你的项目设置，在Targets中选择你的iPad应用。然后，在General选项卡中，勾选“Mac”复选框来启用Mac支持。 调整界面和布局macOS和iOS在用户界面和交互上有所不同。因此，即使是通过Catalyst运行在Mac上的iOS应用，也需要进行一些调整来优化用户体验。 窗口和视图尺寸：Mac应用通常拥有更大的窗口和可调整的大小，你需要确保你的界面能够灵活地适应不同尺寸。 菜单和快捷键：Mac用户习惯于使用顶部菜单栏和快捷键来执行操作。通过Catalyst，你可以为你的应用添加Mac风格的菜单和响应键盘快捷键。 交互方式：Mac应用通常使用鼠标或触控板，而不是触摸屏。你需要考虑这一点来调整你的应用交互方式。 优化代码和资源为了在Mac上提供最佳体验，你可能需要根据平台调整代码和资源。 条件编译：使用#if targetEnvironment(macCatalyst)来条件性地编译只在Mac上运行的代码。 资源适配：可能需要提供更高分辨率的图片或者调整用户界面元素来适应Mac的显示器。 调试和测试在将iOS应用转移到Mac时，详细的调试和测试是必不可少的。你需要确保应用在Mac上的表现同样稳定，并提供流畅的用户体验。 在Mac上运行和调试：就像在iOS设备上一样，在Xcode中选择Mac作为目标设备，运行和调试你的应用。 适配性测试：对于不同的窗口尺寸和屏幕分辨率进行测试，确保布局和界面元素都能正确显示和响应。 发布和分发当你的应用通过Catalyst适配完成后，你可以通过Mac App Store将其发布给全球的用户。这一流程类似于iOS应用的发布，但需要注意的是，你可能需要提供额外的营销材料，如屏幕截图和描述，来适应Mac App Store的展示方式。 结论Catalyst提供了一个强大的桥梁，让开发者能够将iOS应用无缝迁移到Mac平台。这一过程需要细致的界面调整、代码优化以及充分的测试，但最终可以极大地拓宽你的应用市场，并为用户提供跨平台的统一体验。随着技术的发展，Catalyst将继续发展，为开发者和用户带来更多便利。 第2小节：watchOS特有的UI组件 watchOS为Apple Watch提供了一个独特的操作系统平台，它的设计重点在于快速查看信息和简洁交互。由于屏幕尺寸有限，watchOS提供了一些专门的UI组件，以满足特定的用户体验需求。在这一小节，我们将探讨watchOS的一些特有UI组件及其设计和实现。 WKInterfaceControllerWKInterfaceController是watchOS app中视图控制器的基类，用于管理界面。与iOS的UIViewController不同，WKInterfaceController更加专注于内容展示和数据流，而非复杂的布局或动画。 Complications复杂功能（Complications）允许用户在表盘上直接查看来自应用的关键信息。它们需要使用CLKComplicationDataSource协议来提供动态更新的数据。创建Complications需要细心设计图形和文本，以确保信息在极小的空间内清晰可见。 NotificationswatchOS的通知设计用于迅速传递信息。使用UNUserNotificationCenter，开发者可以设计富媒体通知，甚至允许用户通过交互直接在Apple Watch上回应。 WKInterfaceTableWKInterfaceTable是watchOS用于显示列表数据的主要UI组件。与iOS的UITableView相比，WKInterfaceTable的设计更简洁，只支持静态单元格。开发者需要预先定义好所有可能的行类型。 Digital CrownDigital Crown是Apple Watch上的旋钮，允许用户进行精细的滚动和选择操作。通过crownSequencer，开发者可以检测和响应旋钮的旋转，从而提供一个独特的交互方式。 Force TouchForce Touch允许watchOS检测屏幕上的压力级别。这可以用来显示上下文菜单或额外控件，为用户提供更多的操作选择。使用WKInterfaceDevice的play(_:)方法，还可以给予触觉反馈。 Interface ObjectswatchOS提供了一系列预定义的界面对象（如WKInterfaceLabel，WKInterfaceImage等），它们是优化过的，以确保在小屏幕上的最佳显示效果。 布局布局在watchOS中相对简单。所有元素都是垂直或水平排列的，没有自动布局系统。开发者通过设置组（Group）来组织界面，组可以嵌套，以创造更复杂的布局结构。 性能和电池寿命由于Apple Watch的硬件限制，性能优化和电池寿命考量至关重要。应用应当避免过多的背景活动，而且要智能地安排网络请求和数据更新。 总结设计watchOS应用时，开发者必须考虑到平台的独特性，包括小屏幕尺寸和有限的交互方式。通过有效利用watchOS提供的特有UI组件，开发者可以创建出既美观又实用的Apple Watch应用。此外，性能和电池寿命的优化也是watchOS应用设计中不可忽视的一部分。通过精心设计和优化，你的应用将能在这个独特的平台上提供强大功能和良好体验。 第3小节：tvOS和大屏体验 tvOS是苹果为Apple TV设计的操作系统，它为大屏幕交互提供了特殊的用户体验和设计挑战。tvOS的应用开发不仅要考虑到大屏幕带来的视觉冲击，还要处理与iOS明显不同的用户输入方式。以下是tvOS应用开发的关键点。 界面设计 布局 - 由于电视屏幕通常较大，你需要为元素间的距离和尺寸采取不同的考量。确保文字和图标在沙发观看距离仍然清晰可辨。 焦点驱动的交互 - 在tvOS中，用户通过遥控器的触摸板来控制界面上的焦点。应用需要处理焦点变化，并给予用户清晰的视觉反馈。 全屏体验 - 利用大屏幕的优势，提供全屏背景图像和视频，创造沉浸式体验。 用户输入 远程控制 - Apple TV Remote的触摸表面提供了基础的轻扫和点击输入，开发者需设计易于用遥控器导航的界面。 游戏控制器 - 对于游戏应用，Apple TV支持MFi游戏控制器，这为复杂交互提供了更多可能。 语音输入 - 利用Siri远程功能，可以为应用添加语音搜索和控制能力。 图像和视频 分辨率和图像优化 - Apple TV支持高达4K的分辨率，要求图片和视频内容具有高质量，以适应高分辨率的显示需求。 视频播放 - tvOS对于媒体播放有优化，支持HDR和Dolby Vision。开发者应当使用AVKit来实现视频播放，以确保最佳体验。 数据存储和缓存 本地存储限制 - Apple TV对本地数据存储有限制，应用需要通过iCloud或网络来同步和存储大部分数据。 缓存策略 - 为了优化性能和减少加载时间，有效的数据缓存策略是必须的。 性能和流畅性 动画和过渡 - 在大屏幕上，动画需要更加平滑和精细，以避免拖影和断续感。 内存管理 - Apple TV的内存资源比移动设备更丰富，但仍然需要高效的内存管理，尤其是在处理高分辨率媒体内容时。 Accessibility 无障碍功能 - 提供声音指导和简化的控制方案，以确保所有用户都能愉快地使用你的应用。 总结tvOS应用开发是一个大屏幕交互设计和用户体验的全新领域。与手机和平板不同，它要求开发者从居家观看的角度出发，考虑到用户与屏幕之间的距离、环境亮度等因素，从而设计出易于使用、视觉效果出色的界面。此外，由于输入设备的限制和平台特性，tvOS应用需要特别关注焦点管理和用户输入的响应性。通过在设计上投入更多考虑和精心调优性能，你的应用将能在大屏幕上提供卓越的用户体验。","categories":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"http://xuebusi.gitee.io/categories/SwiftUI/"}],"tags":[]},{"title":"SwiftUI核心技术第10章集成Core Data和CloudKit","slug":"SwiftUI核心技术第10章集成Core-Data和CloudKit","date":"2023-11-08T01:20:39.000Z","updated":"2024-03-17T06:11:48.022Z","comments":true,"path":"2023/11/08/SwiftUI核心技术第10章集成Core-Data和CloudKit/","permalink":"http://xuebusi.gitee.io/2023/11/08/SwiftUI%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC10%E7%AB%A0%E9%9B%86%E6%88%90Core-Data%E5%92%8CCloudKit/","excerpt":"","text":"第10章：集成Core Data和CloudKit 第1小节：Core Data概念和配置 Core Data是Apple提供的一套强大的框架，用于iOS、macOS、watchOS和tvOS应用的数据管理。它提供了对象图管理和持久化支持，使得开发者可以高效地存储和查询数据而无需直接操作数据库。在本小节中，我们将深入了解Core Data的基本概念，并指导如何在SwiftUI应用中进行配置。 Core Data的关键概念 托管对象模型（Managed Object Model）：作为Core Data的基础，定义了应用的数据模型。它通常通过Xcode的数据模型编辑器图形化地创建，并保存为.xcdatamodeld文件。 托管对象上下文（Managed Object Context）：是在应用和数据库之间进行交互的主要接口。它管理应用中的数据对象。 持久化存储协调器（Persistent Store Coordinator）：负责管理数据的存储。它连接数据模型和数据存储。 托管对象（Managed Object）：对数据模型中定义的实体（Entity）的实例，它在上下文中被管理。 实体（Entity）：数据模型中定义的一个数据结构，对应于传统数据库中的表。 属性（Attribute）：实体中的字段，用来定义存储数据的类型。 关系（Relationship）：定义实体间的连接，类似于数据库中的外键。 获取请求（Fetch Request）：用来查询数据模型，返回一个或多个托管对象。 配置Core Data 在SwiftUI中配置Core Data通常遵循以下步骤： 创建数据模型：在Xcode中新建一个数据模型文件，并添加必要的实体和属性。 添加Core Data堆栈：设置托管对象模型、持久化存储协调器和托管对象上下文。在Xcode项目模板中，如果选择了使用Core Data，则大部分配置已由模板自动生成。 初始化Core Data堆栈：通常在应用启动时进行，例如在AppDelegate或SceneDelegate中。 在SwiftUI视图中使用：在SwiftUI视图中，通过环境变量@Environment(\\.managedObjectContext)访问托管对象上下文。 示例代码：配置Core Data环境 12345678910111213141516171819202122232425import CoreData// 通常在AppDelegate或类似的地方进行初始化class DataController: ObservableObject &#123; let container: NSPersistentContainer init() &#123; container = NSPersistentContainer(name: &quot;Model&quot;) container.loadPersistentStores &#123; (storeDescription, error) in if let error = error as NSError? &#123; // 实际应用中应处理错误，这里简化了处理 fatalError(&quot;Unresolved error \\(error), \\(error.userInfo)&quot;) &#125; &#125; &#125;&#125;// SwiftUI视图中使用struct ContentView: View &#123; @Environment(\\.managedObjectContext) var managedObjectContext var body: some View &#123; // ... &#125;&#125; 在上述代码中，DataController负责初始化Core Data堆栈，并加载持久化存储。在SwiftUI视图中，我们通过@Environment属性包装器注入了托管对象上下文，以便在视图中使用。 总结 Core Data是一个强大的框架，它为数据持久化和管理提供了丰富的功能。理解其核心概念并在SwiftUI项目中进行正确配置，是高效使用该框架的关键。随后的小节中，我们将探讨如何使用Core Data进行数据的创建、读取、更新和删除操作，以及如何将Core Data与CloudKit集成，实现数据的云同步。 第2小节：SwiftUI中的Core Data集成 在SwiftUI应用中集成Core Data可以让我们更加便捷地管理模型层数据。这个过程涉及到模型定义、上下文管理和视图更新。在本小节，我们将详细介绍如何在SwiftUI中集成Core Data。 模型定义 模型定义是使用Core Data的第一步。在Xcode的模型编辑器中，您可以定义实体、属性和关系。这些模型元素代表了应用中的数据结构。对于每一个实体，Core Data都能自动生成对应的NSManagedObject子类，您可以直接在代码中使用。 示例代码：定义一个Person实体 12345678import CoreData// 假设在.xcdatamodeld文件中已经定义了Person实体及其属性public class Person: NSManagedObject &#123; @NSManaged public var id: UUID @NSManaged public var name: String @NSManaged public var age: Int16&#125; 集成到SwiftUI视图 在SwiftUI中，通过@FetchRequest属性包装器可以创建对Core Data实体的查询请求，并将结果直接绑定到用户界面。当底层数据变化时，界面也会自动更新。 示例代码：使用@FetchRequest展示数据 123456789101112131415161718import SwiftUIimport CoreDatastruct PersonListView: View &#123; @Environment(\\.managedObjectContext) private var viewContext @FetchRequest( sortDescriptors: [NSSortDescriptor(keyPath: \\Person.name, ascending: true)], animation: .default) private var persons: FetchedResults&lt;Person&gt; var body: some View &#123; List &#123; ForEach(persons, id: \\.id) &#123; person in Text(person.name) &#125; &#125; &#125;&#125; 在上面的代码中，@FetchRequest初始化了一个请求来获取所有Person对象，并按name属性升序排序。persons数组将自动更新，以反映数据库中的数据。 数据操作 对于Core Data中的数据，您可以使用托管对象上下文（NSManagedObjectContext）进行操作，包括创建新对象、修改属性、保存更改或删除对象。 示例代码：添加新Person对象 1234567891011121314func addPerson(name: String, age: Int16) &#123; let newPerson = Person(context: viewContext) newPerson.id = UUID() newPerson.name = name newPerson.age = age do &#123; try viewContext.save() &#125; catch &#123; // 这里处理错误 let nsError = error as NSError fatalError(&quot;Unresolved error \\(nsError), \\(nsError.userInfo)&quot;) &#125;&#125; SwiftUI中的Context传递 在SwiftUI应用中，托管对象上下文是通过环境传递的。这意味着您可以在应用的顶层视图中设置上下文，并通过环境变量在子视图中访问。 1234567891011@mainstruct MyApp: App &#123; let dataController = DataController() var body: some Scene &#123; WindowGroup &#123; ContentView() .environment(\\.managedObjectContext, dataController.container.viewContext) &#125; &#125;&#125; 在ContentView或其任何子视图中，您都可以通过@Environment来获取上下文。 总结 SwiftUI与Core Data的集成使得数据管理变得直观和无缝。通过定义数据模型、执行数据操作以及将数据变化反馈到UI，可以构建出响应式的用户界面。确保正确地处理数据操作中的错误，并在需要的地方更新视图。接下来的小节将深入探讨如何优化数据操作，以及如何将Core Data与CloudKit结合使用，实现数据的云同步和共享。 第3小节：使用CloudKit进行数据同步 Core Data与CloudKit的集成为数据提供了一个强大的云同步功能。通过这种集成，用户可以在不同的设备之间无缝同步数据，同时还可以分享数据到其他用户。在本小节中，我们将深入探讨如何设置和使用CloudKit进行数据同步。 CloudKit 概述CloudKit是苹果提供的一个后端存储解决方案，它可以让开发者存储数据在iCloud上，实现跨设备的数据同步。与Core Data集成后，CloudKit可以自动处理网络请求、数据缓存以及差异合并等复杂任务。 设置CloudKit在Xcode中启用CloudKit非常简单。首先需要在应用的Capabilities选项中打开iCloud，并勾选CloudKit。这样做将为您的应用创建一个iCloud container。 然后，确保您的Core Data模型设置正确。在.xcdatamodeld文件的数据模型编辑器中，选择模型文件，然后在Model Inspector中勾选“Use CloudKit”。 模型和记录类型在CloudKit中，每个Core Data实体将映射到一个CloudKit记录类型（CKRecordType）。实体的属性和关系将映射为记录的字段。在设置实体时，需要注意数据类型的兼容性，以确保顺利映射。 数据同步初始化同步使用NSPersistentCloudKitContainer作为您的持久化容器，可以实现Core Data和CloudKit之间的数据同步。在应用启动时，你需要设置持久化容器来初始化CloudKit同步。 123456789101112131415161718192021import CoreDataclass DataController: ObservableObject &#123; let container: NSPersistentCloudKitContainer init() &#123; container = NSPersistentCloudKitContainer(name: &quot;Model&quot;) guard let description = container.persistentStoreDescriptions.first else &#123; fatalError(&quot;Persistent store description was not found.&quot;) &#125; description.setOption(true as NSNumber, forKey: NSPersistentStoreRemoteChangeNotificationPostOptionKey) container.loadPersistentStores &#123; storeDescription, error in if let error = error as NSError? &#123; fatalError(&quot;Unresolved error \\(error), \\(error.userInfo)&quot;) &#125; &#125; &#125;&#125; 在上述代码中，NSPersistentStoreRemoteChangeNotificationPostOptionKey选项允许您接收到数据变更通知。 监听数据变化为了让您的用户界面响应CloudKit的数据变更，您可以监听NSPersistentStoreRemoteChange通知。每当CloudKit中的数据发生变化时，都会发送通知，并且您可以更新UI。 1234567891011NotificationCenter.default.addObserver( self, selector: #selector(handleDataChangeNotification(_:)), name: .NSPersistentStoreRemoteChange, object: nil)@objcfunc handleDataChangeNotification(_ notification: Notification) &#123; // 在这里处理数据变化，更新UI&#125; 数据冲突和合并处理数据冲突是云同步的重要方面。Core Data和CloudKit集成提供了一种自动的冲突解决策略。默认情况下，最后写入的数据将会“赢”，覆盖之前的数据。如果需要，也可以自定义冲突解决策略。 调试和错误处理当处理云同步时，调试和错误处理是不可或缺的。您应当仔细检查错误日志，并对可能的同步错误做出反应。 总结将Core Data与CloudKit集成，为应用添加云同步功能，可以极大地改善用户体验。通过简单的设置和API调用，您可以实现数据在多个设备间的同步，并允许用户之间共享数据。确保在实现过程中，处理好初始化同步、数据变更监听、数据冲突及错误处理等关键环节。在后续小节中，我们将讨论如何利用Cloud Kit的高级特性来构建更为复杂的云同步方案。","categories":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"http://xuebusi.gitee.io/categories/SwiftUI/"}],"tags":[]},{"title":"SwiftUI核心技术第9章复合视图与可复用性","slug":"SwiftUI核心技术第9章复合视图与可复用性","date":"2023-11-08T01:18:34.000Z","updated":"2024-03-17T06:11:44.777Z","comments":true,"path":"2023/11/08/SwiftUI核心技术第9章复合视图与可复用性/","permalink":"http://xuebusi.gitee.io/2023/11/08/SwiftUI%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC9%E7%AB%A0%E5%A4%8D%E5%90%88%E8%A7%86%E5%9B%BE%E4%B8%8E%E5%8F%AF%E5%A4%8D%E7%94%A8%E6%80%A7/","excerpt":"","text":"第9章：复合视图与可复用性 第1小节：组合现有视图 在构建复杂的用户界面时，有效的视图复用和组合是提高代码可维护性和减少重复的关键。SwiftUI以其声明式语法和数据驱动的方法论，为视图的复合提供了极佳的支持。 视图复合的概念 视图复合是指将多个较小的视图组合成一个复杂的视图的过程。这是软件工程中“组合优于继承”原则的直接体现，允许开发者通过构建并组合简单的视图块来创建复杂的用户界面。 基本视图组合 在SwiftUI中，最基本的视图组合可以通过使用Stacks、Groups等容器视图来完成。例如，一个简单的登录表单可以通过组合TextFields和Button视图来创建： 1234567891011121314151617struct LoginForm: View &#123; @State private var username: String = &quot;&quot; @State private var password: String = &quot;&quot; var body: some View &#123; VStack &#123; TextField(&quot;Username&quot;, text: $username) .textFieldStyle(RoundedBorderTextFieldStyle()) SecureField(&quot;Password&quot;, text: $password) .textFieldStyle(RoundedBorderTextFieldStyle()) Button(&quot;Log In&quot;) &#123; // Handle login action &#125; .padding() &#125; &#125;&#125; 在这个例子中，我们创建了一个自定义的LoginForm视图，它将两个文本字段和一个按钮组合在一起。 视图抽象 SwiftUI的另一个强大功能是能够创建可复用的自定义视图。例如，如果我们发现在不同的地方多次使用相同的文本样式，可以将其抽象为一个可复用的视图： 123456789struct TitleText: View &#123; var text: String var body: some View &#123; Text(text) .font(.largeTitle) .foregroundColor(.blue) &#125;&#125; 使用TitleText视图可以确保文本样式的一致性，并且在更新样式时，只需修改TitleText视图的定义即可。 利用视图修饰符 除了创建完整的自定义视图外，开发者也可以定义视图修饰符来封装常用的修改器组合。这可以进一步简化视图定义并增强可读性： 123456789101112131415struct CardStyle: ViewModifier &#123; func body(content: Content) -&gt; some View &#123; content .padding() .background(Color.white) .cornerRadius(10) .shadow(radius: 5) &#125;&#125;extension View &#123; func cardStyle() -&gt; some View &#123; self.modifier(CardStyle()) &#125;&#125; 现在，任何视图都可以轻松地应用这个“卡片”样式： 12Text(&quot;Hello World&quot;) .cardStyle() 小结 通过组合现有视图，开发者可以在SwiftUI中高效地构建复杂的用户界面。这种方法的核心优势是它提高了代码的可维护性、减少了重复，并且通过自定义视图和视图修饰符，能够轻松实现视图的一致性和可复用性。这种模块化的构建方式非常适合快速迭代和扩展，是构建复杂UI时的推荐方法。 第2小节：创建可复用的视图库 在构建复杂的SwiftUI应用时，开发者会逐渐积累起一组可复用的视图和视图修饰符。将这些元素组织成一个内部视图库，不仅可以提升开发效率，还可以确保UI的一致性。在这一节中，我们将探讨如何创建和维护一个可复用的视图库。 可复用视图库的优点 一致性：统一的视图库可以确保整个应用的视觉元素保持一致。 效率：通过重用视图组件，可以避免重复劳动，加快开发速度。 可维护性：需要调整设计时，只需要更新视图库中的组件即可影响整个应用。 设计可复用视图 当设计一个可复用视图时，考虑以下几个方面： 通用性：视图应该足够通用，能够适应不同的使用场景。 可配置性：提供合理的接口来调整视图的外观和行为。 独立性：视图应该是自包含的，不依赖于外部状态。 视图库结构 一个好的视图库应该具有清晰的结构，通常包含以下几个层次： 基础视图：最基本的视图组件，如按钮、标签、输入框等。 视图修饰符：用于修饰视图的通用样式，如阴影、边框、字体样式等。 复合视图：由多个基础视图或其他复合视图组合而成的复杂视图。 布局：用于组织视图在容器中的位置和排列的布局组件。 实施示例 让我们来定义一个基础的可复用视图库的组件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 基础视图struct PrimaryButton: View &#123; var title: String var action: () -&gt; Void var body: some View &#123; Button(action: action) &#123; Text(title) .fontWeight(.bold) .frame(minWidth: 0, maxWidth: .infinity) .padding() .background(Color.blue) .foregroundColor(.white) .cornerRadius(10) &#125; &#125;&#125;// 视图修饰符struct ShadowModifier: ViewModifier &#123; func body(content: Content) -&gt; some View &#123; content .shadow(color: .gray, radius: 5, x: 0, y: 2) &#125;&#125;extension View &#123; func applyShadow() -&gt; some View &#123; modifier(ShadowModifier()) &#125;&#125;// 复合视图struct UserInfoCard: View &#123; var username: String var email: String var body: some View &#123; VStack(alignment: .leading) &#123; Text(username) .font(.headline) .applyShadow() Text(email) .font(.subheadline) &#125; .padding() .background(Color.white) .cornerRadius(10) .applyShadow() &#125;&#125; 视图库的维护 文档：为每个组件编写详细的文档，说明其用法和配置选项。 示例应用：创建一个示例应用，演示视图库中每个组件的用法。 版本控制：当更新视图库时，使用版本控制来管理变更。 小结 创建和维护一个可复用的视图库是提高SwiftUI应用开发效率和质量的有效方法。通过精心设计和文档化，视图库不仅能够确保UI的一致性，还能极大地简化应用的迭代和扩展。 第3小节：自定义Modifier 在SwiftUI中，Modifier允许开发者封装一系列的视图修改操作，并可复用于不同的视图。通过创建自定义的Modifier，可以极大地提高代码的可维护性和清晰度，同时也使得UI组件的风格和布局保持一致。本小节将详细介绍如何定义和使用自定义Modifier。 理解Modifier Modifier是一种遵循ViewModifier协议的结构体，它通过改变视图的渲染和布局属性来修改视图的外观和行为。每当对视图应用Modifier时，SwiftUI都会在背后创建一个新的视图结构，而不是修改旧的视图。这使得视图修改操作既安全又易于管理。 创建自定义Modifier 定义Modifier结构体：首先，需要定义一个结构体并遵循ViewModifier协议。 实现body属性：在结构体中实现必需的body计算属性，它接收一个Content参数，并返回一个新的视图。 添加修改操作：在body属性中，对传入的Content进行修改，如添加边框、改变字体、设置背景等。 示例：自定义圆角和阴影Modifier 12345678910111213141516struct RoundedShadowModifier: ViewModifier &#123; var radius: CGFloat var shadowRadius: CGFloat func body(content: Content) -&gt; some View &#123; content .cornerRadius(radius) .shadow(radius: shadowRadius) &#125;&#125;extension View &#123; func roundedShadow(radius: CGFloat, shadowRadius: CGFloat) -&gt; some View &#123; modifier(RoundedShadowModifier(radius: radius, shadowRadius: shadowRadius)) &#125;&#125; 在上述示例中，我们定义了一个名为RoundedShadowModifier的自定义Modifier，它将圆角和阴影效果应用于任何视图。通过extension扩展View，我们为所有视图添加了一个名为roundedShadow的新方法，它使得应用圆角和阴影更加便捷。 使用自定义Modifier 一旦定义了自定义Modifier，就可以在任何视图上像使用内置Modifier一样使用它： 12Text(&quot;Hello, SwiftUI!&quot;) .roundedShadow(radius: 10, shadowRadius: 5) 优化Modifier 链式调用：Modifier可以链式调用，使得视图修改更加灵活。 条件修改：可以使用条件语句动态地应用Modifier。 性能考虑：尽量避免创建过于复杂的Modifier，以免影响性能。 总结 自定义Modifier在SwiftUI开发中是一项强大的工具，它不仅可以提高代码的复用性和清晰度，还可以帮助维护应用的视觉一致性。通过创建合适的自定义Modifier，可以简化视图的构建过程，并提升开发效率。","categories":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"http://xuebusi.gitee.io/categories/SwiftUI/"}],"tags":[]},{"title":"SwiftUI核心技术第8章动画与转场","slug":"SwiftUI核心技术第8章动画与转场","date":"2023-11-08T01:13:02.000Z","updated":"2024-03-17T06:11:41.709Z","comments":true,"path":"2023/11/08/SwiftUI核心技术第8章动画与转场/","permalink":"http://xuebusi.gitee.io/2023/11/08/SwiftUI%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC8%E7%AB%A0%E5%8A%A8%E7%94%BB%E4%B8%8E%E8%BD%AC%E5%9C%BA/","excerpt":"","text":"第8章：动画与转场 第1小节：基础动画 在SwiftUI中，动画是用来增强用户体验的一种手段，它可以提供平滑的视觉过渡和引人注目的交互。通过使用SwiftUI强大的动画API，你可以轻松地为界面元素添加动画效果。 动画的类型 在SwiftUI中，动画主要可以分为隐式动画和显式动画两大类。 隐式动画：最简单的动画形式，仅需要使用.animation()修饰符，并为其提供一个动画样式。 显式动画：使用withAnimation函数来明确开始动画的时间点，并提供一个动画样式。 创建一个简单的隐式动画 你可以通过在视图的某个状态改变时附加.animation()修饰符，让这个状态改变带有动画效果。 123456789101112struct SimpleAnimationView: View &#123; @State private var scale: CGFloat = 1 var body: some View &#123; Circle() .scaleEffect(scale) .animation(.easeInOut, value: scale) .onTapGesture &#123; scale += 1 &#125; &#125;&#125; 在上面的例子中，每当用户点击圆形，scale状态变量就会增加，而圆形的尺寸变化将以渐进渐出的方式动画显示。 使用withAnimation进行显式动画 如果你想控制动画的触发时机，而不是依赖于状态的改变，你可以使用withAnimation来显式地执行动画。 12345Button(&quot;Tap Me&quot;) &#123; withAnimation(.spring(response: 0.5, dampingFraction: 0.5, blendDuration: 1)) &#123; scale += 1 &#125;&#125; 在这个例子中，当按钮被点击时，不管scale的值如何变化，动画都会被执行。 动画的组合 你可以将不同的动画效果组合在一起，创建复杂的动画序列。这通过在.animation()修饰符中使用Animation的静态方法来实现。 123.animation( Animation.easeInOut(duration: 2).repeatForever(autoreverses: true)) 此代码会创建一个无限重复并自动反向的渐进渐出动画。 动画参数 SwiftUI提供了许多可以调整动画行为的参数： duration：动画的时长。 delay：动画开始前的等待时间。 repeatCount：动画重复的次数。 autoreverses：动画是否在完成后自动反向。 小结 基础动画是SwiftUI中最容易实现的动画类型，它们可以快速为你的应用添加视觉吸引力和反馈。通过使用隐式动画或显式动画，你可以控制动画的触发方式和行为。此外，SwiftUI的动画系统是高度可组合的，允许你通过组合和定制动画参数来创建复杂的动画效果。 在本书的后续章节中，我们将深入探讨如何使用SwiftUI的高级动画功能，比如路径动画、自定义时间曲线以及动画的联动效果，来创建更具表现力和创造力的用户界面。 第2小节：自定义动画 在SwiftUI中，除了内置的动画类型，开发者还可以通过自定义动画来进一步个性化UI交互。自定义动画允许开发者控制动画的具体行为和时间曲线，实现独特的动态效果。 动画时间曲线 时间曲线描述了动画状态值随时间的变化方式。SwiftUI提供了几种内置的时间曲线，例如easeIn、easeOut和easeInOut。要自定义这些曲线，你可以使用timingCurve(_:_:_:_:)方法。 1.animation(.timingCurve(0.2, 0.8, 0.2, 1, duration: 0.5)) 这个方法接受四个表示贝塞尔曲线控制点的参数，可以非常精细地控制动画的加速和减速过程。 使用interpolatingSpring自定义弹簧动画 如果你需要一个物理弹性效果，可以使用interpolatingSpring(stiffness:damping:)函数来自定义一个弹簧动画。 1.animation(.interpolatingSpring(stiffness: 50, damping: 5)) 调整stiffness（刚度）和damping（阻尼）参数可以模拟不同的弹簧物理特性。 使用Animation的delay(_: )和speed(_: )自定义动画速度和延迟 1.animation(.easeInOut(duration: 2).delay(0.5).speed(2)) 这里，动画会在半秒延迟后开始，并且以原始时长的两倍速度播放。 自定义动画路径 SwiftUI动画不仅限于简单的开始和结束状态之间的过渡。使用GeometryEffect，你可以创建完全自定义的动画路径。 12345678910111213141516171819202122232425struct CustomAnimationView: View &#123; @State private var isAnimated = false var body: some View &#123; Circle() .frame(width: 100, height: 100) .modifier(CustomPathModifier(isAnimated: $isAnimated)) .onTapGesture &#123; withAnimation &#123; isAnimated.toggle() &#125; &#125; &#125;&#125;struct CustomPathModifier: GeometryEffect &#123; @Binding var isAnimated: Bool func effectValue(size: CGSize) -&gt; ProjectionTransform &#123; let path = UIBezierPath() path.move(to: CGPoint(x: 0, y: isAnimated ? size.height : 0)) // Your custom path here return ProjectionTransform(CGAffineTransform(translationX: path.currentPoint.x, y: path.currentPoint.y)) &#125;&#125; 通过创建一个遵循GeometryEffect协议的自定义修饰符，你可以定义一个复杂的动画路径，这个路径由一个点沿着给定路径移动的动画组成。 自定义动画的应用场景 当内置动画不能满足你的设计需求时。 当你想要创建一个与众不同的动态交互体验。 在需要精确控制动画行为，如游戏或特定动画教程中。 小结 自定义动画是SwiftUI动画功能的深入使用。通过控制时间曲线、弹簧动画参数和自定义动画路径，你可以创造出个性化和专业级别的动态效果。自定义动画能提升应用的专业感和用户的交互体验，使你的应用在众多相似应用中脱颖而出。 接下来，我们将探讨转场动画，它们可以为视图的呈现和消失提供引人注目的视觉效果。 第3小节：交互式和响应式动画 在构建现代的用户界面时，我们不仅希望动画能够提供视觉上的引导和反馈，还希望它们能够与用户的交互紧密结合，创造流畅的体验。这就是交互式和响应式动画发挥作用的地方。在SwiftUI中，你可以根据用户的输入或其他事件，实时地调整动画，从而创建出高度交互的UI元素。 交互式动画 交互式动画是指随着用户的操作实时变化的动画。例如，拖动滑块时的动态变化或者通过手势控制的动画。 实现交互式动画的方法 你可以通过以下方式为你的应用添加交互式动画： 使用Gesture 绑定手势到视图，然后在手势变化时更新视图的状态。 12345678910111213141516struct InteractiveView: View &#123; @GestureState private var dragState = CGSize.zero var body: some View &#123; Rectangle() .fill(Color.blue) .frame(width: 100, height: 100) .offset(dragState) .gesture( DragGesture() .updating($dragState) &#123; value, state, _ in state = value.translation &#125; ) &#125;&#125; 在这个例子中，DragGesture跟踪手指的拖动，并实时更新Rectangle的偏移。 与动画状态链接 将动画和状态变量结合起来，实现随状态改变而动画的效果。 12345678910111213struct ResponsiveView: View &#123; @State private var position = CGPoint.zero var body: some View &#123; Circle() .position(position) .onTapGesture &#123; withAnimation &#123; position = CGPoint(x: position.x + 100, y: position.y + 100) &#125; &#125; &#125;&#125; 这里，每次点击都会使圆形移动，并伴随平滑的过渡动画。 响应式动画 响应式动画则是指根据外部事件或数据的变化而自动触发的动画。例如，当接收到新消息时，提示符以动画的形式出现。 实现响应式动画的方法 数据绑定 通过观察对象中的@Published属性变化来驱动动画。 1234567891011121314151617class AnimationViewModel: ObservableObject &#123; @Published var isLoading = false&#125;struct LoadingView: View &#123; @ObservedObject var viewModel = AnimationViewModel() var body: some View &#123; Circle() .frame(width: 50, height: 50) .rotationEffect(Angle(degrees: viewModel.isLoading ? 360 : 0)) .animation(Animation.linear(duration: 1).repeatForever(autoreverses: false), value: viewModel.isLoading) .onAppear &#123; viewModel.isLoading = true &#125; &#125;&#125; 当isLoading变为true时，圆形会开始无限旋转，模拟加载指示器的效果。 环境变量 利用@EnvironmentObject或其他环境属性，在多个视图之间共享动画状态。 123456789struct ContentView: View &#123; @EnvironmentObject var userSettings: UserSettings var body: some View &#123; Text(userSettings.username) .scaleEffect(userSettings.isLoggedOut ? 0 : 1) .animation(.spring(), value: userSettings.isLoggedOut) &#125;&#125; 当用户注销时，用户名的文本会通过缩放动画消失。 小结 交互式和响应式动画在提高应用的用户体验方面起着至关重要的作用。在SwiftUI中，你可以轻松地将动画与用户的交互以及应用的数据状态相结合。 第4小节：转场动画 转场动画是用户界面的一部分，它们在视图的呈现和消失时创造连贯的视觉效果。在SwiftUI中，转场是以声明的方式定义的，允许开发者指定添加或删除视图时的动画类型。利用转场，开发者可以提供一种流畅的视觉体验，减少用户界面变化对用户认知的干扰。 基础转场 SwiftUI提供了几种内置的转场类型，例如.opacity、.slide和.scale。 1234567891011121314151617struct ContentView: View &#123; @State private var isPresented = false var body: some View &#123; VStack &#123; if isPresented &#123; Text(&quot;Hello, World!&quot;) .transition(.slide) &#125; Button(&quot;Toggle View&quot;) &#123; withAnimation &#123; isPresented.toggle() &#125; &#125; &#125; &#125;&#125; 在这个示例中，当isPresented状态变化时，Text视图会滑入或滑出。 组合转场 你还可以组合多个转场来创建独特的效果： 1.transition(.asymmetric(insertion: .scale, removal: .opacity)) 在这里，视图出现时使用缩放效果，消失时使用渐隐效果。 自定义转场 SwiftUI还允许创建自定义转场。这通常是通过定义视图的两种状态并描述它们之间的动画过渡来实现的。 123456789101112131415extension AnyTransition &#123; static var pivot: AnyTransition &#123; .modifier( active: CornerRotateModifier(amount: -90), identity: CornerRotateModifier(amount: 0) ) &#125;&#125;struct CornerRotateModifier: ViewModifier &#123; let amount: Double func body(content: Content) -&gt; some View &#123; content.rotationEffect(Angle(degrees: amount), anchor: .topLeading) &#125;&#125; 在这个自定义转场中，pivot通过旋转视图的顶部锚点实现转动效果。 使用转场动画 转场可以与withAnimation闭包结合使用，来实现视图状态变化时的平滑过渡。 12345Button(&quot;Toggle View&quot;) &#123; withAnimation(.spring()) &#123; isPresented.toggle() &#125;&#125; 这将创建一个在点击按钮时视图呈现和消失时有弹簧动效的交互。 小结 转场动画在SwiftUI中为开发者提供了一个高效的方法来处理视图的呈现和消失，使用户界面更加生动和有趣。内置的转场类型适用于多数情况，而自定义转场则为特殊需求提供了无限的可能性。通过恰当使用转场，可以大大提升应用的质感和用户满意度。","categories":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"http://xuebusi.gitee.io/categories/SwiftUI/"}],"tags":[]},{"title":"SwiftUI核心技术第7章导航与呈现","slug":"SwiftUI核心技术第7章导航与呈现","date":"2023-11-08T01:09:18.000Z","updated":"2024-03-17T06:11:38.648Z","comments":true,"path":"2023/11/08/SwiftUI核心技术第7章导航与呈现/","permalink":"http://xuebusi.gitee.io/2023/11/08/SwiftUI%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC7%E7%AB%A0%E5%AF%BC%E8%88%AA%E4%B8%8E%E5%91%88%E7%8E%B0/","excerpt":"","text":"第7章：导航与呈现 1. NavigationView和NavigationViewLink 在SwiftUI中，NavigationView和NavigationLink组合起来使用，提供了一个强大的导航框架，让我们可以构建具有层次结构的页面间跳转。它们的设计遵循了SwiftUI的声明式语法，使得页面跳转和数据传递变得直观和易于管理。 NavigationView NavigationView是一个容器视图，它承载着你的视图层次结构，并提供了展示这些视图的空间。你可以把它看作是页面导航的起点。通常，一个NavigationView包含一个或多个View，这些View可以通过NavigationLink来进行跳转。 12345678NavigationView &#123; List(selection: $selectedItem) &#123; NavigationLink(destination: DetailView(item: item)) &#123; Text(item.title) &#125; &#125; .navigationBarTitle(Text(&quot;Items&quot;))&#125; 在这个例子中，NavigationView包含了一个列表，列表中的每一项都绑定了一个NavigationLink，点击时将展示DetailView。 NavigationLink NavigationLink负责在NavigationView中触发页面跳转。它有多个初始化方法，可以根据需求选择使用。最基本的用法是提供一个目标视图和触发跳转的内容。 123NavigationLink(destination: DetailView(item: item)) &#123; Text(item.title)&#125; 这里NavigationLink的目的地是DetailView，用户点击列表项上的Text时会触发导航到DetailView。 激活和反激活链接 NavigationLink可以与SwiftUI的状态绑定，以编程方式激活或反激活导航。通过在NavigationLink初始化时传递一个布尔型的绑定，你可以控制导航的行为。 1234567891011@State private var isLinkActive = falsevar body: some View &#123; NavigationView &#123; NavigationLink(destination: DetailView(), isActive: $isLinkActive) &#123; Button(&quot;Go to Details&quot;) &#123; self.isLinkActive = true &#125; &#125; &#125;&#125; 在这个例子中，一个按钮被用来激活NavigationLink。当用户点击按钮，isLinkActive状态变为true，触发导航到DetailView。 传递数据 在导航过程中，你可能需要向目的地视图传递数据。NavigationLink的destination参数让你可以轻松做到这一点。 123NavigationLink(destination: DetailView(item: item)) &#123; ItemRow(item: item)&#125; 在这里，每个ItemRow是一个列表中的行，它带有一个与之关联的item数据模型。点击ItemRow时，item将被传递到DetailView。 小结 NavigationView和NavigationLink构成了SwiftUI中页面导航的基石。它们的使用方式灵活而强大，支持各种复杂的导航模式。通过声明式语法，我们可以更专注于视图的内容和业务逻辑，而不是导航的细节。本章节的后续部分将探讨更高级的导航模式，如使用TabView和modal呈现，以及如何处理数据传递和状态管理。 2. TabView 在构建一个用户界面时，底部的标签栏是一种常见的设计，允许用户轻松切换不同的视图或功能模块。在SwiftUI中，这可以通过TabView来实现。TabView为应用提供了一个选项卡式的界面，每个选项卡都代表了一个视图。 基本用法 TabView的基本用法涉及到声明式地列出每一个选项卡，并使用tabItem修饰符来定义每个标签的外观，通常包括图标和文本。 12345678910111213TabView &#123; Text(&quot;首页&quot;) .tabItem &#123; Image(systemName: &quot;house&quot;) Text(&quot;Home&quot;) &#125; Text(&quot;设置&quot;) .tabItem &#123; Image(systemName: &quot;gear&quot;) Text(&quot;Settings&quot;) &#125;&#125; 在这个简单的例子中，TabView包含了两个选项卡：“首页”和“设置”，每个选项卡都是用Text视图表示的，并且有对应的系统图标。 选项卡状态管理 TabView可以与@State变量绑定，从而允许你编程方式控制当前激活的选项卡。 12345678910111213141516171819@State private var selectedTab = 0var body: some View &#123; TabView(selection: $selectedTab) &#123; HomeView() .tabItem &#123; Image(systemName: &quot;house&quot;) Text(&quot;Home&quot;) &#125; .tag(0) SettingsView() .tabItem &#123; Image(systemName: &quot;gear&quot;) Text(&quot;Settings&quot;) &#125; .tag(1) &#125;&#125; 在上述代码中，selectedTab绑定到TabView的selection参数。通过改变selectedTab的值，你可以改变当前选中的标签页。 自定义外观 TabView的外观可以通过多种方式进行自定义。例如，可以使用.accentColor来改变选中标签的颜色。 1234TabView &#123; // ... 你的选项卡&#125;.accentColor(.green) 结合NavigationView使用 在TabView内部，你可能还会嵌入NavigationView，以在选项卡内部提供导航堆栈。 12345678910TabView &#123; NavigationView &#123; HomeView() &#125; .tabItem &#123; Image(systemName: &quot;house&quot;) Text(&quot;Home&quot;) &#125; // ... 其他选项卡&#125; 这样做可以确保每个选项卡都能拥有独立的导航历史，这对于用户体验非常重要。 使用场景 TabView在很多类型的应用中都非常有用。它是构建具有多个独立部分的应用的理想选择，例如社交网络应用、具有个人中心、消息、设置等的应用。 小结 通过本节的介绍，我们了解了如何使用TabView创建具有多个交互式选项卡的界面。TabView不仅提供了高度的可定制性，还能够很好地与其他视图和数据流模式协同工作。在接下来的小节中，我们将继续探索更多关于SwiftUI中视图呈现和数据流管理的先进概念。 3. Sheets和Alerts 在构建应用时，弹出视图和警告框（Alerts）是与用户交互的重要方式。在SwiftUI中，这通常通过使用Sheet和Alert视图完成。 Sheets Sheet是一种覆盖在当前内容上的卡片样式视图，通常用于导航流程之外的辅助任务，比如表单填写、设置选项等。 创建Sheet 要创建一个Sheet，你需要使用.sheet修饰符，并为其提供一个绑定的布尔值，这个布尔值决定Sheet是否可见。 1234567891011@State private var showingSheet = falsevar body: some View &#123; Button(&quot;Show Sheet&quot;) &#123; showingSheet.toggle() &#125; .sheet(isPresented: $showingSheet) &#123; // Sheet的内容 Text(&quot;Here&#x27;s the Sheet&quot;) &#125;&#125; 自定义Sheet Sheet的内容可以是任意视图。例如，你可以创建一个包含表单的NavigationView。 1234567891011.sheet(isPresented: $showingSheet) &#123; NavigationView &#123; Form &#123; // 表单内容 &#125; .navigationBarTitle(&quot;Settings&quot;, displayMode: .inline) .navigationBarItems(trailing: Button(&quot;Done&quot;) &#123; showingSheet = false &#125;) &#125;&#125; 使用Sheet实现细节 在内部，Sheet会自动管理自己的显示和隐藏。你可以将showingSheet绑定到视图的某个状态或者对象的属性上，当这个属性变化时，对应的Sheet会自动显示或隐藏。 Alerts Alerts用于显示重要信息，并可以提供一个或多个操作选项。 创建Alert 和Sheet类似，Alert也使用绑定的布尔值来控制显示状态。不过，创建Alert时，通常还会指定标题、消息和按钮。 1234567891011121314151617@State private var showingAlert = falsevar body: some View &#123; Button(&quot;Show Alert&quot;) &#123; showingAlert = true &#125; .alert(isPresented: $showingAlert) &#123; Alert( title: Text(&quot;Warning&quot;), message: Text(&quot;Are you sure?&quot;), primaryButton: .destructive(Text(&quot;Delete&quot;)) &#123; // 删除操作 &#125;, secondaryButton: .cancel() ) &#125;&#125; Alert的样式 Alert可以有多种样式，从简单的带有单一按钮的Alert到复杂的带有多个按钮和自定义操作的Alert。 小结 Sheet和Alert都是在SwiftUI中管理临时视图和用户交互的重要工具。通过合理使用这两种视图，你可以创建出既直观又有效的用户体验。正如我们所见，SwiftUI提供的.sheet和.alert修饰符让这两种视图的展示和管理变得十分简单。在接下来的章节中，我们将深入探讨如何利用SwiftUI的高级特性来构建更为复杂的用户交互界面。 4. Navigation的高级用法 SwiftUI的导航系统提供了一种直观且声明式的方法来处理视图间的转换。除了基础的NavigationView和NavigationLink之外，我们还可以采用更高级的用法来增强用户体验和视图的灵活性。 程序化导航 在某些情况下，你可能需要从视图模型或响应某个事件时进行导航。这可以通过绑定到视图模型中的属性并使用NavigationLink的isActive参数实现。 123456789101112131415161718class ViewModel: ObservableObject &#123; @Published var isDetailViewActive = false&#125;struct ContentView: View &#123; @StateObject var viewModel = ViewModel() var body: some View &#123; NavigationView &#123; NavigationLink(destination: DetailView(), isActive: $viewModel.isDetailViewActive) &#123; EmptyView() &#125; Button(&quot;Go to Details&quot;) &#123; viewModel.isDetailViewActive = true &#125; &#125; &#125;&#125; 隐藏和显示导航栏 在用户界面中，有时候我们需要隐藏导航栏来提供沉浸式体验，或者我们需要在特定的视图中改变导航栏的显示方式。 12345678910struct DetailView: View &#123; var body: some View &#123; // 隐藏导航栏 .navigationBarHidden(true) // 在视图即将出现时设置导航栏样式 .onAppear &#123; // 设置导航栏样式 &#125; &#125;&#125; 自定义后退按钮行为 有时默认的后退按钮行为并不符合我们的需要。在SwiftUI中，我们可以通过添加一个自定义的按钮并绑定其行为来覆盖默认的后退按钮。 123456789101112131415struct CustomBackButtonView: View &#123; @Environment(\\.presentationMode) var presentationMode var body: some View &#123; Button(action: &#123; // 执行自定义后退操作 presentationMode.wrappedValue.dismiss() &#125;) &#123; HStack &#123; Image(systemName: &quot;arrow.left&quot;) Text(&quot;Back&quot;) &#125; &#125; &#125;&#125; 深度链接 深度链接是指直接导航到应用内部的某个特定页面的链接。在SwiftUI中，我们可以监听来自URL的深度链接，并根据链接的内容导航到相应的视图。 123.onOpenURL &#123; url in // 解析URL并进行导航&#125; 嵌套导航 在构建复杂的界面时，我们可能会需要嵌套多个NavigationView。虽然这在用户界面上并不常见，但在特定的设计中可能是必要的。嵌套导航需要细心处理，以确保导航栈的正确和流畅的用户体验。 123456NavigationView &#123; // 主界面 NavigationView &#123; // 嵌套的子界面 &#125;&#125; 小结 通过上述高级导航功能，开发者可以在SwiftUI中创建复杂且具有出色用户体验的导航流。这些高级技巧的掌握可以帮助你更好地管理视图层级和导航逻辑，让应用的导航更加直观和响应用户操作。在后续章节中，我们将探索如何将这些高级导航技巧与应用的其它部分相结合，以构建完整且功能丰富的应用程序。","categories":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"http://xuebusi.gitee.io/categories/SwiftUI/"}],"tags":[]},{"title":"SwiftUI核心技术第6章数据流与绑定","slug":"SwiftUI核心技术第6章数据流与绑定","date":"2023-11-08T00:52:43.000Z","updated":"2024-03-17T06:11:34.626Z","comments":true,"path":"2023/11/08/SwiftUI核心技术第6章数据流与绑定/","permalink":"http://xuebusi.gitee.io/2023/11/08/SwiftUI%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC6%E7%AB%A0%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%8E%E7%BB%91%E5%AE%9A/","excerpt":"","text":"第6章：数据流与绑定 1. State和Binding 在SwiftUI中，数据流的管理是构建动态和响应式用户界面的核心。State和Binding是实现这种数据流动的基本工具，它们使得数据和视图能够保持同步。 State：拥有数据的真相 @State 是一个属性包装器，用于声明SwiftUI管理的状态。这个状态是私有的，仅在当前视图内部使用。当状态变化时，SwiftUI会自动重新绘制依赖于这个状态的视图部分。 1234567struct ContentView: View &#123; @State private var isToggled = false var body: some View &#123; Toggle(&quot;开关&quot;, isOn: $isToggled) &#125;&#125; 在上面的例子中，isToggled 是一个布尔状态，与一个开关绑定。当用户切换开关时，isToggled 的值会改变，触发视图的更新。 Binding：连接状态和视图 Binding 提供了对某个状态的读写权限，但不拥有这个状态本身。通过$符号，我们可以从一个@State变量创建一个Binding。 1234567struct ToggleView: View &#123; @Binding var isOn: Bool var body: some View &#123; Toggle(&quot;开关&quot;, isOn: $isOn) &#125;&#125; 在这个例子中，ToggleView 需要一个Binding来控制开关的状态，这个Binding可以从父视图的@State中派生而来。 使用State和Binding 在实际的应用中，@State适用于简单的局部状态管理，如界面的某个开关、文本输入框的内容等。当状态改变时，只有使用到该状态的视图会重新渲染，从而优化了性能。 @Binding则用于将状态的控制权从一个视图传递到另一个视图。例如，在一个父视图中定义了@State，那么就可以将这个状态以Binding的形式传递给子视图，让子视图能够读取并修改这个状态。 State和视图的生命周期 理解@State与视图的生命周期是紧密相关的也很重要。当一个视图被SwiftUI重新绘制时，@State所持有的状态会被保留下来。这意味着状态的变更是持久的，即使视图的某些其他部分可能因为不同的原因而重新渲染。 总结 State和Binding是SwiftUI中数据流的基础。@State用于创建可变的状态，当状态变化时，视图会响应这些变化。而Binding则用于在视图之间共享状态，允许多个视图共同拥有和修改状态。通过恰当地使用这两个工具，我们可以创建出既简洁又高效的响应式用户界面。在接下来的章节中，我们将深入探讨如何在更复杂的应用架构中管理状态和数据流。 2. ObservedObject和EnvironmentObject 在构建复杂的SwiftUI应用时，我们经常需要处理跨多个视图共享的数据。在这种情况下，仅使用@State和@Binding可能不够用，因为它们主要用于单个视图或其直接子视图的状态管理。这时，@ObservedObject和@EnvironmentObject就成为了重要的工具。 ObservedObject：动态数据的监听者 @ObservedObject用于绑定外部的可观察对象（通常是遵循ObservableObject协议的类实例），当可观察对象发出变化通知时，视图会重新渲染以反映新的数据。 这里有一个ObservableObject的示例： 123class UserData: ObservableObject &#123; @Published var username: String = &quot;用户&quot;&#125; @Published属性包装器用于标记会发生变化的数据。一旦username的值发生变更，就会自动通知所有的观察者。 在视图中使用@ObservedObject： 1234567struct UserView: View &#123; @ObservedObject var userData: UserData var body: some View &#123; Text(&quot;用户名: \\(userData.username)&quot;) &#125;&#125; 在UserView中，userData作为一个@ObservedObject提供了对UserData实例的引用。当username更新时，UserView也会更新其显示。 EnvironmentObject：跨层级的数据共享 @EnvironmentObject是一种特殊类型的数据流工具，它可以让数据在视图层级间传递而不需要显式地通过参数传递。它非常适合那些被多个视图访问的全局数据或设置。 首先，你需要在某个父视图中将数据对象添加到环境中： 123456789@mainstruct MyApp: App &#123; var body: some Scene &#123; WindowGroup &#123; ContentView() .environmentObject(UserData()) &#125; &#125;&#125; 然后，在子视图中，你可以直接通过@EnvironmentObject来访问这个数据对象： 1234567struct ProfileView: View &#123; @EnvironmentObject var userData: UserData var body: some View &#123; Text(&quot;欢迎, \\(userData.username)!&quot;) &#125;&#125; 不需要显式地从父视图传递UserData到ProfileView，ProfileView可以直接从环境中获取这个对象。 总结 @ObservedObject和@EnvironmentObject为我们提供了强大的数据管理能力，使得数据在视图之间传递变得简单且高效。它们都依赖于ObservableObject协议来观察数据模型的变化并响应更新。@ObservedObject适用于需要直接引用的情况，而@EnvironmentObject更适合于全局或共享数据的情况，尤其是在视图层级较深时。 在接下来的内容中，我们将探讨这些数据流工具如何与SwiftUI的声明式UI框架协同工作，以及如何利用它们来构建响应式和可维护的应用架构。 3. @Published和Combine 在SwiftUI中，数据的流动和管理是构建应用的核心。为了实现响应式的数据流，SwiftUI密切结合了Combine框架。Combine是一个响应式编程框架，它可以处理所有类型的异步事件。@Published是Combine框架中的一个关键特性，它用于创建可观察的对象属性，当这些属性的值发生变化时，它会自动通知系统。 使用@Published 使用@Published可以很容易地将一个类属性变成响应式的属性。这意味着，当属性的值改变时，所有订阅了这个属性的订阅者都会接收到通知，并且可以响应这些变化。 下面是一个使用@Published的例子： 123456import Combineclass ProfileViewModel: ObservableObject &#123; @Published var name: String = &quot;&quot; @Published var age: Int = 0&#125; 在这个例子中，ProfileViewModel是一个遵循ObservableObject协议的类，它有两个@Published属性：name和age。当这些属性中的任何一个的值改变时，所有的观察者都会得到通知。 整合Combine Combine框架的强大之处在于它可以让你定义复杂的数据处理和变换流程。例如，你可以对输入进行校验、过滤、转换，然后将处理后的数据传递到UI或其他部分。 这里是如何使用Combine订阅@Published属性变化的例子： 12345678var cancellables = Set&lt;AnyCancellable&gt;()let profileVM = ProfileViewModel()profileVM.$name .sink &#123; name in print(&quot;Name is now \\(name)&quot;) &#125; .store(in: &amp;cancellables) 在这段代码中，$name是对name属性的Publisher访问。.sink方法会接收一个闭包，这个闭包会在每次name属性更新时被调用。.store(in:)方法用于管理订阅生命周期，防止早期释放。 结合SwiftUI视图 在SwiftUI中，你通常不需要直接处理订阅，因为SwiftUI视图可以直接使用@ObservedObject或@EnvironmentObject来绑定到可观察的对象。 12345678struct ProfileView: View &#123; @ObservedObject var viewModel: ProfileViewModel var body: some View &#123; TextField(&quot;Name&quot;, text: $viewModel.name) TextField(&quot;Age&quot;, value: $viewModel.age, formatter: NumberFormatter()) &#125;&#125; 在ProfileView中，每当viewModel的name或age属性变化时，视图会自动更新。 小结 @Published与Combine框架结合使用，为SwiftUI应用带来了强大的响应式编程能力。这种模式不仅使状态管理变得简洁，还能够创建可维护和可扩展的数据流处理逻辑。随着你深入本书，你将会看到更多关于Combine在实际SwiftUI应用中的强大用例和模式。 4. 数据流的最佳实践 在构建SwiftUI应用时，高效和可维护的数据流管理是非常重要的。为了达到这个目标，我们需要遵循一些最佳实践来确保我们的应用结构清晰，数据流动合理。以下是在使用SwiftUI时应考虑的数据流最佳实践。 一、明确数据源的单一真相 在任何给定的时刻，应用的每个数据点都应该有一个清晰的，可信的来源。这意味着对于任何可变的数据，都应该有一个单一的可信源，而所有视图的状态应反映这个来源。使用@State的私有属性用于视图的内部状态，而模型对象中的@Published属性用于应用范围的状态。 二、使用单向数据流 在SwiftUI中，数据应该从父视图流向子视图（单向数据流）。父视图传递数据到子视图，子视图通过事件传递回父视图，而不是直接修改父视图的状态。这样可以避免复杂的数据依赖和潜在的循环更新问题。 三、合理使用@State，@Binding，@ObservedObject，和@EnvironmentObject @State 应当用于视图的局部状态管理，不应跨越多个视图。 @Binding 允许子视图与父视图的状态或模型中的数据进行通信。 @ObservedObject 用于当视图需要响应外部模型对象变化时。 @EnvironmentObject 适用于多个视图需要访问同一共享数据对象的情况。 四、谨慎管理生命周期 识别并管理数据对象的生命周期，尤其是当使用@ObservedObject或@EnvironmentObject时。避免不必要的重新创建对象，以减少内存使用和性能损耗。 五、精细控制数据变更 使用objectWillChange手动发送变更通知可以精细控制观察的对象何时更新UI。当需要优化性能或处理复杂的数据变更时这非常有用。 六、利用Combine进行复杂的数据操作 Combine框架提供了一套完整的工具，用于处理复杂的数据转换和异步操作。应充分利用这些工具来实现复杂的数据流和事件处理。 七、避免内存泄漏 当处理数据流和绑定时，确保正确管理订阅，使用AnyCancellable存储返回的订阅，并在不需要时取消订阅，以避免内存泄漏。 八、编写可测试的代码 将数据处理逻辑抽象到可单独测试的模型和服务中。避免将业务逻辑放入视图中，这样可以让代码更容易被测试和维护。 小结 遵循上述的数据流最佳实践将有助于您构建出高效、稳定且易于维护的SwiftUI应用。确保理解和正确应用每一种属性装饰器和Combine操作符是至关重要的。本书后续章节将会进一步深入这些概念，并结合实例演示如何在真实世界的应用中实践这些最佳实践。","categories":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"http://xuebusi.gitee.io/categories/SwiftUI/"}],"tags":[]},{"title":"SwiftUI核心技术第5章布局管理","slug":"SwiftUI核心技术第5章布局管理","date":"2023-11-08T00:47:49.000Z","updated":"2024-03-17T06:11:17.149Z","comments":true,"path":"2023/11/08/SwiftUI核心技术第5章布局管理/","permalink":"http://xuebusi.gitee.io/2023/11/08/SwiftUI%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC5%E7%AB%A0%E5%B8%83%E5%B1%80%E7%AE%A1%E7%90%86/","excerpt":"","text":"第5章：布局管理 1. 堆（Stacks） 在SwiftUI中，布局是通过组合不同的视图和使用布局容器来实现的，其中最基础和最常用的布局容器是堆（Stack）。Stacks在SwiftUI中主要有三种类型：HStack、VStack和ZStack，它们分别代表水平堆、垂直堆和覆盖堆。通过这三种Stack，可以构建出复杂的布局结构。 理解堆的工作方式 HStack（水平堆）将其子视图沿着水平轴排列。 VStack（垂直堆）将子视图沿着垂直轴排列。 ZStack（覆盖堆）则将子视图按照代码中的顺序覆盖排列，即先声明的视图会被后声明的视图覆盖。 使用HStack和VStack管理布局 12345678910VStack(alignment: .leading, spacing: 10) &#123; Text(&quot;第一行&quot;) HStack &#123; Text(&quot;左侧&quot;) Spacer() // Spacer会推动旁边的视图尽可能远的距离 Text(&quot;右侧&quot;) &#125; Text(&quot;第二行&quot;)&#125;.padding() // 对VStack添加内边距 在上面的代码示例中，我们首先创建了一个VStack，其子视图之间有10点的间距，并且它们在水平方向上左对齐。在这个垂直堆中，我们有两行文本和一个HStack。在HStack中，两个文本视图被一个Spacer隔开，这会推动这些文本视图到HStack的两侧。 ZStack的层叠效果 12345678910111213ZStack &#123; Image(&quot;background&quot;) .resizable() .aspectRatio(contentMode: .fill) VStack &#123; Text(&quot;层叠的顶部文本&quot;) .font(.largeTitle) .foregroundColor(.white) Spacer() &#125;&#125;.frame(height: 300) // 设置ZStack的高度.clipped() // 保证图片不会超出ZStack的边界 在这个例子中，ZStack用于创建层叠效果。它首先放置了一张背景图片，然后在图片上层放置了一个VStack，其中包含了一行文本。 使用堆的布局行为 Stacks默认会尽可能地占据父视图提供的空间，除非使用frame、edgesIgnoringSafeArea、fixedSize等修饰符进行限制。 alignment参数控制子视图在交叉轴上的对齐方式（对于HStack是垂直对齐，对于VStack是水平对齐）。 spacing参数决定子视图之间的间距。 对齐和分布 Stacks的另一个关键特性是对齐。开发者可以非常细致地控制如何对齐子视图： 12345HStack(alignment: .top) &#123; Text(&quot;顶部对齐&quot;) Divider() Text(&quot;还是顶部对齐&quot;)&#125; 在这个HStack中，所有的子视图都会在顶部对齐，即使它们的高度不同。 总结 通过理解和利用Stacks，你可以构建出直观且灵活的布局。Stacks的简单性和强大的组合能力，使得它们成为SwiftUI布局的核心工具。它们可以嵌套使用，也可以与其他布局视图和控件配合，以创建出复杂且响应式的用户界面。随着你 对这些基础布局工具的熟悉和运用，你将能够更加精准地操控空间，为你的应用提供坚实的视觉基础。 2. 对齐与帧（Alignment and Frames） 布局的精髓在于如何控制视图的大小和位置。在SwiftUI中，对齐和帧是两个基本但强大的概念，它们定义了视图在父视图中的具体摆放方式。 理解对齐 对齐在SwiftUI中是通过对齐指南来实现的，它定义了视图如何根据父视图或兄弟视图的对齐线来定位自己。例如，在一个VStack中，你可以通过alignment参数设置子视图在水平方向上的对齐方式，而在HStack中，这会影响子视图在垂直方向上的对齐。 123456HStack(alignment: .bottom) &#123; Text(&quot;底部对齐&quot;) Image(systemName: &quot;star&quot;) .alignmentGuide(.bottom) &#123; d in d[.top] &#125; Text(&quot;这个星星将对齐顶部&quot;)&#125; 在这个例子中，我们通过.alignmentGuide修饰符来改变图像视图的默认对齐行为，使其按照顶部对齐而不是底部。 使用帧控制视图大小 帧（frame）允许你为视图设置一个明确的大小或者提供一个理想的大小范围。frame修饰符可以指定宽度（width）、高度（height）、最小宽度（minWidth）、最大宽度（maxWidth）、最小高度（minHeight）、和最大高度（maxHeight）。 123Text(&quot;固定大小的文本框&quot;) .frame(width: 100, height: 100) .border(Color.red) 上述代码将文本框的宽度和高度都固定在了100点，无论内容大小如何，文本框都不会改变尺寸。 对齐和帧的组合使用 对齐和帧可以组合使用，以创建更复杂的布局效果。例如，你可能想要创建一个宽度固定，但高度根据内容动态调整的文本视图，同时在其内部文本垂直居中对齐。 1234567Text(&quot;垂直居中的文本&quot;) .frame(minHeight: 0, maxHeight: .infinity) .frame(width: 200) .background(Color.gray) .alignmentGuide(.vertical) &#123; d in d[VerticalAlignment.center] &#125; 这里我们使用了两个frame修饰符：第一个frame确保文本在垂直方向上可以扩展到可用的全部空间，第二个frame则设置了文本的固定宽度。通过alignmentGuide，文本在其框架内垂直居中。 总结 对齐和帧是布局时的两个非常重要的概念。通过精确的对齐控制，你可以确保界面元素以一种一致和预期的方式排列。同时，使用帧可以限制和指定视图的大小，无论是固定的还是灵活的。掌握了这些工具，你将能够设计出外观精确且布局合理的界面，即便是面对各种屏幕尺寸和设备方向，你的应用界面也能保持其应有的布局和结构。 3. Spacer和Divider 在构建用户界面时，除了直接操纵视图的尺寸和对齐，SwiftUI还提供了用于控制视图间隔的工具：Spacer和Divider。这些工具在进行视图布局时是不可或缺的，它们可以帮助我们创建出更为优雅和灵活的用户界面。 Spacer: 创建灵活的空间 Spacer是一个会尽可能占用多余空间的视图。在一个Stack中，Spacer可以推动相邻的视图，使其与Stack的边缘或其他视图保持距离。Spacer本身没有可见的内容，但它可以控制布局的间距。 12345HStack &#123; Text(&quot;左边&quot;) Spacer() // 占据所有可用空间 Text(&quot;右边&quot;)&#125; 在上述例子中，Spacer位于两个文本视图之间，并推动它们分别靠近水平Stack的左右边缘。 Spacer的另一个常用场景是在其前后添加修饰符，以控制其最小空间尺寸。 123456HStack &#123; Text(&quot;左边&quot;) Spacer() .frame(minWidth: 20) Text(&quot;右边&quot;)&#125; 此时，Spacer至少会创建20点的空间，即使在更大的容器中，它也会扩展以填满额外的空间。 Divider: 分隔视图 Divider是一个用于分隔内容的细线，通常在视觉上表示不同部分的内容。它可以在列表、VStack或HStack中作为清晰分界线使用。 12345VStack &#123; Text(&quot;第一部分&quot;) Divider() Text(&quot;第二部分&quot;)&#125; Divider会自动采用垂直或水平方向，取决于它所在的Stack类型。在VStack中，它是水平的；而在HStack中，则是垂直的。 自定义Spacer和Divider 虽然Spacer和Divider是很好的布局工具，但有时你可能需要更多的自定义。例如，你可以使用背景和框架修饰符来自定义Divider的样式。 123Divider() .background(Color.blue) .frame(height: 1) 在这个例子中，我们自定义了Divider的颜色和高度，创建了一个蓝色的分隔线。 同样，你也可以对Spacer进行类似的自定义。 总结 Spacer和Divider是在SwiftUI中创建和维护视图间隙的简单而强大的工具。它们支持布局的灵活性，同时为内容的视觉分隔提供方便。在理解了如何利用Spacer来控制视图的扩展和收缩，以及如何使用Divider来清晰地区分内容之后，你将能够创建出既美观又实用的布局设计。 4. 布局优先级 当我们在SwiftUI中构建复杂的界面时，经常会遇到多个视图争抢空间的情况。布局优先级（Layout Priority）是一个高级的概念，它允许我们微调视图如何在父视图中分配额外的空间。理解并正确使用布局优先级，可以帮助我们创建更加精确和高度定制的用户界面。 基本概念 在SwiftUI中，所有视图默认具有相同的布局优先级，值为0。当空间不足以满足所有子视图的理想尺寸时，系统会根据布局优先级来决定哪个视图可以首先满足其尺寸需求。 12345HStack &#123; Text(&quot;非常非常长的文本&quot;).layoutPriority(1) Spacer() Text(&quot;短文本&quot;)&#125; 在这个例子中，第一个Text视图的布局优先级被设置为1，这意味着它在空间分配时会被优先考虑。即使在有限的空间中，它也会尽可能地显示完整的内容，而Spacer和第二个Text视图会相应地压缩。 布局优先级的使用 布局优先级的值可以是任意的正浮点数。数值越大，获取额外空间的优先级就越高。 12345HStack &#123; Text(&quot;需要更多空间的文本&quot;).layoutPriority(2) Text(&quot;不那么重要的文本&quot;).layoutPriority(1) Text(&quot;普通文本&quot;)&#125; 在上面的代码中，第一个文本视图被赋予了最高的优先级（2），其次是第二个文本视图（1），最后是没有显式设置优先级的文本视图（默认为0）。因此，当空间有限时，第一个文本视图会尽量显示更多的内容。 布局优先级的策略 布局优先级通常用于解决视图间的竞争关系，但是它并不是解决所有布局问题的万能钥匙。合理使用布局优先级需要策略，过度依赖可能会导致布局变得难以预测和管理。在设置优先级时，你应当始终考虑内容的重要性以及用户体验。 一个良好的策略是尽量保持简单，只在确实需要时调整布局优先级。并且，始终牢记布局的整体目标是创造既满足设计需求又对用户友好的界面。 结合其他布局工具 布局优先级并不孤立工作，它应该与其他布局工具一起使用，例如frame、alignment、Spacer等。在实际开发中，你会发现布局优先级是与其他布局概念协同工作的，比如使用fixedSize来防止视图被压缩，或者与flexible结合来调整视图的压缩和扩展行为。 总结 掌握了布局优先级的概念和使用方法后，我们就能更加精细地控制SwiftUI布局的行为。正确的布局优先级设置能够确保重要的内容得到展示，辅助视图适应剩余空间，从而创造出既直观又富有层次的用户界面。在设计复杂的布局时，优先级的细微调整可以带来显著的视觉和体验改善。","categories":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"http://xuebusi.gitee.io/categories/SwiftUI/"}],"tags":[]},{"title":"SwiftUI核心技术4章视图与控件","slug":"SwiftUI核心技术4章视图与控件","date":"2023-11-07T16:35:47.000Z","updated":"2024-03-17T06:11:08.769Z","comments":true,"path":"2023/11/08/SwiftUI核心技术4章视图与控件/","permalink":"http://xuebusi.gitee.io/2023/11/08/SwiftUI%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF4%E7%AB%A0%E8%A7%86%E5%9B%BE%E4%B8%8E%E6%8E%A7%E4%BB%B6/","excerpt":"","text":"第二部分：构建用户界面 第4章：视图与控件 1. Text和Image 在SwiftUI中，用户界面是由各种视图组成的，其中最基本的两种视图是Text和Image。本节将详细探讨如何使用这两种视图来显示文本和图像。 Text Text视图用于在应用中显示一行或多行只读文本。它是最常见的视图之一，因为文本是用户交互的基本元素。 基础用法 创建一个Text视图非常简单，只需要传入一个字符串即可： 1Text(&quot;Hello, SwiftUI!&quot;) 样式定制 Text视图提供了多种修饰符来定制文本的显示方式： .font(_:)：设置字体样式。 .fontWeight(_:)：设置字体的粗细。 .foregroundColor(_:)：设置文本颜色。 .lineLimit(_:)：设置最多显示行数。 .multilineTextAlignment(_:)：设置多行文本的对齐方式。 .padding(_:)：为文本周围添加填充。 例如，要创建一个居中对齐、蓝色、加粗的文本，您可以这样写： 123456Text(&quot;Welcome to SwiftUI&quot;) .font(.headline) .fontWeight(.bold) .foregroundColor(.blue) .multilineTextAlignment(.center) .padding() 国际化和本地化 SwiftUI还支持文本的国际化和本地化。使用LocalizedStringKey初始化Text视图，可以确保文本根据用户的设备语言环境显示正确： 1Text(LocalizedStringKey(&quot;hello_message&quot;)) Image Image视图用于在应用中显示图像。您可以从应用的资产目录、文件系统或网络加载图像。 从资产目录加载 最常用的加载图像方式是从Xcode项目的Assets.xcassets目录： 1Image(&quot;myImage&quot;) 图像修饰符 Image视图也可以使用多种修饰符来调整显示的图像： .resizable()：允许图像根据视图的大小进行拉伸或压缩。 .aspectRatio(_:_:)：设置图像的宽高比。 .clipShape(_:)：剪切图像到特定的形状。 .shadow(_:)：为图像添加阴影。 例如，要创建一个圆形、有阴影的图像，您可以这样写： 123456Image(&quot;profile_pic&quot;) .resizable() .aspectRatio(contentMode: .fill) .frame(width: 100, height: 100) .clipShape(Circle()) .shadow(radius: 10) 加载和显示网络图像 要显示来自网络的图像，您通常需要使用SwiftUI的AsyncImage视图或结合URLSession自定义一个加载器。由于本节重点是Image视图，我们将在后续章节详细探讨如何加载网络图像。 总结 Text和Image是构建SwiftUI应用界面时最基础的元素。它们不仅用法简单，而且通过修饰符提供了强大的样式定制能力。通过合理使用这两种视图，您可以快速构建出丰富多彩且吸引人的界面。接下来的小节，我们将进一步探索SwiftUI中其他重要的视图和控件。 2. Buttons和Toggle 在SwiftUI中，Button和Toggle是两种用于用户交互的基本控件。它们使应用可以响应用户的操作，执行任务或更改状态。 Button 按钮是用户界面的基本组件，用于响应用户的点击或触摸操作。 创建按钮 在SwiftUI中，创建一个按钮需要提供一个动作和一个如何显示的内容： 1234567Button(action: &#123; // 在这里执行按钮的动作 print(&quot;按钮被点击&quot;)&#125;) &#123; // 提供按钮的内容 Text(&quot;点击我&quot;)&#125; 按钮样式 您可以使用修饰符来定制按钮的样式。例如，给按钮添加边框、背景色等： 12345678Button(&quot;点击我&quot;) &#123; print(&quot;按钮被点击&quot;)&#125;.frame(width: 200, height: 60).background(Color.blue).foregroundColor(.white).cornerRadius(10).padding() SwiftUI还提供了buttonStyle(_:)修饰符来应用预定义的按钮样式。 Toggle Toggle是一个开关控件，用于表示和改变一个布尔值的状态。 创建Toggle 创建一个Toggle同样需要一个绑定的状态和一个显示的标签： 1234567@State private var isOn = falsevar body: some View &#123; Toggle(isOn: $isOn) &#123; Text(&quot;切换状态&quot;) &#125;&#125; 在上面的代码中，isOn是一个@State属性，这意味着它是一个可变状态，当Toggle被切换时，视图会自动更新。 定制Toggle 可以使用.toggleStyle(_:)修饰符来定制Toggle的外观。SwiftUI提供了一些内建的样式，如SwitchToggleStyle和CheckboxToggleStyle（后者在macOS上可用）。 绑定和控制 按钮和开关的强大之处在于它们与SwiftUI的数据绑定系统的整合。当您使用$前缀创建绑定时，UI 控件将能够直接修改数据，反之亦然。这是SwiftUI声明式编程范式的核心。 响应用户输入 通常，按钮和开关会更改应用的状态或触发某个操作。例如，您可能会根据开关的状态显示或隐藏文本视图： 123456789101112131415@State private var isAccepted = falsevar body: some View &#123; VStack &#123; Toggle(isOn: $isAccepted) &#123; Text(&quot;接受条款和条件&quot;) &#125; Button(&quot;继续&quot;) &#123; // 可以在这里校验开关状态，例如是否接受了条款和条件 proceedWithAction() &#125; .disabled(!isAccepted) // 当不接受条款时禁用按钮 &#125;&#125; 总结 按钮和开关是任何交互式应用程序的基础，它们提供了一种简单有效的方式来收集用户输入并作出反应。SwiftUI的Button和Toggle视图配合数据绑定，使得创建动态和响应式的用户界面变得异常简单。它们的样式和行为可以通过一系列的修饰符进行定制，以适应您的设计需求。在接下来的小节中，我们将继续探讨如何使用SwiftUI构建更复杂的用户界面元素。 3. TextField和Slider 在SwiftUI中，创建交互式表单和控制元素是构建现代应用程序不可或缺的一部分。TextField和Slider是两种常用的控件，它们允许用户输入文本和选择值的范围。 TextField TextField是一个用于用户输入文本的控件，它可以接受键盘输入，并且可以对输入的文本进行格式化和校验。 创建TextField 创建一个TextField通常需要两个参数：一个标签和一个绑定到文本值的变量。 12345@State private var username: String = &quot;&quot;var body: some View &#123; TextField(&quot;用户名&quot;, text: $username)&#125; 在这个例子中，每当用户在文本字段中输入时，username变量都会更新。@State属性包装器用于在本地视图状态中存储可变数据。 定制TextField 您可以使用修饰符来定制TextField的外观和行为，例如设置字体、颜色、对齐方式、键盘类型等。 123456TextField(&quot;用户名&quot;, text: $username) .textFieldStyle(RoundedBorderTextFieldStyle()) .padding() .keyboardType(.default) .autocapitalization(.none) .disableAutocorrection(true) 在这个例子中，我们使用了textFieldStyle(_:)来为文本字段设置圆角边框样式，并进行了一些其他的配置。 Slider Slider允许用户从一个范围内选择一个值。它可以用于设置音量、选择亮度或应用任何其他需要用户选择一个数值的场景。 创建Slider 创建Slider至少需要一个绑定到数值的变量和一个值的范围。 12345@State private var sliderValue: Double = 0.5var body: some View &#123; Slider(value: $sliderValue, in: 0...1)&#125; 这个Slider允许用户在0到1之间选择一个值。 定制Slider Slider同样可以使用修饰符进行外观和功能的定制。您可以设置步长，决定滑块在变化时是否持续触发更新，以及添加标签。 12345678910Slider( value: $sliderValue, in: 0...1, step: 0.1, onEditingChanged: &#123; editing in // editing 是一个布尔值，表示是否正在编辑 print(&quot;当前滑块的值：\\(sliderValue)&quot;) &#125;).accentColor(.green) 在这个例子中，滑块的步长设置为0.1，且我们还指定了一个闭包，在用户编辑滑块值时触发。 总结 TextField和Slider为SwiftUI应用提供了基本的用户输入功能。通过与@State或其他形式的状态管理相结合，它们为开发者提供了创建动态和响应式表单的能力。定制这些控件的外观和行为使它们能够匹配应用程序的设计语言，提供更好的用户体验。在接下来的章节中，我们将探索SwiftUI中的其他高级控件和视图，并学习如何将它们组合在一起以构建复杂和功能丰富的用户界面。 4. 自定义视图和控件 SwiftUI的真正魅力之一在于它为开发者提供了丰富的自定义视图和控件的能力。通过结合现有的视图和控件以及Swift语言的强大特性，我们可以创建完全定制的用户界面元素，以完美地适应我们的设计需求。 理解视图的组合 在SwiftUI中，最基本的自定义视图起始于现有的视图的组合。SwiftUI的视图是可组合的，意味着你可以将简单的视图组合成复杂的视图。比如，我们可以创建一个带有文本和图像的自定义按钮视图： 1234567891011121314struct CustomButton: View &#123; var body: some View &#123; HStack &#123; Image(systemName: &quot;star.fill&quot;) .resizable() .frame(width: 20, height: 20) Text(&quot;收藏&quot;) &#125; .padding() .background(Color.blue) .foregroundColor(.white) .cornerRadius(10) &#125;&#125; 这个CustomButton就是一个自定义视图，它可以在任何其他的SwiftUI视图中使用。 创建完全自定义的视图 如果需要更高级的自定义，你可以从View协议开始，实现自己的body属性。这允许你控制视图的渲染方式，并响应用户的输入。 12345678910111213141516171819struct CircularProgressView: View &#123; var progress: Double // 从0.0到1.0 var body: some View &#123; ZStack &#123; Circle() .stroke(lineWidth: 20) .opacity(0.3) .foregroundColor(Color.blue) Circle() .trim(from: 0.0, to: CGFloat(min(self.progress, 1.0))) .stroke(style: StrokeStyle(lineWidth: 20, lineCap: .round, lineJoin: .round)) .foregroundColor(Color.blue) .rotationEffect(Angle(degrees: 270.0)) .animation(.linear) &#125; &#125;&#125; 在这个例子中，我们创建了一个显示进度的环形视图，它会根据progress属性显示不同的填充量。 响应用户交互 自定义视图可以通过各种手势识别器来响应用户的交互。例如，你可能会有一个自定义滑块控件，它通过拖动来改变值： 1234567891011121314151617struct CustomSlider: View &#123; @Binding var value: Double // 绑定到外部状态 var body: some View &#123; GeometryReader &#123; geometry in Rectangle() .foregroundColor(.gray) .frame(height: 20) .gesture( DragGesture(minimumDistance: 0) .onChanged &#123; gesture in self.value = Double(gesture.location.x / geometry.size.width) &#125; ) &#125; &#125;&#125; 在这个例子中，我们使用GeometryReader来获取视图的大小，并根据用户拖动的位置来更新value。 保持性能 在创建自定义视图和控件时，要记住保持它们的性能。这意味着： 避免不必要的视图重绘和状态更新。 合理使用.animation()和.transition()修饰符来为视图变化提供流畅的过渡效果。 当视图层次变得复杂时，考虑使用drawingGroup()或cache等优化技术。 总结 SwiftUI提供了强大的工具集，可以帮助开发者创建精美且功能丰富的自定义视图和控件。通过结合视图的组合、自定义绘制、响应用户输入等技术，你可以创建出完全符合你的设计和功能需求的用户界面元素。记住，自定义视图和控件不仅仅是关于创造外观，更重要的是它们提供了 与用户交互的新方式。随着你的SwiftUI技能的提高，你将能够更有效地利用这些工具，打造出既美观又高效的应用程序。","categories":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"http://xuebusi.gitee.io/categories/SwiftUI/"}],"tags":[]},{"title":"SwiftUI核心技术第3章环境搭建","slug":"SwiftUI核心技术第3章环境搭建","date":"2023-11-07T16:28:17.000Z","updated":"2024-03-17T06:11:12.787Z","comments":true,"path":"2023/11/08/SwiftUI核心技术第3章环境搭建/","permalink":"http://xuebusi.gitee.io/2023/11/08/SwiftUI%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC3%E7%AB%A0%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","excerpt":"","text":"1. Xcode和SwiftUI 为了开始使用SwiftUI，您需要安装Xcode，这是Apple提供的官方集成开发环境（IDE）。Xcode提供了构建iOS、iPadOS、macOS、watchOS和tvOS应用的所有工具和资源。SwiftUI是Xcode的一部分，是一个用于设计和开发用户界面的框架。在这一节中，我们将指导您如何设置Xcode和开始使用SwiftUI。 安装Xcode 从Mac App Store下载Xcode Xcode是免费的，可以直接从Mac App Store下载。确保您的Mac操作系统是最新的，因为新版本的Xcode通常只能在最新或次新的操作系统上运行。 启动Xcode并安装额外组件 当您第一次打开Xcode时，它可能会提示您安装额外的必需组件。按照提示进行安装。 接受Xcode许可协议 在安装组件之前，您可能需要接受Xcode的许可协议。您可以通过Xcode或使用终端命令行来完成这一步骤。 配置Xcode 安装完成后，您可能需要进行一些基础配置： 设置开发者账户 在Xcode的Preferences（偏好设置）中，您可以登录您的Apple开发者账户。如果您还没有账户，您需要注册一个。 下载模拟器或配置开发设备 如果您打算在真实设备上运行应用，需要在Xcode中配置您的iOS设备。否则，您可以下载并使用模拟器。 创建SwiftUI项目 打开Xcode并创建一个新的项目 选择“Create a new Xcode project”（创建一个新的Xcode项目）。 选择项目模板 在模板选择器中，选择“App”作为您的项目模板。 配置项目设置 您需要填写项目名称、团队、组织名称、组织标识符以及选择您想要支持的平台。 选择SwiftUI作为界面 在创建项目时，确保在“User Interface”选项中选择“SwiftUI”。 探索SwiftUI Canvas Xcode提供了一个实时预览界面（Canvas），您可以看到SwiftUI代码的实时渲染结果。通过点击Canvas右上角的“Resume”按钮，可以启动或刷新预览。 Inspector Xcode的Inspector可以帮助您调整SwiftUI视图的属性，您可以直接通过图形界面来调整代码，而不需要编写任何代码。 代码编辑器 Xcode的代码编辑器是您编写Swift和SwiftUI代码的地方。它提供了代码高亮、自动完成等功能，这可以极大提升编码效率。 构建和运行 选择目标 在Xcode顶部的工具栏中，您可以选择要在哪个模拟器或真实设备上运行您的应用。 构建并运行应用 点击工具栏中的“Run”按钮（或使用快捷键Command + R）来构建并运行您的应用。如果一切设置正确，您应该能看到您的SwiftUI应用在模拟器或设备上运行。 总结 设置Xcode并开始使用SwiftUI是开发现代iOS应用的第一步。通过Xcode，您可以使用SwiftUI框架来创建美观、响应迅速且易于维护的用户界面。本节提供了有关如何安装和配置Xcode、创建新的SwiftUI项目以及构建和运行应用的基本信息。掌握这些基础知识后，您将准备好深入探索SwiftUI的强大功能，并开始构建您自己的应用。 2. Swift Package Manager Swift Package Manager（简称SPM）是Apple官方提供的一个用于自动化Swift代码的依赖管理和分发的工具。它与Xcode紧密集成，允许开发者方便地添加、更新和管理依赖库。 SPM的概念 包（Package）：是一个或多个库的集合，它们共享一个构建设置和版本号。 库（Library）：是可复用代码的集合，用于构建程序或其他库。 依赖（Dependency）：是您的项目需要的外部库或包。 使用Swift Package Manager 创建Package.swift 为了使用SPM，您的项目需要一个Package.swift文件，这是一个定义了包的名称、平台、Swift版本和依赖的清单文件。以下是一个基本的Package.swift示例： 12345678910111213141516171819202122232425// swift-tools-version:5.3import PackageDescriptionlet package = Package( name: &quot;MyLibrary&quot;, platforms: [ .macOS(.v10_15), .iOS(.v13) ], products: [ .library( name: &quot;MyLibrary&quot;, targets: [&quot;MyLibrary&quot;]), ], dependencies: [ .package(url: &quot;https://github.com/someone/Something.git&quot;, from: &quot;1.0.0&quot;), ], targets: [ .target( name: &quot;MyLibrary&quot;, dependencies: []), .testTarget( name: &quot;MyLibraryTests&quot;, dependencies: [&quot;MyLibrary&quot;]), ]) 添加依赖 在Package.swift文件中，您可以添加其他包作为依赖。SPM将自动下载和链接这些依赖。 集成到Xcode项目 您可以通过Xcode直接添加SPM依赖： 打开Xcode项目或工作区。 选择“File” &gt; “Swift Packages” &gt; “Add Package Dependency…”。 输入包的Git存储库URL，然后选择一个版本号或分支。 选择要添加到哪个目标，然后完成集成流程。 使用命令行 您也可以通过命令行界面使用SPM： swift build：构建您的项目。 swift test：测试您的项目。 swift run：运行您的项目。 swift package update：更新您的依赖。 管理依赖版本 SPM支持多种方式指定依赖版本： 指定一个具体版本号。 指定一个版本范围。 使用分支名称或提交哈希。 例如： 123.package(url: &quot;https://github.com/someone/Something.git&quot;, .exact(&quot;1.0.0&quot;)).package(url: &quot;https://github.com/someone/Something.git&quot;, from: &quot;1.0.0&quot;).package(url: &quot;https://github.com/someone/Something.git&quot;, .branch(&quot;main&quot;)) 总结 Swift Package Manager是一个强大的依赖管理工具，它简化了Swift项目中库和依赖的管理。通过声明式的Package.swift文件和Xcode的集成，SPM使得添加、更新和维护依赖变得既简单又可靠。了解SPM是现代Swift开发的重要组成部分，尤其是当您开始构建更大型且依赖多个第三方库的项目时。掌握SPM的使用将帮助您保持项目的清洁和组织，提高构建的可复用性和可维护性。 3. 创建第一个SwiftUI应用 进入到SwiftUI世界的第一步是创建您的第一个SwiftUI应用。本节将指导您完成创建和运行一个基本的SwiftUI应用程序的步骤，让您快速体验到SwiftUI开发的流畅和直观。 设置项目 启动Xcode：打开Xcode。在欢迎屏幕上选择“Create a new Xcode project”或在菜单栏选择“File” &gt; “New” &gt; “Project”。 选择模板：在项目模板选择界面，选择“App”作为项目模板。这将创建一个包含所有必需文件的iOS应用程序项目。 项目配置：在“Choose options for your new project”界面，填写项目的详细信息： Product Name：应用程序的名称。 Team：如果您已注册Apple开发者计划并设置了Xcode，选择您的开发者团队。 Organization Identifier：通常是您或您公司的域名反写（例如com.example）。 Interface：确保选择“SwiftUI”。 Language：选择“Swift”。 Lifecycle：根据您的需求选择“SwiftUI App”。 Use Core Data：如果不需要，保持未选中状态。 Include Tests：如果您打算写测试，选择相应的测试复选框。 选择保存位置：选择一个适合您项目的位置，并且如果您想使用版本控制（例如Git），确保选中“Create Git repository”。 探索SwiftUI工作区 Project Navigator：在Xcode左侧的侧边栏中，您可以看到Project Navigator，它展示了项目中所有的文件和资源。 ContentView.swift：这是您的SwiftUI视图代码所在的文件。Xcode默认为您提供了一个包含Text视图的简单SwiftUI视图。 Preview：Xcode支持SwiftUI的实时预览。如果Preview未自动显示，您可以点击代码编辑器顶部的“Resume”按钮来加载它。 编写SwiftUI代码 修改ContentView： 用以下代码替换ContentView结构体中的内容： 123456struct ContentView: View &#123; var body: some View &#123; Text(&quot;Hello, SwiftUI!&quot;) .padding() &#125;&#125; 使用Preview： 使用Preview功能，您可以实时看到代码更改的效果。如果预览未显示，点击“Resume”按钮。 运行应用 选择模拟器或设备：在Xcode工具栏中，选择一个模拟器或连接的设备作为目标。 构建并运行：点击工具栏中的“Run”按钮或使用快捷键Command + R来编译并运行您的应用。 查看结果：您的应用程序将启动，并在所选模拟器或设备上显示“Hello, SwiftUI!”文本。 总结 恭喜您！通过完成这些步骤，您已经成功创建并运行了您的第一个SwiftUI应用。这只是一个开始，SwiftUI有着非常丰富的视图和控件供您使用，通过学习和实验，您将能够构建出功能强大且界面美观的应用程序。接下来的章节中，我们将进一步深入探索SwiftUI提供的各种构建用户界面的工具和技术。","categories":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"http://xuebusi.gitee.io/categories/SwiftUI/"}],"tags":[]},{"title":"SwiftUI核心技术","slug":"SwiftUI核心技术","date":"2023-11-07T16:07:31.000Z","updated":"2024-03-17T06:11:04.809Z","comments":true,"path":"2023/11/08/SwiftUI核心技术/","permalink":"http://xuebusi.gitee.io/2023/11/08/SwiftUI%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/","excerpt":"","text":"前言 SwiftUI的介绍 SwiftUI与UIKit的比较 本书适用读者 如何使用本书 第一部分：SwiftUI基础 第1章：SwiftUI概述 SwiftUI的设计哲学 SwiftUI的架构 MVVM设计模式在SwiftUI中的应用 第2章：Swift语言回顾 Swift基础 面向协议编程 Swift中的函数式编程特性 第3章：环境搭建 Xcode和SwiftUI Swift Package Manager 创建第一个SwiftUI应用 第二部分：构建用户界面 第4章：视图与控件 Text和Image Buttons和Toggle TextField和Slider 自定义视图和控件 第5章：布局管理 堆（Stacks） 对齐与帧（Alignment and Frames） Spacer和Divider 布局优先级 第6章：数据流与绑定 State和Binding ObservedObject和EnvironmentObject @Published和Combine 数据流的最佳实践 第7章：导航与呈现 NavigationView和NavigationViewLink TabView Sheets和Alerts Navigation的高级用法 第三部分：进阶SwiftUI 第8章：动画与转场 基础动画 自定义动画 交互式和响应式动画 转场动画 第9章：复合视图与可复用性 组合现有视图 创建可复用的视图库 自定义Modifier 第10章：集成Core Data和CloudKit Core Data概念和配置 SwiftUIT中的Core Data集成 使用CloudKit进行数据同步 第四部分：平台特定的设计 第11章：适配多平台 Catalyst: 从iOS到macOS watchOS特有的UI组件 tvOS和大屏体验 第12章：Dark Mode和Accessibility 支持暗黑模式 辅助功能的最佳实践 动态字体与国际化 第五部分：性能优化与测试 第13章：性能优化 诊断和解决性能问题 延迟加载和内存管理 视图更新效率优化 第14章：测试与调试 单元测试和UI测试 使用Xcode调试 预览与条件编译 第六部分：实战案例 第15章：构建一个完整的应用（Part 1） 应用结构规划 用户界面设计 应用逻辑实现 第16章：构建一个完整的应用（Part 2） 数据持久化 网络请求和数据处理 应用测试和发布准备 附录 A：SwiftUI视图和控件清单 B：SwiftUI常见问题解答 C：资源和进一步阅读 结束语 对SwiftUI的展望 社区和支持 索引 这个大纲为读者提供了从基础到进阶，再到实际应用开发的完整路径。可以 根据读者的反馈和最新的SwiftUI更新不断调整和增补内容。 当然，以下是一段示例前言的草稿，可以用作你书籍的前言部分。 前言 欢迎来到《SwiftUI核心技术》，一本旨在探索和解锁Apple最新UI框架——SwiftUI的无限潜力的指南。在这个移动第一的时代，出色的用户界面和顺畅的用户体验是成功应用的关键。随着SwiftUI的出现，Apple开创了一种新的构建UI的方式，它比以往更加直观，更具表现力，且在所有Apple设备上都提供一致的体验。 SwiftUI的介绍 SwiftUI是Apple在2019年引入的一个创新的UI工具包，用于在所有Apple平台上构建用户界面。它利用Swift语言的强大功能，通过声明性语法简化了UI开发。SwiftUI不仅提供了一种更简洁、更易于理解的方式来构建UI，而且还具有数据驱动的特点，这意味着UI的每个部分都是根据应用状态的变化来更新的。 SwiftUI与UIKit的比较 尽管UIKit已经是iOS应用开发的主导UI框架多年，但SwiftUI带来了许多优势，特别是在创建跨平台UI时。UIKit依赖于命令式编程和手动管理的UIView，而SwiftUI使用声明式代码和自动管理的视图体系结构。这就意味着用SwiftUI可以用更少的代码做更多的工作，同时减少了出错的可能性。不过，对于已经存在的项目，UIKit仍然是必不可少的，因此理解两者的差异对于现代iOS开发者来说至关重要。 本书适用读者 无论您是新手程序员还是有经验的开发者，只要您对掌握SwiftUI感兴趣，这本书就是为您准备的。我们假设您已经对Swift语言有了基本的了解，并希望扩展您的知识库来包括UI设计。如果您是从UIKit转型来的开发者，这本书将帮助您理解SwiftUI的独特之处，并指导您如何迁移现有的知识和技能。 如何使用本书 《SwiftUI核心技术》是按模块组织的，从基础知识到高级应用，最后是综合案例研究。您可以按顺序阅读以构建坚实的基础，也可以直接跳到对您当前项目最相关的章节。每个概念都伴随着代码示例和最佳实践，以便您可以实践所学，并在实际中应用这些技能。书中还包含了挑战和练习，让您能够测试自己的理解并巩固学习成果。 当您准备开始您的SwiftUI之旅时，希望这本书成为您的指南，带您更深入地了解如何使用这一令人兴奋的新框架来创造美妙、响应迅速且富有表现力的用户界面。 希望这段前言能够为您的书籍奠定一个温馨而专业的开场。您可以根据实际需要调整这段文本，以更好地符合您对书籍的愿景。 第1章：SwiftUI概述 1. SwiftUI的设计哲学 苹果公司在2019年WWDC上推出SwiftUI时，开启了iOS、macOS、watchOS和tvOS开发的新篇章。该框架的设计哲学突破了以往UI开发的界限，以优雅且革命性的方式提高了开发速度、改善了代码的质量，并统一了跨平台的用户体验。本节将详细介绍构成SwiftUI设计哲学的核心元素。 简洁的声明性语法 SwiftUI的核心是其声明性语法。在传统的命令式编程模型中，开发者需要详细指定如何绘制和更新用户界面的每一个变化。这种方式虽然直接，但随着应用界面变得越来越复杂，代码就会变得难以理解和维护。相比之下，SwiftUI采用声明性方法，允许开发者表达他们想要的界面应该是什么样子，而非如何绘制界面。 例如，一个按钮的创建和配置，在UIKit中可能需要数行代码来设定它的状态和外观，还要添加响应点击的动作。而在SwiftUI中，同样的按钮只需要几行声明性代码即可完成： 123Button(&quot;点击我&quot;) &#123; print(&quot;按钮被点击&quot;)&#125; 这样的语法不仅使代码更易读，也使得UI的各个组件能够更容易地重用和组合。 组件化和可组合性 SwiftUI强调组件化—创建可重用的UI组件—以及可组合性—将这些组件拼接成复杂的UI。每个SwiftUI视图都是一种结构体，这是一种轻量级的数据类型，非常适合用来描述UI组件。这与UIKit的类和对象相比，可以显著提高性能，特别是在用户界面需要快速重建时。 此外，SwiftUI的视图可以包含其他视图，这就为开发者提供了极大的灵活性来构建复杂的用户界面。例如，可以创建一个自定义的按钮样式，然后在不同的地方多次使用，而无需重写样式代码。 一致性和跨平台设计 SwiftUI的一个显著特点是其跨平台能力。相同的SwiftUI代码可以运行在iOS、macOS、watchOS和tvOS上，无需做出太多修改。这种一致性意味着开发者可以为所有Apple平台构建统一的应用体验，同时允许针对特定平台的优化。 跨平台设计的好处是显而易见的。开发者可以集中精力于创建出色的用户体验，而不是花费时间在适配不同平台的布局和控件上。SwiftUI通过提供一致的API和控件集，确保了界面在各个设备上都能保持良好的交互和视觉效果。 数据驱动的UI更新 SwiftUI的另一个核心特性是数据驱动的UI更新。这意味着UI的状态可以被绑定到应用程序的数据模型上，当数据变化时，UI会自动更新。这种绑定使用了Swift的属性包装器如@State和@Binding，它们提供了一种声明性的方式来定义视图的源数据。 以一个简单的文本输入为例，在UIKit中，您可能需要实现委托模式来响应文本变化，然后手动更新UI。而在SwiftUI中，您可以这样做： 12345678910struct ContentView: View &#123; @State private var userName: String = &quot;&quot; var body: some View &#123; TextField(&quot;请输入用户名&quot;, text: $userName) Text(&quot;您好，\\(userName)!&quot;) &#125;&#125; 在这个例子中，TextField的文本被绑定到userName状态上。当用户在文本字段中输入时，userName会自动更新，而且相关的Text视图也会即时反映这个变化。 总结 SwiftUI的设计哲学是为了提高开发效率、改善代码质量，并使应用能够快速适应未来的变化。通过其声明性语法、组件化和可组合性、一致性以及数据驱动的UI更新，SwiftUI为现代应用开发树立了新的标准。接下来，我们将进一步探讨SwiftUI是如何实现这些设计理念的，并通过实例展示这些概念在实际开发中的应用。 2. SwiftUI的架构 SwiftUI是构建在一系列高效且现代的编程模式和原则之上的，它不仅简化了用户界面的创建，而且通过其独特的架构提升了应用性能和开发效率。在本节中，我们将深入了解构成SwiftUI架构的各个部分，以及它们如何协同工作以创建流畅且动态的用户界面。 视图层次结构与组件 在SwiftUI中，一切都是视图。从文本标签(Text)到按钮(Button)，再到整个屏幕(ContentView)，所有的UI组件都是视图。SwiftUI使用一种结构体(struct)来定义视图，这是一个轻量级的数据类型，非常适合描述UI组件。每个视图都知道如何绘制自己，并能定义自己的布局。 一个关键概念是视图的层次结构，它表示视图的嵌套。父视图可以包含多个子视图，创建出丰富的布局。SwiftUI使用声明性的方法来组织视图层次，这意味着您声明界面应该如何组织，而不是编写代码来动态创建和管理视图对象。 布局系统 SwiftUI的布局系统是自适应和响应式的，允许视图以一种非常自然的方式响应外部条件的变化，如设备的屏幕大小或者设备方向。布局是由视图本身以及环境(Environment)中的信息决定的。每个视图提供了一个body属性，描述了其子视图的布局。 SwiftUI的Stack、List、Grid等布局容器帮助您定义强大而灵活的布局。例如，一个VStack会垂直堆叠其子视图，而一个HStack则会水平堆叠。每个容器都可以包含其他容器，从而创建复杂且响应式的布局结构。 数据流和绑定 SwiftUI的架构旨在促进数据流的清晰和一致。它通过使用一系列属性包装器来实现，如@State、@Binding、@ObservedObject和@EnvironmentObject。这些属性包装器提供了不同层级的数据流和状态管理，确保视图与数据保持同步。 @State是一种私有的、视图内的状态管理，用于存储视图的本地数据。@Binding则创建了一个可读写的连接到另一个视图持有的@State的连接，从而允许数据在不同视图间共享。 对于更复杂的数据管理，@ObservedObject和@EnvironmentObject使得视图能够订阅外部的数据模型。当数据模型标记为ObservableObject并且其内部的数据通过@Published包装器进行更改时，订阅这些模型的视图会自动更新。 声明性渲染 SwiftUI的架构在内部使用了一种高效的声明性渲染引擎，它能够智能地重绘改变了的部分而非整个界面。这是通过比较视图的当前状态和新的声明来实现的。当状态发生变化时，SwiftUI计算出最小的差异，并且只更新需要改变的部分。 这种智能重绘是非常重要的，因为它意味着视图的更新可以非常快速，并且能保持性能，即使在复杂的界面和动画中也是如此。 Swift与SwiftUI的紧密集成 SwiftUI与Swift编程语言的紧密集成提供了许多编程上的好处。利用Swift的强类型系统、函数式编程特性和高级语言构造，SwiftUI可以确保代码安全、清晰且易于理解。 SwiftUI的一切，从其布局系统到与Combine框架的集成，都是为了简化编程模型，允许开发者以一种更直观和高效的方式来构建用户界面。 总结 SwiftUI的架构是其强大功能和易用性的基石。通过视图层次结构、响应式布局系统、清晰的数据流和绑定以及高效的声明性渲染，SwiftUI提供了一个坚实的基础来构建现代的跨平台应用。了解这些概念对于充分利用SwiftUI的潜力是至关重要的。在本书的后续章节中，我们将进一步深入探讨每个概念，并通过具体的代码示例来展示它们在实际开发中的应用。 3. MVVM设计模式在SwiftUI中的应用 在现代应用开发中，架构模式的选择对于确保代码的可读性、可维护性和可扩展性至关重要。Model-View-ViewModel (MVVM) 是一种被广泛采用的设计模式，尤其是在SwiftUI中，它提供了一种清晰地分离用户界面和业务逻辑的方式。本节将探讨MVVM设计模式，并详细说明它如何在SwiftUI中得到应用。 MVVM的核心概念 MVVM设计模式将应用分为三个主要组件：Model、View和ViewModel。 Model - 表示应用的数据和业务逻辑。它是纯粹的Swift类或结构体，不含任何UI代码。 View - 显示应用的用户界面。在SwiftUI中，所有的UI组件都是视图，从单个按钮到整个屏幕。 ViewModel - 作为Model和View之间的桥梁。它包含了展示逻辑，但不包含业务逻辑或者状态管理的代码。 MVVM通过这种分离，确保了UI代码的简洁性，并允许业务逻辑独立于UI，使其更易于测试和重用。 ViewModel在SwiftUI中的角色 在SwiftUI中，ViewModel通常是一个符合ObservableObject协议的Swift类。它会暴露出用于UI显示的数据，并将用户的交互转化为模型更新和视图的状态更改。 例如，如果您有一个任务列表应用，ViewModel可能包含一个任务数组的状态以及添加新任务的方法。当用户通过界面添加任务时，ViewModel会更新Model，并通知View重新渲染以显示新任务。 数据绑定和状态管理 SwiftUI的数据绑定特性与MVVM的配合尤其紧密。使用@Published属性包装器，ViewModel可以提供可观察的数据属性，当这些属性的值变化时，关联的视图可以自动更新。 此外，SwiftUI的状态管理属性包装器，如@State、@Binding、@StateObject和@EnvironmentObject，进一步简化了ViewModel与View之间数据和状态的同步。 MVVM的实际应用 在SwiftUI应用中实施MVVM时，ViewModel的职责包括： 提供视图所需的数据。 响应用户输入并更新Model。 监控Model的变化并通知View更新。 处理导航和视图间的协调逻辑。 由于SwiftUI的视图是声明性的，ViewModel成为控制视图状态的中心。开发者不再需要写大量的引导代码来手动更新UI，而是可以依靠SwiftUI的绑定机制和ViewModel来自动处理。 总结 MVVM设计模式在SwiftUI中的应用为创建结构化和高效的应用程序提供了框架。通过将业务逻辑移至ViewModel，并利用SwiftUI的响应式数据绑定，开发者能够创建更清晰、更易于维护和扩展的代码。在本书接下来的章节中，我们将通过具体示例深入探讨MVVM模式在SwiftUI应用开发中的具体实现和最佳实践。 第2章：Swift语言回顾 1. Swift基础 Swift 是由苹果公司开发的一种强大的编程语言，旨在为开发者提供一种简单、清晰且高效的语言工具。它既适合新手学习编程，也足以满足专业开发者构建复杂应用的需求。在本节中，我们将回顾Swift语言的基础，为深入学习SwiftUI打下坚实的基础。 变量和常量 Swift 使用 var 关键字来声明变量，let 关键字来声明常量。变量是可以被赋予不同值的标识符，而常量一旦设定初始值后则不能更改。 12var greeting = &quot;Hello, world!&quot;let pi = 3.14159 数据类型 Swift 是一种类型安全的语言，这意味着每个变量都有一个明确的类型。Swift 的基本数据类型包括 Int、Float、Double、Bool、String 等。 1234var age: Int = 30var price: Double = 29.99var isHidden: Bool = falsevar name: String = &quot;John Doe&quot; 控制流 Swift 提供了丰富的控制流结构，包括 if、else 条件语句，switch 语句，以及 for-in、while 和 repeat-while 循环。 123456789if age &gt; 18 &#123; print(&quot;Adult&quot;)&#125; else &#123; print(&quot;Minor&quot;)&#125;for index in 1...5 &#123; print(index)&#125; 函数 函数是执行特定任务的自包含代码块。Swift 的函数使用 func 关键字声明，可以接受参数和返回值。 1234func greet(person: String) -&gt; String &#123; return &quot;Hello, \\(person)!&quot;&#125;print(greet(person: &quot;Anna&quot;)) // Prints &quot;Hello, Anna!&quot; 闭包 闭包是可以在代码中被传递和使用的自包含功能块，类似于其他语言中的匿名函数。闭包捕获并存储它们的上下文中的任何常量和变量的引用。 12let names = [&quot;Chris&quot;, &quot;Alex&quot;, &quot;Ewa&quot;, &quot;Barry&quot;, &quot;Daniella&quot;]var reversedNames = names.sorted(by: &#123; $0 &gt; $1 &#125;) 结构体和类 Swift 中的结构体和类是构建代码的基本构件。结构体是值类型，而类是引用类型。 1234567891011struct Point &#123; var x: Int var y: Int&#125;class Vehicle &#123; var numberOfWheels = 0 func description() -&gt; String &#123; return &quot;\\(numberOfWheels) wheel(s)&quot; &#125;&#125; 属性和方法 属性用于存储值，方法用于添加特定的行为。计算属性则提供了一种自定义的 getter 和 setter 来间接获取和设置其他属性或变量的值。 123456class Circle &#123; var radius: Double = 0 var circumference: Double &#123; return pi * radius * 2 &#125;&#125; 协议和扩展 协议定义了一组方法和属性的蓝图，类、结构体和枚举可以实现这些协议。扩展则允许你为现有的类型添加新的功能。 123456789protocol Identifiable &#123; var id: String &#123; get set &#125;&#125;extension String &#123; func capitalizedFirst() -&gt; String &#123; return prefix(1).uppercased() + self.lowercased().dropFirst() &#125;&#125; 错误处理 Swift 中的错误处理允许你表示并处理程序执行中可能遇到的错误条件。 1234567891011121314enum PrinterError: Error &#123; case outOfPaper case noToner case onFire&#125;func send(job: Int, toPrinter printerName: String) throws -&gt; String &#123; if printerName == &quot;Never Has Toner&quot; &#123; throw PrinterError.noToner &#125; return &quot;Job sent&quot;&#125; 泛型 泛型允许你写出灵活、可重用的函数和类型，它们可以工作于任何类型。 12345func swapTwoValues&lt;T&gt;(_ a: inout T, _ b: inout T) &#123; let temporaryA = a a = b b = temporaryA&#125; 总结 这些是Swift语言的一些核心概念，掌握它们对于理解SwiftUI的工作方式至关重要。Swift的这些特性提供了构建SwiftUI应用所需的工具和构建块，接下来的章节中我们将看到这些基础如何在实际的SwiftUI编程中得到应用。 2. 面向协议编程 面向协议编程（Protocol-Oriented Programming，POP）是Swift语言的一个核心范式。与面向对象编程（Object-Oriented Programming，OOP）关注在类和继承上构建程序的层次结构不同，POP倡导通过定义协议并将它们实现于类、结构体或枚举来构建程序的行为和形态。在本节中，我们将探讨POP的基础，以及如何在Swift中应用这个强大的编程范式。 协议的定义 协议定义了一套蓝图，规定了采纳协议的类型必须实现哪些方法和属性。协议可以被类、结构体或枚举类型采纳，以提供所需的实现。 12345678910protocol Identifiable &#123; var id: String &#123; get set &#125; func identify()&#125;extension Identifiable &#123; func identify() &#123; print(&quot;My ID is \\(id).&quot;) &#125;&#125; 在上述例子中，任何采纳Identifiable协议的类型都必须有一个id属性，并且默认提供了一个identify方法的实现。 面向协议的优势 复用性：通过定义协议，您可以创建可在多种类型间复用的方法和属性。 松耦合：类型之间的依赖性降低，因为它们依赖于协议，而不是具体的实现。 灵活性：可以为不同的类型添加协议扩展，为它们提供特定的功能，而无需修改原有类型代码。 适应性：类型可以同时采纳多个协议，易于适配和扩展。 使用协议定义行为 一个典型的POP实践是定义一系列协议来代表应用的不同部分可以共享的行为，而不是创建基类。 12345678910111213protocol Flyable &#123; var airspeedVelocity: Double &#123; get &#125;&#125;protocol Feasible &#123; var isFeasible: Bool &#123; get &#125;&#125;// 现在，任何类型都可以采纳Flyable和Feasible协议，不仅限于某个类的子类。struct Bird: Flyable, Feasible &#123; var airspeedVelocity: Double var isFeasible: Bool&#125; 在扩展中采纳协议 Swift允许在类型的扩展中采纳协议。这意味着即使是先前定义好的类型，也可以被增强来采纳新的协议。 12345extension Array: Identifiable where Element: Identifiable &#123; var id: String &#123; return self.map &#123; $0.id &#125;.joined(separator: &quot;, &quot;) &#125;&#125; 这里，只要数组的元素采纳了Identifiable协议，数组本身就自动采纳了Identifiable。 关联类型 协议可以具有关联类型，这是一种未被指定的类型占位符，其具体类型将由协议的采纳者提供。 123456789101112protocol Container &#123; associatedtype Item mutating func append(_ item: Item) var count: Int &#123; get &#125; subscript(i: Int) -&gt; Item &#123; get &#125;&#125;struct IntStack: Container &#123; // 实现Container协议的要求 typealias Item = Int // ...&#125; 关联类型增加了协议的灵活性，使其可以被不同的类型以不同的方式采纳。 总结 面向协议编程是Swift语言的一个核心原则，它鼓励开发者通过协议来定义接口和行为，而不是传统的继承。这样的方法为代码提供了更高的复用性和灵活性，也更加 安全。在SwiftUI中，您会发现许多UI组件都是基于协议来构建的，这使得自定义和扩展UI变得十分方便和高效。通过本节的学习，您应该对如何使用面向协议编程来构建更强大、更模块化的Swift应用有了更深刻的理解。 3. Swift中的函数式编程特性 函数式编程是一种编程范式，它将计算视为数学函数的评估，并避免状态以及可变数据。Swift虽然不是一个纯函数式编程语言，但它融合了许多函数式编程的特性。这些特性可以帮助开发者编写更简洁、更易于理解的代码。在本节中，我们将探索Swift中的函数式编程特性及其在实际编程中的应用。 不可变性 在函数式编程中，不可变性是一个核心概念。不可变的数据可以避免副作用和状态变化，这使得程序更容易理解和调试。在Swift中，使用let关键字声明的常量是不可变的。 12let constantArray = [1, 2, 3]// constantArray[0] = 4 // 这行代码将导致编译错误，因为数组是不可变的 一等函数 Swift将函数作为一等公民，这意味着函数可以作为其他函数的参数传递，也可以作为函数的返回值，还可以赋值给变量。 123456func add(_ a: Int, _ b: Int) -&gt; Int &#123; return a + b&#125;var mathFunction: (Int, Int) -&gt; Int = addprint(mathFunction(2, 3)) // 输出 5 高阶函数 Swift标准库中提供了多种高阶函数，如map、filter、reduce等，这些函数都可以接受一个函数作为输入。 map 用于将集合中的每个元素通过特定的方法进行转换。 filter 用于选择集合中符合特定条件的元素。 reduce 用于将集合中的元素合并成一个单一的值。 1234let numbers = [1, 2, 3, 4, 5]let squaredNumbers = numbers.map &#123; $0 * $0 &#125; // [1, 4, 9, 16, 25]let evenNumbers = numbers.filter &#123; $0 % 2 == 0 &#125; // [2, 4]let sumOfNumbers = numbers.reduce(0, +) // 15 闭包 闭包是自包含的函数代码块，可以在代码中传递和使用。它们尤其适用于函数式编程，因为它们可以捕获和存储任何它们所在上下文中的常量和变量的引用。 12let names = [&quot;Chris&quot;, &quot;Alex&quot;, &quot;Ewa&quot;, &quot;Barry&quot;, &quot;Daniella&quot;]let reversedNames = names.sorted(by: &#123; s1, s2 in return s1 &gt; s2 &#125;) 柯里化（Currying） 柯里化是函数式编程中的一个概念，指的是将一个接受多个参数的函数转换成一系列只接受单一参数的函数。 123456func add(_ a: Int) -&gt; (Int) -&gt; Int &#123; return &#123; b in return a + b &#125;&#125;let addTwo = add(2)let result = addTwo(3) // 5 惰性求值（Lazy Evaluation） Swift中的序列和集合提供了惰性求值的选项，这意味着只有在需要计算值的时候才会进行计算。这可以提高程序的性能，特别是在处理大型数据集时。 123let data = 1...1000let result = data.lazy.filter &#123; $0 % 2 == 0 &#125;.map &#123; $0 * 2 &#125;// result 的计算将会被延迟，直到实际被需要 总结 Swift的函数式编程特性能够帮助开发者写出更加清晰、简洁和可维护的代码。通过利用不可变性、高阶函数、闭 包等特性，Swift开发者可以编写出更加表达力强、逻辑清晰的代码。在SwiftUI开发中，这些特性被广泛应用，以实现数据和UI的高效绑定和操作。掌握这些函数式编程的概念将在接下来的章节中帮助读者更好地理解SwiftUI的设计和实现方式。","categories":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"http://xuebusi.gitee.io/categories/SwiftUI/"}],"tags":[]},{"title":"SwiftUI中ScrollView的用法","slug":"SwiftUI中ScrollView的用法","date":"2023-11-07T14:08:11.000Z","updated":"2024-03-17T06:13:07.568Z","comments":true,"path":"2023/11/07/SwiftUI中ScrollView的用法/","permalink":"http://xuebusi.gitee.io/2023/11/07/SwiftUI%E4%B8%ADScrollView%E7%9A%84%E7%94%A8%E6%B3%95/","excerpt":"","text":"在 SwiftUI 中，ScrollView 是一个可以滚动显示其子视图的容器。使用 ScrollView，你可以创建一个可以纵向或横向滚动的区域，这对于构建超出屏幕限制的内容是非常有用的。 基本用法默认情况下，ScrollView 滚动方向是垂直的。 12345678910111213141516171819import SwiftUIstruct BasicScrollView: View &#123; var body: some View &#123; ScrollView &#123; VStack(spacing: 20) &#123; ForEach(0..&lt;50) &#123; index in Text(&quot;Row \\(index)&quot;) &#125; &#125; &#125; &#125;&#125;struct BasicScrollView_Previews: PreviewProvider &#123; static var previews: some View &#123; BasicScrollView() &#125;&#125; 水平滚动要创建一个水平滚动视图，需要设置 ScrollView 的 axis 参数。 1234567891011121314151617181920212223import SwiftUIstruct HorizontalScrollView: View &#123; var body: some View &#123; ScrollView(.horizontal, showsIndicators: false) &#123; HStack(spacing: 20) &#123; ForEach(0..&lt;50) &#123; index in Text(&quot;Column \\(index)&quot;) .frame(width: 200, height: 200) .background(Color.blue) .foregroundColor(.white) .cornerRadius(10) &#125; &#125; &#125; &#125;&#125;struct HorizontalScrollView_Previews: PreviewProvider &#123; static var previews: some View &#123; HorizontalScrollView() &#125;&#125; 同时水平和垂直滚动可以通过在 ScrollView 中嵌套另一个 ScrollView 来创建同时支持水平和垂直滚动的视图。 1234567891011121314151617181920212223242526272829import SwiftUIstruct BothDirectionsScrollView: View &#123; var body: some View &#123; ScrollView &#123; VStack(spacing: 20) &#123; ForEach(0..&lt;10) &#123; index in ScrollView(.horizontal, showsIndicators: true) &#123; HStack(spacing: 20) &#123; ForEach(0..&lt;10) &#123; index in Text(&quot;Item \\(index)&quot;) .frame(width: 100, height: 100) .background(Color.green) .cornerRadius(10) &#125; &#125; &#125; .frame(height: 100) &#125; &#125; &#125; &#125;&#125;struct BothDirectionsScrollView_Previews: PreviewProvider &#123; static var previews: some View &#123; BothDirectionsScrollView() &#125;&#125; 添加滚动条指示器ScrollView 的 showsIndicators 参数可以控制是否显示滚动条指示器。 响应滚动事件SwiftUI ScrollView 没有像 UIKit 的 UIScrollView 那样直接提供滚动事件的回调。但是，你可以通过在 ScrollView 内部放置一个 GeometryReader 来读取滚动偏移量。 使用 ScrollViewReaderScrollViewReader 可以用来在 ScrollView 内部进行编程式导航（比如滚动到特定的子视图）。 12345678910111213141516171819202122232425262728import SwiftUIstruct ScrollViewReaderExample: View &#123; var body: some View &#123; ScrollViewReader &#123; proxy in ScrollView &#123; VStack(spacing: 10) &#123; ForEach(0..&lt;100) &#123; index in Text(&quot;Item \\(index)&quot;) .id(index) &#125; &#125; Button(&quot;Jump to Item 50&quot;) &#123; withAnimation &#123; proxy.scrollTo(50, anchor: .top) &#125; &#125; &#125; &#125; &#125;&#125;struct ScrollViewReaderExample_Previews: PreviewProvider &#123; static var previews: some View &#123; ScrollViewReaderExample() &#125;&#125; 在这个例子中，点击按钮会自动滚动到第 50 个元素。ScrollViewReader 提供了一个 proxy 对象，它有一个 scrollTo(_:anchor:) 方法可以使用，其中 id 参数对应子视图的 id。","categories":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"http://xuebusi.gitee.io/categories/SwiftUI/"}],"tags":[]},{"title":"SwiftUI中List的用法","slug":"SwiftUI中List的用法","date":"2023-11-07T14:05:28.000Z","updated":"2024-03-17T06:12:55.248Z","comments":true,"path":"2023/11/07/SwiftUI中List的用法/","permalink":"http://xuebusi.gitee.io/2023/11/07/SwiftUI%E4%B8%ADList%E7%9A%84%E7%94%A8%E6%B3%95/","excerpt":"","text":"在 SwiftUI 中，List 是一个用来展示数据集合的滚动列表视图。它类似于 UIKit 中的 UITableView，可以显示静态或动态的数据集合。List 可以和 ForEach 一起使用来显示动态数据，也可以直接放入静态视图。 以下是使用 List 的几种常见方法： 显示静态内容1234567891011121314151617import SwiftUIstruct StaticListView: View &#123; var body: some View &#123; List &#123; Text(&quot;Item 1&quot;) Text(&quot;Item 2&quot;) Text(&quot;Item 3&quot;) &#125; &#125;&#125;struct StaticListView_Previews: PreviewProvider &#123; static var previews: some View &#123; StaticListView() &#125;&#125; 显示动态数据当你有一组动态数据时，可以使用 ForEach 来创建列表的每一行。 12345678910111213141516171819import SwiftUIstruct DynamicListView: View &#123; let items = [&quot;Apple&quot;, &quot;Banana&quot;, &quot;Cherry&quot;] var body: some View &#123; List &#123; ForEach(items, id: \\.self) &#123; item in Text(item) &#125; &#125; &#125;&#125;struct DynamicListView_Previews: PreviewProvider &#123; static var previews: some View &#123; DynamicListView() &#125;&#125; 使用 Identifiable 数据模型当你的数据模型遵守 Identifiable 协议时，你不需要指定 id。 12345678910111213141516171819202122import SwiftUIstruct Item: Identifiable &#123; let id = UUID() let name: String&#125;struct IdentifiableListView: View &#123; let items = [Item(name: &quot;Apple&quot;), Item(name: &quot;Banana&quot;), Item(name: &quot;Cherry&quot;)] var body: some View &#123; List(items) &#123; item in Text(item.name) &#125; &#125;&#125;struct IdentifiableListView_Previews: PreviewProvider &#123; static var previews: some View &#123; IdentifiableListView() &#125;&#125; 添加和删除操作你可以通过在 ForEach 上调用 .onDelete() 和 .onMove() 方法来添加对列表的删除和移动操作的支持。 1234567891011121314151617181920212223242526272829303132import SwiftUIstruct EditableListView: View &#123; @State private var items = [&quot;Apple&quot;, &quot;Banana&quot;, &quot;Cherry&quot;] var body: some View &#123; NavigationView &#123; List &#123; ForEach(items, id: \\.self) &#123; item in Text(item) &#125; .onDelete(perform: delete) .onMove(perform: move) &#125; .navigationBarItems(trailing: EditButton()) &#125; &#125; func delete(at offsets: IndexSet) &#123; items.remove(atOffsets: offsets) &#125; func move(from source: IndexSet, to destination: Int) &#123; items.move(fromOffsets: source, toOffset: destination) &#125;&#125;struct EditableListView_Previews: PreviewProvider &#123; static var previews: some View &#123; EditableListView() &#125;&#125; 自定义行你可以在 List 中自定义行，比如添加图标和导航链接。 1234567891011121314151617181920import SwiftUIstruct CustomRowListView: View &#123; var body: some View &#123; List &#123; NavigationLink(destination: Text(&quot;Destination&quot;)) &#123; HStack &#123; Image(systemName: &quot;folder&quot;) Text(&quot;Files&quot;) &#125; &#125; &#125; &#125;&#125;struct CustomRowListView_Previews: PreviewProvider &#123; static var previews: some View &#123; CustomRowListView() &#125;&#125; 使用 List 的选择模式你还可以使用 List 的选择模式来创建可以选择单个或多个项的列表。 12345678910111213141516171819202122import SwiftUIstruct SelectableListView: View &#123; let items = [&quot;Apple&quot;, &quot;Banana&quot;, &quot;Cherry&quot;] @State private var selectedItems = Set&lt;String&gt;() var body: some View &#123; List(items, id: \\.self, selection: $selectedItems) &#123; item in Text(item) &#125; .toolbar &#123; EditButton() &#125; .environment(\\.editMode, .constant(.active)) // 使得列表始终处于编辑模式 &#125;&#125;struct SelectableListView_Previews: PreviewProvider &#123; static var previews: some View &#123; SelectableListView() &#125;&#125; 在 SwiftUI 中，List 是一个非常强大的构建用户界面的工具，可以通过上述的各种方式灵活地显示和管理集合数据。","categories":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"http://xuebusi.gitee.io/categories/SwiftUI/"}],"tags":[]},{"title":"SwiftUI中ZStack的用法","slug":"SwiftUI中ZStack的用法","date":"2023-11-07T13:57:02.000Z","updated":"2024-03-17T06:13:27.124Z","comments":true,"path":"2023/11/07/SwiftUI中ZStack的用法/","permalink":"http://xuebusi.gitee.io/2023/11/07/SwiftUI%E4%B8%ADZStack%E7%9A%84%E7%94%A8%E6%B3%95/","excerpt":"","text":"ZStack 在 SwiftUI 中是用来重叠视图的，它按照代码中的顺序堆叠视图，最先声明的视图会出现在底部，随后声明的视图则依次叠加在上面。这对于创建覆盖效果或者需要视图叠加的界面非常有用。 以下是 ZStack 的一些基本用法： 基本用法1234ZStack &#123; Text(&quot;Underneath&quot;) Text(&quot;On top&quot;)&#125; 第二个 Text 视图将会覆盖在第一个 Text 视图上面。 对齐ZStack 默认会将所有子视图居中对齐，但可以指定一个不同的对齐方式。 1234ZStack(alignment: .topLeading) &#123; Text(&quot;Aligned to the top leading corner&quot;) Text(&quot;Second view&quot;)&#125; 上面的代码会使所有子视图在 ZStack 的顶部左侧对齐。 使用背景和覆盖ZStack 常用来给视图添加背景或者覆盖。 123456789101112ZStack &#123; Image(&quot;photo&quot;) .resizable() .aspectRatio(contentMode: .fit) Text(&quot;Over the Image&quot;) .font(.caption) .foregroundColor(.white) .padding(5) .background(Color.black.opacity(0.7)) .cornerRadius(10) .padding(10)&#125; 文本会作为覆盖层显示在图片上，并且带有半透明的黑色背景以确保文字的可读性。 结合 Frame 和 Alignment 使用可以通过 frame 和 alignment 属性来控制子视图的大小和位置。 123456789ZStack &#123; Color.blue VStack &#123; Text(&quot;Hello&quot;) Text(&quot;World&quot;) &#125; .alignmentGuide(.top) &#123; d in d[.top] &#125; .frame(width: 200, height: 200, alignment: .top)&#125; 在这个例子中，VStack 被设定在蓝色背景的上方，并且它的大小被限制为 200x200。 在实际应用中ZStack 可以创建自定义的复杂视图，如下面的代码片段中，一个定制按钮的视觉效果就是通过 ZStack 实现的： 12345678ZStack &#123; Circle() .fill(Color.blue) .frame(width: 100, height: 100) Text(&quot;Click Me&quot;) .font(.title) .foregroundColor(.white)&#125; 这会创建一个带有文本的圆形按钮视图。 ZStack 是一个非常强大的工具，允许开发者在 SwiftUI 中以创造性的方式构建复杂且富有层次感的用户界面。通过合理地堆叠和对齐视图，可以实现各种自定义设计。","categories":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"http://xuebusi.gitee.io/categories/SwiftUI/"}],"tags":[]},{"title":"SwiftUI中VStack的用法","slug":"SwiftUI中VStack的用法","date":"2023-11-07T13:54:54.000Z","updated":"2024-03-17T06:13:24.364Z","comments":true,"path":"2023/11/07/SwiftUI中VStack的用法/","permalink":"http://xuebusi.gitee.io/2023/11/07/SwiftUI%E4%B8%ADVStack%E7%9A%84%E7%94%A8%E6%B3%95/","excerpt":"","text":"在 SwiftUI 中，VStack 是一个容器视图，它在垂直方向上排列其子视图。这是组织多个子视图，使其在单列中自上而下排列的一种简单有效的方式。 以下是 VStack 的基本和高级用法： 基本用法12345VStack &#123; Text(&quot;First Line&quot;) Text(&quot;Second Line&quot;) Text(&quot;Third Line&quot;)&#125; 这将会把三行文本垂直排列。 调整间距通过间距参数可以调整子视图之间的距离。 12345VStack(spacing: 10) &#123; Text(&quot;First Line&quot;) Text(&quot;Second Line&quot;) Text(&quot;Third Line&quot;)&#125; 这样设置会在每行文本之间添加10点的空间。 对齐VStack 默认在水平方向上是居中对齐的，但可以改变这个对齐方式： 1234VStack(alignment: .leading) &#123; Text(&quot;Aligned to&quot;) Text(&quot;the leading edge&quot;)&#125; 这样会将文本对齐到 VStack 的前缘（左边）。 使用 SpacerSpacer 可以用来推动子视图，让它们靠近容器的边缘或者分散对齐。 12345VStack &#123; Text(&quot;Top&quot;) Spacer() // 推动所有内容到顶部和底部 Text(&quot;Bottom&quot;)&#125; 这里的 Spacer 会尝试占据所有可用的垂直空间，推动“Top”到顶部，将“Bottom”推到底部。 嵌套使用可以在 VStack 中嵌套其他 HStack 或 VStack 来创建复杂的布局结构。 12345678910VStack &#123; HStack &#123; Text(&quot;Top Left&quot;) Text(&quot;Top Right&quot;) &#125; HStack &#123; Text(&quot;Bottom Left&quot;) Text(&quot;Bottom Right&quot;) &#125;&#125; 这将创建一个两行的布局，每行都有左右两个文本视图。 结合 Frame 和 Alignment 使用你可以为 VStack 或其子视图指定大小和对齐方式： 123456VStack(alignment: .trailing) &#123; Text(&quot;Line 1&quot;) .frame(width: 200) Text(&quot;Line 2 is longer&quot;) .frame(width: 150, alignment: .trailing)&#125; 这样会使 VStack 的文本对齐到右边，尽管子视图的宽度不同。 在实际应用中VStack 经常被用来组织表单、列表的单个项、或者任何需要垂直排列的内容。 12345678VStack &#123; Image(systemName: &quot;photo&quot;) Text(&quot;Welcome to SwiftUI&quot;) .font(.title) Text(&quot;Let&#x27;s build some UIs!&quot;) .font(.subheadline)&#125;.padding() 在这个例子中，图像位于顶部，紧接着是标题和副标题，所有内容都在 VStack 中垂直排列，并且使用 .padding 修饰符在周围添加空间。 VStack 是实现 SwiftUI 应用程序中垂直布局的基石，与 HStack、ZStack 和其他容器视图一起，可以构建出几乎任何布局结构。","categories":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"http://xuebusi.gitee.io/categories/SwiftUI/"}],"tags":[]},{"title":"SwiftUI中HStack的用法","slug":"SwiftUI中HStack的用法","date":"2023-11-07T13:52:20.000Z","updated":"2024-03-17T06:12:45.636Z","comments":true,"path":"2023/11/07/SwiftUI中HStack的用法/","permalink":"http://xuebusi.gitee.io/2023/11/07/SwiftUI%E4%B8%ADHStack%E7%9A%84%E7%94%A8%E6%B3%95/","excerpt":"","text":"HStack 是 SwiftUI 中一个非常基础和常用的布局工具，用于在水平方向上堆叠视图。以下是 HStack 的一些基本用法： 创建一个基础的 HStack12345HStack &#123; Text(&quot;Left&quot;) Text(&quot;Center&quot;) Text(&quot;Right&quot;)&#125; 这会将三个文本视图水平排列在一行内。 调整间距12345HStack(spacing: 20) &#123; Text(&quot;Left&quot;) Text(&quot;Center&quot;) Text(&quot;Right&quot;)&#125; 这将会在子视图之间设置为20点的间距。 对齐HStack 默认在垂直方向上是居中对齐的，但你可以改变这个对齐方式： 12345HStack(alignment: .top) &#123; Text(&quot;Top&quot;) Text(&quot;Aligned&quot;) Text(&quot;Text&quot;)&#125; 这会在垂直方向上将文本对齐到顶部。 使用 Spacer12345HStack &#123; Text(&quot;Left&quot;) Spacer() // 使用 Spacer 会推动两侧的文本到左右边缘 Text(&quot;Right&quot;)&#125; Spacer 占据所有可用的空间，这里将会使两个文本视图分别对齐到左右边缘。 嵌套 HStackHStack 可以嵌套使用，以创建更复杂的布局： 12345678910HStack &#123; VStack &#123; Text(&quot;Top Left&quot;) Text(&quot;Bottom Left&quot;) &#125; VStack &#123; Text(&quot;Top Right&quot;) Text(&quot;Bottom Right&quot;) &#125;&#125; 这将在水平方向上创建两个垂直堆叠，每个堆叠包含两个文本视图。 结合使用 Frame 和 Alignment123456HStack(alignment: .bottom) &#123; Text(&quot;Bottom&quot;) .frame(width: 100) Text(&quot;Aligned&quot;) .frame(width: 100, alignment: .trailing)&#125; 这将设置每个文本视图的宽度，并在底部对齐它们。 在实际应用中HStack 通常与其它布局视图（如 VStack, ZStack, ScrollView）一起使用，以实现复杂的用户界面布局。下面是一个常见的例子，结合 HStack 和 VStack： 1234567891011121314VStack &#123; HStack &#123; Image(systemName: &quot;star.fill&quot;) .foregroundColor(.yellow) Text(&quot;Favorite&quot;) .font(.headline) Spacer() &#125; .padding() Divider() // 其他内容&#125; 这会创建一个包含星形图标和标题的水平布局，并将其包裹在垂直布局中，通常这会作为列表的一部分。使用 Divider 来分隔列表项是常见的做法。","categories":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"http://xuebusi.gitee.io/categories/SwiftUI/"}],"tags":[]},{"title":"SwiftUI中的布局","slug":"SwiftUI中的布局","date":"2023-11-07T13:47:45.000Z","updated":"2024-03-17T06:12:21.929Z","comments":true,"path":"2023/11/07/SwiftUI中的布局/","permalink":"http://xuebusi.gitee.io/2023/11/07/SwiftUI%E4%B8%AD%E7%9A%84%E5%B8%83%E5%B1%80/","excerpt":"","text":"在 SwiftUI 中，布局是通过一系列的容器视图来实现的，这些容器视图可以控制它们子视图的位置和大小。常用的布局容器有 HStack、VStack、ZStack、Grid、List 和 ScrollView 等。 基本的布局结构 HStack：水平堆叠子视图。 VStack：垂直堆叠子视图。 ZStack：重叠子视图，即在 Z 轴上（深度方向）堆叠。 123456789101112131415struct ContentView: View &#123; var body: some View &#123; VStack &#123; // 垂直堆叠 HStack &#123; // 水平堆叠 Text(&quot;Left&quot;) Spacer() // 使用 Spacer 来推动两边的文本 Text(&quot;Right&quot;) &#125; ZStack &#123; // Z轴堆叠 Circle().fill(Color.blue) Text(&quot;Foreground&quot;) &#125; &#125; &#125;&#125; 对齐和间距可以对堆叠容器使用 alignment 和 spacing 参数来定义子视图的对齐方式和间距。 1234HStack(alignment: .top, spacing: 20) &#123; Text(&quot;Left&quot;) Text(&quot;Right&quot;)&#125; 帧（Frame）通过 .frame 修饰符可以为视图设定宽度、高度和对齐方式。 12Text(&quot;Hello, World!&quot;) .frame(width: 200, height: 200, alignment: .center) 弹性空间和填充 Spacer：在视图之间创建一个可扩展的空间，常用于推动视图到屏幕的边缘。 Padding：通过 .padding 修饰符来为视图添加内边距。 123456VStack &#123; Text(&quot;First&quot;) Spacer() // 将占据可用的所有空间 Text(&quot;Last&quot;)&#125;.padding() // 在 VStack 的所有边缘添加内边距 Divider 和 Separator可以使用 Divider 来在视图中添加一条分割线。 12345VStack &#123; Text(&quot;Above Divider&quot;) Divider() Text(&quot;Below Divider&quot;)&#125; ScrollViewScrollView 允许内容超出屏幕大小时滚动查看。 1234567ScrollView &#123; VStack(spacing: 20) &#123; ForEach(0..&lt;100) &#123; index in Text(&quot;Row \\(index)&quot;) &#125; &#125;&#125; ListList 用于创建一个滚动的列表视图。 123List(0..&lt;100) &#123; index in Text(&quot;Item \\(index)&quot;)&#125; Grids在 SwiftUI 中，可以使用 LazyVGrid 和 LazyHGrid 来创建网格布局。 12345LazyVGrid(columns: [GridItem(.adaptive(minimum: 100))]) &#123; ForEach(0..&lt;100) &#123; index in Text(&quot;Item \\(index)&quot;) &#125;&#125; Frame Layout对于复杂的布局，可能需要手动计算视图的尺寸和位置，使用 .frame 修饰符来设置大小，并使用 .offset、.position 等修饰符来调整位置。 自定义布局可以通过创建自定义的 ViewModifier 或者自定义的布局容器来创建复杂的布局模式。 SwiftUI 的布局系统是高度可组合的，你可以将多个布局容器和修饰符组合在一起，来创建复杂和响应式的用户界面。重要的是要理解 SwiftUI 的布局原则——尤其是容器如何影响内部子视图的布局，以及修饰符的顺序如何影响结果。","categories":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"http://xuebusi.gitee.io/categories/SwiftUI/"}],"tags":[]},{"title":"SwiftUI中Link组件的用法","slug":"SwiftUI中Link组件的用法","date":"2023-11-07T13:40:26.000Z","updated":"2024-03-17T06:12:52.439Z","comments":true,"path":"2023/11/07/SwiftUI中Link组件的用法/","permalink":"http://xuebusi.gitee.io/2023/11/07/SwiftUI%E4%B8%ADLink%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%A8%E6%B3%95/","excerpt":"","text":"在 SwiftUI 中，Link 是一个用于创建可导航的超链接的视图。它可以让你在应用内打开一个网页链接，或者在支持深度链接的应用之间进行跳转。 以下是 Link 的几种基本用法： 打开网页链接使用 Link，你可以打开一个 URL。以下是一个简单的例子，展示了如何使用 Link 来打开一个网页： 12345struct ContentView: View &#123; var body: some View &#123; Link(&quot;Visit OpenAI&quot;, destination: URL(string: &quot;https://www.openai.com&quot;)!) &#125;&#125; 在这个例子中，点击文本 “Visit OpenAI” 会尝试在默认浏览器中打开链接。 自定义链接外观你可以自定义 Link 的外观，将它包装在其它视图中。例如，你可以使用一个按钮样式的链接： 1234567891011struct ContentView: View &#123; var body: some View &#123; Link(destination: URL(string: &quot;https://www.openai.com&quot;)!) &#123; Text(&quot;Visit OpenAI&quot;) .padding() .background(Color.blue) .foregroundColor(.white) .cornerRadius(10) &#125; &#125;&#125; 在这个例子中，链接看起来更像是一个按钮，带有蓝色背景和圆角。 在列表中使用链接Link 可以和列表结合使用，作为列表项的一部分，提供导航功能。 1234567891011struct ContentView: View &#123; var body: some View &#123; NavigationView &#123; List &#123; Link(&quot;OpenAI Website&quot;, destination: URL(string: &quot;https://www.openai.com&quot;)!) Link(&quot;OpenAI Twitter&quot;, destination: URL(string: &quot;https://twitter.com/openai&quot;)!) &#125; .navigationTitle(&quot;OpenAI Links&quot;) &#125; &#125;&#125; 这个例子创建了一个包含两个链接的列表。点击这些链接会打开相应的网页。 使用深度链接在应用间导航如果其他应用支持 URL Scheme，你可以使用 Link 进行应用间的深度链接导航。例如，以下代码尝试打开 Twitter 应用的 OpenAI 页面（如果用户安装了支持的应用）： 12345struct ContentView: View &#123; var body: some View &#123; Link(&quot;Open OpenAI Twitter in App&quot;, destination: URL(string: &quot;twitter://user?screen_name=openai&quot;)!) &#125;&#125; 在使用 Link 时，请确保提供有效的 URL，并在可能的情况下处理无法打开链接的情况（例如，用户设备上没有安装相应的应用）。","categories":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"http://xuebusi.gitee.io/categories/SwiftUI/"}],"tags":[]},{"title":"SwiftUI中ProgressView的用法","slug":"SwiftUI中ProgressView的用法","date":"2023-11-07T13:12:20.000Z","updated":"2024-03-17T06:13:04.783Z","comments":true,"path":"2023/11/07/SwiftUI中ProgressView的用法/","permalink":"http://xuebusi.gitee.io/2023/11/07/SwiftUI%E4%B8%ADProgressView%E7%9A%84%E7%94%A8%E6%B3%95/","excerpt":"","text":"ProgressView 在 SwiftUI 中被用来表示一个任务的进度。它可以展示为一个旋转的指示器，用来表示正在进行的工作，但具体的进度未知，也可以显示为一个水平的进度条，用来表示可确定进度的任务。 以下是 ProgressView 的几种用法： 不确定进度的指示器当你没有具体进度值时，可以使用不带参数的 ProgressView，它会显示为一个旋转的活动指示器。 123456struct ContentView: View &#123; var body: some View &#123; ProgressView() .progressViewStyle(CircularProgressViewStyle()) // 在iOS上默认样式，可省略 &#125;&#125; 确定进度的进度条如果你有具体的进度值，你可以通过设置一个 0.0 到 1.0 之间的值来创建一个进度条。 1234567struct ContentView: View &#123; @State private var progress = 0.5 var body: some View &#123; ProgressView(value: progress, total: 1.0) &#125;&#125; 你可以通过定时器或者其他事件更新进度值，进度条会反映这些变化。 带有标签和描述的进度条ProgressView 还可以提供更多的上下文信息，比如一个标签或者一个描述性文本。 1234567891011121314151617struct ContentView: View &#123; @State private var progress = 0.5 var body: some View &#123; VStack &#123; ProgressView(&quot;Downloading...&quot;, value: progress, total: 1.0) // 或者使用标签和系统图标 ProgressView(value: progress) &#123; Label(&quot;Downloading&quot;, systemImage: &quot;arrow.down.doc&quot;) &#125; // 添加描述性文本 .progressViewStyle(LinearProgressViewStyle()) // 水平进度条 .accessibilityValue(&quot;\\(Int(progress * 100)) percent&quot;) &#125; &#125;&#125; 自定义进度条样式你可以通过 progressViewStyle 修饰符来自定义进度条的样式。 12345678struct ContentView: View &#123; @State private var progress = 0.5 var body: some View &#123; ProgressView(value: progress) .progressViewStyle(LinearProgressViewStyle(tint: .blue)) // 自定义颜色 &#125;&#125; 使用 ProgressView 的时候要注意，它需要在应用的适当位置显示，以避免阻碍用户操作，尤其是当使用不确定进度的指示器时。确保当任务完成或不再相关时，从界面上移除进度指示器。","categories":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"http://xuebusi.gitee.io/categories/SwiftUI/"}],"tags":[]},{"title":"SwiftUI中的模态视图","slug":"SwiftUI中的模态视图","date":"2023-11-07T13:09:46.000Z","updated":"2024-03-17T06:12:27.923Z","comments":true,"path":"2023/11/07/SwiftUI中的模态视图/","permalink":"http://xuebusi.gitee.io/2023/11/07/SwiftUI%E4%B8%AD%E7%9A%84%E6%A8%A1%E6%80%81%E8%A7%86%E5%9B%BE/","excerpt":"","text":"在 SwiftUI 中，通常我们提到“模态”时，指的是一个全屏或部分屏幕的视图，它会暂时中断用户的当前工作流程以获取用户的注意和交互。在 SwiftUI 中，没有直接命名为 Modal 的控件，但模态行为可以通过多种方式实现，如 sheet、fullScreenCover 以及 popover（在 iPad 上）。下面将介绍如何实现模态行为的几种方法。 使用 sheet 展示模态视图sheet 修饰符可以用来展示一个模态视图，这个视图会覆盖在当前视图的上方，并带有一个背景遮罩。用户必须明确地关闭模态视图才能返回到原始视图。 12345678910111213141516171819struct ContentView: View &#123; @State private var showingSheet = false var body: some View &#123; Button(&quot;Show Sheet&quot;) &#123; showingSheet = true &#125; .sheet(isPresented: $showingSheet) &#123; // Sheet的内容 ModalContentView() &#125; &#125;&#125;struct ModalContentView: View &#123; var body: some View &#123; Text(&quot;This is a modal view.&quot;) &#125;&#125; 使用 fullScreenCover 展示模态视图fullScreenCover 类似于 sheet，但是会覆盖整个屏幕，为模态视图提供了更多的空间。 12345678910111213141516171819202122struct ContentView: View &#123; @State private var showingFullScreenModal = false var body: some View &#123; Button(&quot;Show Full-Screen Modal&quot;) &#123; showingFullScreenModal = true &#125; .fullScreenCover(isPresented: $showingFullScreenModal) &#123; FullScreenModalView() &#125; &#125;&#125;struct FullScreenModalView: View &#123; @Environment(\\.presentationMode) var presentationMode var body: some View &#123; Button(&quot;Dismiss&quot;) &#123; presentationMode.wrappedValue.dismiss() &#125; &#125;&#125; 使用 popover 展示模态视图（仅限 iPad）Popover 在 iPad 上提供了另一种模态体验，它显示一个浮动的视图，不会覆盖整个屏幕，允许用户在不完全离开当前上下文的情况下与 popover 互动。 123456789101112struct ContentView: View &#123; @State private var showingPopover = false var body: some View &#123; Button(&quot;Show Popover&quot;) &#123; showingPopover = true &#125; .popover(isPresented: $showingPopover) &#123; Text(&quot;Popover content here&quot;) &#125; &#125;&#125; 使用 NavigationLink 或 @State 和 @Binding 触发模态视图在某些情况下，你可能需要通过更传统的方式来显示一个模态视图，例如使用 NavigationLink 或通过程序化地控制视图的显示。 1234567891011121314151617181920212223struct ContentView: View &#123; @State private var isModalPresented = false var body: some View &#123; Button(action: &#123; isModalPresented = true &#125;) &#123; Text(&quot;Show Modal&quot;) &#125; .background( NavigationLink(destination: ModalView(), isActive: $isModalPresented) &#123; EmptyView() &#125; .hidden() ) &#125;&#125;struct ModalView: View &#123; var body: some View &#123; Text(&quot;This is a modal view presented via NavigationLink.&quot;) &#125;&#125; 在 SwiftUI 中，这些模态呈现方法都是通过声明式的 API 来控制，使状态变化与视图更新之间保持同步。你需要根据你的应用设计需求来选择使用哪种模态展示方式。","categories":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"http://xuebusi.gitee.io/categories/SwiftUI/"}],"tags":[]},{"title":"SwiftUI中Popover控件的用法","slug":"SwiftUI中Popover控件的用法","date":"2023-11-07T13:06:54.000Z","updated":"2024-03-17T06:13:01.788Z","comments":true,"path":"2023/11/07/SwiftUI中Popover控件的用法/","permalink":"http://xuebusi.gitee.io/2023/11/07/SwiftUI%E4%B8%ADPopover%E6%8E%A7%E4%BB%B6%E7%9A%84%E7%94%A8%E6%B3%95/","excerpt":"","text":"在 SwiftUI 中，Popover 是一种用于临时显示浮动内容的组件。它通常被用来提供额外的信息或选项，而不必将用户带离他们当前的上下文。Popover 在 iPad 上特别有用，因为它可以利用更大的屏幕尺寸来展示额外内容而不覆盖整个屏幕。 Popover 的基本用法要在 SwiftUI 中创建一个 popover，你可以使用 .popover 修饰符。这需要一个绑定的布尔值，当该值为真时，会显示 popover。 1234567891011121314struct ContentView: View &#123; @State private var showingPopover = false var body: some View &#123; Button(&quot;Show Popover&quot;) &#123; showingPopover = true &#125; .popover(isPresented: $showingPopover) &#123; Text(&quot;Here&#x27;s the content of the Popover.&quot;) .font(.headline) .padding() &#125; &#125;&#125; 在这个例子中，当用户点击按钮时，showingPopover 变为 true，这会触发 popover 的展示。 Popover 的附加配置Popover 支持使用 attachmentAnchor 和 arrowEdge 参数来进一步配置其位置和箭头的朝向。 123.popover(isPresented: $showingPopover, attachmentAnchor: .point(.bottom), arrowEdge: .top) &#123; // Popover 的内容&#125; Popover 用于显示动态内容Popover 也可以用来显示动态内容，这意味着你可以根据某些状态或者条件来决定展示什么内容。 1234567.popover(isPresented: $showingPopover) &#123; if someCondition &#123; SomeView() &#125; else &#123; AnotherView() &#125;&#125; Popover 与 item 绑定除了使用布尔值，popover 还可以通过绑定到一个可选项上来展示，这可以使你基于选择的特定对象显示不同的 popover。 1234567891011121314151617181920struct ContentView: View &#123; @State private var selectedPerson: Person? var body: some View &#123; List(people) &#123; person in Text(person.name) .onTapGesture &#123; self.selectedPerson = person &#125; &#125; .popover(item: $selectedPerson) &#123; person in PersonDetailView(person: person) &#125; &#125;&#125;struct Person: Identifiable &#123; let id: UUID let name: String&#125; 在上面的例子中，每个人的名字是一个列表项。当点击名字时，selectedPerson 被设置为该 Person 实例，并且展示了一个 popover 来显示更多关于这个人的详情。 在不同设备上的表现Popover 在 iPadOS 上以浮动视图的形式展现，在 iPhone 上则会占据整个屏幕，类似于 modal presentation。因此，设计你的 popover 内容时，要考虑它在不同设备上的表现。 Popover 通常用于临时任务或补充内容的场景，它的优点在于能够保持用户在当前的上下文中，同时提供额外的交互或信息。与其它模态视图一样，它们应该被谨慎使用，以免打断用户的工作流程。","categories":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"http://xuebusi.gitee.io/categories/SwiftUI/"}],"tags":[]},{"title":"SwiftUI中Sheet控件的用法","slug":"SwiftUI中Sheet控件的用法","date":"2023-11-07T13:02:27.000Z","updated":"2024-03-17T06:13:14.464Z","comments":true,"path":"2023/11/07/SwiftUI中Sheet控件的用法/","permalink":"http://xuebusi.gitee.io/2023/11/07/SwiftUI%E4%B8%ADSheet%E6%8E%A7%E4%BB%B6%E7%9A%84%E7%94%A8%E6%B3%95/","excerpt":"","text":"在 SwiftUI 中，sheet 是一种展示模态视图的方式。它通常用于显示一个临时的内容屏幕，例如表单、详情页或者是一个步骤的一部分。sheet 修饰符可以让你在当前视图上方展示一个新的视图，并提供内容和行为的自定义。 使用 sheet 修饰符展示模态视图基本的 sheet 用法涉及一个绑定的布尔值，当这个布尔值为真时，sheet 会显示出来。这个布尔值通常用 @State 属性来管理。 12345678910111213struct ContentView: View &#123; @State private var showingSheet = false var body: some View &#123; Button(&quot;Show Sheet&quot;) &#123; showingSheet = true &#125; .sheet(isPresented: $showingSheet) &#123; // Sheet 的内容 DetailView() &#125; &#125;&#125; 在这个例子中，点击按钮会设置 showingSheet 为 true，从而触发 sheet 的显示。DetailView() 就是你想要作为 sheet 显示的视图。 使用 sheet 与 item 参数当你要为每个不同的数据对象显示一个 sheet 时，你可以使用 sheet(item:onDismiss:content:) 修饰符。这个修饰符需要一个绑定到可选项的 @State 属性。当这个属性不是 nil 时，将会显示一个 sheet。 123456789101112131415161718192021struct ContentView: View &#123; @State private var selectedUser: User? var body: some View &#123; // 假设你有一个用户列表 ForEach(users) &#123; user in Button(user.name) &#123; selectedUser = user &#125; &#125; .sheet(item: $selectedUser) &#123; user in // 当 selectedUser 不是 nil 时，显示的视图 UserDetailView(user: user) &#125; &#125;&#125;struct User: Identifiable &#123; let id = UUID() let name: String&#125; 在这个例子中，当你点击一个用户的按钮时，selectedUser 被设置为那个用户的实例，触发对应用户详情的 sheet。 使用 sheet 的 onDismiss 参数当你的 sheet 被关闭时，你可能想要执行一些代码。onDismiss 参数允许你添加一个闭包，当 sheet 消失时会被调用。 12345.sheet(isPresented: $showingSheet, onDismiss: &#123; print(&quot;Sheet was dismissed.&quot;)&#125;) &#123; DetailView()&#125; 动态内容的 sheet你还可以在 sheet 的闭包中直接构造视图，而不是传递一个预先定义的视图。这样，你可以基于当前状态动态地改变 sheet 的内容。 1234567.sheet(isPresented: $showingSheet) &#123; if someCondition &#123; SomeView() &#125; else &#123; AnotherView() &#125;&#125; FullScreenCover除了标准的 sheet，SwiftUI 还提供了 fullScreenCover，它以全屏模式显示内容，对于那些需要更多空间或需要从视觉上区分出来的情况非常有用。 123.fullScreenCover(isPresented: $showingCover) &#123; FullScreenModalView()&#125; 结论Sheet 控件在 SwiftUI 中为模态内容的展示提供了一种简洁而强大的方式。通过简单的状态绑定和自定义视图传递，你可以创建丰富的用户体验，并管理视图的呈现和隐藏。记得，模态视图是一个打断用户当前流程的操作，所以应该在需要的时候谨慎使用。","categories":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"http://xuebusi.gitee.io/categories/SwiftUI/"}],"tags":[]},{"title":"SwiftUI中Alert控件的用法","slug":"SwiftUI中Alert控件的用法","date":"2023-11-07T12:58:19.000Z","updated":"2024-03-17T06:12:42.552Z","comments":true,"path":"2023/11/07/SwiftUI中Alert控件的用法/","permalink":"http://xuebusi.gitee.io/2023/11/07/SwiftUI%E4%B8%ADAlert%E6%8E%A7%E4%BB%B6%E7%9A%84%E7%94%A8%E6%B3%95/","excerpt":"","text":"在 SwiftUI 中，Alert 控件用来向用户显示警告或者提示信息，并且可以提供一个或多个操作供用户选择。Alert 通常用于提示错误信息、确认重要操作或展示信息确认。 基础用法使用 Alert 需要创建一个状态变量来控制它的显示与隐藏，并且在视图的某个事件中触发这个状态变量的变化。然后，你可以使用 .alert 修饰符来在视图层级中添加一个 Alert。 123456789101112struct ContentView: View &#123; @State private var showAlert = false var body: some View &#123; Button(&quot;Show Alert&quot;) &#123; self.showAlert = true &#125; .alert(&quot;Important message&quot;, isPresented: $showAlert) &#123; Button(&quot;OK&quot;, role: .cancel) &#123; &#125; &#125; &#125;&#125; 在这个例子中，当按钮被点击时，showAlert 状态变为 true，这会触发 .alert 修饰符显示一个带有 “OK” 按钮的警告框。 带有多个按钮的 Alert12345.alert(&quot;Important message&quot;, isPresented: $showAlert) &#123; Button(&quot;Cancel&quot;, role: .cancel) &#123; &#125; Button(&quot;Delete&quot;, role: .destructive) &#123; &#125; Button(&quot;Save&quot;) &#123; &#125;&#125; 这里，除了取消按钮外，我们还添加了一个具有破坏性的删除操作和一个普通的保存操作。 Alert 的自定义内容你还可以自定义 Alert 的标题、消息和按钮。例如，下面的 Alert 有一个标题、消息和两个按钮： 12345678.alert(isPresented: $showAlert) &#123; Alert( title: Text(&quot;Important message&quot;), message: Text(&quot;Please read this.&quot;), primaryButton: .default(Text(&quot;Got it!&quot;)), secondaryButton: .cancel() )&#125; 使用 Alert 获取用户输入在 SwiftUI 中，如果你想在 Alert 中获取用户的输入，你通常会使用其他视图，如 sheet，因为 Alert 本身并不支持文本输入。不过，你可以通过弹出一个带有文本字段的 sheet 或者使用自定义的对话框视图来模拟这个行为。 使用 Alert 与 ObservableObject当你的视图模型遵循 ObservableObject 并使用 @Published 属性来管理状态时，你可以这样使用 Alert： 1234567891011121314151617181920struct ContentView: View &#123; @ObservedObject var viewModel = MyViewModel() var body: some View &#123; Button(&quot;Show Alert&quot;) &#123; viewModel.triggerAlert() &#125; .alert(&quot;Important message&quot;, isPresented: $viewModel.showAlert) &#123; Button(&quot;OK&quot;, role: .cancel) &#123; &#125; &#125; &#125;&#125;class MyViewModel: ObservableObject &#123; @Published var showAlert = false func triggerAlert() &#123; showAlert = true &#125;&#125; 在上面的例子中，MyViewModel 控制 showAlert 的状态，当 triggerAlert 方法被调用时，会显示 Alert。 Alert 在 SwiftUI 中是模态的，这意味着当它出现时，用户必须进行选择才能继续与应用交互。它的设计旨在用于必须要立即解决的情况，因此在设计用户界面时应慎用。","categories":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"http://xuebusi.gitee.io/categories/SwiftUI/"}],"tags":[]},{"title":"SwiftUI中Stepper的用法","slug":"SwiftUI中Stepper的用法","date":"2023-11-07T12:55:21.000Z","updated":"2024-03-17T06:13:21.729Z","comments":true,"path":"2023/11/07/SwiftUI中Stepper的用法/","permalink":"http://xuebusi.gitee.io/2023/11/07/SwiftUI%E4%B8%ADStepper%E7%9A%84%E7%94%A8%E6%B3%95/","excerpt":"","text":"在 SwiftUI 中，Stepper 控件允许用户通过点击增加或减少按钮来增加或减少一个值。它通常用于输入数量或调整设置，例如设置闹钟的时间或者调整购物车内商品的数量。 基础用法下面是一个基础的 Stepper 控件用法示例： 1234567struct ContentView: View &#123; @State private var quantity = 0 var body: some View &#123; Stepper(&quot;Quantity: \\(quantity)&quot;, value: $quantity) &#125;&#125; 在这个例子中，quantity 是一个 @State 属性，它与 Stepper 绑定，用户点击 Stepper 来增加或减少 quantity 的值。 设置范围你可以为 Stepper 设置一个具体的数值范围： 1Stepper(&quot;Quantity: \\(quantity)&quot;, value: $quantity, in: 0...10) 这样，quantity 的值将被限制在 0 到 10 之间。 指定步长通过指定 step 参数，你可以控制每次增加或减少的量： 1Stepper(&quot;Quantity: \\(quantity)&quot;, value: $quantity, in: 0...10, step: 2) 这里每次点击会增加或减少 2 的单位。 响应更改如果你需要在值改变时执行某些操作，可以使用 onIncrement 和 onDecrement 闭包： 123456789Stepper(onIncrement: &#123; self.quantity += 1 self.performSomeAction()&#125;, onDecrement: &#123; self.quantity -= 1 self.performSomeAction()&#125;, label: &#123; Text(&quot;Quantity: \\(quantity)&quot;)&#125;) performSomeAction() 函数会在数量增加或减少时被调用。 样式自定义Stepper 可以通过修饰符自定义样式，例如加入 .labelsHidden() 来隐藏标签： 12Stepper(&quot;Quantity: \\(quantity)&quot;, value: $quantity) .labelsHidden() 集成到其他 UI 中Stepper 可以很容易地集成到列表或者表单中： 12345Form &#123; Section(header: Text(&quot;Settings&quot;)) &#123; Stepper(&quot;Quantity: \\(quantity)&quot;, value: $quantity) &#125;&#125; 使用场景 调整设置，如定时器的分钟数。 购物车中商品的数量。 任何需要简单加减数字输入的地方。 Stepper 因其简单直观的用户体验，在需要数字输入但又不适合打开键盘的场合尤其有用。在 SwiftUI 中，它的使用非常简洁，只需几行代码即可集成。","categories":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"http://xuebusi.gitee.io/categories/SwiftUI/"}],"tags":[]},{"title":"SwiftUI中Slider组件的用法","slug":"SwiftUI中Slider组件的用法","date":"2023-11-07T12:50:43.000Z","updated":"2024-03-17T06:13:18.491Z","comments":true,"path":"2023/11/07/SwiftUI中Slider组件的用法/","permalink":"http://xuebusi.gitee.io/2023/11/07/SwiftUI%E4%B8%ADSlider%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%A8%E6%B3%95/","excerpt":"","text":"在 SwiftUI 中，Slider 是一个控件，允许用户从一个连续或者离散的值范围内选择一个值。它通常用来表示设置项中的数值，比如音量控制或者屏幕亮度调整。 基础用法基础的 Slider 需要与 @State 绑定，来跟踪滑块的当前值。例如，创建一个调节音量的滑块： 1234567struct ContentView: View &#123; @State private var volume: Double = 50 var body: some View &#123; Slider(value: $volume, in: 0...100) &#125;&#125; 在这个例子中，volume 变量将会跟踪滑块的当前位置，并且滑块的取值范围被设置在 0 到 100 之间。 步长你可以指定 Slider 的 step 参数来更改滑块的步长： 1Slider(value: $volume, in: 0...100, step: 5) 在这个例子中，滑块的值将以 5 的倍数变化。 自定义外观Slider 提供了多个修饰符来自定义外观： 123Slider(value: $volume, in: 0...100) .accentColor(.green) // 改变滑块的颜色 .trackColor(.blue, minimumValueLabel: Text(&quot;0&quot;), maximumValueLabel: Text(&quot;100&quot;)) // 自iOS 16起可用 添加标签为了增加无障碍性，你可以为 Slider 添加一个标签，这样辅助技术如 VoiceOver 可以读取这个标签： 1234Slider(value: $volume, in: 0...100) &#123; Text(&quot;Volume&quot;)&#125;.accessibilityValue(Text(&quot;\\(Int(volume))&quot;)) 实时预览如果你想在用户拖动滑块时实时获得更新，可以添加 onEditingChanged 回调： 12345Slider(value: $volume, in: 0...100, onEditingChanged: &#123; editing in if !editing &#123; // 用户停止拖动滑块时的操作 &#125;&#125;) 范围选择SwiftUI 也支持范围选择器，从 iOS 14 开始可以使用 RangeSlider： 123@State private var priceRange: ClosedRange&lt;Double&gt; = 10...50RangeSlider(values: $priceRange, in: 0...100) 在这个例子中，priceRange 会跟踪一个范围值，用户可以选择从最低到最高价之间的任何价格区间。 使用 Slider 配置对于更复杂的配置，你可以使用 Slider 初始化器的更多参数： 12345678910111213Slider( value: $volume, in: 0...100, step: 1, onEditingChanged: &#123; editing in // 用户拖动滑块时的操作 &#125;, minimumValueLabel: Text(&quot;0&quot;), maximumValueLabel: Text(&quot;100&quot;), label: &#123; Text(&quot;Volume&quot;) &#125;) 以上是 Slider 的一些常用用法和配置选项。通过合理利用，你可以在 SwiftUI 应用中提供丰富的交互式元素。","categories":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"http://xuebusi.gitee.io/categories/SwiftUI/"}],"tags":[]},{"title":"SwiftUI中Picker的用法","slug":"SwiftUI中Picker的用法","date":"2023-11-07T12:47:14.000Z","updated":"2024-03-17T06:12:58.066Z","comments":true,"path":"2023/11/07/SwiftUI中Picker的用法/","permalink":"http://xuebusi.gitee.io/2023/11/07/SwiftUI%E4%B8%ADPicker%E7%9A%84%E7%94%A8%E6%B3%95/","excerpt":"","text":"在 SwiftUI 中，Picker 是一个可以让用户从一组选项中选择一个选项的控件。它可以采用多种样式，如轮盘、菜单或段控制（segmented control）。 基础用法最基本的 Picker 使用时需要配合 @State 属性来绑定选择的值。以下是一个简单的 Picker 示例： 12345678910111213struct ContentView: View &#123; @State private var selectedFruit: String = &quot;Apple&quot; var fruits = [&quot;Apple&quot;, &quot;Banana&quot;, &quot;Cherry&quot;, &quot;Date&quot;] var body: some View &#123; Picker(&quot;Select a fruit&quot;, selection: $selectedFruit) &#123; ForEach(fruits, id: \\.self) &#123; fruit in Text(fruit).tag(fruit) &#125; &#125; &#125;&#125; 在表单中使用Picker 常常用在 Form 中，这会自动采用最适合表单样式的方式显示： 123456789101112131415struct ContentView: View &#123; @State private var selectedFruit: String = &quot;Apple&quot; var fruits = [&quot;Apple&quot;, &quot;Banana&quot;, &quot;Cherry&quot;, &quot;Date&quot;] var body: some View &#123; Form &#123; Picker(&quot;Select a fruit&quot;, selection: $selectedFruit) &#123; ForEach(fruits, id: \\.self) &#123; fruit in Text(fruit).tag(fruit) &#125; &#125; &#125; &#125;&#125; 使用 PickerStyle可以使用 PickerStyle 来改变 Picker 的外观和感觉： 123456Picker(&quot;Select a fruit&quot;, selection: $selectedFruit) &#123; ForEach(fruits, id: \\.self) &#123; fruit in Text(fruit).tag(fruit) &#125;&#125;.pickerStyle(SegmentedPickerStyle()) SwiftUI 提供的 PickerStyle 有： DefaultPickerStyle SegmentedPickerStyle WheelPickerStyle InlinePickerStyle MenuPickerStyle AutomaticPickerStyle 不同的 PickerStyle 在不同的平台和上下文中有不同的外观和行为。 在导航视图中使用在导航视图中，Picker 通常会显示为可以导航到另一个视图选择项的列表： 123456789101112131415161718struct ContentView: View &#123; @State private var selectedFruit: String = &quot;Apple&quot; var fruits = [&quot;Apple&quot;, &quot;Banana&quot;, &quot;Cherry&quot;, &quot;Date&quot;] var body: some View &#123; NavigationView &#123; Form &#123; Picker(&quot;Select a fruit&quot;, selection: $selectedFruit) &#123; ForEach(fruits, id: \\.self) &#123; fruit in Text(fruit).tag(fruit) &#125; &#125; .navigationTitle(&quot;Fruits&quot;) &#125; &#125; &#125;&#125; 在 iOS 上，Picker 会自动跳转到一个新的屏幕，用户可以选择一个选项后返回。 结合使用 ForEach 和 Identifiable如果你的数据模型遵循 Identifiable 协议，你可以更简洁地使用 ForEach： 1234567891011121314151617struct Fruit: Identifiable &#123; let id = UUID() let name: String&#125;struct ContentView: View &#123; @State private var selectedFruit: Fruit? var fruits = [Fruit(name: &quot;Apple&quot;), Fruit(name: &quot;Banana&quot;), Fruit(name: &quot;Cherry&quot;), Fruit(name: &quot;Date&quot;)] var body: some View &#123; Picker(&quot;Select a fruit&quot;, selection: $selectedFruit) &#123; ForEach(fruits) &#123; fruit in Text(fruit.name).tag(fruit as Fruit?) &#125; &#125; &#125;&#125; 注意，当使用自定义数据类型作为 Picker 的 tag 值时，需要将 selectedFruit 类型设置为可选的 (Fruit?)，因为 Picker 的 tag 需要能够匹配未选择任何值的情况。 SwiftUI 的 Picker 是一个强大的控件，提供了灵活的接口来适应各种选择需求，并且能够很好地与其他 UI 控件集成，创建直观且有效的用户界面。","categories":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"http://xuebusi.gitee.io/categories/SwiftUI/"}],"tags":[]},{"title":"SwiftUI中Label的用法","slug":"SwiftUI中Label的用法","date":"2023-11-07T12:43:44.000Z","updated":"2024-03-17T06:12:48.736Z","comments":true,"path":"2023/11/07/SwiftUI中Label的用法/","permalink":"http://xuebusi.gitee.io/2023/11/07/SwiftUI%E4%B8%ADLabel%E7%9A%84%E7%94%A8%E6%B3%95/","excerpt":"","text":"在 SwiftUI 中，Label 是用于展示一个文本和一个图标（icon）的用户界面控件。这对于清晰表达控件或动作的目的非常有用，尤其是在列表、菜单和导航栏中。 基础用法最简单的 Label 用法是提供文本和系统图标的名称： 1Label(&quot;Add Item&quot;, systemImage: &quot;plus&quot;) 使用自定义图像你也可以使用自定义图像来创建一个 Label： 1Label(&quot;Edit&quot;, image: &quot;customIconName&quot;) 这里 &quot;customIconName&quot; 是你的资产目录中的图像的名称。 使用 SF SymbolsSwiftUI 和 SF Symbols 集成，允许你方便地使用数千种符号图标： 1Label(&quot;Message&quot;, systemImage: &quot;message.fill&quot;) 自定义视图如果你需要对 Label 的文本或图标部分进行更多的自定义，你可以提供自定义视图： 1234567891011121314Label &#123; Text(&quot;Settings&quot;) .foregroundColor(.primary) .font(.body) .padding() .background(Color.gray.opacity(0.2)) .cornerRadius(5)&#125; icon: &#123; Image(systemName: &quot;gear&quot;) .foregroundColor(.blue) .padding() .background(Color.gray.opacity(0.2)) .cornerRadius(5)&#125; 嵌套在其他视图中Label 可以嵌套在列表、按钮和其他容器视图中。例如，在一个 List 中： 12345List &#123; Label(&quot;Notifications&quot;, systemImage: &quot;bell&quot;) Label(&quot;Privacy&quot;, systemImage: &quot;hand.raised&quot;) Label(&quot;General&quot;, systemImage: &quot;wrench&quot;)&#125; 样式Label 还可以使用不同的样式，例如：iconOnlyLabelStyle 或 titleOnlyLabelStyle。 12345Label(&quot;Airplane Mode&quot;, systemImage: &quot;airplane&quot;) .labelStyle(TitleOnlyLabelStyle())Label(&quot;WiFi&quot;, systemImage: &quot;wifi&quot;) .labelStyle(IconOnlyLabelStyle()) 无障碍不要忘了考虑无障碍需求，你可以添加描述来帮助辅助技术，如 VoiceOver，更好地解释 Label 的内容： 123Label(&quot;Delete&quot;, systemImage: &quot;trash&quot;) .accessibilityLabel(Text(&quot;Delete&quot;)) .accessibilityHint(Text(&quot;Double tap to remove the item&quot;)) 使用场景 在 NavigationView 和工具栏按钮中展示图标和文本。 在列表或菜单中作为条目显示，既要展示图标也要展示文本。 在用户界面的其他任何地方，当你需要在文本旁边显示图标以提高识别度时。 Label 由于其多功能性和易用性，在 SwiftUI 中是一个很受欢迎的组件。通过组合使用文本和图标，你可以创建既美观又直观的用户界面元素。","categories":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"http://xuebusi.gitee.io/categories/SwiftUI/"}],"tags":[]},{"title":"SwiftUI中SecureField的用法","slug":"SwiftUI中SecureField的用法","date":"2023-11-07T12:40:52.000Z","updated":"2024-03-17T06:13:11.125Z","comments":true,"path":"2023/11/07/SwiftUI中SecureField的用法/","permalink":"http://xuebusi.gitee.io/2023/11/07/SwiftUI%E4%B8%ADSecureField%E7%9A%84%E7%94%A8%E6%B3%95/","excerpt":"","text":"在 SwiftUI 中，SecureField 用于输入敏感信息，如密码，它会自动遮蔽输入的文字。SecureField 的 API 使用起来和 TextField 非常相似。 基础用法下面是一个简单的 SecureField 示例： 123456789struct ContentView: View &#123; @State private var password: String = &quot;&quot; var body: some View &#123; SecureField(&quot;Enter your password&quot;, text: $password) .textFieldStyle(RoundedBorderTextFieldStyle()) .padding() &#125;&#125; 在这个例子中，用户输入的文本会被遮蔽，不会直接显示在屏幕上。 与 TextField 结合通常，在一个表单中，你可能会将 TextField 用于用户名输入，而将 SecureField 用于密码输入： 123456789101112131415161718192021222324struct ContentView: View &#123; @State private var username: String = &quot;&quot; @State private var password: String = &quot;&quot; var body: some View &#123; VStack &#123; TextField(&quot;Username&quot;, text: $username) .textFieldStyle(RoundedBorderTextFieldStyle()) .autocapitalization(.none) .disableAutocorrection(true) .padding() SecureField(&quot;Password&quot;, text: $password) .textFieldStyle(RoundedBorderTextFieldStyle()) .padding() Button(&quot;Login&quot;) &#123; // Perform login action &#125; .disabled(username.isEmpty || password.isEmpty) &#125; .padding() &#125;&#125; 在上面的代码中，登录按钮会在用户名或密码字段为空时被禁用。 自定义外观和 TextField 一样，你可以使用修饰符来自定义 SecureField 的外观： 12345SecureField(&quot;Password&quot;, text: $password) .padding() .background(Color.gray.opacity(0.2)) .cornerRadius(5) .padding(.horizontal) 响应提交事件如果你想要在用户提交密码时做出响应（例如，按下键盘的 return 键），你可以使用 onCommit 闭包： 123456SecureField(&quot;Password&quot;, text: $password, onCommit: &#123; // Perform an action when the user submits the password loginUser()&#125;).textFieldStyle(RoundedBorderTextFieldStyle()).padding() 在这个示例中，loginUser() 函数会在用户按下 return 键后被调用。 SecureField 是构建安全文本输入场景的基础组件，它可以与你的验证逻辑、用户认证服务以及其他 UI 组件结合使用，以创建安全的用户体验。","categories":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"http://xuebusi.gitee.io/categories/SwiftUI/"}],"tags":[]},{"title":"使用TextField开发一个记事本","slug":"使用TextField开发一个记事本","date":"2023-11-07T12:30:16.000Z","updated":"2023-11-07T12:30:37.230Z","comments":true,"path":"2023/11/07/使用TextField开发一个记事本/","permalink":"http://xuebusi.gitee.io/2023/11/07/%E4%BD%BF%E7%94%A8TextField%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E8%AE%B0%E4%BA%8B%E6%9C%AC/","excerpt":"","text":"要使用 SwiftUI 创建一个简单的记事本应用，你可以按照以下步骤操作： 创建一个用于存储用户输入文本的状态变量。 使用 TextField 为用户提供文本输入的地方。 将输入的文本存储起来，并显示在界面上。 提供一个方法来保存和加载这些文本。 下面是一个简单记事本应用的基本代码框架： 123456789101112131415161718192021222324252627282930313233343536373839import SwiftUIstruct ContentView: View &#123; @State private var noteText: String = &quot;&quot; @State private var savedNotes: [String] = [] var body: some View &#123; NavigationView &#123; VStack &#123; TextField(&quot;Write your note here...&quot;, text: $noteText) .textFieldStyle(RoundedBorderTextFieldStyle()) .padding() Button(&quot;Save Note&quot;) &#123; saveNote() noteText = &quot;&quot; // Clear the TextField after saving &#125; .padding() .disabled(noteText.isEmpty) // Disable the button if there is no text List(savedNotes, id: \\.self) &#123; note in Text(note) &#125; &#125; .navigationTitle(&quot;My Notes&quot;) &#125; &#125; func saveNote() &#123; savedNotes.append(noteText) // Adds the current note text to the saved notes array // Here, you might also write the notes to persistent storage &#125;&#125;struct ContentView_Previews: PreviewProvider &#123; static var previews: some View &#123; ContentView() &#125;&#125; 上述代码创建了一个简单的记事本界面。用户可以在 TextField 中输入文本，点击 “Save Note” 按钮后，文本会被添加到 savedNotes 数组中，并且显示在下面的列表中。 进阶： 你可能希望将这些笔记保存到持久存储中，例如使用 UserDefaults 或文件系统，这样即使应用关闭，数据也不会丢失。 可以考虑使用 ForEach 而不是直接在 List 中使用数组，以便于处理删除操作等。 对 List 使用 .onDelete(perform:) 方法可以让用户删除条目。 这个代码示例仅是一个起点，根据你的需求，你可以添加更多的功能，比如编辑已保存的笔记、按日期排序笔记、将笔记分组等。记事本应用可以根据个人需求有很多复杂的变体，上面的示例为你提供了一个构建更复杂应用的基础。","categories":[],"tags":[]},{"title":"SwiftUI中的TextField组件的用法","slug":"SwiftUI中的TextField组件的用法","date":"2023-11-07T12:27:08.000Z","updated":"2024-03-17T06:12:39.198Z","comments":true,"path":"2023/11/07/SwiftUI中的TextField组件的用法/","permalink":"http://xuebusi.gitee.io/2023/11/07/SwiftUI%E4%B8%AD%E7%9A%84TextField%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%A8%E6%B3%95/","excerpt":"","text":"在 SwiftUI 中，TextField 组件用于收集用户输入的文本信息。它类似于 UIKit 中的 UITextField 或者 Web 开发中的 &lt;input type=&quot;text&quot;&gt;。 基础用法要创建一个 TextField，你至少需要提供两个参数：一个标签和一个绑定到文本值的变量。 123456789struct ContentView: View &#123; @State private var name: String = &quot;&quot; var body: some View &#123; TextField(&quot;Enter your name&quot;, text: $name) .textFieldStyle(RoundedBorderTextFieldStyle()) // 为文本框添加边框样式 .padding() // 增加一些内边距 &#125;&#125; 定制样式SwiftUI 允许通过修饰符来定制 TextField 的外观和行为。 123456TextField(&quot;Enter your name&quot;, text: $name) .padding() .background(Color.gray.opacity(0.2)) // 设置背景色 .cornerRadius(5) // 设置圆角 .font(.title) // 设置字体样式 .padding(.horizontal) // 水平方向的内边距 键盘类型、自动纠错和安全输入你可以为 TextField 设置键盘类型、是否自动纠错以及是否安全输入。 123456TextField(&quot;Email&quot;, text: $email) .keyboardType(.emailAddress) // 设置键盘类型为邮箱地址 .autocapitalization(.none) // 关闭自动大写 .disableAutocorrection(true) // 关闭自动纠错SecureField(&quot;Password&quot;, text: $password) // 用于密码输入，会隐藏输入内容 占位符的定制在 SwiftUI 中，占位符是通过直接在 TextField 的初始化器中设置的。你也可以使用 NSAttributedString 来自定义占位符的外观，但这需要与 UIKit 桥接。 1TextField(&quot;Enter your name&quot;, text: $name) 响应用户操作为了响应用户的输入操作，你可以使用 onCommit 参数来定义当用户按下 Return 键时的行为。 1234TextField(&quot;Enter your name&quot;, text: $name, onCommit: &#123; // 用户按下 Return 键时的操作 print(&quot;User entered: \\(name)&quot;)&#125;) 聚焦和失焦SwiftUI 2.0 引入了 @FocusState，使你能够控制 TextField 的聚焦状态。 123456789101112@State private var name: String = &quot;&quot;@FocusState private var isInputActive: Boolvar body: some View &#123; TextField(&quot;Enter your name&quot;, text: $name) .focused($isInputActive) // 将 TextField 的焦点状态绑定到 isInputActive .onAppear &#123; DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) &#123; self.isInputActive = true // 自动聚焦到 TextField &#125; &#125;&#125; 使用 TextField 修饰符SwiftUI 为 TextField 提供了许多修饰符来自定义外观和行为，例如 .textFieldStyle()、.keyboardType()、.textContentType() 等。 使用 TextField 的过程中，可能需要对其行为和外观进行调整以适应特定的 UI 设计。通过结合多种修饰符，你可以创建出符合需求的文本输入界面。","categories":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"http://xuebusi.gitee.io/categories/SwiftUI/"}],"tags":[]},{"title":"SwiftUI中的开关组件的用法","slug":"SwiftUI中的开关组件的用法","date":"2023-11-07T12:24:24.000Z","updated":"2024-03-17T06:12:25.015Z","comments":true,"path":"2023/11/07/SwiftUI中的开关组件的用法/","permalink":"http://xuebusi.gitee.io/2023/11/07/SwiftUI%E4%B8%AD%E7%9A%84%E5%BC%80%E5%85%B3%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%A8%E6%B3%95/","excerpt":"","text":"在 SwiftUI 中，Toggle 是一个用于切换布尔值的 UI 控件。这通常与应用的一些设置或状态开关对应。 基础用法你可以这样创建一个基础的 Toggle： 12345@State private var isOn = falsevar body: some View &#123; Toggle(&quot;Switch Label&quot;, isOn: $isOn)&#125; 这里的 $isOn 是对 isOn 变量的一个绑定，它会在用户操作 Toggle 时自动更新。 自定义外观SwiftUI 允许使用各种修饰符自定义 Toggle 的外观： 1234Toggle(isOn: $isOn) &#123; Text(&quot;Switch Label&quot;)&#125;.toggleStyle(SwitchToggleStyle(tint: .green)) // 自定义开关颜色 使用自定义图标你也可以为 Toggle 的标签使用自定义图标： 123456Toggle(isOn: $isOn) &#123; HStack &#123; Image(systemName: &quot;moon.stars.fill&quot;) Text(&quot;Dark Mode&quot;) &#125;&#125; 与列表集成Toggle 经常和 List 结合使用，尤其是在设置界面： 12345List &#123; Toggle(&quot;Wi-Fi&quot;, isOn: $isWifiEnabled) Toggle(&quot;Bluetooth&quot;, isOn: $isBluetoothEnabled) // ... 其他设置项&#125; 无文本标签如果你不需要显示文本标签，可以使用空 Text 或直接省略标签参数： 12345Toggle(&quot;&quot;, isOn: $isOn)// 或者Toggle(isOn: $isOn) &#123; // 省略标签&#125; 可访问性为了确保你的 Toggle 对于辅助功能用户来说是可访问的，你可以提供额外的信息： 123Toggle(&quot;Enable Notifications&quot;, isOn: $areNotificationsEnabled) .accessibilityLabel(Text(&quot;Enable Notifications&quot;)) .accessibilityHint(Text(&quot;Toggles whether or not to receive notifications.&quot;)) 响应状态变化如果你想要在 Toggle 状态改变时执行一些操作，你可以使用 .onChange(of:) 修饰符： 12345Toggle(&quot;Enable Notifications&quot;, isOn: $areNotificationsEnabled) .onChange(of: areNotificationsEnabled) &#123; newValue in // 当 Toggle 状态变化时执行 print(&quot;Notifications are now \\(newValue ? &quot;enabled&quot; : &quot;disabled&quot;)&quot;) &#125; 使用 Toggle 组件可以很容易地为用户提供控制应用设置的方式，它是可声明式 UI 的一个例子，将状态的可视化与状态管理结合起来。通过在 SwiftUI 视图中声明状态和状态之间的绑定，Toggle 的状态改变可以传播到你的应用的其他部分，或者触发一些逻辑。","categories":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"http://xuebusi.gitee.io/categories/SwiftUI/"}],"tags":[]},{"title":"SwiftUI中的Image组件的用法","slug":"SwiftUI中的Image组件的用法","date":"2023-11-07T12:19:55.000Z","updated":"2024-03-17T06:12:34.479Z","comments":true,"path":"2023/11/07/SwiftUI中的Image组件的用法/","permalink":"http://xuebusi.gitee.io/2023/11/07/SwiftUI%E4%B8%AD%E7%9A%84Image%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%A8%E6%B3%95/","excerpt":"","text":"在 SwiftUI 中，Image 视图用于显示图片。你可以使用多种来源的图片，包括应用的资源包、系统图标库以及从网络获取的图片。下面是一些 Image 组件的基本和进阶用法。 基础用法从 Assets.xcassets 加载图片：1Image(&quot;myImage&quot;) // &quot;myImage&quot; 是你的图片在 Assets.xcassets 中的名称 使用系统图标：1Image(systemName: &quot;star.fill&quot;) // 使用 SF Symbols 的图标 常用修饰符重新着色（tinting）：1234Image(&quot;myImage&quot;) .resizable() // 允许图片被拉伸 .renderingMode(.template) // 将图片设置为模板模式 .foregroundColor(.blue) // 改变图片颜色 缩放以适应容器大小：123Image(&quot;myImage&quot;) .resizable() // 允许图片被拉伸 .aspectRatio(contentMode: .fit) // 保持图片的宽高比 填充整个容器：1234Image(&quot;myImage&quot;) .resizable() .aspectRatio(contentMode: .fill) // 图片可能会超出容器大小 .clipped() // 超出部分将被裁剪 调整图片大小：123Image(&quot;myImage&quot;) .resizable() .frame(width: 100, height: 100) // 指定图片的宽和高 圆形剪裁：1234567Image(&quot;myImage&quot;) .resizable() .scaledToFill() .frame(width: 100, height: 100) .clipShape(Circle()) // 将图片剪裁成圆形 .overlay(Circle().stroke(Color.white, lineWidth: 4)) // 圆形边框 .shadow(radius: 10) // 阴影效果 高级用法图片叠加（Overlay）：12345678910111213Image(&quot;myImage&quot;) .resizable() .scaledToFit() .overlay( Text(&quot;Overlay&quot;) // 在图片上添加文本覆盖层 .font(.caption) .padding(5) .background(Color.black.opacity(0.5)) .cornerRadius(5) .foregroundColor(.white) .padding(10), // 文本内边距 alignment: .bottomTrailing // 对齐到图片的右下角 ) 图片遮罩（Masking）：12345678Image(&quot;myImage&quot;) .resizable() .scaledToFit() .mask( Text(&quot;SwiftUI&quot;) // 使用文本作为遮罩 .font(.system(size: 72)) .bold() ) 图片动画：1234567891011@State private var isRotated = falsevar body: some View &#123; Image(&quot;myImage&quot;) .resizable() .rotationEffect(.degrees(isRotated ? 360 : 0)) // 旋转动画 .animation(.linear(duration: 2), value: isRotated) .onAppear &#123; isRotated.toggle() &#125;&#125; 使用网络图片在 SwiftUI 中，没有内置从网络直接加载图片的方法。通常，你需要使用 URLSession 获取图片数据，然后将数据转换为 UIImage（在 iOS 上）或 NSImage（在 macOS 上），最后将其转换为 SwiftUI 可以使用的 Image。或者你可以使用第三方库，如 SDWebImageSwiftUI 来简化网络图片的加载过程。 在 SwiftUI 2.0 之后的版本，AsyncImage 视图提供了一个原生的异步加载网络图片的方法： 1234567AsyncImage(url: URL(string: &quot;https://example.com/myImage.png&quot;)) &#123; image in image.resizable() // 如果成功加载，显示图片&#125;placeholder: &#123; ProgressView() // 在加载期间显示加载指示器&#125;.frame(width: 100, height: 100) Image 视图在 SwiftUI 中是核心组件之一，它配 合修饰符和其他视图，能够实现丰富多彩的用户界面元素。","categories":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"http://xuebusi.gitee.io/categories/SwiftUI/"}],"tags":[]},{"title":"SwiftUI中的按钮组件的用法","slug":"SwiftUI中的按钮组件的用法","date":"2023-11-07T12:12:22.000Z","updated":"2024-03-17T06:12:18.419Z","comments":true,"path":"2023/11/07/SwiftUI中的按钮组件的用法/","permalink":"http://xuebusi.gitee.io/2023/11/07/SwiftUI%E4%B8%AD%E7%9A%84%E6%8C%89%E9%92%AE%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%A8%E6%B3%95/","excerpt":"","text":"SwiftUI 中的 Button 组件用于执行用户点击时的操作。它可以容纳文本、图像或其他自定义视图，并且可以通过修饰符来自定义其外观和行为。 下面是 Button 的一些基础用法： 基础用法创建一个简单的按钮，并定义点击时执行的动作： 1234Button(&quot;Click Me&quot;) &#123; // 在这里放置点击按钮后要执行的代码 print(&quot;Button was tapped&quot;)&#125; 自定义外观可以通过链式调用修饰符来自定义按钮的外观： 12345678Button(&quot;Click Me&quot;) &#123; // 执行动作 print(&quot;Button was tapped&quot;)&#125;.foregroundColor(.white).background(Color.blue).cornerRadius(10).padding() 使用图像你还可以使用 Image 视图创建一个图像按钮： 1234567Button(action: &#123; // 执行动作 print(&quot;Image Button was tapped&quot;)&#125;) &#123; Image(systemName: &quot;heart.fill&quot;) .foregroundColor(.red)&#125; 组合文本和图像Button 可以容纳多个视图，例如文本和图像： 12345678Button(action: &#123; // 执行动作&#125;) &#123; HStack &#123; Image(systemName: &quot;heart.fill&quot;) Text(&quot;Like&quot;) &#125;&#125; 自定义按钮样式SwiftUI 允许你通过 .buttonStyle() 修饰符来应用自定义的按钮样式： 1234Button(&quot;Click Me&quot;) &#123; // 执行动作&#125;.buttonStyle(MyCustomButtonStyle()) // 应用自定义的按钮样式 使用 Button 初始化器创建按钮除了使用闭包，Button 还提供了使用 label 参数的初始化器，可以让你为按钮的内容提供一个视图构建器： 1234567Button(action: &#123; // 执行动作&#125;) &#123; // 创建按钮内容 Text(&quot;Click Me&quot;) .fontWeight(.bold)&#125; 按钮的禁用状态你可以通过 .disabled() 修饰符来控制按钮的可点击状态： 1234Button(&quot;Click Me&quot;) &#123; // 执行动作&#125;.disabled(isButtonDisabled) // 根据某个条件禁用按钮 在 SwiftUI 中，Button 组件是可组合的，这意味着你可以通过修饰符、自定义样式和视图构建器，创建各种外观和行为的按钮，满足不同的设计需求。 在SwiftUI中，Button 的高级用法可以包括自定义触摸行为、动画、无障碍功能和集成到复杂的用户界面模式中。以下是一些高级用法： 1. 自定义点击动画你可以在按钮上应用动画，以便在用户点击时提供视觉反馈： 1234567891011121314Button(action: &#123; withAnimation &#123; // 执行动作 &#125;&#125;) &#123; Text(&quot;Click Me&quot;)&#125;.scaleEffect(isPressed ? 1.2 : 1.0).animation(.easeInOut(duration: 0.2), value: isPressed).simultaneousGesture(DragGesture(minimumDistance: 0).onChanged(&#123; _ in self.isPressed = true&#125;).onEnded(&#123; _ in self.isPressed = false&#125;)) 2. 创建自定义按钮样式在SwiftUI中，你可以通过实现ButtonStyle协议来创建复杂的按钮样式： 12345678910111213141516struct MyButtonStyle: ButtonStyle &#123; func makeBody(configuration: Self.Configuration) -&gt; some View &#123; configuration.label .background(configuration.isPressed ? Color.gray : Color.blue) .foregroundColor(.white) .cornerRadius(10) .padding() .scaleEffect(configuration.isPressed ? 0.95 : 1) .animation(.spring(), value: configuration.isPressed) &#125;&#125;// 使用自定义样式Button(&quot;Custom Style&quot;) &#123; // 执行动作&#125;.buttonStyle(MyButtonStyle()) 3. 触摸手势集成通过添加手势，可以对按钮的触摸事件进行更精细的控制： 12345678Button(action: &#123; // 执行动作&#125;) &#123; Text(&quot;Gesture Button&quot;)&#125;.gesture(LongPressGesture(minimumDuration: 2).onEnded &#123; _ in print(&quot;Long press!&quot;)&#125;) 4. 无障碍功能的集成确保按钮对于辅助技术是可访问的，例如屏幕阅读器： 1234567Button(action: &#123; // 执行动作&#125;) &#123; Image(systemName: &quot;star&quot;)&#125;.accessibilityLabel(Text(&quot;Favorite&quot;)).accessibilityHint(Text(&quot;Double-tap to mark as favorite.&quot;)) 5. 按钮与列表集成将按钮集成到列表或者表单中，并通过按钮改变列表内容： 123456789List &#123; Button(&quot;Add Item&quot;) &#123; // 向列表添加项 items.append(&quot;New Item&quot;) &#125; ForEach(items, id: \\.self) &#123; item in Text(item) &#125;&#125; 6. 条件禁用按钮基于特定逻辑禁用按钮： 1234Button(&quot;Submit&quot;) &#123; // 提交表单&#125;.disabled(!formIsValid) 7. 按钮的多样化布局结合HStack, VStack, ZStack以及Spacer等创建复杂布局： 12345678Button(action: &#123; // 执行动作&#125;) &#123; VStack &#123; Image(systemName: &quot;star&quot;) Text(&quot;Favorites&quot;) &#125;&#125; 8. 利用视图修改器创建按钮样式创建一个可以重用的视图修改器，并在按钮上应用： 12345678910111213141516struct OutlineStyle: ViewModifier &#123; func body(content: Content) -&gt; some View &#123; content .padding() .background(Color.white) .overlay( RoundedRectangle(cornerRadius: 5) .stroke(Color.blue, lineWidth: 1) ) &#125;&#125;Button(&quot;Outlined Button&quot;) &#123; // 执行动作&#125;.modifier(OutlineStyle()) SwiftUI中的Button使用起来非常灵活，你可以利用多种方式来自定义行为和样式，以满足特定的用户界面和用户体验需求。","categories":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"http://xuebusi.gitee.io/categories/SwiftUI/"}],"tags":[]},{"title":"SwiftUI中的文本控件的用法","slug":"SwiftUI中的文本控件的用法","date":"2023-11-07T12:04:52.000Z","updated":"2024-03-17T06:12:31.171Z","comments":true,"path":"2023/11/07/SwiftUI中的文本控件的用法/","permalink":"http://xuebusi.gitee.io/2023/11/07/SwiftUI%E4%B8%AD%E7%9A%84%E6%96%87%E6%9C%AC%E6%8E%A7%E4%BB%B6%E7%9A%84%E7%94%A8%E6%B3%95/","excerpt":"","text":"SwiftUI 中的 Text 视图用于显示一行或多行只读文本。它是 SwiftUI 中显示文本内容的基础组件，支持字符串文字和动态字符串。 这里有一些基本和常见的用法： 基本用法创建一个简单的 Text 视图： 1Text(&quot;Hello, World!&quot;) 文本样式你可以为 Text 视图添加修饰符来改变文本的样式： 1234Text(&quot;Hello, World!&quot;) .font(.title) // 设置字体样式 .fontWeight(.bold) // 设置字体权重 .foregroundColor(.blue) // 设置文本颜色 多行文本和截断SwiftUI 会根据需要自动换行文本，也可以控制截断的位置： 1234Text(&quot;This is a very long string that will wrap or truncate based on the available space.&quot;) .frame(width: 100) // 限制视图的宽度 .lineLimit(2) // 最多显示两行 .truncationMode(.tail) // 末尾截断 对齐文本可以调整文本的对齐方式： 123Text(&quot;Aligned Text&quot;) .frame(width: 200, height: 200) // 设置视图的大小 .multilineTextAlignment(.center) // 多行文本居中对齐 文本和图像的组合Text 视图可以和其他视图比如 Image 组合在一起： 123456HStack &#123; Image(systemName: &quot;star.fill&quot;) // 系统图标 .foregroundColor(.yellow) // 设置图标颜色 Text(&quot;Favorite&quot;) .font(.headline) // 设置文本字体&#125; 本地化和动态文本SwiftUI 支持本地化和动态文本内容： 12Text(LocalizedStringKey(&quot;WelcomeMessage&quot;))Text(&quot;Hello, \\(userName)!&quot;) 文本样式的继承如果你将 Text 视图放入另一个视图中，它将继承父视图的样式： 1234VStack &#123; Text(&quot;First Line&quot;) Text(&quot;Second Line&quot;)&#125;.font(.title) // 所有文本都应用标题字体样式 交互式文本（例如链接）可以在 Text 视图中添加可交互的链接： 12345678Text(&quot;Visit Apple&#x27;s website for more information.&quot;) .underline() .foregroundColor(.blue) .onTapGesture &#123; if let url = URL(string: &quot;https://www.apple.com&quot;) &#123; UIApplication.shared.open(url) &#125; &#125; Text 视图是 SwiftUI 中非常强大的组件，其修饰符可以链式组合，用于创建丰富且响应式的文本界面。记住在实际的 iOS 开发环境中，某些功能（如打开 URL）可能需要其他的考虑（例如使用 Link 视图而不是 onTapGesture）。 SwiftUI 的 Text 视图虽然简单，但它也支持一些高级用法，允许创建复杂和富有表现力的文本布局。以下是一些高级用法的示例： 富文本（Attributed Strings）在 SwiftUI 中，你可以使用属性字符串来创建富文本，这可以通过直接在 Text 初始化器中使用带有属性的字符串来实现： 12let attributedString = NSAttributedString( ... ) // 创建一个属性字符串Text(attributedString) 在 SwiftUI 3.0 中，可以更方便地创建富文本，使用多个 Text 视图的组合，并对它们应用不同的修饰符： 123Text(&quot;This &quot;) +Text(&quot;word &quot;).fontWeight(.bold) +Text(&quot;is bold.&quot;) 文本插值和格式化SwiftUI 允许对插入到 Text 中的数据进行格式化： 1Text(&quot;The temperature is \\(temperature, specifier: &quot;%.1f&quot;) degrees.&quot;) 或者使用更现代的方法，配合 FormatStyle： 1Text(temperature, format: .number.precision(.fractionLength(1))) 组合和叠加视图在 SwiftUI 中，可以将 Text 视图与其他视图组合，并应用不同的布局和效果： 123456Text(&quot;Hello&quot;) .background( Image(&quot;backgroundImage&quot;) .resizable() .aspectRatio(contentMode: .fill) ) 文本阴影和其他效果可以为文本添加阴影或其他视觉效果： 12Text(&quot;Elevated Text&quot;) .shadow(color: .gray, radius: 2, x: 0, y: 2) 条件修饰符可以基于条件应用不同的修饰符： 12Text(&quot;This might be bold&quot;) .fontWeight(isBold ? .bold : nil) 选择性地隐藏视图有时候你可能想要基于某些条件隐藏 Text 视图。这可以通过条件修饰符实现： 12Text(&quot;Hidden text&quot;) .opacity(isHidden ? 0 : 1) 访问视图大小可以通过 background 修饰符和 GeometryReader 来获取 Text 视图的大小： 123456Text(&quot;Dynamic Size&quot;) .background(GeometryReader &#123; geometry in Color.clear.onAppear &#123; print(&quot;Text size: \\(geometry.size)&quot;) &#125; &#125;) 复杂的文本处理如果你需要对文本进行更复杂的处理，比如解析和渲染 HTML 或者 Markdown，你可能需要使用 NSAttributedString 或查找第三方库，或在 SwiftUI 中嵌入 UIKit 或 AppKit 组件来完成。 响应式文本可以通过环境变量，如 @EnvironmentObject 或 @ObservedObject 来创建响应式文本，使其内容基于应用程序的状态而改变。 SwiftUI Text 视图的高级用法，结合了修饰符和 SwiftUI 的其他视图和功能，可以创建高度定制化的文本展示效果。这些高级技巧可以帮助你更好地控制文本的布局、样式和行为。","categories":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"http://xuebusi.gitee.io/categories/SwiftUI/"}],"tags":[]},{"title":"我现在要开发一个iOS上的APP，我应该使用SwiftUI还是UIKit呢？","slug":"我现在要开发一个iOS上的APP，我应该使用SwiftUI还是UIKit呢？","date":"2023-11-07T09:54:58.000Z","updated":"2023-11-07T09:55:14.773Z","comments":true,"path":"2023/11/07/我现在要开发一个iOS上的APP，我应该使用SwiftUI还是UIKit呢？/","permalink":"http://xuebusi.gitee.io/2023/11/07/%E6%88%91%E7%8E%B0%E5%9C%A8%E8%A6%81%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AAiOS%E4%B8%8A%E7%9A%84APP%EF%BC%8C%E6%88%91%E5%BA%94%E8%AF%A5%E4%BD%BF%E7%94%A8SwiftUI%E8%BF%98%E6%98%AFUIKit%E5%91%A2%EF%BC%9F/","excerpt":"","text":"选择SwiftUI还是UIKit主要取决于几个关键因素，包括项目的需求、目标用户群、开发团队的熟悉程度以及对某些特定API的需求。以下是一些选择SwiftUI或UIKit的考量因素： 使用SwiftUI的理由： 最新技术：SwiftUI是苹果的最新UI框架，它使用了现代的Swift语言特性，能够提供更好的开发体验。 跨平台开发：SwiftUI被设计成可以一次编写，跨平台部署（iOS、macOS、watchOS和tvOS）。 简洁的代码：声明式的语法使得编写UI代码更简洁、更容易阅读和维护。 动态UI和动画：SwiftUI使得创建复杂的动画和动态UI变得更为容易。 实时预览：Xcode集成了SwiftUI的实时预览功能，可以加速设计和开发过程。 自动适配：SwiftUI为自适应布局和暗黑模式提供了内建支持，减少了为不同设备适配的工作量。 使用UIKit的理由： 成熟稳定：UIKit自2007年以来一直在使用，是一个成熟稳定的框架。 更全面的API：UIKit具有更广泛的API和组件集，可以实现一些SwiftUI目前无法实现的功能。 复杂界面和控制：对于高度自定义和动态变化的界面，UIKit可能提供更精确的控制。 更广泛的资源：历史上的教程、解决方案和第三方库大多是基于UIKit的。 向下兼容性：如果需要支持较旧版本的iOS（如iOS 12及以下），UIKit是唯一的选择。 建议： 新项目 &amp; 快速开发：如果你是从头开始一个新项目，特别是当项目不需要向下兼容到较旧的iOS版本时，SwiftUI是一个很好的选择。它能够提供更快的开发速度和未来的兼容性。 现有项目 &amp; 维护：如果你正在维护或扩展一个现有的UIKit项目，那么继续使用UIKit可能更有意义，特别是如果你的团队已经对它非常熟悉。 特定API或复杂UI：如果应用程序需要访问那些SwiftUI尚未覆盖的特定API，或者需要创建极其复杂和高度定制的UI，那么UIKit可能是更好的选择。 混合使用：你也可以选择两者混合使用。SwiftUI可以在UIKit应用中用作某些视图或功能，反之亦然。这样可以充分利用两个框架的优势。 最终，这个决定应该基于你的项目需求、团队技能和项目时间线。如果可能的话，建议创建一个小的原型或者尝试用两种框架实现一些核心功能，以更好地理解它们在实践中的差异。","categories":[],"tags":[]},{"title":"声明式语法和命令式语法的区别","slug":"声明式语法和命令式语法的区别","date":"2023-11-07T07:57:06.000Z","updated":"2023-11-07T07:57:31.823Z","comments":true,"path":"2023/11/07/声明式语法和命令式语法的区别/","permalink":"http://xuebusi.gitee.io/2023/11/07/%E5%A3%B0%E6%98%8E%E5%BC%8F%E8%AF%AD%E6%B3%95%E5%92%8C%E5%91%BD%E4%BB%A4%E5%BC%8F%E8%AF%AD%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"声明式语法和命令式语法是编程中描述软件逻辑的两种不同风格。它们在定义程序如何和应该做什么方面有本质的不同。 声明式语法（Declarative Syntax）在声明式编程中，你描述“你想要什么”（What you want），而不是你要如何达到目的（How you achieve it）。你定义了目标状态，而具体的实现细节则通常由框架、库或系统自己处理。 特点: 抽象层次更高：更加关注描述问题的逻辑，而不是实现的步骤。 易于推理：由于直接表达了目的，因此通常代码更简洁，逻辑更清晰。 减少副作用：代码通常没有临时变量和迭代，从而减少了意外修改状态的风险。 改善可维护性：因为代码量减少且更加直观，所以通常更易于维护。 例子：SQL（描述你想要查询什么数据，而不是如何查询数据）、React和SwiftUI（描述UI应该如何根据数据状态显示，而不是如何修改UI）。 命令式语法（Imperative Syntax）命令式编程关注“你如何做”（How you do it），需要提供达成目标的详细步骤。这通常涉及到编写更多的逻辑来手动处理状态的变化和应用的流程。 特点: 控制流程明确：详细指定了执行顺序和逻辑流程。 具体化操作：每一步都需要程序员明确指定。 灵活性高：因为可以控制每一步，所以在处理复杂逻辑时可能更具优势。 例子：大多数传统的编程语言如C、Java在处理UI时倾向于命令式风格，明确指定每一步如何创建和管理UI元素。 对比示例假设我们要更改一个列表的所有元素，使其翻倍。 声明式（SwiftUI风格）: 12let numbers = [1, 2, 3, 4, 5]let doubledNumbers = numbers.map &#123; $0 * 2 &#125; 这里我们没有指定如何遍历数字，如何存储结果。我们只是描述了对每个元素想做的操作。 命令式（传统的C风格）: 123456int numbers[] = &#123;1, 2, 3, 4, 5&#125;;int doubledNumbers[sizeof(numbers)/sizeof(numbers[0])];for (int i = 0; i &lt; sizeof(numbers)/sizeof(numbers[0]); i++) &#123; doubledNumbers[i] = numbers[i] * 2;&#125; 这里我们具体指定了创建数组、循环的开始和结束条件，以及如何在每一次循环中翻倍当前元素。 在UI开发中，声明式语法让状态和UI的同步变得更简单，因为UI框架（如SwiftUI）会负责监听数据变化并更新UI，而不需要开发者编写代码来手动操作DOM或视图元素。","categories":[],"tags":[]},{"title":"SwiftUI设计思想","slug":"SwiftUI设计思想","date":"2023-11-07T07:49:49.000Z","updated":"2024-03-17T06:12:12.016Z","comments":true,"path":"2023/11/07/SwiftUI设计思想/","permalink":"http://xuebusi.gitee.io/2023/11/07/SwiftUI%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/","excerpt":"","text":"SwiftUI的设计思想体现了现代UI框架的若干核心理念： 声明式语法SwiftUI采用声明式语法，开发者只需要声明UI应该如何根据不同的状态显示，而不是编写代码来控制UI的每一个变化过程。这种方式简化了代码结构，使得UI逻辑更清晰易懂，也更易于维护。 组件化和复用SwiftUI鼓励将UI划分为小的、可复用的组件。每个组件管理自己的状态和表现，这促进了代码的模块化和重用，并使得开发者能够构建出高度复杂且易于维护的UI系统。 数据驱动的UISwiftUI的设计充分利用了Swift语言的特性，如结构体、属性观察器等，实现了数据和UI的紧密绑定。当数据发生变化时，UI会自动响应更新，大大简化了同步UI和数据状态的工作。 单一数据流通过使用单一数据流，SwiftUI确保了数据的一致性和可预测性。状态（State）和绑定（Binding）的概念帮助开发者明确数据流向，并易于跟踪和调试。 跨平台兼容性SwiftUI从设计之初就考虑到了跨平台的需求。相同的SwiftUI代码可以运行在iOS、macOS、watchOS和tvOS上，这降低了为不同平台开发和维护UI的工作量和复杂度。 与Swift语言的一致性SwiftUI紧密集成了Swift语言的功能，例如泛型、协议和函数式编程概念。这种集成确保了SwiftUI的API设计既自然又符合Swift语言的特性和风格。 现代化和简化的APISwiftUI致力于提供一个简洁的API，用最少的代码完成最多的工作。例如，通过链式调用修饰符（Modifier）可以轻松地定制组件的样式和行为。 强调性能和效率SwiftUI的设计充分考虑了性能。它利用了差异化更新（只更新UI的变更部分）以及懒加载视图等机制，以确保高效的内存和资源使用。 通过这些设计理念，SwiftUI旨在实现快速、高效且更少出错的UI开发流程，适应现代应用开发的需求。随着Swift和SwiftUI的不断发展，它将进一步融合和优化，以提供更好的开发体验。","categories":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"http://xuebusi.gitee.io/categories/SwiftUI/"}],"tags":[]},{"title":"SwiftUI提供了哪些UI组件?","slug":"SwiftUI提供了哪些UI组件","date":"2023-11-07T07:44:38.000Z","updated":"2024-03-17T06:12:14.981Z","comments":true,"path":"2023/11/07/SwiftUI提供了哪些UI组件/","permalink":"http://xuebusi.gitee.io/2023/11/07/SwiftUI%E6%8F%90%E4%BE%9B%E4%BA%86%E5%93%AA%E4%BA%9BUI%E7%BB%84%E4%BB%B6/","excerpt":"","text":"SwiftUI 提供了一系列的 UI 组件，它们在 SwiftUI 中被称为 Views。以下是一些基础的组件及其用途： Textual Components Text: 显示一行或多行只读文本。 TextField: 允许用户输入文本。 SecureField: 用于密码输入，输入内容会被遮蔽。 Label: 显示文本和图标旁边的文本，适用于快速创建简单的标签。 Image and Graphics Image: 显示图片。 Icon: 利用 SF Symbols 或自定义图像显示图标。 Shape: 绘制基本图形，如 Rectangle、Circle、Ellipse、Capsule 等。 Buttons and Toggles Button: 可触发动作的标准按钮。 Toggle: 开关按钮，可用于切换状态。 Picker: 选择器，允许从多个选项中选择一个。 Slider: 滑块，用于从范围中选择一个值。 Stepper: 步进器，用于增加或减少一个值。 Containers and Layout HStack: 水平堆叠的容器，用于横向排列子视图。 VStack: 垂直堆叠的容器，用于纵向排列子视图。 ZStack: 重叠容器，用于层叠视图。 List: 用于显示一系列数据的滚动列表。 ScrollView: 提供可滚动视图的容器。 Grids (LazyHGrid&#x2F;LazyVGrid): 创建水平或垂直的网格布局。 Form: 用于创建表单布局，常用于设置页面。 NavigationView: 创建带有导航能力的视图结构。 Presentation Alert: 显示警告消息。 Sheet: 从底部滑出的覆盖层，用于显示次级视图。 Popover: 弹出视图，用于 iPad 上的视图展示。 Modal: 用于展示临时内容，例如详情页或选择器。 Controls and Indicators ProgressView: 显示进度指示器。 ActivityIndicator: 显示一个旋转的加载提示符（iOS 14 以前称为 ActivityIndicator）。 Link: 提供一个可导航至外部链接或其他视图的按钮。 Specialized Views Map: 集成地图显示。 WebView: 显示一个网页的视图（通过 WKWebView）。 Animation and Transition Animation: 将动画应用于视图状态的改变。 Transition: 定义视图添加或移除时的动画效果。 Environment and Preferences Environment: 用于从父视图传递数据到子视图的对象。 这些组件可以结合起来，形成复杂的 UI 布局，并且可以通过各种修饰符（Modifiers）进行扩展和自定义，以实现具体的设计要求和动态效果。修饰符可以更改视图的显示方式，例如字体、颜色、对齐、填充、边框等属性，也可以添加如阴影、圆角等视觉效果。此外，SwiftUI 还提供了强大的数据绑定和状态管理机制，使得用户界面的开发更为动态和交互式。","categories":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"http://xuebusi.gitee.io/categories/SwiftUI/"}],"tags":[]},{"title":"用SwiftUI编写一个Hello World！","slug":"用SwiftUI编写一个Hello-World！","date":"2023-11-07T07:26:48.000Z","updated":"2023-11-07T07:27:21.800Z","comments":true,"path":"2023/11/07/用SwiftUI编写一个Hello-World！/","permalink":"http://xuebusi.gitee.io/2023/11/07/%E7%94%A8SwiftUI%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AAHello-World%EF%BC%81/","excerpt":"","text":"在SwiftUI中编写一个显示”Hello, World!”的界面非常简单。下面是基本的步骤和代码示例： 打开Xcode并创建一个新的SwiftUI项目。 在项目模板创建后，Xcode 会自动生成一个 ContentView.swift 文件，这是我们构建用户界面的地方。 你可以使用以下代码替换 ContentView 结构体的实现： 12345678910111213import SwiftUIstruct ContentView: View &#123; var body: some View &#123; Text(&quot;Hello, World!&quot;) &#125;&#125;struct ContentView_Previews: PreviewProvider &#123; static var previews: some View &#123; ContentView() &#125;&#125; 这段代码定义了一个遵循 View 协议的 ContentView 结构体。在其 body 属性中，我们声明了界面的内容，这里仅仅是一个 Text 视图，显示字符串 “Hello, World!”。 当你在Xcode中打开画布(Canvas)，你应该能够看到 “Hello, World!” 文本的实时预览。你可以通过点击Xcode工具栏上的播放按钮来运行应用，在模拟器或者真实设备上看到你的第一个SwiftUI应用。 SwiftUI的 Text 视图会默认居中于屏幕，除非你使用修饰符（modifiers）来改变它的布局或对齐方式。 这是最简单的SwiftUI界面，但是 SwiftUI 强大之处在于可以轻松地为这个界面添加更多的功能和设计。例如，你可以添加按钮、图片、动画等等，并且利用声明式语法来定义这些元素之间的交互。","categories":[],"tags":[]},{"title":"对于初学者，SwiftUI和UIKit到底先学哪个？","slug":"对于初学者，SwiftUI和UIKit到底先学哪个？","date":"2023-11-07T07:22:42.000Z","updated":"2023-11-07T07:23:31.796Z","comments":true,"path":"2023/11/07/对于初学者，SwiftUI和UIKit到底先学哪个？/","permalink":"http://xuebusi.gitee.io/2023/11/07/%E5%AF%B9%E4%BA%8E%E5%88%9D%E5%AD%A6%E8%80%85%EF%BC%8CSwiftUI%E5%92%8CUIKit%E5%88%B0%E5%BA%95%E5%85%88%E5%AD%A6%E5%93%AA%E4%B8%AA%EF%BC%9F/","excerpt":"","text":"对于初学者来说，选择学习 SwiftUI 还是 UIKit 可能取决于几个因素，包括个人的学习目标、项目需求以及对 Swift 语言的熟悉程度等。这里是一些选择的依据： 学习SwiftUI 如果你是完全的新手，并且打算从事新的项目或个人项目，SwiftUI 是个不错的选择。SwiftUI 的声明式语法通常更容易理解和学习。 SwiftUI 允许你快速看到结果，对于学习和实验来说这非常有用。Xcode 的实时预览可以让你边编写代码边看到界面的变化，这对新手来说是极大的优势。 如果你对最新技术感兴趣并希望跟上苹果的最新开发趋势，学习 SwiftUI 也是合适的。苹果公司很可能会继续在 SwiftUI 上投入资源，并将其作为未来开发的重点。 如果你的目标是跨平台开发（包括 iOS、macOS、watchOS 和 tvOS），SwiftUI 提供了更统一的方法。 学习UIKit 如果你打算为旧版本的 iOS 设备或在现有的大型项目中工作，学习 UIKit 是必要的，因为 SwiftUI 只支持 iOS 13 及更高版本。 UIKit 在工业界有广泛的使用，并且许多公司的现有项目都是基于 UIKit。如果你要进入这些公司工作，了解 UIKit 是很重要的。 UIKit 有更成熟的特性集和更大的社区支持。学习 UIKit 可以让你访问到更多的资源，包括丰富的教程、文档和第三方库。 对于需要高度定制 UI 或有复杂交互的应用，UIKit 提供了更细粒度的控制。 结合学习 在实际开发中，两者并不是互斥的，可以结合起来使用。在 UIKit 项目中，你可以逐渐引入 SwiftUI，反之亦然。 学习 SwiftUI 可以让你快速上手和看到成果，而 UIKit 的学习可能稍慢一些但更加深入。因此，也有人推荐先快速掌握 SwiftUI 来建立信心和兴趣，然后再学习 UIKit。 最终，你可能需要根据自己的具体情况和学习风格来做出决定。如果可能的话，了解两者并能够在项目中根据需求选择最合适的工具，将会是一项非常有价值的技能。","categories":[],"tags":[]},{"title":"SwiftUI和UIKit对比","slug":"SwiftUI和UIKit对比","date":"2023-11-07T07:20:04.000Z","updated":"2024-03-17T06:10:56.967Z","comments":true,"path":"2023/11/07/SwiftUI和UIKit对比/","permalink":"http://xuebusi.gitee.io/2023/11/07/SwiftUI%E5%92%8CUIKit%E5%AF%B9%E6%AF%94/","excerpt":"","text":"SwiftUI 和 UIKit 是 iOS 开发中用于构建用户界面的两个不同的框架，它们各自有着不同的特点和用途。下面是一些比较重要的对比点： 界面构建方式 SwiftUI 是声明式的，你定义了 UI 应该如何根据状态变化进行显示。 UIKit 是命令式的，你需要详细地指出如何在每个状态和交互下更新 UI。 语言和环境 SwiftUI 只能在 Swift 中使用，并且需要 iOS 13 或更高的操作系统。 UIKit 可以用 Swift 或 Objective-C 编写，并支持从 iOS 2 开始的所有版本。 设计理念 SwiftUI 旨在简化 UI 设计流程，使用更少的代码来完成更多的工作，同时强调数据驱动的 UI。 UIKit 更注重细节和控制，开发者可以对界面的每一个部分进行精细调整。 学习曲线 SwiftUI 提供了更简单的语法和更少的样板代码，使得新手更容易入门。 UIKit 由于其历史悠久，资源丰富，但对于新手来说，学习曲线可能相对陡峭。 功能和成熟度 SwiftUI 是比较新的，每年都在迅速增加新功能，但是某些高级或特定的功能可能不如 UIKit 那样成熟。 UIKit 非常成熟，功能全面，经过了多年的测试和使用。 社区和资源 SwiftUI 正在迅速发展，社区和资源也在增加，但是相比于 UIKit 还是较少。 UIKit 拥有广泛的社区支持，大量的教程、书籍和第三方库。 可维护性和扩展性 SwiftUI 由于其新颖的设计，可能会让既有的项目在集成时遇到挑战，但是对于新项目，其可维护性和扩展性被设计得很好。 UIKit 对于既有的项目非常友好，但在维护大型项目时可能需要更多的努力。 性能 SwiftUI 的性能通常很好，但由于是新技术，可能在某些复杂场景下会有性能瓶颈。 UIKit 的性能非常成熟和优化，对于性能敏感的应用来说，它提供了更细粒度的控制。 跨平台 SwiftUI 设计之初就考虑了跨平台，在 macOS、iOS、watchOS 和 tvOS 上有统一的开发体验。 UIKit 主要用于 iOS 和 tvOS，对于 macOS，需要使用 AppKit。 总结来说，SwiftUI 是现代、声明式和跨平台的 UI 框架，适用于新项目和喜欢最新技术的开发者，而 UIKit 是更成熟、更具控制力的 UI 框架，适用于需要广泛支持和细粒度控制的大型应用或项目。对于现有项目，特别是需要支持旧版本 iOS 的项目，UIKit 依然是必须的。很多开发者在现有的 UIKit 应用中逐步引入 SwiftUI，以此来享受两个框架各自的优势。","categories":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"http://xuebusi.gitee.io/categories/SwiftUI/"}],"tags":[]},{"title":"SwiftUI简介","slug":"SwiftUI简介","date":"2023-11-07T07:13:57.000Z","updated":"2024-03-17T06:12:07.973Z","comments":true,"path":"2023/11/07/SwiftUI简介/","permalink":"http://xuebusi.gitee.io/2023/11/07/SwiftUI%E7%AE%80%E4%BB%8B/","excerpt":"","text":"SwiftUI是苹果在2019年WWDC大会上推出的一个用于在苹果生态系统中构建用户界面的框架。它可以用来为iOS、macOS、watchOS和tvOS开发应用程序。SwiftUI的设计目标是提供一种更简洁、更声明式的编程方法来构建用户界面。 以下是SwiftUI的一些关键特点： 声明式语法：SwiftUI使用声明式语法，让开发者可以用简洁的代码描述界面应该呈现的样子，而不是编写实现这个界面的步骤。这种方法提高了代码的可读性和可维护性。 跨平台：SwiftUI代码可以在所有苹果平台上运行，这意味着你可以一次性编写代码，然后将其部署到不同的设备上。 实时预览：与Xcode集成的SwiftUI提供了实时预览功能。你可以边修改代码边看到界面的变化，这极大地提高了开发的效率。 数据驱动：SwiftUI紧密结合了Swift语言的其他功能，比如Combine框架，提供了数据驱动的视图更新。这意味着当数据变化时，UI会自动更新。 易于集成：可以在现有的UIKit应用中使用SwiftUI构建部分界面，这让现有项目可以逐步迁移而无需全部重写。 强大的动画和过渡支持：SwiftUI让添加动画变得非常容易，简单的修改状态即可自动获得平滑的过渡效果。 组件化：SwiftUI鼓励开发者将UI分解为小的、可重用的组件，这样不仅可以提升代码复用性，也使得界面的各个部分更容易管理和维护。 无需记忆性：SwiftUI界面的状态是无需记忆的，它通过绑定数据来直接驱动界面，这样可以避免传统的UI编程中常见的状态不一致问题。 访问性和国际化：SwiftUI使得添加访问性支持更为容易，并且它的设计天然支持国际化和本地化。 Swift语言的集成：SwiftUI紧密集成了Swift编程语言的特性，比如类型安全、函数式编程元素和其他现代编程范式。 SwiftUI的学习曲线相对平缓，尤其对于熟悉Swift语言的开发者来说，它提供了一个更加直观和快速的方式来构建美观且高性能的用户界面。随着SwiftUI不断的迭代和改进，它正在成为苹果开发生态中越来越重要的一部分。","categories":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"http://xuebusi.gitee.io/categories/SwiftUI/"}],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2023-11-06T01:14:03.574Z","updated":"2023-11-06T01:14:03.574Z","comments":true,"path":"2023/11/06/hello-world/","permalink":"http://xuebusi.gitee.io/2023/11/06/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"Java","slug":"Java","permalink":"http://xuebusi.gitee.io/categories/Java/"},{"name":"SwiftUI","slug":"SwiftUI","permalink":"http://xuebusi.gitee.io/categories/SwiftUI/"}],"tags":[{"name":"Mac","slug":"Mac","permalink":"http://xuebusi.gitee.io/tags/Mac/"},{"name":"Socket","slug":"Socket","permalink":"http://xuebusi.gitee.io/tags/Socket/"},{"name":"ServerSocket","slug":"ServerSocket","permalink":"http://xuebusi.gitee.io/tags/ServerSocket/"},{"name":"BufferedReader","slug":"BufferedReader","permalink":"http://xuebusi.gitee.io/tags/BufferedReader/"},{"name":"InputStreamReader","slug":"InputStreamReader","permalink":"http://xuebusi.gitee.io/tags/InputStreamReader/"},{"name":"PrintWriter","slug":"PrintWriter","permalink":"http://xuebusi.gitee.io/tags/PrintWriter/"}]}