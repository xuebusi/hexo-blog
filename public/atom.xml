<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SwiftUI训练营</title>
  
  
  <link href="http://xuebusi.gitee.io/atom.xml" rel="self"/>
  
  <link href="http://xuebusi.gitee.io/"/>
  <updated>2024-03-22T07:31:45.933Z</updated>
  <id>http://xuebusi.gitee.io/</id>
  
  <author>
    <name>林克</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>macOS查看环境变量</title>
    <link href="http://xuebusi.gitee.io/2024/03/22/macOS%E6%9F%A5%E7%9C%8B%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
    <id>http://xuebusi.gitee.io/2024/03/22/macOS%E6%9F%A5%E7%9C%8B%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</id>
    <published>2024-03-22T07:30:58.000Z</published>
    <updated>2024-03-22T07:31:45.933Z</updated>
    
    <content type="html"><![CDATA[<p>在macOS中，您可以通过终端查看和设置环境变量。以下是查看环境变量的方法：</p><p>打开终端。</p><p>输入 echo $PATH 来查看PATH变量，它通常包含执行的程序的路径。</p><p>要查看所有环境变量，可以使用 env 命令。</p><p>如果您想查看特定的环境变量，可以直接输入变量名，例如 echo $HOME 将显示当前用户的主目录。</p><p>以下是实际的命令示例：</p><h1 id="查看PATH变量"><a href="#查看PATH变量" class="headerlink" title="查看PATH变量"></a>查看PATH变量</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo $PATH<br></code></pre></td></tr></table></figure><h1 id="查看所有环境变量"><a href="#查看所有环境变量" class="headerlink" title="查看所有环境变量"></a>查看所有环境变量</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">env<br></code></pre></td></tr></table></figure><h1 id="查看特定的环境变量，例如HOME目录"><a href="#查看特定的环境变量，例如HOME目录" class="headerlink" title="查看特定的环境变量，例如HOME目录"></a>查看特定的环境变量，例如HOME目录</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo $HOME<br></code></pre></td></tr></table></figure><p>这些命令将在终端中输出相应的环境变量信息。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在macOS中，您可以通过终端查看和设置环境变量。以下是查看环境变量的方法：&lt;/p&gt;
&lt;p&gt;打开终端。&lt;/p&gt;
&lt;p&gt;输入 echo $PATH 来查看PATH变量，它通常包含执行的程序的路径。&lt;/p&gt;
&lt;p&gt;要查看所有环境变量，可以使用 env 命令。&lt;/p&gt;
&lt;p&gt;如果</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>DockerCompose脚本一键部署wordpress</title>
    <link href="http://xuebusi.gitee.io/2024/03/21/DockerCompose%E4%B8%80%E9%94%AE%E9%83%A8%E7%BD%B2wordpress/"/>
    <id>http://xuebusi.gitee.io/2024/03/21/DockerCompose%E4%B8%80%E9%94%AE%E9%83%A8%E7%BD%B2wordpress/</id>
    <published>2024-03-21T07:57:06.000Z</published>
    <updated>2024-03-21T08:23:51.928Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&quot;3&quot;</span> <br><span class="hljs-comment"># Defines which compose version to use</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-comment"># Services line define which Docker images to run. In this case, it will be MySQL server and WordPress image.</span><br>  <span class="hljs-attr">docker-mysql:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">mysql:latest</span><br>    <span class="hljs-comment"># image: mysql:latest indicates the MySQL database container image from Docker Hub used in this installation.</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;3306:3306&quot;</span><br>    <span class="hljs-attr">volumes:</span><br>      [<span class="hljs-string">&quot;./wordpress-mysql-data:/var/lib/mysql&quot;</span>]<br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-attr">MYSQL_ROOT_PASSWORD:</span> <span class="hljs-string">your_db_passwrod</span><br>      <span class="hljs-attr">MYSQL_DATABASE:</span> <span class="hljs-string">wordpress</span><br>      <span class="hljs-attr">MYSQL_USER:</span> <span class="hljs-string">your_db_user</span><br>      <span class="hljs-attr">MYSQL_PASSWORD:</span> <span class="hljs-string">your_db_passwrod</span><br>      <span class="hljs-comment"># Previous four lines define the main variables needed for the MySQL container to work: database, database username, database user password, and the MySQL root password.</span><br>  <span class="hljs-attr">wordpress:</span><br>    <span class="hljs-attr">depends_on:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">docker-mysql</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">wordpress:latest</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br>    <span class="hljs-comment"># Restart line controls the restart mode, meaning if the container stops running for any reason, it will restart the process immediately.</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;8000:80&quot;</span><br>      <span class="hljs-comment"># The previous line defines the port that the WordPress container will use. After successful installation, the full path will look like this: http://localhost:8000</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-attr">WORDPRESS_DB_HOST:</span> <span class="hljs-string">docker-mysql:3306</span><br>      <span class="hljs-attr">WORDPRESS_DB_USER:</span> <span class="hljs-string">your_db_user</span><br>      <span class="hljs-attr">WORDPRESS_DB_PASSWORD:</span> <span class="hljs-string">your_db_passwrod</span><br>      <span class="hljs-attr">WORDPRESS_DB_NAME:</span> <span class="hljs-string">wordpress</span><br><span class="hljs-comment"># Similar to MySQL image variables, the last four lines define the main variables needed for the WordPress container to work properly with the MySQL container.</span><br>    <span class="hljs-attr">volumes:</span><br>      [<span class="hljs-string">&quot;./wordpress-html:/var/www/html&quot;</span>]<br><span class="hljs-attr">volumes:</span><br>  <span class="hljs-attr">mysql:</span> &#123;&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight yaml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>使用JavaNIO编写一个HelloWorld程序</title>
    <link href="http://xuebusi.gitee.io/2024/03/17/%E4%BD%BF%E7%94%A8JavaNIO%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AAHelloWorld%E7%A8%8B%E5%BA%8F/"/>
    <id>http://xuebusi.gitee.io/2024/03/17/%E4%BD%BF%E7%94%A8JavaNIO%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AAHelloWorld%E7%A8%8B%E5%BA%8F/</id>
    <published>2024-03-17T02:52:45.000Z</published>
    <updated>2024-03-17T02:53:00.142Z</updated>
    
    <content type="html"><![CDATA[<p>以下是一个简单的 Java NIO 客户端和服务端的 “Hello World” 程序：</p><p><strong>服务端程序（Server.java）：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.net.InetSocketAddress;<br><span class="hljs-keyword">import</span> java.nio.ByteBuffer;<br><span class="hljs-keyword">import</span> java.nio.channels.ServerSocketChannel;<br><span class="hljs-keyword">import</span> java.nio.channels.SocketChannel;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Server</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 创建 ServerSocketChannel</span><br>            <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">serverSocketChannel</span> <span class="hljs-operator">=</span> ServerSocketChannel.open();<br>            <br>            <span class="hljs-comment">// 绑定端口</span><br>            serverSocketChannel.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">9999</span>));<br>            System.out.println(<span class="hljs-string">&quot;Server started, listening on port 9999...&quot;</span>);<br>            <br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-comment">// 接受客户端连接</span><br>                <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">socketChannel</span> <span class="hljs-operator">=</span> serverSocketChannel.accept();<br>                <br>                <span class="hljs-comment">// 读取数据</span><br>                <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>                socketChannel.read(buffer);<br>                buffer.flip();<br>                System.out.println(<span class="hljs-string">&quot;Received message from client: &quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buffer.array()).trim());<br>                <br>                <span class="hljs-comment">// 发送响应</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello Client!&quot;</span>;<br>                <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">responseBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.wrap(response.getBytes());<br>                socketChannel.write(responseBuffer);<br>                <br>                <span class="hljs-comment">// 关闭连接</span><br>                socketChannel.close();<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>客户端程序（Client.java）：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.net.InetSocketAddress;<br><span class="hljs-keyword">import</span> java.nio.ByteBuffer;<br><span class="hljs-keyword">import</span> java.nio.channels.SocketChannel;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 创建 SocketChannel</span><br>            <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">socketChannel</span> <span class="hljs-operator">=</span> SocketChannel.open();<br>            <br>            <span class="hljs-comment">// 连接到服务器</span><br>            socketChannel.connect(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">9999</span>));<br>            System.out.println(<span class="hljs-string">&quot;Connected to server...&quot;</span>);<br>            <br>            <span class="hljs-comment">// 发送数据</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello Server!&quot;</span>;<br>            <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.wrap(message.getBytes());<br>            socketChannel.write(buffer);<br>            <br>            <span class="hljs-comment">// 接收响应</span><br>            <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">responseBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>            socketChannel.read(responseBuffer);<br>            responseBuffer.flip();<br>            System.out.println(<span class="hljs-string">&quot;Received response from server: &quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(responseBuffer.array()).trim());<br>            <br>            <span class="hljs-comment">// 关闭连接</span><br>            socketChannel.close();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个程序包括一个简单的客户端和服务器端。服务器监听端口9999，并在接收到客户端消息后，返回 “Hello Client!”。客户端连接到服务器，发送消息 “Hello Server!”，并打印出从服务器接收到的响应。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;以下是一个简单的 Java NIO 客户端和服务端的 “Hello World” 程序：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;服务端程序（Server.java）：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;t</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Docker部署xxl-job步骤</title>
    <link href="http://xuebusi.gitee.io/2024/03/14/Docker%E9%83%A8%E7%BD%B2xxl-job-admin%E6%AD%A5%E9%AA%A4/"/>
    <id>http://xuebusi.gitee.io/2024/03/14/Docker%E9%83%A8%E7%BD%B2xxl-job-admin%E6%AD%A5%E9%AA%A4/</id>
    <published>2024-03-14T05:09:17.000Z</published>
    <updated>2024-03-14T05:23:58.635Z</updated>
    
    <content type="html"><![CDATA[<h3 id="使用Docker命令创建自定义网络"><a href="#使用Docker命令创建自定义网络" class="headerlink" title="使用Docker命令创建自定义网络"></a>使用Docker命令创建自定义网络</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker network create hdzl_net<br></code></pre></td></tr></table></figure><h3 id="使用Docker命令启动MySQL容器"><a href="#使用Docker命令启动MySQL容器" class="headerlink" title="使用Docker命令启动MySQL容器"></a>使用Docker命令启动MySQL容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -p 3306:3306 \<br>--name mysql \<br>-e MYSQL_ROOT_PASSWORD=qq490983587 \<br>--network hdzl_net \<br>-d mysql<br></code></pre></td></tr></table></figure><h3 id="在MySQL数据库中执行xxl-job数据库脚本"><a href="#在MySQL数据库中执行xxl-job数据库脚本" class="headerlink" title="在MySQL数据库中执行xxl-job数据库脚本"></a>在MySQL数据库中执行xxl-job数据库脚本</h3><p>在宿主机上使用连接mysql执行xxl-job-admin项目中提供的<code>tables_xxl_job.sql</code>脚本</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">主机地址：localhost<br>端口：3306<br>用户名：root<br>密码：qq490983587<br></code></pre></td></tr></table></figure><h3 id="使用Docker命令启动xxl-job-admin"><a href="#使用Docker命令启动xxl-job-admin" class="headerlink" title="使用Docker命令启动xxl-job-admin"></a>使用Docker命令启动xxl-job-admin</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run \<br>-e PARAMS=&quot;--spring.datasource.url=jdbc:mysql://mysql:3306/xxl_job?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai --spring.datasource.username=root --spring.datasource.password=qq490983587&quot; \<br>-p 8080:8080 \<br>-v /Users/shiyanjun/logs:/data/applogs \<br>--network=hdzl_net \<br>--name xxl-job-admin \<br>-d xuxueli/xxl-job-admin:2.4.0<br></code></pre></td></tr></table></figure><h3 id="浏览器访问xxl-job-admin"><a href="#浏览器访问xxl-job-admin" class="headerlink" title="浏览器访问xxl-job-admin"></a>浏览器访问xxl-job-admin</h3><p>打开浏览器访问：<a href="http://localhost:8080/xxl-job-admin/">http://localhost:8080/xxl-job-admin/</a><br>登录用户名：admin<br>登录密码：123456</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;使用Docker命令创建自定义网络&quot;&gt;&lt;a href=&quot;#使用Docker命令创建自定义网络&quot; class=&quot;headerlink&quot; title=&quot;使用Docker命令创建自定义网络&quot;&gt;&lt;/a&gt;使用Docker命令创建自定义网络&lt;/h3&gt;&lt;figure class</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>在Mac上如何终止某个端口所在的进程？</title>
    <link href="http://xuebusi.gitee.io/2023/11/12/%E5%9C%A8Mac%E4%B8%8A%E5%A6%82%E4%BD%95%E7%BB%88%E6%AD%A2%E6%9F%90%E4%B8%AA%E7%AB%AF%E5%8F%A3%E6%89%80%E5%9C%A8%E7%9A%84%E8%BF%9B%E7%A8%8B%EF%BC%9F/"/>
    <id>http://xuebusi.gitee.io/2023/11/12/%E5%9C%A8Mac%E4%B8%8A%E5%A6%82%E4%BD%95%E7%BB%88%E6%AD%A2%E6%9F%90%E4%B8%AA%E7%AB%AF%E5%8F%A3%E6%89%80%E5%9C%A8%E7%9A%84%E8%BF%9B%E7%A8%8B%EF%BC%9F/</id>
    <published>2023-11-12T03:31:14.000Z</published>
    <updated>2023-11-12T03:32:14.994Z</updated>
    
    <content type="html"><![CDATA[<p>在Mac上终止占用特定端口的进程可以通过以下步骤来完成：</p><ol><li><p><strong>查找占用端口的进程</strong>：<br>打开终端（Terminal），然后使用<code>lsof</code>命令来查找占用特定端口的进程。例如，如果你想查找占用端口8080的进程，可以使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">lsof -i :8080<br></code></pre></td></tr></table></figure><p>这将列出所有占用端口8080的进程。输出中通常会包含进程ID（PID），这是一个数字。</p></li><li><p><strong>终止进程</strong>：<br>一旦你知道了进程ID，可以使用<code>kill</code>命令来终止该进程。例如，如果进程ID是1234，可以使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">kill</span> 1234<br></code></pre></td></tr></table></figure><p>如果进程拒绝终止，你可以使用更强制的方式，比如<code>kill -9</code>命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">kill</span> -9 1234<br></code></pre></td></tr></table></figure><p>这将强制终止该进程。</p></li></ol><p>请注意，在使用这些命令时要小心，确保你终止的是正确的进程，因为错误地终止进程可能会影响系统的稳定性或其他应用的运行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在Mac上终止占用特定端口的进程可以通过以下步骤来完成：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;查找占用端口的进程&lt;/strong&gt;：&lt;br&gt;打开终端（Terminal），然后使用&lt;code&gt;lsof&lt;/code&gt;命令来查找占用特定端口的进程。例如，如果你想查找占</summary>
      
    
    
    
    
    <category term="Mac" scheme="http://xuebusi.gitee.io/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>Java实现两台计算机之间长连接通信</title>
    <link href="http://xuebusi.gitee.io/2023/11/09/Java%E5%AE%9E%E7%8E%B0%E4%B8%A4%E5%8F%B0%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E9%97%B4%E9%95%BF%E8%BF%9E%E6%8E%A5%E9%80%9A%E4%BF%A1/"/>
    <id>http://xuebusi.gitee.io/2023/11/09/Java%E5%AE%9E%E7%8E%B0%E4%B8%A4%E5%8F%B0%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E9%97%B4%E9%95%BF%E8%BF%9E%E6%8E%A5%E9%80%9A%E4%BF%A1/</id>
    <published>2023-11-09T12:54:10.000Z</published>
    <updated>2023-11-09T12:55:57.056Z</updated>
    
    <content type="html"><![CDATA[<p>要实现客户端和服务器端的长连接，即一直保持连接直到程序显式关闭，你可以在客户端和服务器端都使用循环来持续地发送和接收消息。下面是相应的代码示例：</p><h3 id="服务器端（B计算机）"><a href="#服务器端（B计算机）" class="headerlink" title="服务器端（B计算机）"></a>服务器端（B计算机）</h3><p>服务器端持续监听客户端发送的消息。使用<code>while(true)</code>确保服务器始终在运行，等待和处理客户端的消息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.net.*;<br><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Server</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">port</span> <span class="hljs-operator">=</span> <span class="hljs-number">1234</span>;<br>        <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(port);<br>        System.out.println(<span class="hljs-string">&quot;等待连接...&quot;</span>);<br>        <span class="hljs-type">Socket</span> <span class="hljs-variable">clientSocket</span> <span class="hljs-operator">=</span> serverSocket.accept();<br>        System.out.println(<span class="hljs-string">&quot;连接成功！&quot;</span>);<br><br>        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(clientSocket.getInputStream()));<br><br>        String inputLine;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123; <span class="hljs-comment">// 一直保持监听状态</span><br>            inputLine = in.readLine();<br>            <span class="hljs-keyword">if</span> (inputLine != <span class="hljs-literal">null</span>) &#123;<br>                System.out.println(<span class="hljs-string">&quot;收到: &quot;</span> + inputLine);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 注意：实际应用中需要添加适当的退出条件和异常处理</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="客户端（A计算机）"><a href="#客户端（A计算机）" class="headerlink" title="客户端（A计算机）"></a>客户端（A计算机）</h3><p>客户端持续发送消息到服务器。在这个例子中，我们仅以发送时间作为消息的示例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.net.*;<br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.util.Date;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">serverAddress</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;服务器的IP地址&quot;</span>; <span class="hljs-comment">// 替换为B计算机的IP地址</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">port</span> <span class="hljs-operator">=</span> <span class="hljs-number">1234</span>;<br>        <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(serverAddress, port);<br><br>        <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintWriter</span>(socket.getOutputStream(), <span class="hljs-literal">true</span>);<br>        <br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123; <span class="hljs-comment">// 一直发送消息</span><br>            out.println(<span class="hljs-string">&quot;当前时间: &quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>            Thread.sleep(<span class="hljs-number">1000</span>); <span class="hljs-comment">// 每秒发送一次</span><br>        &#125;<br>        <span class="hljs-comment">// 注意：实际应用中需要添加适当的退出条件和异常处理</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这两个示例中，我没有添加退出条件和异常处理，但这在实际应用中是非常重要的。你需要确保代码能够优雅地处理网络异常、I&#x2F;O异常以及如何安全地关闭连接。记住，长时间保持连接会增加资源消耗，确保服务器有足够的资源来处理这些长连接。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;要实现客户端和服务器端的长连接，即一直保持连接直到程序显式关闭，你可以在客户端和服务器端都使用循环来持续地发送和接收消息。下面是相应的代码示例：&lt;/p&gt;
&lt;h3 id=&quot;服务器端（B计算机）&quot;&gt;&lt;a href=&quot;#服务器端（B计算机）&quot; class=&quot;headerlink&quot;</summary>
      
    
    
    
    <category term="Java" scheme="http://xuebusi.gitee.io/categories/Java/"/>
    
    
    <category term="Socket" scheme="http://xuebusi.gitee.io/tags/Socket/"/>
    
    <category term="ServerSocket" scheme="http://xuebusi.gitee.io/tags/ServerSocket/"/>
    
    <category term="BufferedReader" scheme="http://xuebusi.gitee.io/tags/BufferedReader/"/>
    
    <category term="InputStreamReader" scheme="http://xuebusi.gitee.io/tags/InputStreamReader/"/>
    
    <category term="PrintWriter" scheme="http://xuebusi.gitee.io/tags/PrintWriter/"/>
    
  </entry>
  
  <entry>
    <title>Java实现两台计算机之间的简单通信</title>
    <link href="http://xuebusi.gitee.io/2023/11/09/Java%E5%AE%9E%E7%8E%B0%E4%B8%A4%E5%8F%B0%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E9%97%B4%E7%9A%84%E7%AE%80%E5%8D%95%E9%80%9A%E4%BF%A1/"/>
    <id>http://xuebusi.gitee.io/2023/11/09/Java%E5%AE%9E%E7%8E%B0%E4%B8%A4%E5%8F%B0%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E9%97%B4%E7%9A%84%E7%AE%80%E5%8D%95%E9%80%9A%E4%BF%A1/</id>
    <published>2023-11-09T12:41:22.000Z</published>
    <updated>2023-11-09T12:43:07.664Z</updated>
    
    <content type="html"><![CDATA[<p>要在Java中实现从一台计算机（A）向另一台计算机（B）发送数据，你可以使用Java的套接字编程。这通常涉及到创建服务器端和客户端程序。服务器在B计算机上运行，监听一个端口等待连接；客户端运行在A计算机上，连接到服务器并发送数据。</p><p>这里是一个简单的示例：</p><h3 id="服务器端（在B计算机上运行）"><a href="#服务器端（在B计算机上运行）" class="headerlink" title="服务器端（在B计算机上运行）"></a>服务器端（在B计算机上运行）</h3><ol><li>创建<code>ServerSocket</code>对象并指定一个端口。</li><li>调用<code>accept</code>方法等待客户端连接。</li><li>通过建立的连接读取数据。</li><li>关闭连接。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.net.*;<br><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Server</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">port</span> <span class="hljs-operator">=</span> <span class="hljs-number">1234</span>; <span class="hljs-comment">// 选择一个端口</span><br>        <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(port);<br><br>        System.out.println(<span class="hljs-string">&quot;等待连接...&quot;</span>);<br>        <span class="hljs-type">Socket</span> <span class="hljs-variable">clientSocket</span> <span class="hljs-operator">=</span> serverSocket.accept();<br>        System.out.println(<span class="hljs-string">&quot;连接成功！&quot;</span>);<br><br>        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(clientSocket.getInputStream()));<br>        String inputLine;<br>        <span class="hljs-keyword">while</span> ((inputLine = in.readLine()) != <span class="hljs-literal">null</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;收到: &quot;</span> + inputLine);<br>        &#125;<br><br>        in.close();<br>        clientSocket.close();<br>        serverSocket.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="客户端（在A计算机上运行）"><a href="#客户端（在A计算机上运行）" class="headerlink" title="客户端（在A计算机上运行）"></a>客户端（在A计算机上运行）</h3><ol><li>创建<code>Socket</code>对象，指定服务器地址和端口。</li><li>获取输出流并发送数据。</li><li>关闭连接。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.net.*;<br><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">serverAddress</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;服务器的IP地址&quot;</span>; <span class="hljs-comment">// 替换为B计算机的IP地址</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">port</span> <span class="hljs-operator">=</span> <span class="hljs-number">1234</span>;<br>        <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(serverAddress, port);<br><br>        <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintWriter</span>(socket.getOutputStream(), <span class="hljs-literal">true</span>);<br>        out.println(<span class="hljs-string">&quot;你好，服务器！&quot;</span>);<br><br>        out.close();<br>        socket.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：</p><ul><li>请确保服务器和客户端使用相同的端口号。</li><li>需要处理网络异常和I&#x2F;O异常。</li><li>根据你的网络设置，你可能需要配置防火墙允许这些端口的通信。</li><li>在实际应用中，还需要考虑安全性和效率等问题。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;要在Java中实现从一台计算机（A）向另一台计算机（B）发送数据，你可以使用Java的套接字编程。这通常涉及到创建服务器端和客户端程序。服务器在B计算机上运行，监听一个端口等待连接；客户端运行在A计算机上，连接到服务器并发送数据。&lt;/p&gt;
&lt;p&gt;这里是一个简单的示例：&lt;/p</summary>
      
    
    
    
    <category term="Java" scheme="http://xuebusi.gitee.io/categories/Java/"/>
    
    
    <category term="Socket" scheme="http://xuebusi.gitee.io/tags/Socket/"/>
    
    <category term="ServerSocket" scheme="http://xuebusi.gitee.io/tags/ServerSocket/"/>
    
  </entry>
  
  <entry>
    <title>使用Vapor编写用户信息CRUD的API接口</title>
    <link href="http://xuebusi.gitee.io/2023/11/09/%E4%BD%BF%E7%94%A8Vapor%E7%BC%96%E5%86%99%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AFCRUD%E7%9A%84API%E6%8E%A5%E5%8F%A3/"/>
    <id>http://xuebusi.gitee.io/2023/11/09/%E4%BD%BF%E7%94%A8Vapor%E7%BC%96%E5%86%99%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AFCRUD%E7%9A%84API%E6%8E%A5%E5%8F%A3/</id>
    <published>2023-11-09T00:49:10.000Z</published>
    <updated>2023-11-09T00:49:57.368Z</updated>
    
    <content type="html"><![CDATA[<p>很高兴你对Vapor框架感兴趣！Vapor 是一个用 Swift 编写的 Web 框架，非常适合于构建快速、可靠的服务端应用程序。接下来我会引导你如何使用 Vapor 创建一个简单的用户信息 CRUD（创建、读取、更新、删除）API。</p><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>首先，确保你的电脑上安装了以下软件：</p><ol><li><strong>Swift</strong>: Vapor 是基于 Swift 的，所以你需要安装 Swift。</li><li><strong>Vapor Toolbox</strong>: 这是一个命令行工具，用于简化 Vapor 项目的创建和管理。</li></ol><h3 id="创建新项目"><a href="#创建新项目" class="headerlink" title="创建新项目"></a>创建新项目</h3><ol><li>打开终端。</li><li>使用 Vapor Toolbox 创建一个新项目：<code>vapor new UserCRUDAPI</code>。</li><li>进入项目目录：<code>cd UserCRUDAPI</code>。</li></ol><h3 id="设定模型和数据库"><a href="#设定模型和数据库" class="headerlink" title="设定模型和数据库"></a>设定模型和数据库</h3><p>为了简单起见，我们将使用内存数据库（SQLite），这样就不需要额外安装数据库软件。</p><ol><li><p><strong>定义用户模型</strong>：在 <code>Sources/App/Models</code> 目录下创建一个新的 Swift 文件 <code>User.swift</code>。</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">import</span> Vapor<br><span class="hljs-keyword">import</span> Fluent<br><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>: <span class="hljs-title class_">Model</span>, <span class="hljs-title class_">Content</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">let</span> schema <span class="hljs-operator">=</span> <span class="hljs-string">&quot;users&quot;</span><br><br>    <span class="hljs-meta">@ID</span>(key: .id)<br>    <span class="hljs-keyword">var</span> id: <span class="hljs-type">UUID</span>?<br><br>    <span class="hljs-meta">@Field</span>(key: <span class="hljs-string">&quot;name&quot;</span>)<br>    <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span><br><br>    <span class="hljs-meta">@Field</span>(key: <span class="hljs-string">&quot;email&quot;</span>)<br>    <span class="hljs-keyword">var</span> email: <span class="hljs-type">String</span><br><br>    <span class="hljs-keyword">init</span>() &#123; &#125;<br><br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">id</span>: <span class="hljs-type">UUID</span>? <span class="hljs-operator">=</span> <span class="hljs-literal">nil</span>, <span class="hljs-params">name</span>: <span class="hljs-type">String</span>, <span class="hljs-params">email</span>: <span class="hljs-type">String</span>) &#123;<br>        <span class="hljs-keyword">self</span>.id <span class="hljs-operator">=</span> id<br>        <span class="hljs-keyword">self</span>.name <span class="hljs-operator">=</span> name<br>        <span class="hljs-keyword">self</span>.email <span class="hljs-operator">=</span> email<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>配置数据库</strong>：在 <code>Sources/App/configure.swift</code> 文件中配置数据库。</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">import</span> Fluent<br><span class="hljs-keyword">import</span> FluentSQLiteDriver<br><span class="hljs-keyword">import</span> Vapor<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">configure</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">app</span>: <span class="hljs-type">Application</span>) <span class="hljs-keyword">throws</span> &#123;<br>    app.databases.use(.sqlite(.memory), as: .sqlite)<br>    app.migrations.add(<span class="hljs-type">CreateUser</span>())<br>    <span class="hljs-keyword">try</span> app.autoMigrate().wait()<br>    <br>    <span class="hljs-comment">// 其他配置...</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>创建数据库迁移</strong>：创建一个新的 Swift 文件 <code>CreateUser.swift</code> 在 <code>Sources/App/Migrations</code>。</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">import</span> Fluent<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CreateUser</span>: <span class="hljs-title class_">Migration</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">prepare</span>(<span class="hljs-params">on</span> <span class="hljs-params">database</span>: <span class="hljs-type">Database</span>) -&gt; <span class="hljs-type">EventLoopFuture</span>&lt;<span class="hljs-type">Void</span>&gt; &#123;<br>        database.schema(<span class="hljs-string">&quot;users&quot;</span>)<br>            .id()<br>            .field(<span class="hljs-string">&quot;name&quot;</span>, .string, .required)<br>            .field(<span class="hljs-string">&quot;email&quot;</span>, .string, .required)<br>            .create()<br>    &#125;<br><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">revert</span>(<span class="hljs-params">on</span> <span class="hljs-params">database</span>: <span class="hljs-type">Database</span>) -&gt; <span class="hljs-type">EventLoopFuture</span>&lt;<span class="hljs-type">Void</span>&gt; &#123;<br>        database.schema(<span class="hljs-string">&quot;users&quot;</span>).delete()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="编写-CRUD-接口"><a href="#编写-CRUD-接口" class="headerlink" title="编写 CRUD 接口"></a>编写 CRUD 接口</h3><ol><li><p><strong>创建路由</strong>：在 <code>Sources/App/routes.swift</code> 文件中定义路由和相应的处理函数。</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">import</span> Vapor<br><br><span class="hljs-keyword">func</span> <span class="hljs-title function_">routes</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">app</span>: <span class="hljs-type">Application</span>) <span class="hljs-keyword">throws</span> &#123;<br>    <span class="hljs-keyword">let</span> userController <span class="hljs-operator">=</span> <span class="hljs-type">UserController</span>()<br>    app.get(<span class="hljs-string">&quot;users&quot;</span>, use: userController.index)<br>    app.post(<span class="hljs-string">&quot;users&quot;</span>, use: userController.create)<br>    app.group(<span class="hljs-string">&quot;users&quot;</span>) &#123; users <span class="hljs-keyword">in</span><br>        users.get(<span class="hljs-string">&quot;:userID&quot;</span>, use: userController.show)<br>        users.put(<span class="hljs-string">&quot;:userID&quot;</span>, use: userController.update)<br>        users.delete(<span class="hljs-string">&quot;:userID&quot;</span>, use: userController.delete)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>实现控制器</strong>：创建一个新的 Swift 文件 <code>UserController.swift</code> 在 <code>Sources/App/Controllers</code>。</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">import</span> Vapor<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">UserController</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">index</span>(<span class="hljs-params">req</span>: <span class="hljs-type">Request</span>) <span class="hljs-keyword">throws</span> -&gt; <span class="hljs-type">EventLoopFuture</span>&lt;[<span class="hljs-type">User</span>]&gt; &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-type">User</span>.query(on: req.db).all()<br>    &#125;<br><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">create</span>(<span class="hljs-params">req</span>: <span class="hljs-type">Request</span>) <span class="hljs-keyword">throws</span> -&gt; <span class="hljs-type">EventLoopFuture</span>&lt;<span class="hljs-type">User</span>&gt; &#123;<br>        <span class="hljs-keyword">let</span> user <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> req.content.decode(<span class="hljs-type">User</span>.<span class="hljs-keyword">self</span>)<br>        <span class="hljs-keyword">return</span> user.save(on: req.db).map &#123; user &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">show</span>(<span class="hljs-params">req</span>: <span class="hljs-type">Request</span>) <span class="hljs-keyword">throws</span> -&gt; <span class="hljs-type">EventLoopFuture</span>&lt;<span class="hljs-type">User</span>&gt; &#123;<br>        <span class="hljs-type">User</span>.find(req.parameters.get(<span class="hljs-string">&quot;userID&quot;</span>), on: req.db)<br>            .unwrap(or: <span class="hljs-type">Abort</span>(.notFound))<br>    &#125;<br><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">update</span>(<span class="hljs-params">req</span>: <span class="hljs-type">Request</span>) <span class="hljs-keyword">throws</span> -&gt; <span class="hljs-type">EventLoopFuture</span>&lt;<span class="hljs-type">User</span>&gt; &#123;<br>        <span class="hljs-keyword">let</span> updatedUser <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> req.content.decode(<span class="hljs-type">User</span>.<span class="hljs-keyword">self</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-type">User</span>.find(req.parameters.get(<span class="hljs-string">&quot;userID&quot;</span>), on: req.db)<br>            .unwrap(or: <span class="hljs-type">Abort</span>(.notFound)).flatMap &#123; user <span class="hljs-keyword">in</span><br>                user.name <span class="hljs-operator">=</span> updatedUser.name<br>                user.email <span class="hljs-operator">=</span> updatedUser.email<br>                <span class="hljs-keyword">return</span> user.save(on: req.db).map &#123; user &#125;<br>            &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">delete</span>(<span class="hljs-params">req</span>: <span class="hljs-type">Request</span>) <span class="hljs-keyword">throws</span> -&gt; <span class="hljs-type">EventLoopFuture</span>&lt;<span class="hljs-type">HTTPStatus</span>&gt; &#123;<br>        <span class="hljs-type">User</span>.find(req.parameters.get(<span class="hljs-string">&quot;userID&quot;</span>), on: req.db)<br>            .unwrap(or: <span class="hljs-type">Abort</span>(.notFound))<br>            .flatMap &#123; user <span class="hljs-keyword">in</span><br>                user.delete(on: req.db)<br>                    .transform(to: .ok)<br>            &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="运行和测试"><a href="#运行和测试" class="headerlink" title="运行和测试"></a>运行和测试</h3><ol><li><p><strong>启动服务器</strong>：在项目根目录下运行 <code>vapor run</code>。</p></li><li><p><strong>测试 API</strong>：使用 Postman 或任何 HTTP 客户端工具测试你的 API。</p><ul><li>创建用户：<code>POST /users</code>，带上 JSON 请求体，比如 <code>&#123;&quot;name&quot;: &quot;Alice&quot;, &quot;email&quot;: &quot;alice@example.com&quot;&#125;</code>。</li><li>列出所有用户：<code>GET /users</code>。</li><li>获取单个用户：<code>GET /users/:userID</code>。</li><li>更新用户信息：<code>PUT /users/:userID</code>。</li><li>删除用户：<code>DELETE /users/:userID</code>。</li></ul></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在这个简单的示例中，我们创建了一个使用 Swift 和 Vapor 框架的 RESTful API，它可以处理基本的用户信息 CRUD 操作。这个示例使用了内存中的 SQLite 数据库，因此在服务器重启时，所有数据都会丢失。在实际应用中，你可能会使用 PostgreSQL 或 MySQL 等持久化的数据库。希望这对你学习 Vapor 有所帮助！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;很高兴你对Vapor框架感兴趣！Vapor 是一个用 Swift 编写的 Web 框架，非常适合于构建快速、可靠的服务端应用程序。接下来我会引导你如何使用 Vapor 创建一个简单的用户信息 CRUD（创建、读取、更新、删除）API。&lt;/p&gt;
&lt;h3 id=&quot;环境准备&quot;&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>SwiftUI核心技术第15章构建一个聊天APP</title>
    <link href="http://xuebusi.gitee.io/2023/11/08/SwiftUI%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC15%E7%AB%A0%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%81%8A%E5%A4%A9APP/"/>
    <id>http://xuebusi.gitee.io/2023/11/08/SwiftUI%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC15%E7%AB%A0%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%81%8A%E5%A4%A9APP/</id>
    <published>2023-11-08T02:24:42.000Z</published>
    <updated>2024-03-17T06:12:04.584Z</updated>
    
    <content type="html"><![CDATA[<p><strong>第1小节：应用结构规划</strong></p><p>在开发一个新的应用时，规划应用的结构是成功的关键。一个良好设计的应用结构可以提高代码的可维护性和扩展性，并使团队合作变得更加高效。本小节我们将讨论如何为我们的聊天应用进行结构规划。</p><h3 id="应用概览"><a href="#应用概览" class="headerlink" title="应用概览"></a>应用概览</h3><p>我们的聊天应用将具备以下基本功能：</p><ul><li>用户注册与登录</li><li>好友列表管理</li><li>实时消息传递</li><li>个人与群组聊天</li><li>消息通知</li></ul><h3 id="架构模式"><a href="#架构模式" class="headerlink" title="架构模式"></a>架构模式</h3><p>首先，我们需要选择一个适合于聊天应用的架构模式。考虑到SwiftUI的特性，我们选择MVVM（Model-View-ViewModel）作为主要架构，因为它能够很好地与SwiftUI的声明式UI和数据流工作模式配合。</p><h3 id="分层设计"><a href="#分层设计" class="headerlink" title="分层设计"></a>分层设计</h3><p>我们的应用将分为以下几层：</p><ol><li><strong>视图层（View）</strong>：负责展示用户界面，捕获用户输入。</li><li><strong>视图模型层（ViewModel）</strong>：处理视图逻辑，响应用户输入，与模型层通信。</li><li><strong>模型层（Model）</strong>：定义数据结构和业务逻辑。</li><li><strong>网络层</strong>：处理所有网络通信，例如发送和接收消息。</li><li><strong>数据库层</strong>：负责数据持久化，存储历史消息和用户数据。</li></ol><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p>为了支持这种分层设计，我们的项目目录将如下组织：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs stylus">ChatApp/<br>├── Views/<br>│   ├── LoginView<span class="hljs-selector-class">.swift</span><br>│   ├── ChatListView<span class="hljs-selector-class">.swift</span><br>│   ├── ChatView<span class="hljs-selector-class">.swift</span><br>│   └── ...<br>├── ViewModels/<br>│   ├── LoginViewModel<span class="hljs-selector-class">.swift</span><br>│   ├── ChatListViewModel<span class="hljs-selector-class">.swift</span><br>│   ├── ChatViewModel<span class="hljs-selector-class">.swift</span><br>│   └── ...<br>├── Models/<br>│   ├── User<span class="hljs-selector-class">.swift</span><br>│   ├── Message<span class="hljs-selector-class">.swift</span><br>│   ├── Conversation<span class="hljs-selector-class">.swift</span><br>│   └── ...<br>├── Services/<br>│   ├── AuthenticationService<span class="hljs-selector-class">.swift</span><br>│   ├── ChatService<span class="hljs-selector-class">.swift</span><br>│   ├── NotificationService<span class="hljs-selector-class">.swift</span><br>│   └── ...<br>└── Utilities/<br>    ├── Constants<span class="hljs-selector-class">.swift</span><br>    ├── Extensions<span class="hljs-selector-class">.swift</span><br>    └── ...<br></code></pre></td></tr></table></figure><h3 id="功能模块划分"><a href="#功能模块划分" class="headerlink" title="功能模块划分"></a>功能模块划分</h3><p>接下来，我们将应用分解为几个核心模块：</p><ul><li><strong>用户认证模块</strong>：包括用户注册、登录和验证。</li><li><strong>联系人模块</strong>：用户的好友列表，添加和删除联系人。</li><li><strong>聊天模块</strong>：展示消息历史，发送新消息，消息推送。</li><li><strong>设置模块</strong>：用户可以修改个人信息，设置应用选项等。</li></ul><h3 id="数据流规划"><a href="#数据流规划" class="headerlink" title="数据流规划"></a>数据流规划</h3><p>由于聊天应用需要实时的数据更新，我们将使用Combine框架来处理数据的发布和订阅，以确保用户界面能够响应数据的变化。</p><ul><li>使用<code>@Published</code>属性包装器来自动管理数据的发布。</li><li><code>ViewModels</code>将订阅<code>Models</code>的变化，并更新视图状态。</li><li>视图将绑定到视图模型的发布者，以获得数据变更的通知。</li></ul><h3 id="安全和隐私"><a href="#安全和隐私" class="headerlink" title="安全和隐私"></a>安全和隐私</h3><p>聊天应用需要格外注意安全和隐私：</p><ul><li>采用安全的认证机制，如OAuth 2.0。</li><li>传输层加密，确保数据传输的安全。</li><li>数据库加密存储敏感信息。</li></ul><h3 id="用户体验（UX）"><a href="#用户体验（UX）" class="headerlink" title="用户体验（UX）"></a>用户体验（UX）</h3><p>用户体验是聊天应用成功的关键，我们需要确保：</p><ul><li>界面简洁明了，易于导航。</li><li>消息即时传送，无明显延迟。</li><li>有声音和震动的通知反馈。</li></ul><p>通过仔细规</p><p>划应用结构，我们为聊天应用的开发奠定了坚实的基础。后续小节中，我们将深入每个模块，开始具体的设计和编码工作。</p><p><strong>第2小节：用户界面设计</strong></p><p>用户界面（UI）设计是创建聊天应用的重要组成部分。一个直观、易用且美观的UI将极大地提升用户体验。在这一小节，我们将概述聊天应用的用户界面设计过程，包括布局、组件选择、颜色和动画的应用等方面。</p><h3 id="UI设计原则"><a href="#UI设计原则" class="headerlink" title="UI设计原则"></a>UI设计原则</h3><p>在设计界面之前，我们首先确定几个核心设计原则：</p><ul><li><strong>一致性</strong>：整个应用的设计风格保持一致，包括按钮样式、字体、颜色等。</li><li><strong>简洁性</strong>：避免不必要的元素，使用户可以集中于聊天功能。</li><li><strong>直观性</strong>：确保用户能够直观地理解如何使用应用，无需额外学习。</li><li><strong>响应式</strong>：界面应该能够适应不同设备和屏幕大小。</li></ul><h3 id="布局设计"><a href="#布局设计" class="headerlink" title="布局设计"></a>布局设计</h3><p>布局是UI设计的基础，我们将采用如下布局策略：</p><ul><li><strong>导航栏</strong>：位于屏幕顶部，包含用户的状态和导航控件。</li><li><strong>消息列表</strong>：主屏幕显示消息列表，一览无余。</li><li><strong>输入区</strong>：屏幕底部为消息输入区，包括文本输入框和发送按钮。</li><li><strong>设置菜单</strong>：通过导航栏访问，包括个人资料编辑和应用设置。</li></ul><h3 id="组件设计"><a href="#组件设计" class="headerlink" title="组件设计"></a>组件设计</h3><p>我们将使用SwiftUI来构建以下组件：</p><ul><li><strong>CustomButton</strong>：自定义按钮，用于登录、发送消息等。</li><li><strong>ChatBubble</strong>：聊天气泡，区分自己和他人的消息。</li><li><strong>UserAvatar</strong>：用户头像，显示在消息旁边和好友列表中。</li><li><strong>TextField</strong>：自定义文本输入框，支持多行文本输入和表情。</li></ul><h3 id="颜色和主题"><a href="#颜色和主题" class="headerlink" title="颜色和主题"></a>颜色和主题</h3><p>颜色方案将支持暗黑模式和光亮模式，我们将定义一组基础颜色：</p><ul><li><strong>主色调</strong>：定义应用的主题颜色，如蓝色或绿色。</li><li><strong>辅助色</strong>：用于强调按钮或重要信息。</li><li><strong>背景色</strong>：分为深色和浅色变体，适应不同模式。</li><li><strong>文字色</strong>：确保在任何背景色上都清晰可见。</li></ul><h3 id="图标和图形"><a href="#图标和图形" class="headerlink" title="图标和图形"></a>图标和图形</h3><p>应用中的图标和图形将采用矢量图形，以确保在不同分辨率下都能清晰显示。我们将为每个主要功能选择直观的图标。</p><h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><p>为了提升用户体验，我们将在以下方面应用动画：</p><ul><li><strong>页面切换</strong>：平滑过渡，增强用户操作的连贯感。</li><li><strong>消息发送</strong>：消息框飞入聊天区域的动画。</li><li><strong>加载指示器</strong>：在等待网络响应时提供动态反馈。</li></ul><h3 id="响应式设计"><a href="#响应式设计" class="headerlink" title="响应式设计"></a>响应式设计</h3><p>我们的UI设计将采用响应式方法，以适应不同的设备和屏幕尺寸：</p><ul><li><strong>自适应布局</strong>：使用<code>Stacks</code>、<code>Grids</code>和<code>Flexible Spaces</code>确保组件在不同屏幕上都能正确布局。</li><li><strong>动态字体大小</strong>：支持系统字体大小设置，适应用户的阅读需求。</li></ul><h3 id="交互设计"><a href="#交互设计" class="headerlink" title="交互设计"></a>交互设计</h3><p>最后，交互设计也是我们关注的重点：</p><ul><li><strong>触控反馈</strong>：按钮和可交互元素将提供触觉反馈。</li><li><strong>滑动删除</strong>：在消息列表中轻松</li></ul><p>滑动来删除消息或撤回。</p><p>通过上述设计，我们将创建一个美观、直观且功能强大的聊天应用用户界面。接下来，我们将在小节中进一步详细说明每个组件和功能的实现过程。</p><p><strong>第3小节：应用逻辑实现</strong></p><p>构建一个聊天应用不仅仅是设计外观上的美观与实用，应用的核心在于其逻辑实现。在本小节，我们将探讨如何在SwiftUI框架下实现聊天应用的基本逻辑，包括消息的发送与接收、状态管理以及实时更新等功能。</p><h3 id="基础逻辑构建"><a href="#基础逻辑构建" class="headerlink" title="基础逻辑构建"></a>基础逻辑构建</h3><p>首先，我们需要建立应用的数据模型和业务逻辑层，这通常涉及以下几个关键部分：</p><ul><li><strong>用户模型（User Model）</strong>：定义用户的基本信息，如用户名、头像、状态等。</li><li><strong>消息模型（Message Model）</strong>：定义消息的数据结构，包含发送者、接收者、消息内容、发送时间等。</li><li><strong>会话列表（Conversations List）</strong>：存储用户的聊天会话，每个会话包含多条消息。</li><li><strong>数据管理器（Data Manager）</strong>：负责处理数据的存取、更新以及同步。</li></ul><h3 id="消息发送与接收"><a href="#消息发送与接收" class="headerlink" title="消息发送与接收"></a>消息发送与接收</h3><p>聊天的核心功能是消息的发送与接收，我们将通过以下步骤来实现：</p><ol><li><p><strong>输入与发送</strong>：</p><ul><li>使用<code>TextField</code>或<code>TextView</code>获取用户输入的消息文本。</li><li>当用户点击发送按钮时，通过数据管理器将消息对象保存到会话列表中。</li></ul></li><li><p><strong>消息展示</strong>：</p><ul><li>使用<code>ScrollView</code>和<code>LazyVStack</code>展示消息列表。</li><li>对于每条消息，使用<code>ChatBubble</code>视图来展示，根据发送者是自己还是对方来调整样式和位置。</li></ul></li><li><p><strong>实时更新</strong>：</p><ul><li>通过<code>Combine</code>框架监听数据变化，实现消息的实时更新。</li><li>当有新消息时，更新UI以展示新消息。</li></ul></li></ol><h3 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h3><p>在SwiftUI中，状态管理是一个重要的概念，它确保UI的正确性和数据的同步。我们将使用<code>@State</code>、<code>@Binding</code>、<code>@ObservedObject</code>等属性包装器来管理状态：</p><ul><li><strong>用户状态</strong>：使用<code>@State</code>管理用户的在线状态，比如在线、离开、忙碌等。</li><li><strong>消息状态</strong>：使用<code>@ObservedObject</code>监控消息的发送和接收状态。</li></ul><h3 id="实时更新和同步"><a href="#实时更新和同步" class="headerlink" title="实时更新和同步"></a>实时更新和同步</h3><p>为了实现聊天应用中的实时互动，我们将使用WebSocket或者Apple的<code>CloudKit</code>来进行网络通信，实现消息的即时推送：</p><ul><li><strong>WebSocket连接</strong>：建立WebSocket连接来监听服务器发来的新消息。</li><li><strong>CloudKit同步</strong>：如果使用<code>CloudKit</code>，则设置相应的记录类型和订阅，以便于新消息到来时可以立即更新。</li></ul><h3 id="聊天功能拓展"><a href="#聊天功能拓展" class="headerlink" title="聊天功能拓展"></a>聊天功能拓展</h3><p>除了基础的文本消息，我们还可以实现以下几个功能：</p><ul><li><strong>图片和视频发送</strong>：允许用户发送媒体文件，并在聊天气泡中预览。</li><li><strong>消息状态标记</strong>：如已读、已发送等状态的标记。</li><li><strong>通知与提醒</strong>：通过本地通知或推送通知，告知用户新消息的到来。</li></ul><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>在实现聊天逻辑时，还需要考虑异常情况的处理：</p><ul><li><strong>网络异常</strong>：当网络不稳定或断开时，给用户适当的反馈，并尝试重新连接。</li><li><strong>数据持久化</strong>：确保消息在本地被保存，即使应用关闭后也能恢复历史消息。</li></ul><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>开发过程中，持续进行单元测试和集成测试来确保各个功能的可靠性，包括：</p><ul><li><strong>逻辑测试</strong>：对数据管理器和业务逻辑层进行测试。</li><li><strong>UI测试</strong>：确保消息正确显示，</li></ul><p>用户交互按预期工作。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在本小节中，我们详细探讨了构建聊天应用的应用逻辑实现。从用户界面的交互到后端的数据处理，每一步都是为了提供流畅而可靠的用户体验。通过上述步骤的实现，我们的聊天应用将能够处理实时的消息交流，拥有健壮的逻辑处理能力以及优雅的错误处理机制。接下来的小节，我们将继续深入探讨应用的其他关键功能和实现细节。</p><p><strong>第4小节：数据持久化</strong></p><p>在聊天应用中，数据持久化是保证用户信息、消息历史以及应用状态在不同会话间能够得到保存和恢复的关键技术。不仅仅是为了增强用户体验，数据持久化同样是数据安全和隐私的重要组成部分。在本小节中，我们将讨论在SwiftUI应用中实现数据持久化的策略和技术。</p><h3 id="持久化选项"><a href="#持久化选项" class="headerlink" title="持久化选项"></a>持久化选项</h3><p>SwiftUI应用中，我们可以选择多种方式来实现数据持久化：</p><ol><li><strong>UserDefaults</strong>：适合存储少量的用户偏好设置或简单的应用状态。</li><li><strong>文件系统</strong>：适合存储大量数据，如日志文件或者用户生成的内容。</li><li><strong>SQLite数据库</strong>：适合复杂的数据结构和大量数据的管理。</li><li><strong>Core Data</strong>：苹果推荐的解决方案，集成了SQLite，并提供了丰富的数据管理功能。</li><li><strong>CloudKit</strong>：允许数据在设备间同步，同时保留在iCloud上。</li></ol><h3 id="Core-Data集成"><a href="#Core-Data集成" class="headerlink" title="Core Data集成"></a>Core Data集成</h3><p>我们将以Core Data为例，探讨如何在SwiftUI聊天应用中实现数据持久化。</p><ul><li><strong>设置Core Data堆栈</strong>：这包括了<code>NSPersistentContainer</code>的创建和配置，它将负责管理数据模型和协调数据存储。</li><li><strong>定义数据模型</strong>：在<code>.xcdatamodeld</code>文件中定义实体（Entity），包括<code>User</code>和<code>Message</code>等，并设置好它们的属性和关系。</li><li><strong>管理上下文（Context）</strong>：使用<code>NSManagedObjectContext</code>来管理对象的生命周期，实现数据的增删改查操作。</li></ul><h3 id="数据存储和检索"><a href="#数据存储和检索" class="headerlink" title="数据存储和检索"></a>数据存储和检索</h3><ul><li><strong>存储消息</strong>：当用户发送消息时，创建<code>Message</code>的实例，并通过上下文将其插入到持久化存储中。</li><li><strong>读取会话</strong>：加载聊天会话时，从Core Data中检索相关联的<code>Message</code>实例，根据时间戳排序后显示在界面上。</li></ul><h3 id="同步和更新"><a href="#同步和更新" class="headerlink" title="同步和更新"></a>同步和更新</h3><ul><li><strong>监听数据变化</strong>：利用<code>NSFetchedResultsController</code>监听Core Data模型的变化，当新消息被插入时，自动刷新UI。</li><li><strong>后台更新</strong>：通过<code>performBackgroundTask</code>方法在后台线程上进行数据更新操作，以避免阻塞UI线程。</li></ul><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><ul><li><strong>处理Core Data错误</strong>：在进行数据操作时，正确处理<code>NSManagedObjectContext</code>的保存（save）操作可能出现的错误。</li><li><strong>数据迁移</strong>：为了应对未来数据模型的变化，实现Core Data的数据迁移策略。</li></ul><h3 id="测试与维护"><a href="#测试与维护" class="headerlink" title="测试与维护"></a>测试与维护</h3><ul><li><strong>单元测试</strong>：为数据模型的创建、更新、删除编写单元测试，确保数据层逻辑的正确性。</li><li><strong>数据清理</strong>：实现数据清理策略，比如删除过旧的消息，避免数据库不断增大。</li></ul><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>数据持久化不仅能提高用户体验，同时对于保证数据的安全性和完整性也至关重要。通过使用Core Data，我们可以为聊天应用提供一个强大、灵活且易于维护的数据存储方案。在聊天应用中实现了数据持久化之后，无论用户何时回到应用，都能够立即接入到他们离开时的状态，保持流畅的聊天体验。在下一小节中，我们将进一步探讨如何将我们的聊天应用与云服务（如CloudKit）整合，实现跨设备的数据同步功能。</p><p><strong>第5小节：网络请求和数据处理</strong></p><p>当我们在构建一个现代的聊天应用时，网络请求成为了一个核心部分，它负责从远程服务器获取数据以及将数据推送到服务器。在本小节中，我们将介绍如何在聊天应用中处理网络请求和数据。</p><h3 id="设计API接口"><a href="#设计API接口" class="headerlink" title="设计API接口"></a>设计API接口</h3><p>在开始编写代码之前，我们需要设计我们聊天应用所需的API接口。这些接口应包括：</p><ul><li>用户注册与登录</li><li>消息发送与接收</li><li>用户状态更新</li><li>好友列表和消息历史获取</li></ul><p>API设计应该遵循RESTful原则或者使用更现代的GraphQL。</p><h3 id="使用Swift的网络框架"><a href="#使用Swift的网络框架" class="headerlink" title="使用Swift的网络框架"></a>使用Swift的网络框架</h3><p>Swift提供了多种网络请求的方法，如<code>URLSession</code>，它是一个强大且灵活的网络通信框架。</p><ul><li><strong>创建网络请求</strong>：使用<code>URLRequest</code>构建请求，包括URL、HTTP方法（如GET、POST）、请求头和请求体。</li><li><strong>发送请求和接收响应</strong>：利用<code>URLSession</code>发起请求，并通过<code>URLSessionDataTask</code>处理回调。</li><li><strong>解析JSON数据</strong>：使用<code>JSONDecoder</code>将服务器返回的JSON数据解析成Swift的结构体。</li></ul><h3 id="异步和等待"><a href="#异步和等待" class="headerlink" title="异步和等待"></a>异步和等待</h3><p>SwiftUI 与 Swift 5.5 引入的 async&#x2F;await 一起，可以大大简化异步网络请求的处理。</p><ul><li><strong>异步函数</strong>：定义异步函数来发起网络请求，使用<code>await</code>关键字等待响应。</li><li><strong>错误处理</strong>：使用<code>do-catch</code>语句捕获并处理网络请求或数据解析中可能发生的错误。</li></ul><h3 id="数据模型和解析"><a href="#数据模型和解析" class="headerlink" title="数据模型和解析"></a>数据模型和解析</h3><p>定义数据模型来对应API返回的数据格式。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">User</span>: <span class="hljs-title class_">Codable</span> &#123;<br>    <span class="hljs-keyword">var</span> id: <span class="hljs-type">String</span><br>    <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Message</span>: <span class="hljs-title class_">Codable</span> &#123;<br>    <span class="hljs-keyword">var</span> senderId: <span class="hljs-type">String</span><br>    <span class="hljs-keyword">var</span> receiverId: <span class="hljs-type">String</span><br>    <span class="hljs-keyword">var</span> content: <span class="hljs-type">String</span><br>    <span class="hljs-keyword">var</span> timestamp: <span class="hljs-type">Date</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>使用<code>Codable</code>协议自动将JSON数据和模型进行映射。</p><h3 id="实时聊天功能"><a href="#实时聊天功能" class="headerlink" title="实时聊天功能"></a>实时聊天功能</h3><p>对于聊天应用来说，实时通讯是必不可少的。WebSocket 是一种在单个TCP连接上进行全双工通讯的协议。</p><ul><li><strong>使用WebSocket</strong>：通过<code>URLSessionWebSocketTask</code>来与服务器建立WebSocket连接。</li><li><strong>接收消息</strong>：监听WebSocket的消息事件来实时接收新消息。</li><li><strong>发送消息</strong>：发送消息通过WebSocket实时传递给其他用户。</li></ul><h3 id="网络状态监听"><a href="#网络状态监听" class="headerlink" title="网络状态监听"></a>网络状态监听</h3><p>考虑到网络状态可能时常变化，应用应能响应网络状态的改变。</p><ul><li><strong>使用Reachability</strong>：检测网络连接状态，根据网络状况提示用户或执行重连策略。</li><li><strong>网络指示器</strong>：提供用户界面反馈，例如当应用正在进行网络请求时显示加载指示器。</li></ul><h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>安全性是聊天应用中一个重要的议题。</p><ul><li><strong>使用HTTPS</strong>：确保所有的网络请求都通过安全的HTTP连接进行。</li><li><strong>身份验证</strong>：使用OAuth、JWT等机制来管理和验证用户身份。</li><li><strong>数据加密</strong>：对敏感数据进行加密，确保即使在传输过程中数据被截获也无法被解读。</li></ul><h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3><p>网络请求的测试至关重要。</p><ul><li><strong>单元测试</strong>：为网络请求编写单元测试，使用Mock对象来模拟网络响应。</li><li><strong>集成测试</strong>：确保网络请求与应用其他部分的整合运行无误。</li></ul><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>网络请求和数据处理是构建聊天应用的核心部分。利用Swift的现代编程特性和网络框架，我们可以有效地发送请求、接收响应、处理数据，并保证用户信息的安全性。在下一小节中，我们将讨论如何</p><p>实现跨平台的消息推送通知，这是提升用户体验的另一个关键点。</p><p><strong>第6小节：应用测试和发布准备</strong></p><p>在开发完一个应用后，进行彻底的测试并做好发布前的各种准备工作是至关重要的。这一步骤确保了你的应用能够在广泛发布之前，满足质量标准，减少可能的错误或问题，为最终用户提供良好的体验。</p><h3 id="应用测试"><a href="#应用测试" class="headerlink" title="应用测试"></a>应用测试</h3><p><strong>单元测试</strong>：为应用的每一个独立模块编写单元测试，验证逻辑的正确性。在聊天应用中，需要确保消息处理、用户认证、数据解析等核心功能的准确无误。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">import</span> XCTest<br><span class="hljs-keyword">@testable</span> <span class="hljs-keyword">import</span> ChatApp<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ChatAppTests</span>: <span class="hljs-title class_">XCTestCase</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">testMessageParsing</span>() &#123;<br>        <span class="hljs-keyword">let</span> json <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&#123; <span class="hljs-subst">\&quot;</span>senderId<span class="hljs-subst">\&quot;</span>: <span class="hljs-subst">\&quot;</span>1<span class="hljs-subst">\&quot;</span>, <span class="hljs-subst">\&quot;</span>receiverId<span class="hljs-subst">\&quot;</span>: <span class="hljs-subst">\&quot;</span>2<span class="hljs-subst">\&quot;</span>, <span class="hljs-subst">\&quot;</span>content<span class="hljs-subst">\&quot;</span>: <span class="hljs-subst">\&quot;</span>Hello<span class="hljs-subst">\&quot;</span> &#125;&quot;</span><br>        <span class="hljs-keyword">let</span> data <span class="hljs-operator">=</span> <span class="hljs-type">Data</span>(json.utf8)<br>        <span class="hljs-keyword">let</span> message <span class="hljs-operator">=</span> <span class="hljs-keyword">try?</span> <span class="hljs-type">JSONDecoder</span>().decode(<span class="hljs-type">Message</span>.<span class="hljs-keyword">self</span>, from: data)<br>        <span class="hljs-type">XCTAssertNotNil</span>(message)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>集成测试</strong>：检查应用中各个模块之间的交互是否正确。这包括用户界面流程的测试，确保视图控制器和视图模型间的交互按预期工作。</p><p><strong>性能测试</strong>：确保应用的性能达标。例如，消息加载和发送的速度要快，内存消耗要低。</p><p><strong>安全性测试</strong>：验证应用的安全措施，包括数据加密和身份验证流程。</p><h3 id="用户界面测试"><a href="#用户界面测试" class="headerlink" title="用户界面测试"></a>用户界面测试</h3><p><strong>UI测试</strong>：自动化测试用户界面，确保用户的交互行为如点击、滚动、输入等能够产生预期的结果。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">import</span> XCTest<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ChatAppUITests</span>: <span class="hljs-title class_">XCTestCase</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">testChatFlow</span>() &#123;<br>        <span class="hljs-keyword">let</span> app <span class="hljs-operator">=</span> <span class="hljs-type">XCUIApplication</span>()<br>        app.launch()<br>        <br>        <span class="hljs-keyword">let</span> messageTextField <span class="hljs-operator">=</span> app.textFields[<span class="hljs-string">&quot;messageTextField&quot;</span>]<br>        messageTextField.tap()<br>        messageTextField.typeText(<span class="hljs-string">&quot;Hello, World!&quot;</span>)<br>        <br>        <span class="hljs-keyword">let</span> sendButton <span class="hljs-operator">=</span> app.buttons[<span class="hljs-string">&quot;sendButton&quot;</span>]<br>        sendButton.tap()<br>        <br>        <span class="hljs-comment">// 验证消息是否显示在聊天界面上</span><br>        <span class="hljs-keyword">let</span> chatBubble <span class="hljs-operator">=</span> app.staticTexts[<span class="hljs-string">&quot;Hello, World!&quot;</span>]<br>        <span class="hljs-type">XCTAssertTrue</span>(chatBubble.exists)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>可访问性测试</strong>：确保应用支持VoiceOver等辅助功能，使得所有用户都能使用你的应用。</p><h3 id="发布前的准备"><a href="#发布前的准备" class="headerlink" title="发布前的准备"></a>发布前的准备</h3><p><strong>Beta测试</strong>：通过TestFlight或类似的服务，发布应用的测试版本，邀请用户参与beta测试。</p><p><strong>性能优化</strong>：回顾代码，查找并优化可能的性能瓶颈，如减少不必要的网络请求，优化图片加载。</p><p><strong>本地化</strong>：确保应用支持多语言，包括界面文本和用户内容的适当本地化。</p><p><strong>应用商店优化（ASO）</strong>：为了在应用商店中获得更好的曝光，优化应用的标题、描述、关键字和截图。</p><p><strong>隐私政策和用户协议</strong>：准备并审核应用的隐私政策和用户协议文档，确保符合法律法规和应用商店的要求。</p><p><strong>备份和恢复策略</strong>：确保应用支持数据备份和恢复功能，以便用户更换设备后可以恢复数据。</p><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>确保你的聊天应用在发布前通过了各种形式的测试，这包括了功能、性能、安全性和用户界面的测试。同时，完成发布前的各项准备工作，确保你的应用在上架后能够吸引用户并且避免法律风险。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;第1小节：应用结构规划&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在开发一个新的应用时，规划应用的结构是成功的关键。一个良好设计的应用结构可以提高代码的可维护性和扩展性，并使团队合作变得更加高效。本小节我们将讨论如何为我们的聊天应用进行结构规划。&lt;/p&gt;
&lt;h3 id</summary>
      
    
    
    
    <category term="SwiftUI" scheme="http://xuebusi.gitee.io/categories/SwiftUI/"/>
    
    
  </entry>
  
  <entry>
    <title>SwiftUI核心技术第14章测试与调试</title>
    <link href="http://xuebusi.gitee.io/2023/11/08/SwiftUI%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC14%E7%AB%A0%E6%B5%8B%E8%AF%95%E4%B8%8E%E8%B0%83%E8%AF%95/"/>
    <id>http://xuebusi.gitee.io/2023/11/08/SwiftUI%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC14%E7%AB%A0%E6%B5%8B%E8%AF%95%E4%B8%8E%E8%B0%83%E8%AF%95/</id>
    <published>2023-11-08T01:49:07.000Z</published>
    <updated>2024-03-17T06:12:01.380Z</updated>
    
    <content type="html"><![CDATA[<p><strong>第1小节：单元测试和UI测试</strong></p><p>在软件开发过程中，测试是确保应用质量的关键步骤。SwiftUI应用的测试主要分为单元测试和UI测试两种。单元测试确保代码逻辑的正确性，而UI测试确保用户界面的行为与期望一致。本节将详细介绍如何在SwiftUI中实施有效的单元测试和UI测试策略。</p><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>单元测试是在最小的代码单位级别上验证功能正确性的测试。在Swift中，单元测试通常是针对独立的函数或对象进行的。</p><h4 id="设计可测试的代码"><a href="#设计可测试的代码" class="headerlink" title="设计可测试的代码"></a>设计可测试的代码</h4><ul><li><strong>解耦和模块化</strong>：确保代码是松耦合和高内聚的，这样更容易编写测试。</li><li><strong>依赖注入</strong>：通过依赖注入可以在测试时替换实际的依赖，以实现更精确的测试。</li><li><strong>使用协议和Mock对象</strong>：定义接口并在测试中使用Mock对象来模拟真实对象。</li></ul><h4 id="编写单元测试"><a href="#编写单元测试" class="headerlink" title="编写单元测试"></a>编写单元测试</h4><ul><li><strong>XCTest框架</strong>：使用Xcode集成的XCTest框架编写测试用例。</li><li><strong>Assert函数</strong>：使用assert函数（如<code>XCTAssertTrue</code>, <code>XCTAssertEqual</code>等）验证预期结果。</li><li><strong>测试边界条件</strong>：确保测试边界情况和异常情况。</li></ul><h3 id="UI测试"><a href="#UI测试" class="headerlink" title="UI测试"></a>UI测试</h3><p>UI测试模拟用户与应用界面的交互，验证UI元素的存在性、状态和应用的响应性。</p><h4 id="配置UI测试环境"><a href="#配置UI测试环境" class="headerlink" title="配置UI测试环境"></a>配置UI测试环境</h4><ul><li><strong>使用XCTestUI框架</strong>：XCTestUI提供了一套工具用于编写UI测试。</li><li><strong>Accessibility标识</strong>：给UI元素设置Accessibility标识，以便测试脚本可以准确地定位它们。</li></ul><h4 id="编写UI测试脚本"><a href="#编写UI测试脚本" class="headerlink" title="编写UI测试脚本"></a>编写UI测试脚本</h4><ul><li><strong>记录UI交互</strong>：Xcode提供了UI测试录制功能，可以自动生成用户交互的基本代码。</li><li><strong>编写测试用例</strong>：基于录制的代码，编写完整的测试用例来验证特定的UI行为。</li><li><strong>断言验证</strong>：使用断言来验证UI状态是否符合预期。</li></ul><h3 id="测试最佳实践"><a href="#测试最佳实践" class="headerlink" title="测试最佳实践"></a>测试最佳实践</h3><ul><li><strong>持续集成（CI）</strong>：将测试集成到持续集成流程中，确保每次提交都通过测试。</li><li><strong>代码覆盖率</strong>：监控代码覆盖率，尽量使之覆盖所有的代码路径。</li><li><strong>性能测试</strong>：包含性能测试来验证关键功能的响应时间。</li><li><strong>定期回归测试</strong>：每次代码更新后进行回归测试，确保新改动没有引入新的错误。</li></ul><p>通过遵循上述方法，您可以为SwiftUI应用实施一套全面的测试策略，显著提高应用的质量和可靠性。记得，测试是一个持续的过程，应随着应用的迭代而不断更新和完善。</p><p><strong>第2小节：使用Xcode调试</strong></p><p>调试是发现、定位并修正编程错误过程。Xcode提供了强大的调试工具，它们可以帮助开发者理解代码在运行时的行为，并有效地找到并解决问题。在这一小节中，我们将深入探讨如何使用Xcode来调试SwiftUI应用。</p><h3 id="断点（Breakpoints）"><a href="#断点（Breakpoints）" class="headerlink" title="断点（Breakpoints）"></a>断点（Breakpoints）</h3><p>断点是调试中的一个核心概念，它允许你在特定的代码行暂停代码执行，以便你可以检查此时的变量状态和应用逻辑。</p><h4 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a>设置断点</h4><ul><li><strong>标准断点</strong>：点击Xcode编辑器左侧的边栏，即可在代码行旁设置断点。</li><li><strong>条件断点</strong>：断点可设置条件，使之仅在满足特定条件时才触发。</li><li><strong>动作断点</strong>：在触发断点时自动执行一个特定的动作，如打印一条日志信息。</li></ul><h3 id="调试面板"><a href="#调试面板" class="headerlink" title="调试面板"></a>调试面板</h3><p>当代码在断点处停止时，Xcode的调试面板会提供多种工具来帮助你理解代码的状态。</p><ul><li><strong>变量查看器</strong>：显示当前作用域内所有变量的值。</li><li><strong>调用堆栈查看器</strong>：查看函数调用堆栈，了解当前代码执行的路径。</li><li><strong>内存检查器</strong>：检查应用的内存使用情况，发现潜在的内存泄露。</li></ul><h3 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h3><p>使用调试面板的控件来控制应用的执行流。</p><ul><li><strong>继续执行</strong>（Continue）：继续执行代码直到下一个断点。</li><li><strong>逐步执行</strong>（Step Over）：执行当前行，并在下一行停止。</li><li><strong>深入执行</strong>（Step Into）：如果当前行调用了一个函数，进入该函数内部。</li><li><strong>跳出执行</strong>（Step Out）：从当前函数跳出，回到上一层函数。</li></ul><h3 id="LLDB调试器"><a href="#LLDB调试器" class="headerlink" title="LLDB调试器"></a>LLDB调试器</h3><p>LLDB是Xcode使用的底层调试器。你可以使用LLDB控制台来执行更复杂的调试命令。</p><ul><li><strong>打印变量</strong>：使用<code>po</code>命令打印变量的描述。</li><li><strong>设置变量值</strong>：直接在调试会话中修改变量的值。</li><li><strong>执行表达式</strong>：使用<code>expr</code>命令执行代码表达式。</li></ul><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>Xcode的Instrument工具可以用来分析应用的性能问题。</p><ul><li><strong>时间分析器</strong>：查看CPU的使用情况以及代码执行的时间。</li><li><strong>内存分析器</strong>：分析应用的内存使用模式和潜在的内存泄露。</li><li><strong>网络分析器</strong>：检查应用的网络请求和响应。</li></ul><h3 id="Xcode调试技巧"><a href="#Xcode调试技巧" class="headerlink" title="Xcode调试技巧"></a>Xcode调试技巧</h3><ul><li><strong>视图调试</strong>（View Debugging）：可视化地检查UI元素的布局和属性。</li><li><strong>条件表达式</strong>：使用条件表达式来精确控制断点的触发时机。</li><li><strong>符号断点</strong>：在特定的系统函数或方法调用时触发断点。</li></ul><p>通过熟练使用Xcode的调试工具，你将能够更快地发现问题所在，并对SwiftUI应用进行高效的故障排查。记得，耐心和细心是调试过程中的良师益友，不断实践将使你成为更高效的开发者。</p><p><strong>第3小节：预览与条件编译</strong></p><p>SwiftUI 的预览功能是其最具革命性的特点之一，它允许开发者在不运行整个应用的情况下快速迭代和测试其视图。条件编译则是一种控制代码在不同环境下如何编译的方法。在这一小节中，我们将讨论如何使用这两个强大的功能来提高开发效率和代码质量。</p><h3 id="使用SwiftUI预览"><a href="#使用SwiftUI预览" class="headerlink" title="使用SwiftUI预览"></a>使用SwiftUI预览</h3><p>SwiftUI的<code>Canvas</code>视图提供了一个实时预览，它显示了你的用户界面组件在实际应用中的外观和表现。以下是如何高效使用SwiftUI预览的指南：</p><ul><li><strong>基本预览</strong>：每个SwiftUI视图都可以有一个或多个预览。通过创建<code>PreviewProvider</code>的实现，你可以快速看到你的UI更改的效果。</li><li><strong>多设备预览</strong>：在预览提供者中，你可以设置多个预览设备和配置，同时查看在不同设备和方向上的界面表现。</li><li><strong>动态预览</strong>：通过添加预览参数，如不同的字体大小、颜色主题（包括Dark Mode）和辅助功能设置，你可以查看你的视图在不同用户设置下的表现。</li><li><strong>交互式预览</strong>：你可以在Canvas中与UI交互，例如点击按钮或切换开关，这有助于测试视图的响应性。</li><li><strong>实时数据预览</strong>：将模型对象注入到预览中，使你可以用实际数据来展示和测试视图。</li></ul><h3 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h3><p>在Swift中，可以使用编译配置来为不同的编译目标提供不同的代码路径。这对于处理开发和生产环境的差异至关重要。</p><ul><li><strong>编译标志</strong>：使用<code>#if</code>、<code>#elseif</code>和<code>#endif</code>指令来控制哪些代码块应被编译。这常用于开发和生产环境的日志记录和配置。</li><li><strong>平台特定代码</strong>：可以检查<code>os(macOS)</code>、<code>os(iOS)</code>等条件，来编写只在特定操作系统上编译的代码。</li><li><strong>功能特性检查</strong>：使用<code>canImport(module)</code>来确定是否可以导入一个特定的模块，这在跨多个Swift版本或平台时很有用。</li><li><strong>调试与发布区分</strong>：使用<code>DEBUG</code>标识符来保证某些代码仅在调试构建中编译，而在发布构建中不会包含这些代码。</li></ul><h3 id="组合预览与条件编译"><a href="#组合预览与条件编译" class="headerlink" title="组合预览与条件编译"></a>组合预览与条件编译</h3><p>将SwiftUI预览和条件编译相结合，可以创建更为强大和灵活的开发环境。</p><ul><li><strong>预览特定配置</strong>：为不同的预览目标配置不同的环境变量或者模拟数据。</li><li><strong>隐藏调试UI</strong>：使用条件编译隐藏调试时用到的UI元素，以免它们出现在生产版本的应用中。</li></ul><p>通过利用这些工具，你可以确保在开发过程中，你的应用表现出色，并且在上线前能有效地去除所有不必要的测试代码。这样的实践不仅可以提高代码的质量，也能显著减少调试和测试时的工作量。预览和条件编译应当成为每一个SwiftUI开发者工具箱中的核心部分。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;第1小节：单元测试和UI测试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在软件开发过程中，测试是确保应用质量的关键步骤。SwiftUI应用的测试主要分为单元测试和UI测试两种。单元测试确保代码逻辑的正确性，而UI测试确保用户界面的行为与期望一致。本节将详细介绍如何在S</summary>
      
    
    
    
    <category term="SwiftUI" scheme="http://xuebusi.gitee.io/categories/SwiftUI/"/>
    
    
  </entry>
  
  <entry>
    <title>SwiftUI核心技术第13章性能优化</title>
    <link href="http://xuebusi.gitee.io/2023/11/08/SwiftUI%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC13%E7%AB%A0%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://xuebusi.gitee.io/2023/11/08/SwiftUI%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC13%E7%AB%A0%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</id>
    <published>2023-11-08T01:43:56.000Z</published>
    <updated>2024-03-17T06:11:58.265Z</updated>
    
    <content type="html"><![CDATA[<p><strong>第13章：性能优化</strong></p><p><strong>第1小节：诊断和解决性能问题</strong></p><p>性能优化是软件开发中的关键步骤，特别是对于那些要求快速响应和流畅体验的应用。性能问题可能是由许多因素造成的，包括但不限于内存泄漏、过度渲染、网络延迟或者不高效的数据结构和算法。有效的性能优化往往从准确诊断问题开始。</p><h3 id="1-性能评估"><a href="#1-性能评估" class="headerlink" title="1. 性能评估"></a>1. 性能评估</h3><p>在深入代码优化之前，首先要进行一个全面的性能评估。使用Xcode自带的Instrument工具可以帮助检测应用的CPU使用率、内存泄漏、能耗和网络性能等。</p><h3 id="2-识别瓶颈"><a href="#2-识别瓶颈" class="headerlink" title="2. 识别瓶颈"></a>2. 识别瓶颈</h3><p>在性能评估之后，需要确定应用中的性能瓶颈。通过分析Instruments的报告，可以识别出CPU和内存的高消耗区域。对于图形密集型的应用，可能还需要检查GPU的使用情况。</p><h3 id="3-代码分析与调优"><a href="#3-代码分析与调优" class="headerlink" title="3. 代码分析与调优"></a>3. 代码分析与调优</h3><p>一旦确定了瓶颈，就可以开始针对性的代码优化了。这可能包括：</p><ul><li><strong>优化算法和数据结构</strong>：改进或替换那些复杂度高的算法和数据结构。</li><li><strong>减少计算量</strong>：避免不必要的计算，特别是在渲染和布局的过程中。</li><li><strong>异步执行</strong>：使用异步编程模式来避免UI线程阻塞。</li><li><strong>资源优化</strong>：优化图像和资源的加载，确保它们是压缩的且以正确的尺寸使用。</li></ul><h3 id="4-内存管理"><a href="#4-内存管理" class="headerlink" title="4. 内存管理"></a>4. 内存管理</h3><p>内存问题，尤其是内存泄漏，是性能问题的常见原因。使用ARC（自动引用计数）应该是管理内存的首选方法，但开发者仍需避免循环引用，及时释放不再使用的对象。</p><h3 id="5-网络优化"><a href="#5-网络优化" class="headerlink" title="5. 网络优化"></a>5. 网络优化</h3><p>应用的响应时间很大程度上受网络状况的影响。通过优化API调用，使用缓存和数据预加载技术，可以显著提高性能。</p><h3 id="6-测试与监控"><a href="#6-测试与监控" class="headerlink" title="6. 测试与监控"></a>6. 测试与监控</h3><ul><li><strong>单元测试</strong>：编写单元测试来确保代码的效率。</li><li><strong>性能测试</strong>：模拟高负载情况下应用的表现。</li><li><strong>监控</strong>：发布应用后，继续监控其性能，并根据用户反馈和数据进行调整。</li></ul><h3 id="7-优化策略"><a href="#7-优化策略" class="headerlink" title="7. 优化策略"></a>7. 优化策略</h3><ul><li><strong>延迟加载</strong>：只有当需要时才加载数据或执行计算。</li><li><strong>预计算和缓存</strong>：预计算重复计算的结果并进行缓存。</li><li><strong>复用和回收</strong>：在可能的情况下复用对象和视图。</li></ul><h3 id="8-持续优化"><a href="#8-持续优化" class="headerlink" title="8. 持续优化"></a>8. 持续优化</h3><p>性能优化不是一次性的任务，而是一个持续的过程。随着应用的发展和用户基础的增长，应持续关注性能指标，并进行相应的优化。</p><p>通过遵循上述步骤，开发者可以诊断出性能问题的根本原因，并采取相应的措施来解决问题。从用户体验的角度出发，提升应用的性能将直接影响到应用的成功与否。</p><p><strong>第2小节：延迟加载和内存管理</strong></p><p>在移动应用开发中，高效的内存使用是至关重要的。用户设备的内存资源有限，如果应用消耗过多内存，会影响用户体验，并可能导致应用被系统终止。延迟加载（Lazy Loading）和精心的内存管理是优化应用性能的关键策略。</p><h3 id="延迟加载（Lazy-Loading）"><a href="#延迟加载（Lazy-Loading）" class="headerlink" title="延迟加载（Lazy Loading）"></a>延迟加载（Lazy Loading）</h3><p>延迟加载是一种在需要时才加载数据或对象到内存的策略。这种方法可以减少应用的启动时间，降低内存消耗，提高整体性能。</p><h4 id="实施延迟加载的策略："><a href="#实施延迟加载的策略：" class="headerlink" title="实施延迟加载的策略："></a>实施延迟加载的策略：</h4><ol><li><strong>按需实例化</strong>：仅当确实需要显示或处理某个对象时，才创建该对象的实例。</li><li><strong>视图渲染优化</strong>：对于列表和滚动视图，可以使用如SwiftUI的<code>LazyVStack</code>和<code>LazyHStack</code>，这些组件能确保只有那些在屏幕上的视图才会被加载和渲染。</li><li><strong>数据获取</strong>：对于网络请求，可以实现预加载和按页面分段加载数据，避免一次性加载大量数据。</li><li><strong>资源管理</strong>：对图像和视频等大型文件进行按需加载，并考虑实现缓存机制。</li></ol><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><p>良好的内存管理可以避免内存泄漏和过度消耗，从而提高应用性能。</p><h4 id="内存管理的关键点："><a href="#内存管理的关键点：" class="headerlink" title="内存管理的关键点："></a>内存管理的关键点：</h4><ol><li><strong>自动引用计数（ARC）</strong>：理解并正确使用ARC是必要的，避免循环引用和内存泄漏。</li><li><strong>弱引用和无主引用</strong>：在闭包和委托模式中使用<code>weak</code>和<code>unowned</code>关键字来避免强引用循环。</li><li><strong>资源释放</strong>：及时释放不再需要的对象，特别是在处理大型对象和文件时。</li><li><strong>内存警告处理</strong>：正确处理内存警告，释放可以释放的资源，避免应用被系统终止。</li><li><strong>内存分析工具</strong>：使用Xcode的Memory Graph Debugger和Leaks工具定期检查内存问题。</li></ol><h4 id="实施内存管理的技术："><a href="#实施内存管理的技术：" class="headerlink" title="实施内存管理的技术："></a>实施内存管理的技术：</h4><ul><li><strong>使用<code>deinit</code>进行清理</strong>：当对象被销毁时，确保释放它持有的资源。</li><li><strong>缓存策略</strong>：智能地实施缓存策略，既要提高数据访问的效率，又要避免过度消耗内存。</li><li><strong>内存池</strong>：对于频繁创建和销毁的小对象，可以使用内存池来管理。</li><li><strong>对象复用</strong>：例如，在UITableView中复用cell，而不是每次都创建新的cell。</li></ul><p>通过延迟加载和内存管理，开发者可以显著提高应用的性能和用户体验。理解和正确实现这些概念将使应用在不同设备和操作系统上更加稳定和流畅。</p><p><strong>第3小节：视图更新效率优化</strong></p><p>在现代移动应用中，保持流畅的用户界面至关重要。在SwiftUI中，视图更新的效率直接影响到用户体验。这一小节将探讨如何优化视图更新的效率。</p><h3 id="理解视图更新机制"><a href="#理解视图更新机制" class="headerlink" title="理解视图更新机制"></a>理解视图更新机制</h3><p>首先，我们需要理解SwiftUI是如何处理视图更新的。SwiftUI视图是声明式的，这意味着你定义的是视图的期望状态，而非状态变化的过程。当视图的状态发生变化时，SwiftUI会重新计算视图的body属性。</p><h4 id="管理状态变化"><a href="#管理状态变化" class="headerlink" title="管理状态变化"></a>管理状态变化</h4><ul><li><strong>最小化状态变化</strong>：确保只有真正需要更新的视图状态时才进行更改。</li><li><strong>精确的观察</strong>：使用<code>@State</code>、<code>@Binding</code>、<code>@ObservedObject</code>和<code>@EnvironmentObject</code>智能地观察模型的变化。</li></ul><h3 id="避免不必要的视图更新"><a href="#避免不必要的视图更新" class="headerlink" title="避免不必要的视图更新"></a>避免不必要的视图更新</h3><p>不必要的视图重建会浪费资源并降低性能。</p><h4 id="实现策略："><a href="#实现策略：" class="headerlink" title="实现策略："></a>实现策略：</h4><ol><li>**合理使用<code>Equatable</code>**：对于自定义视图，实现<code>Equatable</code>协议并在<code>shouldUpdate</code>中提供差异对比，以避免相同状态时的重建。</li><li><strong>条件式视图更新</strong>：通过逻辑判断确保只有当状态确实改变时才更新视图。</li><li><strong>局部更新</strong>：使用<code>.id()</code>修饰符或其他方式来提示SwiftUI哪些部分的视图是稳定的，不需要重建。</li></ol><h3 id="高效的数据流"><a href="#高效的数据流" class="headerlink" title="高效的数据流"></a>高效的数据流</h3><p>数据流向视图的方式也影响更新效率。</p><h4 id="优化数据流的方法："><a href="#优化数据流的方法：" class="headerlink" title="优化数据流的方法："></a>优化数据流的方法：</h4><ul><li><strong>使用<code>@State</code>进行本地状态管理</strong>：对于视图私有的状态，使用<code>@State</code>来进行本地化管理。</li><li><strong>利用<code>@ObservedObject</code>和<code>@EnvironmentObject</code>共享状态</strong>：对于需要在多个视图间共享的状态，可以使用这些属性包装器。</li></ul><h3 id="性能分析工具"><a href="#性能分析工具" class="headerlink" title="性能分析工具"></a>性能分析工具</h3><p>使用Xcode提供的性能分析工具来查找性能瓶颈。</p><h4 id="分析方法："><a href="#分析方法：" class="headerlink" title="分析方法："></a>分析方法：</h4><ol><li><strong>时间分析器</strong>：利用Xcode的时间分析器查看哪些部分的代码耗时最多。</li><li><strong>SwiftUI预览性能检查</strong>：在SwiftUI预览中测试视图更新，观察是否有延迟。</li></ol><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><ul><li><strong>延迟复杂计算</strong>：对于复杂的视图计算，可以考虑将其推迟到视图显示之后的背景线程。</li><li><strong>异步图片加载</strong>：对于图片和其他媒体资源，使用异步加载以避免阻塞UI线程。</li><li><strong>智能组件分割</strong>：将复杂视图拆分成更小的、可以独立更新的组件。</li></ul><p>通过以上策略，可以确保SwiftUI应用中的视图更新是高效的，从而提供流畅的用户体验。记住，性能调优是一个持续的过程，定期的性能评测和分析是非常必要的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;第13章：性能优化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第1小节：诊断和解决性能问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;性能优化是软件开发中的关键步骤，特别是对于那些要求快速响应和流畅体验的应用。性能问题可能是由许多因素造成的，包括但不限于内存泄漏</summary>
      
    
    
    
    <category term="SwiftUI" scheme="http://xuebusi.gitee.io/categories/SwiftUI/"/>
    
    
  </entry>
  
  <entry>
    <title>SwiftUI核心技术第12章Dark Mode和Accessibility</title>
    <link href="http://xuebusi.gitee.io/2023/11/08/SwiftUI%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC12%E7%AB%A0Dark-Mode%E5%92%8CAccessibility/"/>
    <id>http://xuebusi.gitee.io/2023/11/08/SwiftUI%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC12%E7%AB%A0Dark-Mode%E5%92%8CAccessibility/</id>
    <published>2023-11-08T01:33:25.000Z</published>
    <updated>2024-03-17T06:11:54.398Z</updated>
    
    <content type="html"><![CDATA[<p><strong>第12章：Dark Mode和Accessibility</strong></p><p><strong>第1小节：支持暗黑模式</strong></p><p>随着用户对于在不同光照条件下使用设备的需求增加，暗黑模式（Dark Mode）成为了现代应用设计不可或缺的一部分。它不仅有助于减少在低光环境下使用设备时的眼睛疲劳，还能为电池续航带来好处，特别是在OLED屏幕上。此外，暗黑模式还能为用户提供一个更为集中和减少分心的视觉环境。</p><h3 id="理解暗黑模式"><a href="#理解暗黑模式" class="headerlink" title="理解暗黑模式"></a>理解暗黑模式</h3><ol><li><p><strong>色彩转换</strong> - 暗黑模式不仅仅是将背景设置为黑色和文本设置为白色那么简单。它涉及到色彩配色的整体调整，以确保可读性、可访问性和品牌一致性。</p></li><li><p><strong>图层和深度</strong> - 暗色背景提升了颜色对比，这意味着阴影和高亮可以用来模拟层次感和深度。</p></li><li><p><strong>用户控制</strong> - 用户应当能够选择在明亮或暗黑模式下使用应用，或让应用跟随系统设置自动切换。</p></li></ol><h3 id="设计指南"><a href="#设计指南" class="headerlink" title="设计指南"></a>设计指南</h3><ol><li><p><strong>颜色主题</strong> - 定义一套色彩主题，包括在暗黑模式下使用的色彩。应使用较亮的色调和透明度来增加层次感，同时避免使用纯白色，以减少对比度导致的刺眼感。</p></li><li><p><strong>组件和控件</strong> - 确保所有UI组件和控件在暗黑模式下都是可见的，并且它们的状态（如激活、禁用）在两种模式下都清晰。</p></li><li><p><strong>图片和媒体</strong> - 对于暗黑模式，应考虑使用较暗的图片和插图，或者为图片添加蒙版或过滤器，以适应暗背景。</p></li><li><p><strong>文本对比度</strong> - 文本应当足够对比，以确保在暗背景下的可读性。对于文本阴影和轮廓也应进行调整。</p></li></ol><h3 id="技术实现"><a href="#技术实现" class="headerlink" title="技术实现"></a>技术实现</h3><ol><li><p><strong>Asset Catalogs</strong> - 在Xcode的Asset Catalogs中，可以为每种颜色定义亮色和暗色两个版本。</p></li><li><p><strong>CSS支持</strong> - 在Web内容中，可以使用CSS的<code>prefers-color-scheme</code>查询来为网页添加暗黑模式支持。</p></li><li><p><strong>SwiftUI</strong> - 在SwiftUI中，可以通过<code>.environment(\.colorScheme, .dark)</code>为预览添加暗黑模式的支持。对于动态颜色，可以使用<code>Color</code>结构体内置的暗黑模式适配。</p></li><li><p><strong>UIKit</strong> - 在UIKit中，可以使用<code>traitCollection.userInterfaceStyle</code>来检查当前的界面风格，并在需要时调整UI元素的样式。</p></li></ol><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><ol><li><p><strong>测试</strong> - 在两种模式下都对应用进行全面的测试，确保UI元素的可见性和功能的可用性。</p></li><li><p><strong>用户设置</strong> - 提供设置选项，允许用户根据个人喜好切换模式。</p></li><li><p><strong>跟随系统</strong> - 默认情况下，应用应当跟随系统的暗黑模式设置，以保持用户体验的一致性。</p></li><li><p><strong>节能考量</strong> - 利用暗黑模式的节能优势，在OLED屏幕上通过使用更多真正的黑色来减少能耗。</p></li><li><p><strong>无障碍</strong> - 确保暗黑模</p></li></ol><p>式下的色彩对比满足无障碍标准，以便色弱和视力障碍用户也能舒适使用。</p><p>通过以上的设计和技术实现指南，开发者可以为其应用成功地集成暗黑模式，不仅提高了应用的美观性，同时也照顾到了用户的实际使用需求和舒适度。</p><p><strong>第2小节：辅助功能的最佳实践</strong></p><p>辅助功能（Accessibility）是确保所有用户，包括那些有视力、听力、运动或学习障碍的人，能够有效使用你的应用的关键组成部分。对于应用开发者来说，这不仅仅是一项法律义务或道德责任，更是一种设计上的优秀实践，它能够扩大应用的潜在用户群体，并提升用户体验。</p><h3 id="认识辅助功能的范畴"><a href="#认识辅助功能的范畴" class="headerlink" title="认识辅助功能的范畴"></a>认识辅助功能的范畴</h3><ol><li><p><strong>多感官接入</strong> - 保证信息的传递不仅限于一种感官，例如，对于视觉信息，提供文本描述或声音解释。</p></li><li><p><strong>易用性</strong> - 确保应用的操作简单明了，尤其是对于运动障碍用户，考虑到触摸目标的大小和屏幕的可达性。</p></li><li><p><strong>可见性</strong> - 包含字体大小的调整、高对比度模式以及颜色不是传达重要信息的唯一方式。</p></li><li><p><strong>认知考虑</strong> - 设计简洁、一致的界面，减少认知负担，特别是为了那些有认知障碍的用户。</p></li></ol><h3 id="设计指南-1"><a href="#设计指南-1" class="headerlink" title="设计指南"></a>设计指南</h3><ol><li><p><strong>文本可读性</strong> - 提供文本大小调整的功能，支持系统级别的“辅助功能”设置。</p></li><li><p><strong>高对比度</strong> - 提供高对比度主题或模式，辅以清晰的字体，帮助视觉障碍用户更好地识别内容。</p></li><li><p><strong>颜色盲友好</strong> - 设计UI时不要完全依赖颜色来区分元素或传达信息，使用图形符号或标签作为辅助。</p></li><li><p><strong>标签和说明</strong> - 所有的交互控件都应该有清晰的标签，辅以适当的声音或触觉反馈。</p></li><li><p><strong>语音控制</strong> - 支持通过语音命令进行控制，为那些无法使用传统输入设备的用户提供便利。</p></li></ol><h3 id="技术实现-1"><a href="#技术实现-1" class="headerlink" title="技术实现"></a>技术实现</h3><ol><li><p><strong>VoiceOver&#x2F;Speak Screen</strong> - 确保SwiftUI或UIKit组件正确实现了辅助功能标签和行为，以便VoiceOver能够读取屏幕上的内容。</p></li><li><p><strong>动态字体大小</strong> - 使用<code>UIFont.preferredFont(forTextStyle:)</code>和SwiftUI中的<code>.font(.system(size:))</code>来响应用户的字体大小设置。</p></li><li><p><strong>UIAccessibility协议</strong> - 通过实现相关的UIAccessibility协议来自定义非标准UI组件的辅助功能行为。</p></li><li><p><strong>辅助功能快捷方式</strong> - 通过设置快捷方式让用户能够快速访问常用的辅助功能。</p></li></ol><h3 id="最佳实践-1"><a href="#最佳实践-1" class="headerlink" title="最佳实践"></a>最佳实践</h3><ol><li><p><strong>持续测试</strong> - 在开发过程中，经常使用辅助功能进行测试，确保所有用户在使用应用时的体验一致。</p></li><li><p><strong>社群参与</strong> - 与残障社群合作，获取真实的反馈，并根据这些反馈改进产品。</p></li><li><p><strong>遵循标准</strong> - 遵循WCAG（Web Content Accessibility Guidelines）等国际标准来设计和开发应用。</p></li><li><p><strong>教育和文档</strong> - 提供有关如何使用应用中辅助功能的文档或视频教程。</p></li><li><p><strong>UI测试和自动化</strong> - 利用自动化测试框架来验证辅助功能的实现，确保在应用更新后功能依然可用。</p></li></ol><p>通过实施这些最</p><p>佳实践，开发者不仅能够提供一个包容性更强的应用体验，同时也能满足日益增长的多样化用户需求，构建起更加广泛的用户基础。</p><p><strong>第3小节：动态字体与国际化</strong></p><p>设计一个能够轻松适应不同语言和区域设置的用户界面，以及支持动态字体大小调整，是为了确保应用能够覆盖更广泛的用户群体，特别是那些有特定阅读需求的用户。</p><h3 id="动态字体的重要性"><a href="#动态字体的重要性" class="headerlink" title="动态字体的重要性"></a>动态字体的重要性</h3><p>动态字体允许用户根据自己的视力需求来调整字体的大小。这对于那些需要辅助设备阅读的用户尤为重要。</p><h3 id="实现动态字体"><a href="#实现动态字体" class="headerlink" title="实现动态字体"></a>实现动态字体</h3><ol><li><p><strong>使用系统字体尺寸</strong> - 利用系统提供的字体大小，如在SwiftUI中使用<code>.font(.system(size:))</code>。</p></li><li><p><strong>响应用户设置</strong> - 应用应该能够响应并遵循用户的辅助功能设置，比如“更大字体”选项。</p></li><li><p><strong>字体可伸缩性</strong> - 保证应用的布局可以适应不同的字体大小而不会破坏界面设计。</p></li><li><p><strong>自定义字体的辅助功能</strong> - 如果使用自定义字体，确保它们能够与系统的辅助功能设置兼容，如使用<code>UIFontMetrics</code>来调整。</p></li></ol><h3 id="国际化的挑战"><a href="#国际化的挑战" class="headerlink" title="国际化的挑战"></a>国际化的挑战</h3><p>国际化不仅仅是将文本翻译成不同的语言，还需要考虑到文化差异、布局方向（例如从右到左的语言）、日期和时间格式以及货币单位。</p><h3 id="实现国际化"><a href="#实现国际化" class="headerlink" title="实现国际化"></a>实现国际化</h3><ol><li><p><strong>本地化字符串</strong> - 使用本地化字符串文件（<code>.strings</code>）和键值对来管理应用中的文本。</p></li><li><p><strong>自适应布局</strong> - 确保UI能够适应不同的文本长度和布局方向。</p></li><li><p><strong>日期和数字格式</strong> - 使用<code>DateFormatter</code>和<code>NumberFormatter</code>来处理日期和数字的本地化格式。</p></li><li><p><strong>资源的国际化</strong> - 包括图像等资源的国际化，确保它们在不同文化中同样适用。</p></li></ol><h3 id="最佳实践-2"><a href="#最佳实践-2" class="headerlink" title="最佳实践"></a>最佳实践</h3><ol><li><p><strong>全面测试</strong> - 在不同的语言和辅助功能设置下测试应用，确保所有功能正常工作。</p></li><li><p><strong>持续的本地化和国际化</strong> - 让本地化和国际化成为开发流程的一部分，不断更新和完善。</p></li><li><p><strong>伪本地化测试</strong> - 使用伪本地化来测试应用的布局是否能够适应文字长度的变化。</p></li><li><p><strong>文化敏感性</strong> - 在设计和开发应用时，考虑到不同文化背景下的用户需求和习俗。</p></li><li><p><strong>动态字体和布局测试</strong> - 使用Xcode中的辅助功能检查器来预览应用在不同字体大小下的表现。</p></li></ol><p>通过实施这些策略，开发者可以确保他们的应用不仅在不同地区和文化中使用无障碍，而且可以为所有用户提供一个更加个性化和易于使用的体验。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;第12章：Dark Mode和Accessibility&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第1小节：支持暗黑模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;随着用户对于在不同光照条件下使用设备的需求增加，暗黑模式（Dark Mode）成为了现代应用设计</summary>
      
    
    
    
    <category term="SwiftUI" scheme="http://xuebusi.gitee.io/categories/SwiftUI/"/>
    
    
  </entry>
  
  <entry>
    <title>SwiftUI核心技术第11章适配多平台</title>
    <link href="http://xuebusi.gitee.io/2023/11/08/SwiftUI%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC11%E7%AB%A0%E9%80%82%E9%85%8D%E5%A4%9A%E5%B9%B3%E5%8F%B0/"/>
    <id>http://xuebusi.gitee.io/2023/11/08/SwiftUI%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC11%E7%AB%A0%E9%80%82%E9%85%8D%E5%A4%9A%E5%B9%B3%E5%8F%B0/</id>
    <published>2023-11-08T01:31:14.000Z</published>
    <updated>2024-03-17T06:11:51.180Z</updated>
    
    <content type="html"><![CDATA[<p><strong>第11章：适配多平台</strong></p><p><strong>第1小节：Catalyst：从iOS到macOS</strong></p><p>随着Apple推出Project Catalyst，现在开发者可以更加轻松地将iOS应用带到macOS平台。这一技术允许一个单一的代码库运行在iPad和Mac上，极大地简化了多平台支持的开发过程。在这一小节，我们将讨论如何使用Catalyst来适配你的iOS应用到macOS。</p><h3 id="Catalyst基础"><a href="#Catalyst基础" class="headerlink" title="Catalyst基础"></a>Catalyst基础</h3><p>Catalyst是Apple提供的一套工具和API，使得开发者可以用几乎同样的代码在Mac上运行iPad应用。这不仅减少了开发和维护成本，同时也保持了用户在iOS和macOS平台间的一致体验。</p><h3 id="启用Catalyst"><a href="#启用Catalyst" class="headerlink" title="启用Catalyst"></a>启用Catalyst</h3><p>在Xcode项目中启用Catalyst非常简单。首先打开你的项目设置，在Targets中选择你的iPad应用。然后，在General选项卡中，勾选“Mac”复选框来启用Mac支持。</p><h3 id="调整界面和布局"><a href="#调整界面和布局" class="headerlink" title="调整界面和布局"></a>调整界面和布局</h3><p>macOS和iOS在用户界面和交互上有所不同。因此，即使是通过Catalyst运行在Mac上的iOS应用，也需要进行一些调整来优化用户体验。</p><ul><li><strong>窗口和视图尺寸</strong>：Mac应用通常拥有更大的窗口和可调整的大小，你需要确保你的界面能够灵活地适应不同尺寸。</li><li><strong>菜单和快捷键</strong>：Mac用户习惯于使用顶部菜单栏和快捷键来执行操作。通过Catalyst，你可以为你的应用添加Mac风格的菜单和响应键盘快捷键。</li><li><strong>交互方式</strong>：Mac应用通常使用鼠标或触控板，而不是触摸屏。你需要考虑这一点来调整你的应用交互方式。</li></ul><h3 id="优化代码和资源"><a href="#优化代码和资源" class="headerlink" title="优化代码和资源"></a>优化代码和资源</h3><p>为了在Mac上提供最佳体验，你可能需要根据平台调整代码和资源。</p><ul><li><strong>条件编译</strong>：使用<code>#if targetEnvironment(macCatalyst)</code>来条件性地编译只在Mac上运行的代码。</li><li><strong>资源适配</strong>：可能需要提供更高分辨率的图片或者调整用户界面元素来适应Mac的显示器。</li></ul><h3 id="调试和测试"><a href="#调试和测试" class="headerlink" title="调试和测试"></a>调试和测试</h3><p>在将iOS应用转移到Mac时，详细的调试和测试是必不可少的。你需要确保应用在Mac上的表现同样稳定，并提供流畅的用户体验。</p><ul><li><strong>在Mac上运行和调试</strong>：就像在iOS设备上一样，在Xcode中选择Mac作为目标设备，运行和调试你的应用。</li><li><strong>适配性测试</strong>：对于不同的窗口尺寸和屏幕分辨率进行测试，确保布局和界面元素都能正确显示和响应。</li></ul><h3 id="发布和分发"><a href="#发布和分发" class="headerlink" title="发布和分发"></a>发布和分发</h3><p>当你的应用通过Catalyst适配完成后，你可以通过Mac App Store将其发布给全球的用户。这一流程类似于iOS应用的发布，但需要注意的是，你可能需要提供额外的营销材料，如屏幕截图和描述，来适应Mac App Store的展示方式。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>Catalyst提供了一个强大的桥梁，让开发者能够将iOS应用无缝迁移到Mac平台。这一过程需要细致的界面调整、代码优化以及充分的测试，但最终可以极大地拓宽你的应用市场，并为用户提供跨平台的统一体验。随着技术的发展，Catalyst将继续发展，为开发者和用户带来更多便利。</p><p><strong>第2小节：watchOS特有的UI组件</strong></p><p>watchOS为Apple Watch提供了一个独特的操作系统平台，它的设计重点在于快速查看信息和简洁交互。由于屏幕尺寸有限，watchOS提供了一些专门的UI组件，以满足特定的用户体验需求。在这一小节，我们将探讨watchOS的一些特有UI组件及其设计和实现。</p><h3 id="WKInterfaceController"><a href="#WKInterfaceController" class="headerlink" title="WKInterfaceController"></a>WKInterfaceController</h3><p><code>WKInterfaceController</code>是watchOS app中视图控制器的基类，用于管理界面。与iOS的<code>UIViewController</code>不同，<code>WKInterfaceController</code>更加专注于内容展示和数据流，而非复杂的布局或动画。</p><h3 id="Complications"><a href="#Complications" class="headerlink" title="Complications"></a>Complications</h3><p>复杂功能（Complications）允许用户在表盘上直接查看来自应用的关键信息。它们需要使用<code>CLKComplicationDataSource</code>协议来提供动态更新的数据。创建Complications需要细心设计图形和文本，以确保信息在极小的空间内清晰可见。</p><h3 id="Notifications"><a href="#Notifications" class="headerlink" title="Notifications"></a>Notifications</h3><p>watchOS的通知设计用于迅速传递信息。使用<code>UNUserNotificationCenter</code>，开发者可以设计富媒体通知，甚至允许用户通过交互直接在Apple Watch上回应。</p><h3 id="WKInterfaceTable"><a href="#WKInterfaceTable" class="headerlink" title="WKInterfaceTable"></a>WKInterfaceTable</h3><p><code>WKInterfaceTable</code>是watchOS用于显示列表数据的主要UI组件。与iOS的<code>UITableView</code>相比，<code>WKInterfaceTable</code>的设计更简洁，只支持静态单元格。开发者需要预先定义好所有可能的行类型。</p><h3 id="Digital-Crown"><a href="#Digital-Crown" class="headerlink" title="Digital Crown"></a>Digital Crown</h3><p>Digital Crown是Apple Watch上的旋钮，允许用户进行精细的滚动和选择操作。通过<code>crownSequencer</code>，开发者可以检测和响应旋钮的旋转，从而提供一个独特的交互方式。</p><h3 id="Force-Touch"><a href="#Force-Touch" class="headerlink" title="Force Touch"></a>Force Touch</h3><p>Force Touch允许watchOS检测屏幕上的压力级别。这可以用来显示上下文菜单或额外控件，为用户提供更多的操作选择。使用<code>WKInterfaceDevice</code>的<code>play(_:)</code>方法，还可以给予触觉反馈。</p><h3 id="Interface-Objects"><a href="#Interface-Objects" class="headerlink" title="Interface Objects"></a>Interface Objects</h3><p>watchOS提供了一系列预定义的界面对象（如<code>WKInterfaceLabel</code>，<code>WKInterfaceImage</code>等），它们是优化过的，以确保在小屏幕上的最佳显示效果。</p><h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><p>布局在watchOS中相对简单。所有元素都是垂直或水平排列的，没有自动布局系统。开发者通过设置组（Group）来组织界面，组可以嵌套，以创造更复杂的布局结构。</p><h3 id="性能和电池寿命"><a href="#性能和电池寿命" class="headerlink" title="性能和电池寿命"></a>性能和电池寿命</h3><p>由于Apple Watch的硬件限制，性能优化和电池寿命考量至关重要。应用应当避免过多的背景活动，而且要智能地安排网络请求和数据更新。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>设计watchOS应用时，开发者必须考虑到平台的独特性，包括小屏幕尺寸和有限的交互方式。通过有效利用watchOS提供的特有UI组件，开发者可以创建出既美观又实用的Apple Watch应用。此外，性能和电池寿命的优化也是watchOS应用设计中不可忽视的一部分。通过精心设计和优化，你的应用将能在这个独特的平台上提供强大功能和良好体验。</p><p><strong>第3小节：tvOS和大屏体验</strong></p><p>tvOS是苹果为Apple TV设计的操作系统，它为大屏幕交互提供了特殊的用户体验和设计挑战。tvOS的应用开发不仅要考虑到大屏幕带来的视觉冲击，还要处理与iOS明显不同的用户输入方式。以下是tvOS应用开发的关键点。</p><h3 id="界面设计"><a href="#界面设计" class="headerlink" title="界面设计"></a>界面设计</h3><ol><li><p><strong>布局</strong> - 由于电视屏幕通常较大，你需要为元素间的距离和尺寸采取不同的考量。确保文字和图标在沙发观看距离仍然清晰可辨。</p></li><li><p><strong>焦点驱动的交互</strong> - 在tvOS中，用户通过遥控器的触摸板来控制界面上的焦点。应用需要处理焦点变化，并给予用户清晰的视觉反馈。</p></li><li><p><strong>全屏体验</strong> - 利用大屏幕的优势，提供全屏背景图像和视频，创造沉浸式体验。</p></li></ol><h3 id="用户输入"><a href="#用户输入" class="headerlink" title="用户输入"></a>用户输入</h3><ol><li><p><strong>远程控制</strong> - Apple TV Remote的触摸表面提供了基础的轻扫和点击输入，开发者需设计易于用遥控器导航的界面。</p></li><li><p><strong>游戏控制器</strong> - 对于游戏应用，Apple TV支持MFi游戏控制器，这为复杂交互提供了更多可能。</p></li><li><p><strong>语音输入</strong> - 利用Siri远程功能，可以为应用添加语音搜索和控制能力。</p></li></ol><h3 id="图像和视频"><a href="#图像和视频" class="headerlink" title="图像和视频"></a>图像和视频</h3><ol><li><p><strong>分辨率和图像优化</strong> - Apple TV支持高达4K的分辨率，要求图片和视频内容具有高质量，以适应高分辨率的显示需求。</p></li><li><p><strong>视频播放</strong> - tvOS对于媒体播放有优化，支持HDR和Dolby Vision。开发者应当使用AVKit来实现视频播放，以确保最佳体验。</p></li></ol><h3 id="数据存储和缓存"><a href="#数据存储和缓存" class="headerlink" title="数据存储和缓存"></a>数据存储和缓存</h3><ol><li><p><strong>本地存储限制</strong> - Apple TV对本地数据存储有限制，应用需要通过iCloud或网络来同步和存储大部分数据。</p></li><li><p><strong>缓存策略</strong> - 为了优化性能和减少加载时间，有效的数据缓存策略是必须的。</p></li></ol><h3 id="性能和流畅性"><a href="#性能和流畅性" class="headerlink" title="性能和流畅性"></a>性能和流畅性</h3><ol><li><p><strong>动画和过渡</strong> - 在大屏幕上，动画需要更加平滑和精细，以避免拖影和断续感。</p></li><li><p><strong>内存管理</strong> - Apple TV的内存资源比移动设备更丰富，但仍然需要高效的内存管理，尤其是在处理高分辨率媒体内容时。</p></li></ol><h3 id="Accessibility"><a href="#Accessibility" class="headerlink" title="Accessibility"></a>Accessibility</h3><ol><li><strong>无障碍功能</strong> - 提供声音指导和简化的控制方案，以确保所有用户都能愉快地使用你的应用。</li></ol><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>tvOS应用开发是一个大屏幕交互设计和用户体验的全新领域。与手机和平板不同，它要求开发者从居家观看的角度出发，考虑到用户与屏幕之间的距离、环境亮度等因素，从而设计出易于使用、视觉效果出色的界面。此外，由于输入设备的限制和平台特性，tvOS应用需要特别关注焦点管理和用户输入的响应性。通过在设计上投入更多考虑和精心调优性能，你的应用将能在大屏幕上提供卓越的用户体验。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;第11章：适配多平台&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第1小节：Catalyst：从iOS到macOS&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;随着Apple推出Project Catalyst，现在开发者可以更加轻松地将iOS应用带到macOS平台</summary>
      
    
    
    
    <category term="SwiftUI" scheme="http://xuebusi.gitee.io/categories/SwiftUI/"/>
    
    
  </entry>
  
  <entry>
    <title>SwiftUI核心技术第10章集成Core Data和CloudKit</title>
    <link href="http://xuebusi.gitee.io/2023/11/08/SwiftUI%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC10%E7%AB%A0%E9%9B%86%E6%88%90Core-Data%E5%92%8CCloudKit/"/>
    <id>http://xuebusi.gitee.io/2023/11/08/SwiftUI%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC10%E7%AB%A0%E9%9B%86%E6%88%90Core-Data%E5%92%8CCloudKit/</id>
    <published>2023-11-08T01:20:39.000Z</published>
    <updated>2024-03-17T06:11:48.022Z</updated>
    
    <content type="html"><![CDATA[<p><strong>第10章：集成Core Data和CloudKit</strong></p><p><strong>第1小节：Core Data概念和配置</strong></p><p>Core Data是Apple提供的一套强大的框架，用于iOS、macOS、watchOS和tvOS应用的数据管理。它提供了对象图管理和持久化支持，使得开发者可以高效地存储和查询数据而无需直接操作数据库。在本小节中，我们将深入了解Core Data的基本概念，并指导如何在SwiftUI应用中进行配置。</p><p><strong>Core Data的关键概念</strong></p><ol><li><p><strong>托管对象模型（Managed Object Model）</strong>：作为Core Data的基础，定义了应用的数据模型。它通常通过Xcode的数据模型编辑器图形化地创建，并保存为.xcdatamodeld文件。</p></li><li><p><strong>托管对象上下文（Managed Object Context）</strong>：是在应用和数据库之间进行交互的主要接口。它管理应用中的数据对象。</p></li><li><p><strong>持久化存储协调器（Persistent Store Coordinator）</strong>：负责管理数据的存储。它连接数据模型和数据存储。</p></li><li><p><strong>托管对象（Managed Object）</strong>：对数据模型中定义的实体（Entity）的实例，它在上下文中被管理。</p></li><li><p><strong>实体（Entity）</strong>：数据模型中定义的一个数据结构，对应于传统数据库中的表。</p></li><li><p><strong>属性（Attribute）</strong>：实体中的字段，用来定义存储数据的类型。</p></li><li><p><strong>关系（Relationship）</strong>：定义实体间的连接，类似于数据库中的外键。</p></li><li><p><strong>获取请求（Fetch Request）</strong>：用来查询数据模型，返回一个或多个托管对象。</p></li></ol><p><strong>配置Core Data</strong></p><p>在SwiftUI中配置Core Data通常遵循以下步骤：</p><ol><li><p><strong>创建数据模型</strong>：在Xcode中新建一个数据模型文件，并添加必要的实体和属性。</p></li><li><p><strong>添加Core Data堆栈</strong>：设置托管对象模型、持久化存储协调器和托管对象上下文。在Xcode项目模板中，如果选择了使用Core Data，则大部分配置已由模板自动生成。</p></li><li><p><strong>初始化Core Data堆栈</strong>：通常在应用启动时进行，例如在<code>AppDelegate</code>或<code>SceneDelegate</code>中。</p></li><li><p><strong>在SwiftUI视图中使用</strong>：在SwiftUI视图中，通过环境变量<code>@Environment(\.managedObjectContext)</code>访问托管对象上下文。</p></li></ol><p><strong>示例代码：配置Core Data环境</strong></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">import</span> CoreData<br><br><span class="hljs-comment">// 通常在AppDelegate或类似的地方进行初始化</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DataController</span>: <span class="hljs-title class_">ObservableObject</span> &#123;<br>    <span class="hljs-keyword">let</span> container: <span class="hljs-type">NSPersistentContainer</span><br><br>    <span class="hljs-keyword">init</span>() &#123;<br>        container <span class="hljs-operator">=</span> <span class="hljs-type">NSPersistentContainer</span>(name: <span class="hljs-string">&quot;Model&quot;</span>)<br>        container.loadPersistentStores &#123; (storeDescription, error) <span class="hljs-keyword">in</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> error <span class="hljs-operator">=</span> error <span class="hljs-keyword">as</span> <span class="hljs-type">NSError</span>? &#123;<br>                <span class="hljs-comment">// 实际应用中应处理错误，这里简化了处理</span><br>                <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">&quot;Unresolved error <span class="hljs-subst">\(error)</span>, <span class="hljs-subst">\(error.userInfo)</span>&quot;</span>)<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// SwiftUI视图中使用</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ContentView</span>: <span class="hljs-title class_">View</span> &#123;<br>    <span class="hljs-meta">@Environment</span>(\.managedObjectContext) <span class="hljs-keyword">var</span> managedObjectContext<br><br>    <span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述代码中，<code>DataController</code>负责初始化Core Data堆栈，并加载持久化存储。在SwiftUI视图中，我们通过<code>@Environment</code>属性包装器注入了托管对象上下文，以便在视图中使用。</p><p><strong>总结</strong></p><p>Core Data是一个强大的框架，它为数据持久化和管理提供了丰富的功能。理解其核心概念并在SwiftUI项目中进行正确配置，是高效使用该框架的关键。随后的小节中，我们将探讨如何使用Core Data进行数据的创建、读取、更新和删除操作，以及如何将Core Data与CloudKit集成，实现数据的云同步。</p><p><strong>第2小节：SwiftUI中的Core Data集成</strong></p><p>在SwiftUI应用中集成Core Data可以让我们更加便捷地管理模型层数据。这个过程涉及到模型定义、上下文管理和视图更新。在本小节，我们将详细介绍如何在SwiftUI中集成Core Data。</p><p><strong>模型定义</strong></p><p>模型定义是使用Core Data的第一步。在Xcode的模型编辑器中，您可以定义实体、属性和关系。这些模型元素代表了应用中的数据结构。对于每一个实体，Core Data都能自动生成对应的<code>NSManagedObject</code>子类，您可以直接在代码中使用。</p><p><strong>示例代码：定义一个Person实体</strong></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">import</span> CoreData<br><br><span class="hljs-comment">// 假设在.xcdatamodeld文件中已经定义了Person实体及其属性</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>: <span class="hljs-title class_">NSManagedObject</span> &#123;<br>    <span class="hljs-keyword">@NSManaged</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> id: <span class="hljs-type">UUID</span><br>    <span class="hljs-keyword">@NSManaged</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span><br>    <span class="hljs-keyword">@NSManaged</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> age: <span class="hljs-type">Int16</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>集成到SwiftUI视图</strong></p><p>在SwiftUI中，通过<code>@FetchRequest</code>属性包装器可以创建对Core Data实体的查询请求，并将结果直接绑定到用户界面。当底层数据变化时，界面也会自动更新。</p><p><strong>示例代码：使用<code>@FetchRequest</code>展示数据</strong></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">import</span> SwiftUI<br><span class="hljs-keyword">import</span> CoreData<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">PersonListView</span>: <span class="hljs-title class_">View</span> &#123;<br>    <span class="hljs-meta">@Environment</span>(\.managedObjectContext) <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> viewContext<br>    <span class="hljs-meta">@FetchRequest</span>(<br>        sortDescriptors: [<span class="hljs-type">NSSortDescriptor</span>(keyPath: \<span class="hljs-type">Person</span>.name, ascending: <span class="hljs-literal">true</span>)],<br>        animation: .default)<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> persons: <span class="hljs-type">FetchedResults</span>&lt;<span class="hljs-type">Person</span>&gt;<br><br>    <span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> &#123;<br>        <span class="hljs-type">List</span> &#123;<br>            <span class="hljs-type">ForEach</span>(persons, id: \.id) &#123; person <span class="hljs-keyword">in</span><br>                <span class="hljs-type">Text</span>(person.name)<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的代码中，<code>@FetchRequest</code>初始化了一个请求来获取所有<code>Person</code>对象，并按<code>name</code>属性升序排序。<code>persons</code>数组将自动更新，以反映数据库中的数据。</p><p><strong>数据操作</strong></p><p>对于Core Data中的数据，您可以使用托管对象上下文（<code>NSManagedObjectContext</code>）进行操作，包括创建新对象、修改属性、保存更改或删除对象。</p><p><strong>示例代码：添加新Person对象</strong></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">func</span> <span class="hljs-title function_">addPerson</span>(<span class="hljs-params">name</span>: <span class="hljs-type">String</span>, <span class="hljs-params">age</span>: <span class="hljs-type">Int16</span>) &#123;<br>    <span class="hljs-keyword">let</span> newPerson <span class="hljs-operator">=</span> <span class="hljs-type">Person</span>(context: viewContext)<br>    newPerson.id <span class="hljs-operator">=</span> <span class="hljs-type">UUID</span>()<br>    newPerson.name <span class="hljs-operator">=</span> name<br>    newPerson.age <span class="hljs-operator">=</span> age<br><br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-keyword">try</span> viewContext.save()<br>    &#125; <span class="hljs-keyword">catch</span> &#123;<br>        <span class="hljs-comment">// 这里处理错误</span><br>        <span class="hljs-keyword">let</span> nsError <span class="hljs-operator">=</span> error <span class="hljs-keyword">as</span> <span class="hljs-type">NSError</span><br>        <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">&quot;Unresolved error <span class="hljs-subst">\(nsError)</span>, <span class="hljs-subst">\(nsError.userInfo)</span>&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>SwiftUI中的Context传递</strong></p><p>在SwiftUI应用中，托管对象上下文是通过环境传递的。这意味着您可以在应用的顶层视图中设置上下文，并通过环境变量在子视图中访问。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">@main</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyApp</span>: <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">let</span> dataController <span class="hljs-operator">=</span> <span class="hljs-type">DataController</span>()<br><br>    <span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">Scene</span> &#123;<br>        <span class="hljs-type">WindowGroup</span> &#123;<br>            <span class="hljs-type">ContentView</span>()<br>                .environment(\.managedObjectContext, dataController.container.viewContext)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>ContentView</code>或其任何子视图中，您都可以通过<code>@Environment</code>来获取上下文。</p><p><strong>总结</strong></p><p>SwiftUI与Core Data的集成使得数据管理变得直观和无缝。通过定义数据模型、执行数据操作以及将数据变化反馈到UI，可以构建出响应式的用户界面。确保正确地处理数据操作中的错误，并在需要的地方更新视图。接下来的小节将深入探讨如何优化数据操作，以及如何将Core Data与CloudKit结合使用，实现数据的云同步和共享。</p><p><strong>第3小节：使用CloudKit进行数据同步</strong></p><p>Core Data与CloudKit的集成为数据提供了一个强大的云同步功能。通过这种集成，用户可以在不同的设备之间无缝同步数据，同时还可以分享数据到其他用户。在本小节中，我们将深入探讨如何设置和使用CloudKit进行数据同步。</p><h3 id="CloudKit-概述"><a href="#CloudKit-概述" class="headerlink" title="CloudKit 概述"></a>CloudKit 概述</h3><p>CloudKit是苹果提供的一个后端存储解决方案，它可以让开发者存储数据在iCloud上，实现跨设备的数据同步。与Core Data集成后，CloudKit可以自动处理网络请求、数据缓存以及差异合并等复杂任务。</p><h3 id="设置CloudKit"><a href="#设置CloudKit" class="headerlink" title="设置CloudKit"></a>设置CloudKit</h3><p>在Xcode中启用CloudKit非常简单。首先需要在应用的Capabilities选项中打开iCloud，并勾选CloudKit。这样做将为您的应用创建一个iCloud container。</p><p>然后，确保您的Core Data模型设置正确。在.xcdatamodeld文件的数据模型编辑器中，选择模型文件，然后在Model Inspector中勾选“Use CloudKit”。</p><h3 id="模型和记录类型"><a href="#模型和记录类型" class="headerlink" title="模型和记录类型"></a>模型和记录类型</h3><p>在CloudKit中，每个Core Data实体将映射到一个CloudKit记录类型（CKRecordType）。实体的属性和关系将映射为记录的字段。在设置实体时，需要注意数据类型的兼容性，以确保顺利映射。</p><h3 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h3><h4 id="初始化同步"><a href="#初始化同步" class="headerlink" title="初始化同步"></a>初始化同步</h4><p>使用<code>NSPersistentCloudKitContainer</code>作为您的持久化容器，可以实现Core Data和CloudKit之间的数据同步。在应用启动时，你需要设置持久化容器来初始化CloudKit同步。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">import</span> CoreData<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DataController</span>: <span class="hljs-title class_">ObservableObject</span> &#123;<br>    <span class="hljs-keyword">let</span> container: <span class="hljs-type">NSPersistentCloudKitContainer</span><br><br>    <span class="hljs-keyword">init</span>() &#123;<br>        container <span class="hljs-operator">=</span> <span class="hljs-type">NSPersistentCloudKitContainer</span>(name: <span class="hljs-string">&quot;Model&quot;</span>)<br><br>        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> description <span class="hljs-operator">=</span> container.persistentStoreDescriptions.first <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">&quot;Persistent store description was not found.&quot;</span>)<br>        &#125;<br>        <br>        description.setOption(<span class="hljs-literal">true</span> <span class="hljs-keyword">as</span> <span class="hljs-type">NSNumber</span>, forKey: <span class="hljs-type">NSPersistentStoreRemoteChangeNotificationPostOptionKey</span>)<br>        <br>        container.loadPersistentStores &#123; storeDescription, error <span class="hljs-keyword">in</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> error <span class="hljs-operator">=</span> error <span class="hljs-keyword">as</span> <span class="hljs-type">NSError</span>? &#123;<br>                <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">&quot;Unresolved error <span class="hljs-subst">\(error)</span>, <span class="hljs-subst">\(error.userInfo)</span>&quot;</span>)<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述代码中，<code>NSPersistentStoreRemoteChangeNotificationPostOptionKey</code>选项允许您接收到数据变更通知。</p><h4 id="监听数据变化"><a href="#监听数据变化" class="headerlink" title="监听数据变化"></a>监听数据变化</h4><p>为了让您的用户界面响应CloudKit的数据变更，您可以监听<code>NSPersistentStoreRemoteChange</code>通知。每当CloudKit中的数据发生变化时，都会发送通知，并且您可以更新UI。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-type">NotificationCenter</span>.default.addObserver(<br>    <span class="hljs-keyword">self</span>,<br>    selector: <span class="hljs-keyword">#selector</span>(handleDataChangeNotification(<span class="hljs-keyword">_</span>:)),<br>    name: .<span class="hljs-type">NSPersistentStoreRemoteChange</span>,<br>    object: <span class="hljs-literal">nil</span><br>)<br><br><span class="hljs-keyword">@objc</span><br><span class="hljs-keyword">func</span> <span class="hljs-title function_">handleDataChangeNotification</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">notification</span>: <span class="hljs-type">Notification</span>) &#123;<br>    <span class="hljs-comment">// 在这里处理数据变化，更新UI</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="数据冲突和合并"><a href="#数据冲突和合并" class="headerlink" title="数据冲突和合并"></a>数据冲突和合并</h3><p>处理数据冲突是云同步的重要方面。Core Data和CloudKit集成提供了一种自动的冲突解决策略。默认情况下，最后写入的数据将会“赢”，覆盖之前的数据。如果需要，也可以自定义冲突解决策略。</p><h3 id="调试和错误处理"><a href="#调试和错误处理" class="headerlink" title="调试和错误处理"></a>调试和错误处理</h3><p>当处理云同步时，调试和错误处理是不可或缺的。您应当仔细检查错误日志，并对可能的同步错误做出反应。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>将Core Data与CloudKit集成，为应用添加云同步功能，可以极大地改善用户体验。通过简单的设置和API调用，您可以实现数据在多个设备间的同步，并允许用户之间共享数据。确保在实现过程中，处理好初始化同步、数据变更监听、数据冲突及错误处理等关键环节。在后续小节中，我们将讨论如何利用Cloud</p><p>Kit的高级特性来构建更为复杂的云同步方案。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;第10章：集成Core Data和CloudKit&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第1小节：Core Data概念和配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Core Data是Apple提供的一套强大的框架，用于iOS、macOS、watch</summary>
      
    
    
    
    <category term="SwiftUI" scheme="http://xuebusi.gitee.io/categories/SwiftUI/"/>
    
    
  </entry>
  
  <entry>
    <title>SwiftUI核心技术第9章复合视图与可复用性</title>
    <link href="http://xuebusi.gitee.io/2023/11/08/SwiftUI%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC9%E7%AB%A0%E5%A4%8D%E5%90%88%E8%A7%86%E5%9B%BE%E4%B8%8E%E5%8F%AF%E5%A4%8D%E7%94%A8%E6%80%A7/"/>
    <id>http://xuebusi.gitee.io/2023/11/08/SwiftUI%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC9%E7%AB%A0%E5%A4%8D%E5%90%88%E8%A7%86%E5%9B%BE%E4%B8%8E%E5%8F%AF%E5%A4%8D%E7%94%A8%E6%80%A7/</id>
    <published>2023-11-08T01:18:34.000Z</published>
    <updated>2024-03-17T06:11:44.777Z</updated>
    
    <content type="html"><![CDATA[<p><strong>第9章：复合视图与可复用性</strong></p><p><strong>第1小节：组合现有视图</strong></p><p>在构建复杂的用户界面时，有效的视图复用和组合是提高代码可维护性和减少重复的关键。SwiftUI以其声明式语法和数据驱动的方法论，为视图的复合提供了极佳的支持。</p><p><strong>视图复合的概念</strong></p><p>视图复合是指将多个较小的视图组合成一个复杂的视图的过程。这是软件工程中“组合优于继承”原则的直接体现，允许开发者通过构建并组合简单的视图块来创建复杂的用户界面。</p><p><strong>基本视图组合</strong></p><p>在SwiftUI中，最基本的视图组合可以通过使用Stacks、Groups等容器视图来完成。例如，一个简单的登录表单可以通过组合TextFields和Button视图来创建：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">LoginForm</span>: <span class="hljs-title class_">View</span> &#123;<br>    <span class="hljs-meta">@State</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> username: <span class="hljs-type">String</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-meta">@State</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> password: <span class="hljs-type">String</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span><br><br>    <span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> &#123;<br>        <span class="hljs-type">VStack</span> &#123;<br>            <span class="hljs-type">TextField</span>(<span class="hljs-string">&quot;Username&quot;</span>, text: <span class="hljs-variable">$username</span>)<br>                .textFieldStyle(<span class="hljs-type">RoundedBorderTextFieldStyle</span>())<br>            <span class="hljs-type">SecureField</span>(<span class="hljs-string">&quot;Password&quot;</span>, text: <span class="hljs-variable">$password</span>)<br>                .textFieldStyle(<span class="hljs-type">RoundedBorderTextFieldStyle</span>())<br>            <span class="hljs-type">Button</span>(<span class="hljs-string">&quot;Log In&quot;</span>) &#123;<br>                <span class="hljs-comment">// Handle login action</span><br>            &#125;<br>            .padding()<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，我们创建了一个自定义的<code>LoginForm</code>视图，它将两个文本字段和一个按钮组合在一起。</p><p><strong>视图抽象</strong></p><p>SwiftUI的另一个强大功能是能够创建可复用的自定义视图。例如，如果我们发现在不同的地方多次使用相同的文本样式，可以将其抽象为一个可复用的视图：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TitleText</span>: <span class="hljs-title class_">View</span> &#123;<br>    <span class="hljs-keyword">var</span> text: <span class="hljs-type">String</span><br><br>    <span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> &#123;<br>        <span class="hljs-type">Text</span>(text)<br>            .font(.largeTitle)<br>            .foregroundColor(.blue)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用<code>TitleText</code>视图可以确保文本样式的一致性，并且在更新样式时，只需修改<code>TitleText</code>视图的定义即可。</p><p><strong>利用视图修饰符</strong></p><p>除了创建完整的自定义视图外，开发者也可以定义视图修饰符来封装常用的修改器组合。这可以进一步简化视图定义并增强可读性：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CardStyle</span>: <span class="hljs-title class_">ViewModifier</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">body</span>(<span class="hljs-params">content</span>: <span class="hljs-type">Content</span>) -&gt; <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> &#123;<br>        content<br>            .padding()<br>            .background(<span class="hljs-type">Color</span>.white)<br>            .cornerRadius(<span class="hljs-number">10</span>)<br>            .shadow(radius: <span class="hljs-number">5</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">extension</span> <span class="hljs-title class_">View</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">cardStyle</span>() -&gt; <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> &#123;<br>        <span class="hljs-keyword">self</span>.modifier(<span class="hljs-type">CardStyle</span>())<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在，任何视图都可以轻松地应用这个“卡片”样式：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-type">Text</span>(<span class="hljs-string">&quot;Hello World&quot;</span>)<br>    .cardStyle()<br></code></pre></td></tr></table></figure><p><strong>小结</strong></p><p>通过组合现有视图，开发者可以在SwiftUI中高效地构建复杂的用户界面。这种方法的核心优势是它提高了代码的可维护性、减少了重复，并且通过自定义视图和视图修饰符，能够轻松实现视图的一致性和可复用性。这种模块化的构建方式非常适合快速迭代和扩展，是构建复杂UI时的推荐方法。</p><p><strong>第2小节：创建可复用的视图库</strong></p><p>在构建复杂的SwiftUI应用时，开发者会逐渐积累起一组可复用的视图和视图修饰符。将这些元素组织成一个内部视图库，不仅可以提升开发效率，还可以确保UI的一致性。在这一节中，我们将探讨如何创建和维护一个可复用的视图库。</p><p><strong>可复用视图库的优点</strong></p><ol><li><strong>一致性</strong>：统一的视图库可以确保整个应用的视觉元素保持一致。</li><li><strong>效率</strong>：通过重用视图组件，可以避免重复劳动，加快开发速度。</li><li><strong>可维护性</strong>：需要调整设计时，只需要更新视图库中的组件即可影响整个应用。</li></ol><p><strong>设计可复用视图</strong></p><p>当设计一个可复用视图时，考虑以下几个方面：</p><ul><li><strong>通用性</strong>：视图应该足够通用，能够适应不同的使用场景。</li><li><strong>可配置性</strong>：提供合理的接口来调整视图的外观和行为。</li><li><strong>独立性</strong>：视图应该是自包含的，不依赖于外部状态。</li></ul><p><strong>视图库结构</strong></p><p>一个好的视图库应该具有清晰的结构，通常包含以下几个层次：</p><ol><li><strong>基础视图</strong>：最基本的视图组件，如按钮、标签、输入框等。</li><li><strong>视图修饰符</strong>：用于修饰视图的通用样式，如阴影、边框、字体样式等。</li><li><strong>复合视图</strong>：由多个基础视图或其他复合视图组合而成的复杂视图。</li><li><strong>布局</strong>：用于组织视图在容器中的位置和排列的布局组件。</li></ol><p><strong>实施示例</strong></p><p>让我们来定义一个基础的可复用视图库的组件：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// 基础视图</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">PrimaryButton</span>: <span class="hljs-title class_">View</span> &#123;<br>    <span class="hljs-keyword">var</span> title: <span class="hljs-type">String</span><br>    <span class="hljs-keyword">var</span> action: () -&gt; <span class="hljs-type">Void</span><br><br>    <span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> &#123;<br>        <span class="hljs-type">Button</span>(action: action) &#123;<br>            <span class="hljs-type">Text</span>(title)<br>                .fontWeight(.bold)<br>                .frame(minWidth: <span class="hljs-number">0</span>, maxWidth: .infinity)<br>                .padding()<br>                .background(<span class="hljs-type">Color</span>.blue)<br>                .foregroundColor(.white)<br>                .cornerRadius(<span class="hljs-number">10</span>)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 视图修饰符</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ShadowModifier</span>: <span class="hljs-title class_">ViewModifier</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">body</span>(<span class="hljs-params">content</span>: <span class="hljs-type">Content</span>) -&gt; <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> &#123;<br>        content<br>            .shadow(color: .gray, radius: <span class="hljs-number">5</span>, x: <span class="hljs-number">0</span>, y: <span class="hljs-number">2</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">extension</span> <span class="hljs-title class_">View</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">applyShadow</span>() -&gt; <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> &#123;<br>        modifier(<span class="hljs-type">ShadowModifier</span>())<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 复合视图</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">UserInfoCard</span>: <span class="hljs-title class_">View</span> &#123;<br>    <span class="hljs-keyword">var</span> username: <span class="hljs-type">String</span><br>    <span class="hljs-keyword">var</span> email: <span class="hljs-type">String</span><br><br>    <span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> &#123;<br>        <span class="hljs-type">VStack</span>(alignment: .leading) &#123;<br>            <span class="hljs-type">Text</span>(username)<br>                .font(.headline)<br>                .applyShadow()<br>            <span class="hljs-type">Text</span>(email)<br>                .font(.subheadline)<br>        &#125;<br>        .padding()<br>        .background(<span class="hljs-type">Color</span>.white)<br>        .cornerRadius(<span class="hljs-number">10</span>)<br>        .applyShadow()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>视图库的维护</strong></p><ul><li><strong>文档</strong>：为每个组件编写详细的文档，说明其用法和配置选项。</li><li><strong>示例应用</strong>：创建一个示例应用，演示视图库中每个组件的用法。</li><li><strong>版本控制</strong>：当更新视图库时，使用版本控制来管理变更。</li></ul><p><strong>小结</strong></p><p>创建和维护一个可复用的视图库是提高SwiftUI应用开发效率和质量的有效方法。通过精心设计和文档化，视图库不仅能够确保UI的一致性，还能极大地简化应用的迭代和扩展。</p><p><strong>第3小节：自定义Modifier</strong></p><p>在SwiftUI中，<code>Modifier</code>允许开发者封装一系列的视图修改操作，并可复用于不同的视图。通过创建自定义的<code>Modifier</code>，可以极大地提高代码的可维护性和清晰度，同时也使得UI组件的风格和布局保持一致。本小节将详细介绍如何定义和使用自定义Modifier。</p><p><strong>理解Modifier</strong></p><p>Modifier是一种遵循<code>ViewModifier</code>协议的结构体，它通过改变视图的渲染和布局属性来修改视图的外观和行为。每当对视图应用Modifier时，SwiftUI都会在背后创建一个新的视图结构，而不是修改旧的视图。这使得视图修改操作既安全又易于管理。</p><p><strong>创建自定义Modifier</strong></p><ol><li><strong>定义Modifier结构体</strong>：首先，需要定义一个结构体并遵循<code>ViewModifier</code>协议。</li><li><strong>实现<code>body</code>属性</strong>：在结构体中实现必需的<code>body</code>计算属性，它接收一个<code>Content</code>参数，并返回一个新的视图。</li><li><strong>添加修改操作</strong>：在<code>body</code>属性中，对传入的<code>Content</code>进行修改，如添加边框、改变字体、设置背景等。</li></ol><p><strong>示例：自定义圆角和阴影Modifier</strong></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">RoundedShadowModifier</span>: <span class="hljs-title class_">ViewModifier</span> &#123;<br>    <span class="hljs-keyword">var</span> radius: <span class="hljs-type">CGFloat</span><br>    <span class="hljs-keyword">var</span> shadowRadius: <span class="hljs-type">CGFloat</span><br><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">body</span>(<span class="hljs-params">content</span>: <span class="hljs-type">Content</span>) -&gt; <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> &#123;<br>        content<br>            .cornerRadius(radius)<br>            .shadow(radius: shadowRadius)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">extension</span> <span class="hljs-title class_">View</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">roundedShadow</span>(<span class="hljs-params">radius</span>: <span class="hljs-type">CGFloat</span>, <span class="hljs-params">shadowRadius</span>: <span class="hljs-type">CGFloat</span>) -&gt; <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> &#123;<br>        modifier(<span class="hljs-type">RoundedShadowModifier</span>(radius: radius, shadowRadius: shadowRadius))<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述示例中，我们定义了一个名为<code>RoundedShadowModifier</code>的自定义Modifier，它将圆角和阴影效果应用于任何视图。通过<code>extension</code>扩展<code>View</code>，我们为所有视图添加了一个名为<code>roundedShadow</code>的新方法，它使得应用圆角和阴影更加便捷。</p><p><strong>使用自定义Modifier</strong></p><p>一旦定义了自定义Modifier，就可以在任何视图上像使用内置Modifier一样使用它：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-type">Text</span>(<span class="hljs-string">&quot;Hello, SwiftUI!&quot;</span>)<br>    .roundedShadow(radius: <span class="hljs-number">10</span>, shadowRadius: <span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><p><strong>优化Modifier</strong></p><ul><li><strong>链式调用</strong>：Modifier可以链式调用，使得视图修改更加灵活。</li><li><strong>条件修改</strong>：可以使用条件语句动态地应用Modifier。</li><li><strong>性能考虑</strong>：尽量避免创建过于复杂的Modifier，以免影响性能。</li></ul><p><strong>总结</strong></p><p>自定义Modifier在SwiftUI开发中是一项强大的工具，它不仅可以提高代码的复用性和清晰度，还可以帮助维护应用的视觉一致性。通过创建合适的自定义Modifier，可以简化视图的构建过程，并提升开发效率。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;第9章：复合视图与可复用性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第1小节：组合现有视图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在构建复杂的用户界面时，有效的视图复用和组合是提高代码可维护性和减少重复的关键。SwiftUI以其声明式语法和数据驱动的方法论</summary>
      
    
    
    
    <category term="SwiftUI" scheme="http://xuebusi.gitee.io/categories/SwiftUI/"/>
    
    
  </entry>
  
  <entry>
    <title>SwiftUI核心技术第8章动画与转场</title>
    <link href="http://xuebusi.gitee.io/2023/11/08/SwiftUI%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC8%E7%AB%A0%E5%8A%A8%E7%94%BB%E4%B8%8E%E8%BD%AC%E5%9C%BA/"/>
    <id>http://xuebusi.gitee.io/2023/11/08/SwiftUI%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC8%E7%AB%A0%E5%8A%A8%E7%94%BB%E4%B8%8E%E8%BD%AC%E5%9C%BA/</id>
    <published>2023-11-08T01:13:02.000Z</published>
    <updated>2024-03-17T06:11:41.709Z</updated>
    
    <content type="html"><![CDATA[<p><strong>第8章：动画与转场</strong></p><p><strong>第1小节：基础动画</strong></p><p>在SwiftUI中，动画是用来增强用户体验的一种手段，它可以提供平滑的视觉过渡和引人注目的交互。通过使用SwiftUI强大的动画API，你可以轻松地为界面元素添加动画效果。</p><p><strong>动画的类型</strong></p><p>在SwiftUI中，动画主要可以分为隐式动画和显式动画两大类。</p><ol><li><strong>隐式动画</strong>：最简单的动画形式，仅需要使用<code>.animation()</code>修饰符，并为其提供一个动画样式。</li><li><strong>显式动画</strong>：使用<code>withAnimation</code>函数来明确开始动画的时间点，并提供一个动画样式。</li></ol><p><strong>创建一个简单的隐式动画</strong></p><p>你可以通过在视图的某个状态改变时附加<code>.animation()</code>修饰符，让这个状态改变带有动画效果。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SimpleAnimationView</span>: <span class="hljs-title class_">View</span> &#123;<br>    <span class="hljs-meta">@State</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> scale: <span class="hljs-type">CGFloat</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> &#123;<br>        <span class="hljs-type">Circle</span>()<br>            .scaleEffect(scale)<br>            .animation(.easeInOut, value: scale)<br>            .onTapGesture &#123;<br>                scale <span class="hljs-operator">+=</span> <span class="hljs-number">1</span><br>            &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的例子中，每当用户点击圆形，<code>scale</code>状态变量就会增加，而圆形的尺寸变化将以渐进渐出的方式动画显示。</p><p><strong>使用<code>withAnimation</code>进行显式动画</strong></p><p>如果你想控制动画的触发时机，而不是依赖于状态的改变，你可以使用<code>withAnimation</code>来显式地执行动画。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-type">Button</span>(<span class="hljs-string">&quot;Tap Me&quot;</span>) &#123;<br>    withAnimation(.spring(response: <span class="hljs-number">0.5</span>, dampingFraction: <span class="hljs-number">0.5</span>, blendDuration: <span class="hljs-number">1</span>)) &#123;<br>        scale <span class="hljs-operator">+=</span> <span class="hljs-number">1</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，当按钮被点击时，不管<code>scale</code>的值如何变化，动画都会被执行。</p><p><strong>动画的组合</strong></p><p>你可以将不同的动画效果组合在一起，创建复杂的动画序列。这通过在<code>.animation()</code>修饰符中使用<code>Animation</code>的静态方法来实现。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs swift">.animation(<br>    <span class="hljs-type">Animation</span>.easeInOut(duration: <span class="hljs-number">2</span>).repeatForever(autoreverses: <span class="hljs-literal">true</span>)<br>)<br></code></pre></td></tr></table></figure><p>此代码会创建一个无限重复并自动反向的渐进渐出动画。</p><p><strong>动画参数</strong></p><p>SwiftUI提供了许多可以调整动画行为的参数：</p><ul><li><code>duration</code>：动画的时长。</li><li><code>delay</code>：动画开始前的等待时间。</li><li><code>repeatCount</code>：动画重复的次数。</li><li><code>autoreverses</code>：动画是否在完成后自动反向。</li></ul><p><strong>小结</strong></p><p>基础动画是SwiftUI中最容易实现的动画类型，它们可以快速为你的应用添加视觉吸引力和反馈。通过使用隐式动画或显式动画，你可以控制动画的触发方式和行为。此外，SwiftUI的动画系统是高度可组合的，允许你通过组合和定制动画参数来创建复杂的动画效果。</p><p>在本书的后续章节中，我们将深入探讨如何使用SwiftUI的高级动画功能，比如路径动画、自定义时间曲线以及动画的联动效果，来创建更具表现力和创造力的用户界面。</p><p><strong>第2小节：自定义动画</strong></p><p>在SwiftUI中，除了内置的动画类型，开发者还可以通过自定义动画来进一步个性化UI交互。自定义动画允许开发者控制动画的具体行为和时间曲线，实现独特的动态效果。</p><p><strong>动画时间曲线</strong></p><p>时间曲线描述了动画状态值随时间的变化方式。SwiftUI提供了几种内置的时间曲线，例如<code>easeIn</code>、<code>easeOut</code>和<code>easeInOut</code>。要自定义这些曲线，你可以使用<code>timingCurve(_:_:_:_:)</code>方法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs swift">.animation(.timingCurve(<span class="hljs-number">0.2</span>, <span class="hljs-number">0.8</span>, <span class="hljs-number">0.2</span>, <span class="hljs-number">1</span>, duration: <span class="hljs-number">0.5</span>))<br></code></pre></td></tr></table></figure><p>这个方法接受四个表示贝塞尔曲线控制点的参数，可以非常精细地控制动画的加速和减速过程。</p><p><strong>使用<code>interpolatingSpring</code>自定义弹簧动画</strong></p><p>如果你需要一个物理弹性效果，可以使用<code>interpolatingSpring(stiffness:damping:)</code>函数来自定义一个弹簧动画。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs swift">.animation(.interpolatingSpring(stiffness: <span class="hljs-number">50</span>, damping: <span class="hljs-number">5</span>))<br></code></pre></td></tr></table></figure><p>调整<code>stiffness</code>（刚度）和<code>damping</code>（阻尼）参数可以模拟不同的弹簧物理特性。</p><p><strong>使用<code>Animation</code>的<code>delay(_: )</code>和<code>speed(_: )</code>自定义动画速度和延迟</strong></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs swift">.animation(.easeInOut(duration: <span class="hljs-number">2</span>).delay(<span class="hljs-number">0.5</span>).speed(<span class="hljs-number">2</span>))<br></code></pre></td></tr></table></figure><p>这里，动画会在半秒延迟后开始，并且以原始时长的两倍速度播放。</p><p><strong>自定义动画路径</strong></p><p>SwiftUI动画不仅限于简单的开始和结束状态之间的过渡。使用<code>GeometryEffect</code>，你可以创建完全自定义的动画路径。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CustomAnimationView</span>: <span class="hljs-title class_">View</span> &#123;<br>    <span class="hljs-meta">@State</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> isAnimated <span class="hljs-operator">=</span> <span class="hljs-literal">false</span><br><br>    <span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> &#123;<br>        <span class="hljs-type">Circle</span>()<br>            .frame(width: <span class="hljs-number">100</span>, height: <span class="hljs-number">100</span>)<br>            .modifier(<span class="hljs-type">CustomPathModifier</span>(isAnimated: <span class="hljs-variable">$isAnimated</span>))<br>            .onTapGesture &#123;<br>                withAnimation &#123;<br>                    isAnimated.toggle()<br>                &#125;<br>            &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CustomPathModifier</span>: <span class="hljs-title class_">GeometryEffect</span> &#123;<br>    <span class="hljs-meta">@Binding</span> <span class="hljs-keyword">var</span> isAnimated: <span class="hljs-type">Bool</span><br><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">effectValue</span>(<span class="hljs-params">size</span>: <span class="hljs-type">CGSize</span>) -&gt; <span class="hljs-type">ProjectionTransform</span> &#123;<br>        <span class="hljs-keyword">let</span> path <span class="hljs-operator">=</span> <span class="hljs-type">UIBezierPath</span>()<br>        path.move(to: <span class="hljs-type">CGPoint</span>(x: <span class="hljs-number">0</span>, y: isAnimated <span class="hljs-operator">?</span> size.height : <span class="hljs-number">0</span>))<br>        <span class="hljs-comment">// Your custom path here</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-type">ProjectionTransform</span>(<span class="hljs-type">CGAffineTransform</span>(translationX: path.currentPoint.x, y: path.currentPoint.y))<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过创建一个遵循<code>GeometryEffect</code>协议的自定义修饰符，你可以定义一个复杂的动画路径，这个路径由一个点沿着给定路径移动的动画组成。</p><p><strong>自定义动画的应用场景</strong></p><ul><li>当内置动画不能满足你的设计需求时。</li><li>当你想要创建一个与众不同的动态交互体验。</li><li>在需要精确控制动画行为，如游戏或特定动画教程中。</li></ul><p><strong>小结</strong></p><p>自定义动画是SwiftUI动画功能的深入使用。通过控制时间曲线、弹簧动画参数和自定义动画路径，你可以创造出个性化和专业级别的动态效果。自定义动画能提升应用的专业感和用户的交互体验，使你的应用在众多相似应用中脱颖而出。</p><p>接下来，我们将探讨转场动画，它们可以为视图的呈现和消失提供引人注目的视觉效果。</p><p><strong>第3小节：交互式和响应式动画</strong></p><p>在构建现代的用户界面时，我们不仅希望动画能够提供视觉上的引导和反馈，还希望它们能够与用户的交互紧密结合，创造流畅的体验。这就是交互式和响应式动画发挥作用的地方。在SwiftUI中，你可以根据用户的输入或其他事件，实时地调整动画，从而创建出高度交互的UI元素。</p><p><strong>交互式动画</strong></p><p>交互式动画是指随着用户的操作实时变化的动画。例如，拖动滑块时的动态变化或者通过手势控制的动画。</p><p><strong>实现交互式动画的方法</strong></p><p>你可以通过以下方式为你的应用添加交互式动画：</p><ol><li><p><strong>使用Gesture</strong></p><p>绑定手势到视图，然后在手势变化时更新视图的状态。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">InteractiveView</span>: <span class="hljs-title class_">View</span> &#123;<br>    <span class="hljs-meta">@GestureState</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> dragState <span class="hljs-operator">=</span> <span class="hljs-type">CGSize</span>.zero<br><br>    <span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> &#123;<br>        <span class="hljs-type">Rectangle</span>()<br>            .fill(<span class="hljs-type">Color</span>.blue)<br>            .frame(width: <span class="hljs-number">100</span>, height: <span class="hljs-number">100</span>)<br>            .offset(dragState)<br>            .gesture(<br>                <span class="hljs-type">DragGesture</span>()<br>                    .updating(<span class="hljs-variable">$dragState</span>) &#123; value, state, <span class="hljs-keyword">_</span> <span class="hljs-keyword">in</span><br>                        state <span class="hljs-operator">=</span> value.translation<br>                    &#125;<br>            )<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>DragGesture</code>跟踪手指的拖动，并实时更新<code>Rectangle</code>的偏移。</p></li><li><p><strong>与动画状态链接</strong></p><p>将动画和状态变量结合起来，实现随状态改变而动画的效果。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ResponsiveView</span>: <span class="hljs-title class_">View</span> &#123;<br>    <span class="hljs-meta">@State</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> position <span class="hljs-operator">=</span> <span class="hljs-type">CGPoint</span>.zero<br><br>    <span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> &#123;<br>        <span class="hljs-type">Circle</span>()<br>            .position(position)<br>            .onTapGesture &#123;<br>                withAnimation &#123;<br>                    position <span class="hljs-operator">=</span> <span class="hljs-type">CGPoint</span>(x: position.x <span class="hljs-operator">+</span> <span class="hljs-number">100</span>, y: position.y <span class="hljs-operator">+</span> <span class="hljs-number">100</span>)<br>                &#125;<br>            &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里，每次点击都会使圆形移动，并伴随平滑的过渡动画。</p></li></ol><p><strong>响应式动画</strong></p><p>响应式动画则是指根据外部事件或数据的变化而自动触发的动画。例如，当接收到新消息时，提示符以动画的形式出现。</p><p><strong>实现响应式动画的方法</strong></p><ol><li><p><strong>数据绑定</strong></p><p>通过观察对象中的<code>@Published</code>属性变化来驱动动画。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AnimationViewModel</span>: <span class="hljs-title class_">ObservableObject</span> &#123;<br>    <span class="hljs-meta">@Published</span> <span class="hljs-keyword">var</span> isLoading <span class="hljs-operator">=</span> <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">LoadingView</span>: <span class="hljs-title class_">View</span> &#123;<br>    <span class="hljs-meta">@ObservedObject</span> <span class="hljs-keyword">var</span> viewModel <span class="hljs-operator">=</span> <span class="hljs-type">AnimationViewModel</span>()<br><br>    <span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> &#123;<br>        <span class="hljs-type">Circle</span>()<br>            .frame(width: <span class="hljs-number">50</span>, height: <span class="hljs-number">50</span>)<br>            .rotationEffect(<span class="hljs-type">Angle</span>(degrees: viewModel.isLoading <span class="hljs-operator">?</span> <span class="hljs-number">360</span> : <span class="hljs-number">0</span>))<br>            .animation(<span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">1</span>).repeatForever(autoreverses: <span class="hljs-literal">false</span>), value: viewModel.isLoading)<br>            .onAppear &#123;<br>                viewModel.isLoading <span class="hljs-operator">=</span> <span class="hljs-literal">true</span><br>            &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当<code>isLoading</code>变为<code>true</code>时，圆形会开始无限旋转，模拟加载指示器的效果。</p></li><li><p><strong>环境变量</strong></p><p>利用<code>@EnvironmentObject</code>或其他环境属性，在多个视图之间共享动画状态。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ContentView</span>: <span class="hljs-title class_">View</span> &#123;<br>    <span class="hljs-meta">@EnvironmentObject</span> <span class="hljs-keyword">var</span> userSettings: <span class="hljs-type">UserSettings</span><br><br>    <span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> &#123;<br>        <span class="hljs-type">Text</span>(userSettings.username)<br>            .scaleEffect(userSettings.isLoggedOut <span class="hljs-operator">?</span> <span class="hljs-number">0</span> : <span class="hljs-number">1</span>)<br>            .animation(.spring(), value: userSettings.isLoggedOut)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当用户注销时，用户名的文本会通过缩放动画消失。</p></li></ol><p><strong>小结</strong></p><p>交互式和响应式动画在提高应用的用户体验方面起着至关重要的作用。在SwiftUI中，你可以轻松地将动画与用户的交互以及应用的数据状态相结合。</p><p><strong>第4小节：转场动画</strong></p><p>转场动画是用户界面的一部分，它们在视图的呈现和消失时创造连贯的视觉效果。在SwiftUI中，转场是以声明的方式定义的，允许开发者指定添加或删除视图时的动画类型。利用转场，开发者可以提供一种流畅的视觉体验，减少用户界面变化对用户认知的干扰。</p><p><strong>基础转场</strong></p><p>SwiftUI提供了几种内置的转场类型，例如<code>.opacity</code>、<code>.slide</code>和<code>.scale</code>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ContentView</span>: <span class="hljs-title class_">View</span> &#123;<br>    <span class="hljs-meta">@State</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> isPresented <span class="hljs-operator">=</span> <span class="hljs-literal">false</span><br><br>    <span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> &#123;<br>        <span class="hljs-type">VStack</span> &#123;<br>            <span class="hljs-keyword">if</span> isPresented &#123;<br>                <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;Hello, World!&quot;</span>)<br>                    .transition(.slide)<br>            &#125;<br>            <span class="hljs-type">Button</span>(<span class="hljs-string">&quot;Toggle View&quot;</span>) &#123;<br>                withAnimation &#123;<br>                    isPresented.toggle()<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个示例中，当<code>isPresented</code>状态变化时，<code>Text</code>视图会滑入或滑出。</p><p><strong>组合转场</strong></p><p>你还可以组合多个转场来创建独特的效果：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs swift">.transition(.asymmetric(insertion: .scale, removal: .opacity))<br></code></pre></td></tr></table></figure><p>在这里，视图出现时使用缩放效果，消失时使用渐隐效果。</p><p><strong>自定义转场</strong></p><p>SwiftUI还允许创建自定义转场。这通常是通过定义视图的两种状态并描述它们之间的动画过渡来实现的。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">extension</span> <span class="hljs-title class_">AnyTransition</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> pivot: <span class="hljs-type">AnyTransition</span> &#123;<br>        .modifier(<br>            active: <span class="hljs-type">CornerRotateModifier</span>(amount: <span class="hljs-operator">-</span><span class="hljs-number">90</span>),<br>            identity: <span class="hljs-type">CornerRotateModifier</span>(amount: <span class="hljs-number">0</span>)<br>        )<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CornerRotateModifier</span>: <span class="hljs-title class_">ViewModifier</span> &#123;<br>    <span class="hljs-keyword">let</span> amount: <span class="hljs-type">Double</span><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">body</span>(<span class="hljs-params">content</span>: <span class="hljs-type">Content</span>) -&gt; <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> &#123;<br>        content.rotationEffect(<span class="hljs-type">Angle</span>(degrees: amount), anchor: .topLeading)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个自定义转场中，<code>pivot</code>通过旋转视图的顶部锚点实现转动效果。</p><p><strong>使用转场动画</strong></p><p>转场可以与<code>withAnimation</code>闭包结合使用，来实现视图状态变化时的平滑过渡。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-type">Button</span>(<span class="hljs-string">&quot;Toggle View&quot;</span>) &#123;<br>    withAnimation(.spring()) &#123;<br>        isPresented.toggle()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这将创建一个在点击按钮时视图呈现和消失时有弹簧动效的交互。</p><p><strong>小结</strong></p><p>转场动画在SwiftUI中为开发者提供了一个高效的方法来处理视图的呈现和消失，使用户界面更加生动和有趣。内置的转场类型适用于多数情况，而自定义转场则为特殊需求提供了无限的可能性。通过恰当使用转场，可以大大提升应用的质感和用户满意度。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;第8章：动画与转场&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第1小节：基础动画&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在SwiftUI中，动画是用来增强用户体验的一种手段，它可以提供平滑的视觉过渡和引人注目的交互。通过使用SwiftUI强大的动画API，你</summary>
      
    
    
    
    <category term="SwiftUI" scheme="http://xuebusi.gitee.io/categories/SwiftUI/"/>
    
    
  </entry>
  
  <entry>
    <title>SwiftUI核心技术第7章导航与呈现</title>
    <link href="http://xuebusi.gitee.io/2023/11/08/SwiftUI%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC7%E7%AB%A0%E5%AF%BC%E8%88%AA%E4%B8%8E%E5%91%88%E7%8E%B0/"/>
    <id>http://xuebusi.gitee.io/2023/11/08/SwiftUI%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC7%E7%AB%A0%E5%AF%BC%E8%88%AA%E4%B8%8E%E5%91%88%E7%8E%B0/</id>
    <published>2023-11-08T01:09:18.000Z</published>
    <updated>2024-03-17T06:11:38.648Z</updated>
    
    <content type="html"><![CDATA[<p><strong>第7章：导航与呈现</strong></p><p><strong>1. NavigationView和NavigationViewLink</strong></p><p>在SwiftUI中，<code>NavigationView</code>和<code>NavigationLink</code>组合起来使用，提供了一个强大的导航框架，让我们可以构建具有层次结构的页面间跳转。它们的设计遵循了SwiftUI的声明式语法，使得页面跳转和数据传递变得直观和易于管理。</p><p><strong>NavigationView</strong></p><p><code>NavigationView</code>是一个容器视图，它承载着你的视图层次结构，并提供了展示这些视图的空间。你可以把它看作是页面导航的起点。通常，一个<code>NavigationView</code>包含一个或多个<code>View</code>，这些<code>View</code>可以通过<code>NavigationLink</code>来进行跳转。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-type">NavigationView</span> &#123;<br>    <span class="hljs-type">List</span>(selection: <span class="hljs-variable">$selectedItem</span>) &#123;<br>        <span class="hljs-type">NavigationLink</span>(destination: <span class="hljs-type">DetailView</span>(item: item)) &#123;<br>            <span class="hljs-type">Text</span>(item.title)<br>        &#125;<br>    &#125;<br>    .navigationBarTitle(<span class="hljs-type">Text</span>(<span class="hljs-string">&quot;Items&quot;</span>))<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>NavigationView</code>包含了一个列表，列表中的每一项都绑定了一个<code>NavigationLink</code>，点击时将展示<code>DetailView</code>。</p><p><strong>NavigationLink</strong></p><p><code>NavigationLink</code>负责在<code>NavigationView</code>中触发页面跳转。它有多个初始化方法，可以根据需求选择使用。最基本的用法是提供一个目标视图和触发跳转的内容。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-type">NavigationLink</span>(destination: <span class="hljs-type">DetailView</span>(item: item)) &#123;<br>    <span class="hljs-type">Text</span>(item.title)<br>&#125;<br></code></pre></td></tr></table></figure><p>这里<code>NavigationLink</code>的目的地是<code>DetailView</code>，用户点击列表项上的<code>Text</code>时会触发导航到<code>DetailView</code>。</p><p><strong>激活和反激活链接</strong></p><p><code>NavigationLink</code>可以与SwiftUI的状态绑定，以编程方式激活或反激活导航。通过在<code>NavigationLink</code>初始化时传递一个布尔型的绑定，你可以控制导航的行为。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-meta">@State</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> isLinkActive <span class="hljs-operator">=</span> <span class="hljs-literal">false</span><br><br><span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> &#123;<br>    <span class="hljs-type">NavigationView</span> &#123;<br>        <span class="hljs-type">NavigationLink</span>(destination: <span class="hljs-type">DetailView</span>(), isActive: <span class="hljs-variable">$isLinkActive</span>) &#123;<br>            <span class="hljs-type">Button</span>(<span class="hljs-string">&quot;Go to Details&quot;</span>) &#123;<br>                <span class="hljs-keyword">self</span>.isLinkActive <span class="hljs-operator">=</span> <span class="hljs-literal">true</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，一个按钮被用来激活<code>NavigationLink</code>。当用户点击按钮，<code>isLinkActive</code>状态变为<code>true</code>，触发导航到<code>DetailView</code>。</p><p><strong>传递数据</strong></p><p>在导航过程中，你可能需要向目的地视图传递数据。<code>NavigationLink</code>的<code>destination</code>参数让你可以轻松做到这一点。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-type">NavigationLink</span>(destination: <span class="hljs-type">DetailView</span>(item: item)) &#123;<br>    <span class="hljs-type">ItemRow</span>(item: item)<br>&#125;<br></code></pre></td></tr></table></figure><p>在这里，每个<code>ItemRow</code>是一个列表中的行，它带有一个与之关联的<code>item</code>数据模型。点击<code>ItemRow</code>时，<code>item</code>将被传递到<code>DetailView</code>。</p><p><strong>小结</strong></p><p><code>NavigationView</code>和<code>NavigationLink</code>构成了SwiftUI中页面导航的基石。它们的使用方式灵活而强大，支持各种复杂的导航模式。通过声明式语法，我们可以更专注于视图的内容和业务逻辑，而不是导航的细节。本章节的后续部分将探讨更高级的导航模式，如使用<code>TabView</code>和<code>modal</code>呈现，以及如何处理数据传递和状态管理。</p><p><strong>2. TabView</strong></p><p>在构建一个用户界面时，底部的标签栏是一种常见的设计，允许用户轻松切换不同的视图或功能模块。在SwiftUI中，这可以通过<code>TabView</code>来实现。<code>TabView</code>为应用提供了一个选项卡式的界面，每个选项卡都代表了一个视图。</p><p><strong>基本用法</strong></p><p><code>TabView</code>的基本用法涉及到声明式地列出每一个选项卡，并使用<code>tabItem</code>修饰符来定义每个标签的外观，通常包括图标和文本。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-type">TabView</span> &#123;<br>    <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;首页&quot;</span>)<br>        .tabItem &#123;<br>            <span class="hljs-type">Image</span>(systemName: <span class="hljs-string">&quot;house&quot;</span>)<br>            <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;Home&quot;</span>)<br>        &#125;<br>    <br>    <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;设置&quot;</span>)<br>        .tabItem &#123;<br>            <span class="hljs-type">Image</span>(systemName: <span class="hljs-string">&quot;gear&quot;</span>)<br>            <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;Settings&quot;</span>)<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个简单的例子中，<code>TabView</code>包含了两个选项卡：“首页”和“设置”，每个选项卡都是用<code>Text</code>视图表示的，并且有对应的系统图标。</p><p><strong>选项卡状态管理</strong></p><p><code>TabView</code>可以与<code>@State</code>变量绑定，从而允许你编程方式控制当前激活的选项卡。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-meta">@State</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> selectedTab <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br><br><span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> &#123;<br>    <span class="hljs-type">TabView</span>(selection: <span class="hljs-variable">$selectedTab</span>) &#123;<br>        <span class="hljs-type">HomeView</span>()<br>            .tabItem &#123;<br>                <span class="hljs-type">Image</span>(systemName: <span class="hljs-string">&quot;house&quot;</span>)<br>                <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;Home&quot;</span>)<br>            &#125;<br>            .tag(<span class="hljs-number">0</span>)<br>        <br>        <span class="hljs-type">SettingsView</span>()<br>            .tabItem &#123;<br>                <span class="hljs-type">Image</span>(systemName: <span class="hljs-string">&quot;gear&quot;</span>)<br>                <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;Settings&quot;</span>)<br>            &#125;<br>            .tag(<span class="hljs-number">1</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述代码中，<code>selectedTab</code>绑定到<code>TabView</code>的<code>selection</code>参数。通过改变<code>selectedTab</code>的值，你可以改变当前选中的标签页。</p><p><strong>自定义外观</strong></p><p><code>TabView</code>的外观可以通过多种方式进行自定义。例如，可以使用<code>.accentColor</code>来改变选中标签的颜色。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-type">TabView</span> &#123;<br>    <span class="hljs-comment">// ... 你的选项卡</span><br>&#125;<br>.accentColor(.green)<br></code></pre></td></tr></table></figure><p><strong>结合NavigationView使用</strong></p><p>在<code>TabView</code>内部，你可能还会嵌入<code>NavigationView</code>，以在选项卡内部提供导航堆栈。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-type">TabView</span> &#123;<br>    <span class="hljs-type">NavigationView</span> &#123;<br>        <span class="hljs-type">HomeView</span>()<br>    &#125;<br>    .tabItem &#123;<br>        <span class="hljs-type">Image</span>(systemName: <span class="hljs-string">&quot;house&quot;</span>)<br>        <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;Home&quot;</span>)<br>    &#125;<br>    <span class="hljs-comment">// ... 其他选项卡</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这样做可以确保每个选项卡都能拥有独立的导航历史，这对于用户体验非常重要。</p><p><strong>使用场景</strong></p><p><code>TabView</code>在很多类型的应用中都非常有用。它是构建具有多个独立部分的应用的理想选择，例如社交网络应用、具有个人中心、消息、设置等的应用。</p><p><strong>小结</strong></p><p>通过本节的介绍，我们了解了如何使用<code>TabView</code>创建具有多个交互式选项卡的界面。<code>TabView</code>不仅提供了高度的可定制性，还能够很好地与其他视图和数据流模式协同工作。在接下来的小节中，我们将继续探索更多关于SwiftUI中视图呈现和数据流管理的先进概念。</p><p><strong>3. Sheets和Alerts</strong></p><p>在构建应用时，弹出视图和警告框（Alerts）是与用户交互的重要方式。在SwiftUI中，这通常通过使用<code>Sheet</code>和<code>Alert</code>视图完成。</p><p><strong>Sheets</strong></p><p>Sheet是一种覆盖在当前内容上的卡片样式视图，通常用于导航流程之外的辅助任务，比如表单填写、设置选项等。</p><p><strong>创建Sheet</strong></p><p>要创建一个Sheet，你需要使用<code>.sheet</code>修饰符，并为其提供一个绑定的布尔值，这个布尔值决定Sheet是否可见。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-meta">@State</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> showingSheet <span class="hljs-operator">=</span> <span class="hljs-literal">false</span><br><br><span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> &#123;<br>    <span class="hljs-type">Button</span>(<span class="hljs-string">&quot;Show Sheet&quot;</span>) &#123;<br>        showingSheet.toggle()<br>    &#125;<br>    .sheet(isPresented: <span class="hljs-variable">$showingSheet</span>) &#123;<br>        <span class="hljs-comment">// Sheet的内容</span><br>        <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;Here&#x27;s the Sheet&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>自定义Sheet</strong></p><p>Sheet的内容可以是任意视图。例如，你可以创建一个包含表单的<code>NavigationView</code>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs swift">.sheet(isPresented: <span class="hljs-variable">$showingSheet</span>) &#123;<br>    <span class="hljs-type">NavigationView</span> &#123;<br>        <span class="hljs-type">Form</span> &#123;<br>            <span class="hljs-comment">// 表单内容</span><br>        &#125;<br>        .navigationBarTitle(<span class="hljs-string">&quot;Settings&quot;</span>, displayMode: .inline)<br>        .navigationBarItems(trailing: <span class="hljs-type">Button</span>(<span class="hljs-string">&quot;Done&quot;</span>) &#123;<br>            showingSheet <span class="hljs-operator">=</span> <span class="hljs-literal">false</span><br>        &#125;)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>使用Sheet实现细节</strong></p><p>在内部，Sheet会自动管理自己的显示和隐藏。你可以将<code>showingSheet</code>绑定到视图的某个状态或者对象的属性上，当这个属性变化时，对应的Sheet会自动显示或隐藏。</p><p><strong>Alerts</strong></p><p>Alerts用于显示重要信息，并可以提供一个或多个操作选项。</p><p><strong>创建Alert</strong></p><p>和Sheet类似，Alert也使用绑定的布尔值来控制显示状态。不过，创建Alert时，通常还会指定标题、消息和按钮。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-meta">@State</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> showingAlert <span class="hljs-operator">=</span> <span class="hljs-literal">false</span><br><br><span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> &#123;<br>    <span class="hljs-type">Button</span>(<span class="hljs-string">&quot;Show Alert&quot;</span>) &#123;<br>        showingAlert <span class="hljs-operator">=</span> <span class="hljs-literal">true</span><br>    &#125;<br>    .alert(isPresented: <span class="hljs-variable">$showingAlert</span>) &#123;<br>        <span class="hljs-type">Alert</span>(<br>            title: <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;Warning&quot;</span>),<br>            message: <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;Are you sure?&quot;</span>),<br>            primaryButton: .destructive(<span class="hljs-type">Text</span>(<span class="hljs-string">&quot;Delete&quot;</span>)) &#123;<br>                <span class="hljs-comment">// 删除操作</span><br>            &#125;,<br>            secondaryButton: .cancel()<br>        )<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Alert的样式</strong></p><p>Alert可以有多种样式，从简单的带有单一按钮的Alert到复杂的带有多个按钮和自定义操作的Alert。</p><p><strong>小结</strong></p><p>Sheet和Alert都是在SwiftUI中管理临时视图和用户交互的重要工具。通过合理使用这两种视图，你可以创建出既直观又有效的用户体验。正如我们所见，SwiftUI提供的<code>.sheet</code>和<code>.alert</code>修饰符让这两种视图的展示和管理变得十分简单。在接下来的章节中，我们将深入探讨如何利用SwiftUI的高级特性来构建更为复杂的用户交互界面。</p><p><strong>4. Navigation的高级用法</strong></p><p>SwiftUI的导航系统提供了一种直观且声明式的方法来处理视图间的转换。除了基础的<code>NavigationView</code>和<code>NavigationLink</code>之外，我们还可以采用更高级的用法来增强用户体验和视图的灵活性。</p><p><strong>程序化导航</strong></p><p>在某些情况下，你可能需要从视图模型或响应某个事件时进行导航。这可以通过绑定到视图模型中的属性并使用<code>NavigationLink</code>的<code>isActive</code>参数实现。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ViewModel</span>: <span class="hljs-title class_">ObservableObject</span> &#123;<br>    <span class="hljs-meta">@Published</span> <span class="hljs-keyword">var</span> isDetailViewActive <span class="hljs-operator">=</span> <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ContentView</span>: <span class="hljs-title class_">View</span> &#123;<br>    <span class="hljs-meta">@StateObject</span> <span class="hljs-keyword">var</span> viewModel <span class="hljs-operator">=</span> <span class="hljs-type">ViewModel</span>()<br><br>    <span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> &#123;<br>        <span class="hljs-type">NavigationView</span> &#123;<br>            <span class="hljs-type">NavigationLink</span>(destination: <span class="hljs-type">DetailView</span>(), isActive: <span class="hljs-variable">$viewModel</span>.isDetailViewActive) &#123; <br>                <span class="hljs-type">EmptyView</span>()<br>            &#125;<br>            <span class="hljs-type">Button</span>(<span class="hljs-string">&quot;Go to Details&quot;</span>) &#123;<br>                viewModel.isDetailViewActive <span class="hljs-operator">=</span> <span class="hljs-literal">true</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>隐藏和显示导航栏</strong></p><p>在用户界面中，有时候我们需要隐藏导航栏来提供沉浸式体验，或者我们需要在特定的视图中改变导航栏的显示方式。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DetailView</span>: <span class="hljs-title class_">View</span> &#123;<br>    <span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> &#123;<br>        <span class="hljs-comment">// 隐藏导航栏</span><br>        .navigationBarHidden(<span class="hljs-literal">true</span>)<br>        <span class="hljs-comment">// 在视图即将出现时设置导航栏样式</span><br>        .onAppear &#123;<br>            <span class="hljs-comment">// 设置导航栏样式</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>自定义后退按钮行为</strong></p><p>有时默认的后退按钮行为并不符合我们的需要。在SwiftUI中，我们可以通过添加一个自定义的按钮并绑定其行为来覆盖默认的后退按钮。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CustomBackButtonView</span>: <span class="hljs-title class_">View</span> &#123;<br>    <span class="hljs-meta">@Environment</span>(\.presentationMode) <span class="hljs-keyword">var</span> presentationMode<br><br>    <span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> &#123;<br>        <span class="hljs-type">Button</span>(action: &#123;<br>            <span class="hljs-comment">// 执行自定义后退操作</span><br>            presentationMode.wrappedValue.dismiss()<br>        &#125;) &#123;<br>            <span class="hljs-type">HStack</span> &#123;<br>                <span class="hljs-type">Image</span>(systemName: <span class="hljs-string">&quot;arrow.left&quot;</span>)<br>                <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;Back&quot;</span>)<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>深度链接</strong></p><p>深度链接是指直接导航到应用内部的某个特定页面的链接。在SwiftUI中，我们可以监听来自URL的深度链接，并根据链接的内容导航到相应的视图。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs swift">.onOpenURL &#123; url <span class="hljs-keyword">in</span><br>    <span class="hljs-comment">// 解析URL并进行导航</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>嵌套导航</strong></p><p>在构建复杂的界面时，我们可能会需要嵌套多个<code>NavigationView</code>。虽然这在用户界面上并不常见，但在特定的设计中可能是必要的。嵌套导航需要细心处理，以确保导航栈的正确和流畅的用户体验。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-type">NavigationView</span> &#123;<br>    <span class="hljs-comment">// 主界面</span><br>    <span class="hljs-type">NavigationView</span> &#123;<br>        <span class="hljs-comment">// 嵌套的子界面</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>小结</strong></p><p>通过上述高级导航功能，开发者可以在SwiftUI中创建复杂且具有出色用户体验的导航流。这些高级技巧的掌握可以帮助你更好地管理视图层级和导航逻辑，让应用的导航更加直观和响应用户操作。在后续章节中，我们将探索如何将这些高级导航技巧与应用的其它部分相结合，以构建完整且功能丰富的应用程序。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;第7章：导航与呈现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. NavigationView和NavigationViewLink&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在SwiftUI中，&lt;code&gt;NavigationView&lt;/code&gt;和&lt;cod</summary>
      
    
    
    
    <category term="SwiftUI" scheme="http://xuebusi.gitee.io/categories/SwiftUI/"/>
    
    
  </entry>
  
  <entry>
    <title>SwiftUI核心技术第6章数据流与绑定</title>
    <link href="http://xuebusi.gitee.io/2023/11/08/SwiftUI%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC6%E7%AB%A0%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%8E%E7%BB%91%E5%AE%9A/"/>
    <id>http://xuebusi.gitee.io/2023/11/08/SwiftUI%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC6%E7%AB%A0%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%8E%E7%BB%91%E5%AE%9A/</id>
    <published>2023-11-08T00:52:43.000Z</published>
    <updated>2024-03-17T06:11:34.626Z</updated>
    
    <content type="html"><![CDATA[<p><strong>第6章：数据流与绑定</strong></p><p><strong>1. State和Binding</strong></p><p>在SwiftUI中，数据流的管理是构建动态和响应式用户界面的核心。<code>State</code>和<code>Binding</code>是实现这种数据流动的基本工具，它们使得数据和视图能够保持同步。</p><p><strong>State：拥有数据的真相</strong></p><p><code>@State</code> 是一个属性包装器，用于声明SwiftUI管理的状态。这个状态是私有的，仅在当前视图内部使用。当状态变化时，SwiftUI会自动重新绘制依赖于这个状态的视图部分。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ContentView</span>: <span class="hljs-title class_">View</span> &#123;<br>    <span class="hljs-meta">@State</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> isToggled <span class="hljs-operator">=</span> <span class="hljs-literal">false</span><br><br>    <span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> &#123;<br>        <span class="hljs-type">Toggle</span>(<span class="hljs-string">&quot;开关&quot;</span>, isOn: <span class="hljs-variable">$isToggled</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的例子中，<code>isToggled</code> 是一个布尔状态，与一个开关绑定。当用户切换开关时，<code>isToggled</code> 的值会改变，触发视图的更新。</p><p><strong>Binding：连接状态和视图</strong></p><p><code>Binding</code> 提供了对某个状态的读写权限，但不拥有这个状态本身。通过<code>$</code>符号，我们可以从一个<code>@State</code>变量创建一个<code>Binding</code>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ToggleView</span>: <span class="hljs-title class_">View</span> &#123;<br>    <span class="hljs-meta">@Binding</span> <span class="hljs-keyword">var</span> isOn: <span class="hljs-type">Bool</span><br><br>    <span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> &#123;<br>        <span class="hljs-type">Toggle</span>(<span class="hljs-string">&quot;开关&quot;</span>, isOn: <span class="hljs-variable">$isOn</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>ToggleView</code> 需要一个<code>Binding</code>来控制开关的状态，这个<code>Binding</code>可以从父视图的<code>@State</code>中派生而来。</p><p><strong>使用State和Binding</strong></p><p>在实际的应用中，<code>@State</code>适用于简单的局部状态管理，如界面的某个开关、文本输入框的内容等。当状态改变时，只有使用到该状态的视图会重新渲染，从而优化了性能。</p><p><code>@Binding</code>则用于将状态的控制权从一个视图传递到另一个视图。例如，在一个父视图中定义了<code>@State</code>，那么就可以将这个状态以<code>Binding</code>的形式传递给子视图，让子视图能够读取并修改这个状态。</p><p><strong>State和视图的生命周期</strong></p><p>理解<code>@State</code>与视图的生命周期是紧密相关的也很重要。当一个视图被SwiftUI重新绘制时，<code>@State</code>所持有的状态会被保留下来。这意味着状态的变更是持久的，即使视图的某些其他部分可能因为不同的原因而重新渲染。</p><p><strong>总结</strong></p><p><code>State</code>和<code>Binding</code>是SwiftUI中数据流的基础。<code>@State</code>用于创建可变的状态，当状态变化时，视图会响应这些变化。而<code>Binding</code>则用于在视图之间共享状态，允许多个视图共同拥有和修改状态。通过恰当地使用这两个工具，我们可以创建出既简洁又高效的响应式用户界面。在接下来的章节中，我们将深入探讨如何在更复杂的应用架构中管理状态和数据流。</p><p><strong>2. ObservedObject和EnvironmentObject</strong></p><p>在构建复杂的SwiftUI应用时，我们经常需要处理跨多个视图共享的数据。在这种情况下，仅使用<code>@State</code>和<code>@Binding</code>可能不够用，因为它们主要用于单个视图或其直接子视图的状态管理。这时，<code>@ObservedObject</code>和<code>@EnvironmentObject</code>就成为了重要的工具。</p><p><strong>ObservedObject：动态数据的监听者</strong></p><p><code>@ObservedObject</code>用于绑定外部的可观察对象（通常是遵循<code>ObservableObject</code>协议的类实例），当可观察对象发出变化通知时，视图会重新渲染以反映新的数据。</p><p>这里有一个<code>ObservableObject</code>的示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserData</span>: <span class="hljs-title class_">ObservableObject</span> &#123;<br>    <span class="hljs-meta">@Published</span> <span class="hljs-keyword">var</span> username: <span class="hljs-type">String</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;用户&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>@Published</code>属性包装器用于标记会发生变化的数据。一旦<code>username</code>的值发生变更，就会自动通知所有的观察者。</p><p>在视图中使用<code>@ObservedObject</code>：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">UserView</span>: <span class="hljs-title class_">View</span> &#123;<br>    <span class="hljs-meta">@ObservedObject</span> <span class="hljs-keyword">var</span> userData: <span class="hljs-type">UserData</span><br><br>    <span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> &#123;<br>        <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;用户名: <span class="hljs-subst">\(userData.username)</span>&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>UserView</code>中，<code>userData</code>作为一个<code>@ObservedObject</code>提供了对<code>UserData</code>实例的引用。当<code>username</code>更新时，<code>UserView</code>也会更新其显示。</p><p><strong>EnvironmentObject：跨层级的数据共享</strong></p><p><code>@EnvironmentObject</code>是一种特殊类型的数据流工具，它可以让数据在视图层级间传递而不需要显式地通过参数传递。它非常适合那些被多个视图访问的全局数据或设置。</p><p>首先，你需要在某个父视图中将数据对象添加到环境中：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">@main</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyApp</span>: <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">Scene</span> &#123;<br>        <span class="hljs-type">WindowGroup</span> &#123;<br>            <span class="hljs-type">ContentView</span>()<br>                .environmentObject(<span class="hljs-type">UserData</span>())<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后，在子视图中，你可以直接通过<code>@EnvironmentObject</code>来访问这个数据对象：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ProfileView</span>: <span class="hljs-title class_">View</span> &#123;<br>    <span class="hljs-meta">@EnvironmentObject</span> <span class="hljs-keyword">var</span> userData: <span class="hljs-type">UserData</span><br><br>    <span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> &#123;<br>        <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;欢迎, <span class="hljs-subst">\(userData.username)</span>!&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>不需要显式地从父视图传递<code>UserData</code>到<code>ProfileView</code>，<code>ProfileView</code>可以直接从环境中获取这个对象。</p><p><strong>总结</strong></p><p><code>@ObservedObject</code>和<code>@EnvironmentObject</code>为我们提供了强大的数据管理能力，使得数据在视图之间传递变得简单且高效。它们都依赖于<code>ObservableObject</code>协议来观察数据模型的变化并响应更新。<code>@ObservedObject</code>适用于需要直接引用的情况，而<code>@EnvironmentObject</code>更适合于全局或共享数据的情况，尤其是在视图层级较深时。</p><p>在接下来的内容中，我们将探讨这些数据流工具如何与SwiftUI的声明式UI框架协同工作，以及如何利用它们来构建响应式和可维护的应用架构。</p><p><strong>3. @Published和Combine</strong></p><p>在SwiftUI中，数据的流动和管理是构建应用的核心。为了实现响应式的数据流，SwiftUI密切结合了Combine框架。Combine是一个响应式编程框架，它可以处理所有类型的异步事件。<code>@Published</code>是Combine框架中的一个关键特性，它用于创建可观察的对象属性，当这些属性的值发生变化时，它会自动通知系统。</p><p><strong>使用@Published</strong></p><p>使用<code>@Published</code>可以很容易地将一个类属性变成响应式的属性。这意味着，当属性的值改变时，所有订阅了这个属性的订阅者都会接收到通知，并且可以响应这些变化。</p><p>下面是一个使用<code>@Published</code>的例子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">import</span> Combine<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProfileViewModel</span>: <span class="hljs-title class_">ObservableObject</span> &#123;<br>    <span class="hljs-meta">@Published</span> <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-meta">@Published</span> <span class="hljs-keyword">var</span> age: <span class="hljs-type">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>ProfileViewModel</code>是一个遵循<code>ObservableObject</code>协议的类，它有两个<code>@Published</code>属性：<code>name</code>和<code>age</code>。当这些属性中的任何一个的值改变时，所有的观察者都会得到通知。</p><p><strong>整合Combine</strong></p><p>Combine框架的强大之处在于它可以让你定义复杂的数据处理和变换流程。例如，你可以对输入进行校验、过滤、转换，然后将处理后的数据传递到UI或其他部分。</p><p>这里是如何使用Combine订阅<code>@Published</code>属性变化的例子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> cancellables <span class="hljs-operator">=</span> <span class="hljs-type">Set</span>&lt;<span class="hljs-type">AnyCancellable</span>&gt;()<br><br><span class="hljs-keyword">let</span> profileVM <span class="hljs-operator">=</span> <span class="hljs-type">ProfileViewModel</span>()<br>profileVM.<span class="hljs-variable">$name</span><br>    .sink &#123; name <span class="hljs-keyword">in</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Name is now <span class="hljs-subst">\(name)</span>&quot;</span>)<br>    &#125;<br>    .store(in: <span class="hljs-operator">&amp;</span>cancellables)<br></code></pre></td></tr></table></figure><p>在这段代码中，<code>$name</code>是对<code>name</code>属性的Publisher访问。<code>.sink</code>方法会接收一个闭包，这个闭包会在每次<code>name</code>属性更新时被调用。<code>.store(in:)</code>方法用于管理订阅生命周期，防止早期释放。</p><p><strong>结合SwiftUI视图</strong></p><p>在SwiftUI中，你通常不需要直接处理订阅，因为SwiftUI视图可以直接使用<code>@ObservedObject</code>或<code>@EnvironmentObject</code>来绑定到可观察的对象。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ProfileView</span>: <span class="hljs-title class_">View</span> &#123;<br>    <span class="hljs-meta">@ObservedObject</span> <span class="hljs-keyword">var</span> viewModel: <span class="hljs-type">ProfileViewModel</span><br><br>    <span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> &#123;<br>        <span class="hljs-type">TextField</span>(<span class="hljs-string">&quot;Name&quot;</span>, text: <span class="hljs-variable">$viewModel</span>.name)<br>        <span class="hljs-type">TextField</span>(<span class="hljs-string">&quot;Age&quot;</span>, value: <span class="hljs-variable">$viewModel</span>.age, formatter: <span class="hljs-type">NumberFormatter</span>())<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>ProfileView</code>中，每当<code>viewModel</code>的<code>name</code>或<code>age</code>属性变化时，视图会自动更新。</p><p><strong>小结</strong></p><p><code>@Published</code>与Combine框架结合使用，为SwiftUI应用带来了强大的响应式编程能力。这种模式不仅使状态管理变得简洁，还能够创建可维护和可扩展的数据流处理逻辑。随着你深入本书，你将会看到更多关于Combine在实际SwiftUI应用中的强大用例和模式。</p><p><strong>4. 数据流的最佳实践</strong></p><p>在构建SwiftUI应用时，高效和可维护的数据流管理是非常重要的。为了达到这个目标，我们需要遵循一些最佳实践来确保我们的应用结构清晰，数据流动合理。以下是在使用SwiftUI时应考虑的数据流最佳实践。</p><p><strong>一、明确数据源的单一真相</strong></p><p>在任何给定的时刻，应用的每个数据点都应该有一个清晰的，可信的来源。这意味着对于任何可变的数据，都应该有一个单一的可信源，而所有视图的状态应反映这个来源。使用<code>@State</code>的私有属性用于视图的内部状态，而模型对象中的<code>@Published</code>属性用于应用范围的状态。</p><p><strong>二、使用单向数据流</strong></p><p>在SwiftUI中，数据应该从父视图流向子视图（单向数据流）。父视图传递数据到子视图，子视图通过事件传递回父视图，而不是直接修改父视图的状态。这样可以避免复杂的数据依赖和潜在的循环更新问题。</p><p><strong>三、合理使用@State，@Binding，@ObservedObject，和@EnvironmentObject</strong></p><ul><li><strong>@State</strong> 应当用于视图的局部状态管理，不应跨越多个视图。</li><li><strong>@Binding</strong> 允许子视图与父视图的状态或模型中的数据进行通信。</li><li><strong>@ObservedObject</strong> 用于当视图需要响应外部模型对象变化时。</li><li><strong>@EnvironmentObject</strong> 适用于多个视图需要访问同一共享数据对象的情况。</li></ul><p><strong>四、谨慎管理生命周期</strong></p><p>识别并管理数据对象的生命周期，尤其是当使用<code>@ObservedObject</code>或<code>@EnvironmentObject</code>时。避免不必要的重新创建对象，以减少内存使用和性能损耗。</p><p><strong>五、精细控制数据变更</strong></p><p>使用<code>objectWillChange</code>手动发送变更通知可以精细控制观察的对象何时更新UI。当需要优化性能或处理复杂的数据变更时这非常有用。</p><p><strong>六、利用Combine进行复杂的数据操作</strong></p><p>Combine框架提供了一套完整的工具，用于处理复杂的数据转换和异步操作。应充分利用这些工具来实现复杂的数据流和事件处理。</p><p><strong>七、避免内存泄漏</strong></p><p>当处理数据流和绑定时，确保正确管理订阅，使用<code>AnyCancellable</code>存储返回的订阅，并在不需要时取消订阅，以避免内存泄漏。</p><p><strong>八、编写可测试的代码</strong></p><p>将数据处理逻辑抽象到可单独测试的模型和服务中。避免将业务逻辑放入视图中，这样可以让代码更容易被测试和维护。</p><p><strong>小结</strong></p><p>遵循上述的数据流最佳实践将有助于您构建出高效、稳定且易于维护的SwiftUI应用。确保理解和正确应用每一种属性装饰器和Combine操作符是至关重要的。本书后续章节将会进一步深入这些概念，并结合实例演示如何在真实世界的应用中实践这些最佳实践。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;第6章：数据流与绑定&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. State和Binding&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在SwiftUI中，数据流的管理是构建动态和响应式用户界面的核心。&lt;code&gt;State&lt;/code&gt;和&lt;code&gt;Bin</summary>
      
    
    
    
    <category term="SwiftUI" scheme="http://xuebusi.gitee.io/categories/SwiftUI/"/>
    
    
  </entry>
  
  <entry>
    <title>SwiftUI核心技术第5章布局管理</title>
    <link href="http://xuebusi.gitee.io/2023/11/08/SwiftUI%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC5%E7%AB%A0%E5%B8%83%E5%B1%80%E7%AE%A1%E7%90%86/"/>
    <id>http://xuebusi.gitee.io/2023/11/08/SwiftUI%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC5%E7%AB%A0%E5%B8%83%E5%B1%80%E7%AE%A1%E7%90%86/</id>
    <published>2023-11-08T00:47:49.000Z</published>
    <updated>2024-03-17T06:11:17.149Z</updated>
    
    <content type="html"><![CDATA[<p><strong>第5章：布局管理</strong></p><p><strong>1. 堆（Stacks）</strong></p><p>在SwiftUI中，布局是通过组合不同的视图和使用布局容器来实现的，其中最基础和最常用的布局容器是堆（Stack）。Stacks在SwiftUI中主要有三种类型：<code>HStack</code>、<code>VStack</code>和<code>ZStack</code>，它们分别代表水平堆、垂直堆和覆盖堆。通过这三种Stack，可以构建出复杂的布局结构。</p><p><strong>理解堆的工作方式</strong></p><ul><li><code>HStack</code>（水平堆）将其子视图沿着水平轴排列。</li><li><code>VStack</code>（垂直堆）将子视图沿着垂直轴排列。</li><li><code>ZStack</code>（覆盖堆）则将子视图按照代码中的顺序覆盖排列，即先声明的视图会被后声明的视图覆盖。</li></ul><p><strong>使用HStack和VStack管理布局</strong></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-type">VStack</span>(alignment: .leading, spacing: <span class="hljs-number">10</span>) &#123;<br>    <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;第一行&quot;</span>)<br>    <span class="hljs-type">HStack</span> &#123;<br>        <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;左侧&quot;</span>)<br>        <span class="hljs-type">Spacer</span>() <span class="hljs-comment">// Spacer会推动旁边的视图尽可能远的距离</span><br>        <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;右侧&quot;</span>)<br>    &#125;<br>    <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;第二行&quot;</span>)<br>&#125;<br>.padding() <span class="hljs-comment">// 对VStack添加内边距</span><br></code></pre></td></tr></table></figure><p>在上面的代码示例中，我们首先创建了一个<code>VStack</code>，其子视图之间有10点的间距，并且它们在水平方向上左对齐。在这个垂直堆中，我们有两行文本和一个<code>HStack</code>。在<code>HStack</code>中，两个文本视图被一个<code>Spacer</code>隔开，这会推动这些文本视图到<code>HStack</code>的两侧。</p><p><strong>ZStack的层叠效果</strong></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-type">ZStack</span> &#123;<br>    <span class="hljs-type">Image</span>(<span class="hljs-string">&quot;background&quot;</span>)<br>        .resizable()<br>        .aspectRatio(contentMode: .fill)<br>    <span class="hljs-type">VStack</span> &#123;<br>        <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;层叠的顶部文本&quot;</span>)<br>            .font(.largeTitle)<br>            .foregroundColor(.white)<br>        <span class="hljs-type">Spacer</span>()<br>    &#125;<br>&#125;<br>.frame(height: <span class="hljs-number">300</span>) <span class="hljs-comment">// 设置ZStack的高度</span><br>.clipped() <span class="hljs-comment">// 保证图片不会超出ZStack的边界</span><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>ZStack</code>用于创建层叠效果。它首先放置了一张背景图片，然后在图片上层放置了一个<code>VStack</code>，其中包含了一行文本。</p><p><strong>使用堆的布局行为</strong></p><ul><li><code>Stacks</code>默认会尽可能地占据父视图提供的空间，除非使用<code>frame</code>、<code>edgesIgnoringSafeArea</code>、<code>fixedSize</code>等修饰符进行限制。</li><li><code>alignment</code>参数控制子视图在交叉轴上的对齐方式（对于<code>HStack</code>是垂直对齐，对于<code>VStack</code>是水平对齐）。</li><li><code>spacing</code>参数决定子视图之间的间距。</li></ul><p><strong>对齐和分布</strong></p><p>Stacks的另一个关键特性是对齐。开发者可以非常细致地控制如何对齐子视图：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-type">HStack</span>(alignment: .top) &#123;<br>    <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;顶部对齐&quot;</span>)<br>    <span class="hljs-type">Divider</span>()<br>    <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;还是顶部对齐&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个<code>HStack</code>中，所有的子视图都会在顶部对齐，即使它们的高度不同。</p><p><strong>总结</strong></p><p>通过理解和利用Stacks，你可以构建出直观且灵活的布局。Stacks的简单性和强大的组合能力，使得它们成为SwiftUI布局的核心工具。它们可以嵌套使用，也可以与其他布局视图和控件配合，以创建出复杂且响应式的用户界面。随着你</p><p>对这些基础布局工具的熟悉和运用，你将能够更加精准地操控空间，为你的应用提供坚实的视觉基础。</p><p><strong>2. 对齐与帧（Alignment and Frames）</strong></p><p>布局的精髓在于如何控制视图的大小和位置。在SwiftUI中，<code>对齐</code>和<code>帧</code>是两个基本但强大的概念，它们定义了视图在父视图中的具体摆放方式。</p><p><strong>理解对齐</strong></p><p>对齐在SwiftUI中是通过对齐指南来实现的，它定义了视图如何根据父视图或兄弟视图的对齐线来定位自己。例如，在一个<code>VStack</code>中，你可以通过<code>alignment</code>参数设置子视图在水平方向上的对齐方式，而在<code>HStack</code>中，这会影响子视图在垂直方向上的对齐。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-type">HStack</span>(alignment: .bottom) &#123;<br>    <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;底部对齐&quot;</span>)<br>    <span class="hljs-type">Image</span>(systemName: <span class="hljs-string">&quot;star&quot;</span>)<br>        .alignmentGuide(.bottom) &#123; d <span class="hljs-keyword">in</span> d[.top] &#125;<br>    <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;这个星星将对齐顶部&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，我们通过<code>.alignmentGuide</code>修饰符来改变图像视图的默认对齐行为，使其按照顶部对齐而不是底部。</p><p><strong>使用帧控制视图大小</strong></p><p>帧（frame）允许你为视图设置一个明确的大小或者提供一个理想的大小范围。<code>frame</code>修饰符可以指定宽度（<code>width</code>）、高度（<code>height</code>）、最小宽度（<code>minWidth</code>）、最大宽度（<code>maxWidth</code>）、最小高度（<code>minHeight</code>）、和最大高度（<code>maxHeight</code>）。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-type">Text</span>(<span class="hljs-string">&quot;固定大小的文本框&quot;</span>)<br>    .frame(width: <span class="hljs-number">100</span>, height: <span class="hljs-number">100</span>)<br>    .border(<span class="hljs-type">Color</span>.red)<br></code></pre></td></tr></table></figure><p>上述代码将文本框的宽度和高度都固定在了100点，无论内容大小如何，文本框都不会改变尺寸。</p><p><strong>对齐和帧的组合使用</strong></p><p>对齐和帧可以组合使用，以创建更复杂的布局效果。例如，你可能想要创建一个宽度固定，但高度根据内容动态调整的文本视图，同时在其内部文本垂直居中对齐。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-type">Text</span>(<span class="hljs-string">&quot;垂直居中的文本&quot;</span>)<br>    .frame(minHeight: <span class="hljs-number">0</span>, maxHeight: .infinity)<br>    .frame(width: <span class="hljs-number">200</span>)<br>    .background(<span class="hljs-type">Color</span>.gray)<br>    .alignmentGuide(.vertical) &#123; d <span class="hljs-keyword">in</span><br>        d[<span class="hljs-type">VerticalAlignment</span>.center]<br>    &#125;<br></code></pre></td></tr></table></figure><p>这里我们使用了两个<code>frame</code>修饰符：第一个<code>frame</code>确保文本在垂直方向上可以扩展到可用的全部空间，第二个<code>frame</code>则设置了文本的固定宽度。通过<code>alignmentGuide</code>，文本在其框架内垂直居中。</p><p><strong>总结</strong></p><p>对齐和帧是布局时的两个非常重要的概念。通过精确的对齐控制，你可以确保界面元素以一种一致和预期的方式排列。同时，使用帧可以限制和指定视图的大小，无论是固定的还是灵活的。掌握了这些工具，你将能够设计出外观精确且布局合理的界面，即便是面对各种屏幕尺寸和设备方向，你的应用界面也能保持其应有的布局和结构。</p><p><strong>3. Spacer和Divider</strong></p><p>在构建用户界面时，除了直接操纵视图的尺寸和对齐，SwiftUI还提供了用于控制视图间隔的工具：Spacer和Divider。这些工具在进行视图布局时是不可或缺的，它们可以帮助我们创建出更为优雅和灵活的用户界面。</p><p><strong>Spacer: 创建灵活的空间</strong></p><p>Spacer是一个会尽可能占用多余空间的视图。在一个Stack中，Spacer可以推动相邻的视图，使其与Stack的边缘或其他视图保持距离。Spacer本身没有可见的内容，但它可以控制布局的间距。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-type">HStack</span> &#123;<br>    <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;左边&quot;</span>)<br>    <span class="hljs-type">Spacer</span>() <span class="hljs-comment">// 占据所有可用空间</span><br>    <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;右边&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述例子中，Spacer位于两个文本视图之间，并推动它们分别靠近水平Stack的左右边缘。</p><p>Spacer的另一个常用场景是在其前后添加修饰符，以控制其最小空间尺寸。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-type">HStack</span> &#123;<br>    <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;左边&quot;</span>)<br>    <span class="hljs-type">Spacer</span>()<br>        .frame(minWidth: <span class="hljs-number">20</span>)<br>    <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;右边&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>此时，Spacer至少会创建20点的空间，即使在更大的容器中，它也会扩展以填满额外的空间。</p><p><strong>Divider: 分隔视图</strong></p><p>Divider是一个用于分隔内容的细线，通常在视觉上表示不同部分的内容。它可以在列表、VStack或HStack中作为清晰分界线使用。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-type">VStack</span> &#123;<br>    <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;第一部分&quot;</span>)<br>    <span class="hljs-type">Divider</span>()<br>    <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;第二部分&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>Divider会自动采用垂直或水平方向，取决于它所在的Stack类型。在VStack中，它是水平的；而在HStack中，则是垂直的。</p><p><strong>自定义Spacer和Divider</strong></p><p>虽然Spacer和Divider是很好的布局工具，但有时你可能需要更多的自定义。例如，你可以使用背景和框架修饰符来自定义Divider的样式。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-type">Divider</span>()<br>    .background(<span class="hljs-type">Color</span>.blue)<br>    .frame(height: <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>在这个例子中，我们自定义了Divider的颜色和高度，创建了一个蓝色的分隔线。</p><p>同样，你也可以对Spacer进行类似的自定义。</p><p><strong>总结</strong></p><p>Spacer和Divider是在SwiftUI中创建和维护视图间隙的简单而强大的工具。它们支持布局的灵活性，同时为内容的视觉分隔提供方便。在理解了如何利用Spacer来控制视图的扩展和收缩，以及如何使用Divider来清晰地区分内容之后，你将能够创建出既美观又实用的布局设计。</p><p><strong>4. 布局优先级</strong></p><p>当我们在SwiftUI中构建复杂的界面时，经常会遇到多个视图争抢空间的情况。布局优先级（Layout Priority）是一个高级的概念，它允许我们微调视图如何在父视图中分配额外的空间。理解并正确使用布局优先级，可以帮助我们创建更加精确和高度定制的用户界面。</p><p><strong>基本概念</strong></p><p>在SwiftUI中，所有视图默认具有相同的布局优先级，值为0。当空间不足以满足所有子视图的理想尺寸时，系统会根据布局优先级来决定哪个视图可以首先满足其尺寸需求。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-type">HStack</span> &#123;<br>    <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;非常非常长的文本&quot;</span>).layoutPriority(<span class="hljs-number">1</span>)<br>    <span class="hljs-type">Spacer</span>()<br>    <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;短文本&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，第一个<code>Text</code>视图的布局优先级被设置为1，这意味着它在空间分配时会被优先考虑。即使在有限的空间中，它也会尽可能地显示完整的内容，而<code>Spacer</code>和第二个<code>Text</code>视图会相应地压缩。</p><p><strong>布局优先级的使用</strong></p><p>布局优先级的值可以是任意的正浮点数。数值越大，获取额外空间的优先级就越高。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-type">HStack</span> &#123;<br>    <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;需要更多空间的文本&quot;</span>).layoutPriority(<span class="hljs-number">2</span>)<br>    <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;不那么重要的文本&quot;</span>).layoutPriority(<span class="hljs-number">1</span>)<br>    <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;普通文本&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的代码中，第一个文本视图被赋予了最高的优先级（2），其次是第二个文本视图（1），最后是没有显式设置优先级的文本视图（默认为0）。因此，当空间有限时，第一个文本视图会尽量显示更多的内容。</p><p><strong>布局优先级的策略</strong></p><p>布局优先级通常用于解决视图间的竞争关系，但是它并不是解决所有布局问题的万能钥匙。合理使用布局优先级需要策略，过度依赖可能会导致布局变得难以预测和管理。在设置优先级时，你应当始终考虑内容的重要性以及用户体验。</p><p>一个良好的策略是尽量保持简单，只在确实需要时调整布局优先级。并且，始终牢记布局的整体目标是创造既满足设计需求又对用户友好的界面。</p><p><strong>结合其他布局工具</strong></p><p>布局优先级并不孤立工作，它应该与其他布局工具一起使用，例如<code>frame</code>、<code>alignment</code>、<code>Spacer</code>等。在实际开发中，你会发现布局优先级是与其他布局概念协同工作的，比如使用<code>fixedSize</code>来防止视图被压缩，或者与<code>flexible</code>结合来调整视图的压缩和扩展行为。</p><p><strong>总结</strong></p><p>掌握了布局优先级的概念和使用方法后，我们就能更加精细地控制SwiftUI布局的行为。正确的布局优先级设置能够确保重要的内容得到展示，辅助视图适应剩余空间，从而创造出既直观又富有层次的用户界面。在设计复杂的布局时，优先级的细微调整可以带来显著的视觉和体验改善。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;第5章：布局管理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 堆（Stacks）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在SwiftUI中，布局是通过组合不同的视图和使用布局容器来实现的，其中最基础和最常用的布局容器是堆（Stack）。Stacks在Sw</summary>
      
    
    
    
    <category term="SwiftUI" scheme="http://xuebusi.gitee.io/categories/SwiftUI/"/>
    
    
  </entry>
  
  <entry>
    <title>SwiftUI核心技术4章视图与控件</title>
    <link href="http://xuebusi.gitee.io/2023/11/08/SwiftUI%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF4%E7%AB%A0%E8%A7%86%E5%9B%BE%E4%B8%8E%E6%8E%A7%E4%BB%B6/"/>
    <id>http://xuebusi.gitee.io/2023/11/08/SwiftUI%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF4%E7%AB%A0%E8%A7%86%E5%9B%BE%E4%B8%8E%E6%8E%A7%E4%BB%B6/</id>
    <published>2023-11-07T16:35:47.000Z</published>
    <updated>2024-03-17T06:11:08.769Z</updated>
    
    <content type="html"><![CDATA[<p><strong>第二部分：构建用户界面</strong></p><p><strong>第4章：视图与控件</strong></p><p><strong>1. Text和Image</strong></p><p>在SwiftUI中，用户界面是由各种视图组成的，其中最基本的两种视图是<code>Text</code>和<code>Image</code>。本节将详细探讨如何使用这两种视图来显示文本和图像。</p><p><strong>Text</strong></p><p><code>Text</code>视图用于在应用中显示一行或多行只读文本。它是最常见的视图之一，因为文本是用户交互的基本元素。</p><p><strong>基础用法</strong></p><p>创建一个<code>Text</code>视图非常简单，只需要传入一个字符串即可：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-type">Text</span>(<span class="hljs-string">&quot;Hello, SwiftUI!&quot;</span>)<br></code></pre></td></tr></table></figure><p><strong>样式定制</strong></p><p><code>Text</code>视图提供了多种修饰符来定制文本的显示方式：</p><ul><li><code>.font(_:)</code>：设置字体样式。</li><li><code>.fontWeight(_:)</code>：设置字体的粗细。</li><li><code>.foregroundColor(_:)</code>：设置文本颜色。</li><li><code>.lineLimit(_:)</code>：设置最多显示行数。</li><li><code>.multilineTextAlignment(_:)</code>：设置多行文本的对齐方式。</li><li><code>.padding(_:)</code>：为文本周围添加填充。</li></ul><p>例如，要创建一个居中对齐、蓝色、加粗的文本，您可以这样写：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-type">Text</span>(<span class="hljs-string">&quot;Welcome to SwiftUI&quot;</span>)<br>    .font(.headline)<br>    .fontWeight(.bold)<br>    .foregroundColor(.blue)<br>    .multilineTextAlignment(.center)<br>    .padding()<br></code></pre></td></tr></table></figure><p><strong>国际化和本地化</strong></p><p>SwiftUI还支持文本的国际化和本地化。使用<code>LocalizedStringKey</code>初始化<code>Text</code>视图，可以确保文本根据用户的设备语言环境显示正确：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-type">Text</span>(<span class="hljs-type">LocalizedStringKey</span>(<span class="hljs-string">&quot;hello_message&quot;</span>))<br></code></pre></td></tr></table></figure><p><strong>Image</strong></p><p><code>Image</code>视图用于在应用中显示图像。您可以从应用的资产目录、文件系统或网络加载图像。</p><p><strong>从资产目录加载</strong></p><p>最常用的加载图像方式是从Xcode项目的Assets.xcassets目录：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-type">Image</span>(<span class="hljs-string">&quot;myImage&quot;</span>)<br></code></pre></td></tr></table></figure><p><strong>图像修饰符</strong></p><p><code>Image</code>视图也可以使用多种修饰符来调整显示的图像：</p><ul><li><code>.resizable()</code>：允许图像根据视图的大小进行拉伸或压缩。</li><li><code>.aspectRatio(_:_:)</code>：设置图像的宽高比。</li><li><code>.clipShape(_:)</code>：剪切图像到特定的形状。</li><li><code>.shadow(_:)</code>：为图像添加阴影。</li></ul><p>例如，要创建一个圆形、有阴影的图像，您可以这样写：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-type">Image</span>(<span class="hljs-string">&quot;profile_pic&quot;</span>)<br>    .resizable()<br>    .aspectRatio(contentMode: .fill)<br>    .frame(width: <span class="hljs-number">100</span>, height: <span class="hljs-number">100</span>)<br>    .clipShape(<span class="hljs-type">Circle</span>())<br>    .shadow(radius: <span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure><p><strong>加载和显示网络图像</strong></p><p>要显示来自网络的图像，您通常需要使用SwiftUI的<code>AsyncImage</code>视图或结合URLSession自定义一个加载器。由于本节重点是<code>Image</code>视图，我们将在后续章节详细探讨如何加载网络图像。</p><p><strong>总结</strong></p><p><code>Text</code>和<code>Image</code>是构建SwiftUI应用界面时最基础的元素。它们不仅用法简单，而且通过修饰符提供了强大的样式定制能力。通过合理使用这两种视图，您可以快速构建出丰富多彩且吸引人的界面。接下来的小节，我们将进一步探索SwiftUI中其他重要的视图和控件。</p><p><strong>2. Buttons和Toggle</strong></p><p>在SwiftUI中，<code>Button</code>和<code>Toggle</code>是两种用于用户交互的基本控件。它们使应用可以响应用户的操作，执行任务或更改状态。</p><p><strong>Button</strong></p><p>按钮是用户界面的基本组件，用于响应用户的点击或触摸操作。</p><p><strong>创建按钮</strong></p><p>在SwiftUI中，创建一个按钮需要提供一个动作和一个如何显示的内容：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-type">Button</span>(action: &#123;<br>    <span class="hljs-comment">// 在这里执行按钮的动作</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;按钮被点击&quot;</span>)<br>&#125;) &#123;<br>    <span class="hljs-comment">// 提供按钮的内容</span><br>    <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;点击我&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>按钮样式</strong></p><p>您可以使用修饰符来定制按钮的样式。例如，给按钮添加边框、背景色等：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-type">Button</span>(<span class="hljs-string">&quot;点击我&quot;</span>) &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;按钮被点击&quot;</span>)<br>&#125;<br>.frame(width: <span class="hljs-number">200</span>, height: <span class="hljs-number">60</span>)<br>.background(<span class="hljs-type">Color</span>.blue)<br>.foregroundColor(.white)<br>.cornerRadius(<span class="hljs-number">10</span>)<br>.padding()<br></code></pre></td></tr></table></figure><p>SwiftUI还提供了<code>buttonStyle(_:)</code>修饰符来应用预定义的按钮样式。</p><p><strong>Toggle</strong></p><p><code>Toggle</code>是一个开关控件，用于表示和改变一个布尔值的状态。</p><p><strong>创建Toggle</strong></p><p>创建一个<code>Toggle</code>同样需要一个绑定的状态和一个显示的标签：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-meta">@State</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> isOn <span class="hljs-operator">=</span> <span class="hljs-literal">false</span><br><br><span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> &#123;<br>    <span class="hljs-type">Toggle</span>(isOn: <span class="hljs-variable">$isOn</span>) &#123;<br>        <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;切换状态&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的代码中，<code>isOn</code>是一个<code>@State</code>属性，这意味着它是一个可变状态，当<code>Toggle</code>被切换时，视图会自动更新。</p><p><strong>定制Toggle</strong></p><p>可以使用<code>.toggleStyle(_:)</code>修饰符来定制<code>Toggle</code>的外观。SwiftUI提供了一些内建的样式，如<code>SwitchToggleStyle</code>和<code>CheckboxToggleStyle</code>（后者在macOS上可用）。</p><p><strong>绑定和控制</strong></p><p>按钮和开关的强大之处在于它们与SwiftUI的数据绑定系统的整合。当您使用<code>$</code>前缀创建绑定时，UI 控件将能够直接修改数据，反之亦然。这是SwiftUI声明式编程范式的核心。</p><p><strong>响应用户输入</strong></p><p>通常，按钮和开关会更改应用的状态或触发某个操作。例如，您可能会根据开关的状态显示或隐藏文本视图：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-meta">@State</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> isAccepted <span class="hljs-operator">=</span> <span class="hljs-literal">false</span><br><br><span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> &#123;<br>    <span class="hljs-type">VStack</span> &#123;<br>        <span class="hljs-type">Toggle</span>(isOn: <span class="hljs-variable">$isAccepted</span>) &#123;<br>            <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;接受条款和条件&quot;</span>)<br>        &#125;<br><br>        <span class="hljs-type">Button</span>(<span class="hljs-string">&quot;继续&quot;</span>) &#123;<br>            <span class="hljs-comment">// 可以在这里校验开关状态，例如是否接受了条款和条件</span><br>            proceedWithAction()<br>        &#125;<br>        .disabled(<span class="hljs-operator">!</span>isAccepted) <span class="hljs-comment">// 当不接受条款时禁用按钮</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><p>按钮和开关是任何交互式应用程序的基础，它们提供了一种简单有效的方式来收集用户输入并作出反应。SwiftUI的<code>Button</code>和<code>Toggle</code>视图配合数据绑定，使得创建动态和响应式的用户界面变得异常简单。它们的样式和行为可以通过一系列的修饰符进行定制，以适应您的设计需求。在接下来的小节中，我们将继续探讨如何使用SwiftUI构建更复杂的用户界面元素。</p><p><strong>3. TextField和Slider</strong></p><p>在SwiftUI中，创建交互式表单和控制元素是构建现代应用程序不可或缺的一部分。<code>TextField</code>和<code>Slider</code>是两种常用的控件，它们允许用户输入文本和选择值的范围。</p><p><strong>TextField</strong></p><p><code>TextField</code>是一个用于用户输入文本的控件，它可以接受键盘输入，并且可以对输入的文本进行格式化和校验。</p><p><strong>创建TextField</strong></p><p>创建一个<code>TextField</code>通常需要两个参数：一个标签和一个绑定到文本值的变量。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-meta">@State</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> username: <span class="hljs-type">String</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span><br><br><span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> &#123;<br>    <span class="hljs-type">TextField</span>(<span class="hljs-string">&quot;用户名&quot;</span>, text: <span class="hljs-variable">$username</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，每当用户在文本字段中输入时，<code>username</code>变量都会更新。<code>@State</code>属性包装器用于在本地视图状态中存储可变数据。</p><p><strong>定制TextField</strong></p><p>您可以使用修饰符来定制<code>TextField</code>的外观和行为，例如设置字体、颜色、对齐方式、键盘类型等。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-type">TextField</span>(<span class="hljs-string">&quot;用户名&quot;</span>, text: <span class="hljs-variable">$username</span>)<br>    .textFieldStyle(<span class="hljs-type">RoundedBorderTextFieldStyle</span>())<br>    .padding()<br>    .keyboardType(.default)<br>    .autocapitalization(.none)<br>    .disableAutocorrection(<span class="hljs-literal">true</span>)<br></code></pre></td></tr></table></figure><p>在这个例子中，我们使用了<code>textFieldStyle(_:)</code>来为文本字段设置圆角边框样式，并进行了一些其他的配置。</p><p><strong>Slider</strong></p><p><code>Slider</code>允许用户从一个范围内选择一个值。它可以用于设置音量、选择亮度或应用任何其他需要用户选择一个数值的场景。</p><p><strong>创建Slider</strong></p><p>创建<code>Slider</code>至少需要一个绑定到数值的变量和一个值的范围。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-meta">@State</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> sliderValue: <span class="hljs-type">Double</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.5</span><br><br><span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> &#123;<br>    <span class="hljs-type">Slider</span>(value: <span class="hljs-variable">$sliderValue</span>, in: <span class="hljs-number">0</span><span class="hljs-operator">...</span><span class="hljs-number">1</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>这个<code>Slider</code>允许用户在0到1之间选择一个值。</p><p><strong>定制Slider</strong></p><p><code>Slider</code>同样可以使用修饰符进行外观和功能的定制。您可以设置步长，决定滑块在变化时是否持续触发更新，以及添加标签。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-type">Slider</span>(<br>    value: <span class="hljs-variable">$sliderValue</span>,<br>    in: <span class="hljs-number">0</span><span class="hljs-operator">...</span><span class="hljs-number">1</span>,<br>    step: <span class="hljs-number">0.1</span>,<br>    onEditingChanged: &#123; editing <span class="hljs-keyword">in</span><br>        <span class="hljs-comment">// editing 是一个布尔值，表示是否正在编辑</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;当前滑块的值：<span class="hljs-subst">\(sliderValue)</span>&quot;</span>)<br>    &#125;<br>)<br>.accentColor(.green)<br></code></pre></td></tr></table></figure><p>在这个例子中，滑块的步长设置为0.1，且我们还指定了一个闭包，在用户编辑滑块值时触发。</p><p><strong>总结</strong></p><p><code>TextField</code>和<code>Slider</code>为SwiftUI应用提供了基本的用户输入功能。通过与<code>@State</code>或其他形式的状态管理相结合，它们为开发者提供了创建动态和响应式表单的能力。定制这些控件的外观和行为使它们能够匹配应用程序的设计语言，提供更好的用户体验。在接下来的章节中，我们将探索SwiftUI中的其他高级控件和视图，并学习如何将它们组合在一起以构建复杂和功能丰富的用户界面。</p><p><strong>4. 自定义视图和控件</strong></p><p>SwiftUI的真正魅力之一在于它为开发者提供了丰富的自定义视图和控件的能力。通过结合现有的视图和控件以及Swift语言的强大特性，我们可以创建完全定制的用户界面元素，以完美地适应我们的设计需求。</p><p><strong>理解视图的组合</strong></p><p>在SwiftUI中，最基本的自定义视图起始于现有的视图的组合。SwiftUI的视图是可组合的，意味着你可以将简单的视图组合成复杂的视图。比如，我们可以创建一个带有文本和图像的自定义按钮视图：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CustomButton</span>: <span class="hljs-title class_">View</span> &#123;<br>    <span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> &#123;<br>        <span class="hljs-type">HStack</span> &#123;<br>            <span class="hljs-type">Image</span>(systemName: <span class="hljs-string">&quot;star.fill&quot;</span>)<br>                .resizable()<br>                .frame(width: <span class="hljs-number">20</span>, height: <span class="hljs-number">20</span>)<br>            <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;收藏&quot;</span>)<br>        &#125;<br>        .padding()<br>        .background(<span class="hljs-type">Color</span>.blue)<br>        .foregroundColor(.white)<br>        .cornerRadius(<span class="hljs-number">10</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个<code>CustomButton</code>就是一个自定义视图，它可以在任何其他的SwiftUI视图中使用。</p><p><strong>创建完全自定义的视图</strong></p><p>如果需要更高级的自定义，你可以从<code>View</code>协议开始，实现自己的<code>body</code>属性。这允许你控制视图的渲染方式，并响应用户的输入。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CircularProgressView</span>: <span class="hljs-title class_">View</span> &#123;<br>    <span class="hljs-keyword">var</span> progress: <span class="hljs-type">Double</span> <span class="hljs-comment">// 从0.0到1.0</span><br>    <br>    <span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> &#123;<br>        <span class="hljs-type">ZStack</span> &#123;<br>            <span class="hljs-type">Circle</span>()<br>                .stroke(lineWidth: <span class="hljs-number">20</span>)<br>                .opacity(<span class="hljs-number">0.3</span>)<br>                .foregroundColor(<span class="hljs-type">Color</span>.blue)<br>            <br>            <span class="hljs-type">Circle</span>()<br>                .trim(from: <span class="hljs-number">0.0</span>, to: <span class="hljs-type">CGFloat</span>(<span class="hljs-built_in">min</span>(<span class="hljs-keyword">self</span>.progress, <span class="hljs-number">1.0</span>)))<br>                .stroke(style: <span class="hljs-type">StrokeStyle</span>(lineWidth: <span class="hljs-number">20</span>, lineCap: .round, lineJoin: .round))<br>                .foregroundColor(<span class="hljs-type">Color</span>.blue)<br>                .rotationEffect(<span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">270.0</span>))<br>                .animation(.linear)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，我们创建了一个显示进度的环形视图，它会根据<code>progress</code>属性显示不同的填充量。</p><p><strong>响应用户交互</strong></p><p>自定义视图可以通过各种手势识别器来响应用户的交互。例如，你可能会有一个自定义滑块控件，它通过拖动来改变值：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CustomSlider</span>: <span class="hljs-title class_">View</span> &#123;<br>    <span class="hljs-meta">@Binding</span> <span class="hljs-keyword">var</span> value: <span class="hljs-type">Double</span> <span class="hljs-comment">// 绑定到外部状态</span><br>    <br>    <span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> &#123;<br>        <span class="hljs-type">GeometryReader</span> &#123; geometry <span class="hljs-keyword">in</span><br>            <span class="hljs-type">Rectangle</span>()<br>                .foregroundColor(.gray)<br>                .frame(height: <span class="hljs-number">20</span>)<br>                .gesture(<br>                    <span class="hljs-type">DragGesture</span>(minimumDistance: <span class="hljs-number">0</span>)<br>                        .onChanged &#123; gesture <span class="hljs-keyword">in</span><br>                            <span class="hljs-keyword">self</span>.value <span class="hljs-operator">=</span> <span class="hljs-type">Double</span>(gesture.location.x <span class="hljs-operator">/</span> geometry.size.width)<br>                        &#125;<br>                )<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，我们使用<code>GeometryReader</code>来获取视图的大小，并根据用户拖动的位置来更新<code>value</code>。</p><p><strong>保持性能</strong></p><p>在创建自定义视图和控件时，要记住保持它们的性能。这意味着：</p><ul><li>避免不必要的视图重绘和状态更新。</li><li>合理使用<code>.animation()</code>和<code>.transition()</code>修饰符来为视图变化提供流畅的过渡效果。</li><li>当视图层次变得复杂时，考虑使用<code>drawingGroup()</code>或<code>cache</code>等优化技术。</li></ul><p><strong>总结</strong></p><p>SwiftUI提供了强大的工具集，可以帮助开发者创建精美且功能丰富的自定义视图和控件。通过结合视图的组合、自定义绘制、响应用户输入等技术，你可以创建出完全符合你的设计和功能需求的用户界面元素。记住，自定义视图和控件不仅仅是关于创造外观，更重要的是它们提供了</p><p>与用户交互的新方式。随着你的SwiftUI技能的提高，你将能够更有效地利用这些工具，打造出既美观又高效的应用程序。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;第二部分：构建用户界面&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第4章：视图与控件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. Text和Image&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在SwiftUI中，用户界面是由各种视图组成的，其中最基本</summary>
      
    
    
    
    <category term="SwiftUI" scheme="http://xuebusi.gitee.io/categories/SwiftUI/"/>
    
    
  </entry>
  
</feed>
