{"meta":{"version":1,"warehouse":"5.0.0"},"models":{"Asset":[{"_id":"themes/fluid/source/css/gitalk.css","path":"css/gitalk.css","modified":0,"renderable":1},{"_id":"themes/fluid/source/css/highlight.styl","path":"css/highlight.styl","modified":0,"renderable":1},{"_id":"themes/fluid/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/favicon.jpg","path":"img/favicon.jpg","modified":0,"renderable":1},{"_id":"themes/fluid/source/css/highlight-dark.styl","path":"css/highlight-dark.styl","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/fluid.png","path":"img/fluid.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/police_beian.png","path":"img/police_beian.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/loading.gif","path":"img/loading.gif","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/default.png","path":"img/default.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/boot.js","path":"js/boot.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/color-schema.js","path":"js/color-schema.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/events.js","path":"js/events.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/img-lazyload.js","path":"js/img-lazyload.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/leancloud.js","path":"js/leancloud.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/xml/local-search.xml","path":"xml/local-search.xml","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/plugins.js","path":"js/plugins.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/about/index.md","hash":"774124e47ef9109d86d6046113f99abe5f55be2e","modified":1699428190829},{"_id":"source/.DS_Store","hash":"66ba89e5729e0e3a692a82fa3e098946b384e9e6","modified":1710656824009},{"_id":"source/tags/index.md","hash":"66054fbb13e98bc5b4a4a431a39ad657078892cc","modified":1699440499666},{"_id":"source/_posts/DockerCompose一键部署wordpress.md","hash":"99f9b2fc8622d986b303796279366c8c465b12bc","modified":1711009431928},{"_id":"source/_posts/Java实现两台计算机之间的简单通信.md","hash":"43ed06f09339b7f3f7c882d84f3243697cee66f5","modified":1699533787664},{"_id":"source/_posts/Docker部署xxl-job-admin步骤.md","hash":"7ed17a4935c157f5fbcc3b3678f65a86a666af2a","modified":1710393838635},{"_id":"source/categories/index.md","hash":"1f6f9db5cf4cba5be4d91278021eb9873b80d376","modified":1699440525843},{"_id":"source/_posts/.DS_Store","hash":"653e27ec8ac92658e8fbe40e355f9e78de4b9801","modified":1710657113710},{"_id":"source/_posts/Java实现两台计算机之间长连接通信.md","hash":"2f329e6d9df8a9f37229ad1e87ed710ca1e25e61","modified":1699534557056},{"_id":"source/_posts/SwiftUI中Label的用法.md","hash":"cb3d67c800875c89ec50e45235d244c2d53ff7ef","modified":1710655968736},{"_id":"source/_posts/SwiftUI中List的用法.md","hash":"cd2f51a2e2bcfdc444b2145bc910af616255ac94","modified":1710655975248},{"_id":"source/_posts/Publish.md","hash":"7036d31fc10829df0bb319ce2d8da1d246b8e265","modified":1699761675280},{"_id":"source/_posts/SwiftUI中HStack的用法.md","hash":"06d445a0b0a68257dadb1bad5407e3190669b295","modified":1710655965636},{"_id":"source/_posts/SwiftUI中Alert控件的用法.md","hash":"d305cb2c6f23180650980ef0cfe134ca9ab6e6e6","modified":1710655962552},{"_id":"source/_posts/SwiftUI中ScrollView的用法.md","hash":"7318e0f9f02c3d0363b6c9f7d27d163cb587bde5","modified":1710655987568},{"_id":"source/_posts/SwiftUI中Picker的用法.md","hash":"9a82abddd6466b4eb12538bdc1bd1af9355b4cd2","modified":1710655978066},{"_id":"source/_posts/SwiftUI中Slider组件的用法.md","hash":"25bf2ef4347ed7664acb3aa3ae32ac74fdf8681b","modified":1710655998491},{"_id":"source/_posts/SwiftUI中SecureField的用法.md","hash":"2f362466186e21e2cb060ed6d8923bbabeabb3fc","modified":1710655991125},{"_id":"source/_posts/SwiftUI中Stepper的用法.md","hash":"8a4562c492bcadf623a857e5ce9e16b1f314b1e8","modified":1710656001729},{"_id":"source/_posts/SwiftUI中ZStack的用法.md","hash":"7d8942b9e11415dc72cd07d7512b2e4e0cebfec7","modified":1710656007124},{"_id":"source/_posts/SwiftUI中的TextField组件的用法.md","hash":"81489c6ff46ca245e5033e8648e5ba26cdf7dc92","modified":1710655959198},{"_id":"source/_posts/SwiftUI中Sheet控件的用法.md","hash":"ae06692be4cb9be2f6d03638a63f6ac33fe126e8","modified":1710655994464},{"_id":"source/_posts/SwiftUI中的Image组件的用法.md","hash":"4db60f1549217d18cbbb7ef4b46e278ed3335e74","modified":1710655954479},{"_id":"source/_posts/SwiftUI中VStack的用法.md","hash":"129c5b0d6d38a20f759cdca932c85614270b2565","modified":1710656004364},{"_id":"source/_posts/SwiftUI中Popover控件的用法.md","hash":"5994f1d9a9ed7cf02195bf35f57fa1eb12ef5000","modified":1710655981788},{"_id":"source/_posts/SwiftUI中的布局.md","hash":"2539961554144709fab85685475dc2c07df9820b","modified":1710655941929},{"_id":"source/_posts/SwiftUI中的开关组件的用法.md","hash":"f1d612cae118a87991453f60b11271f59c4d3421","modified":1710655945015},{"_id":"source/_posts/SwiftUI和UIKit对比.md","hash":"168feef0b7a9cd41908c8a63b5834a53df325217","modified":1710655856967},{"_id":"source/_posts/SwiftUI中的按钮组件的用法.md","hash":"234fc3b139efc049a73bda7044669f6950a9a5c3","modified":1710655938419},{"_id":"source/_posts/SwiftUI中的文本控件的用法.md","hash":"3779d3a663a1fc896f7fd191e15ab79be915e2ff","modified":1710655951171},{"_id":"source/_posts/SwiftUI中的模态视图.md","hash":"c158c781f1012b427e3b6e6e4126857debe4dfa6","modified":1710655947923},{"_id":"source/_posts/SwiftUI提供了哪些UI组件.md","hash":"18b783aa6ef2de73be6e00b9fdc5502f77ab0444","modified":1710655934981},{"_id":"source/_posts/SwiftUI核心技术第11章适配多平台.md","hash":"361f4ed42d4e277e130c33122b3bc82ad8846982","modified":1710655911180},{"_id":"source/_posts/SwiftUI中Link组件的用法.md","hash":"e7fb89a1ee20ac76ae03e84edb53c36dc820680a","modified":1710655972439},{"_id":"source/_posts/SwiftUI核心技术.md","hash":"15b9f821444fbafbbffd3077239f7c44e5b5b4eb","modified":1710655864809},{"_id":"source/_posts/SwiftUI核心技术第12章Dark-Mode和Accessibility.md","hash":"89c00020182309f9ad972ff9f1ac7b27f29f95da","modified":1710655914398},{"_id":"source/_posts/SwiftUI核心技术第3章环境搭建.md","hash":"0d4d1f13d2086cc878cd6a7aa84d6c34aa5a9137","modified":1710655872787},{"_id":"source/_posts/SwiftUI核心技术第14章测试与调试.md","hash":"e4a86bcff3734bea88d012ee68092502316fabe5","modified":1710655921380},{"_id":"source/_posts/SwiftUI核心技术第10章集成Core-Data和CloudKit.md","hash":"c38ab47532a9531173f9e8ebaaf2971ad4e03fa3","modified":1710655908022},{"_id":"source/_posts/SwiftUI核心技术第15章构建一个聊天APP.md","hash":"614ac1bb12695e715152627b5db67d4a6118be31","modified":1710655924584},{"_id":"source/_posts/SwiftUI核心技术第6章数据流与绑定.md","hash":"6645ec1c29a4eb939082ce11fadf67b945788348","modified":1710655894626},{"_id":"source/_posts/SwiftUI核心技术第13章性能优化.md","hash":"99adbdb30788700f00261e9f56a37733e7ca1237","modified":1710655918265},{"_id":"source/_posts/SwiftUI核心技术第5章布局管理.md","hash":"939cfe6daa2219651459a7fd62536e0721a37da2","modified":1710655877149},{"_id":"source/_posts/SwiftUI核心技术第8章动画与转场.md","hash":"9cbc0b148a73879536373adc797f8bbc3ac84317","modified":1710655901709},{"_id":"source/_posts/SwiftUI简介.md","hash":"a075dd8e8bfb80df8ae7fcf33a6b624aaa16ef37","modified":1710655927973},{"_id":"source/_posts/SwiftUI设计思想.md","hash":"c8298da0ded48471a864e24c1f2665406d6fb231","modified":1710655932016},{"_id":"source/_posts/hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":1699233243574},{"_id":"source/_posts/SwiftUI核心技术4章视图与控件.md","hash":"cddc33c8708df349fa24aae26e59ccaf06116aaa","modified":1710655868769},{"_id":"source/_posts/SwiftUI核心技术第7章导航与呈现.md","hash":"4084af470aafd725c47101eab0853a3c37fbb4ee","modified":1710655898648},{"_id":"source/_posts/macOS查看环境变量.md","hash":"a993ae72f7df985cc70d90e18aedfaf913b2e2d0","modified":1711092705933},{"_id":"source/_posts/SwiftUI中ProgressView的用法.md","hash":"61a79b8c339db409c47f782e7a67f9f103f8319f","modified":1710655984783},{"_id":"source/_posts/使用TextField开发一个记事本.md","hash":"327581726788969c70a74f732730fbb7b0424725","modified":1699360237230},{"_id":"source/_posts/SwiftUI核心技术第9章复合视图与可复用性.md","hash":"b5698cf3ef9d26c2910362e729e879d65248fb06","modified":1710655904777},{"_id":"source/_posts/用SwiftUI编写一个Hello-World！.md","hash":"8ee5cff424c7136b59b5cad401499cce5fac03e8","modified":1699342041800},{"_id":"source/_posts/我现在要开发一个iOS上的APP，我应该使用SwiftUI还是UIKit呢？.md","hash":"c335294649c84d8dd94ed99f171dae7094b15efa","modified":1699350914773},{"_id":"source/_posts/使用JavaNIO编写一个HelloWorld程序.md","hash":"73283b8506b8b8adc2bc188eb4ecd15889e236c1","modified":1710643980142},{"_id":"source/_posts/使用Vapor编写用户信息CRUD的API接口.md","hash":"34ff103cff1965b4b4c0f572837c4319df8c121f","modified":1699490997368},{"_id":"source/_posts/在Mac上如何终止某个端口所在的进程？.md","hash":"311b11cd38d909ae0d11208fcda8492b756a156e","modified":1699759934994},{"_id":"source/_posts/声明式语法和命令式语法的区别.md","hash":"d07a87372ace052910b37b41a6d7758d1e8cfdf3","modified":1699343851823},{"_id":"source/_posts/对于初学者，SwiftUI和UIKit到底先学哪个？.md","hash":"70777b58e8580f766c7028b99c05e1222e5be47f","modified":1699341811796},{"_id":"themes/fluid/source/css/_pages/_tag/tag.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1699427989224},{"_id":"themes/fluid/.gitignore","hash":"ae3bfcb89777657c5dfb5169d91445dcb0e5ab98","modified":1699427989213},{"_id":"themes/fluid/README.md","hash":"088496f29af0e946055ebd781fa312685335139c","modified":1699427989213},{"_id":"themes/fluid/README_en.md","hash":"49541d4ec48c4b517c5b3fe17a2e92d87090d007","modified":1699427989213},{"_id":"themes/fluid/.editorconfig","hash":"33218fbd623feb43edf5f99f15965392cecc44a6","modified":1699427989212},{"_id":"themes/fluid/.gitattributes","hash":"a54f902957d49356376b59287b894b1a3d7a003f","modified":1699427989213},{"_id":"themes/fluid/.DS_Store","hash":"e8d1ad47248e9d042435d8a48cc2de3f0dd33bf4","modified":1710396000784},{"_id":"themes/fluid/package.json","hash":"41983970c0977b3c626c3f1e3c714cf78ac6a04e","modified":1699427989218},{"_id":"themes/fluid/.github/.DS_Store","hash":"81f1f82d89293016d68e7441975309b08610660b","modified":1710394881870},{"_id":"themes/fluid/languages/eo.yml","hash":"a556251cc50a5680578c03f1efbf252b1f4ab860","modified":1699427989214},{"_id":"themes/fluid/languages/en.yml","hash":"cb11b39f44ea069652c9647179606b6cecc98d50","modified":1699427989214},{"_id":"themes/fluid/languages/es.yml","hash":"7112594259c88c04714be152af7fd377687dad40","modified":1699427989214},{"_id":"themes/fluid/languages/ru.yml","hash":"7dc78f22696649a4c68dc65a9b52d9a992fa82a0","modified":1699427989214},{"_id":"themes/fluid/_config.yml","hash":"4227e37876dba281c118649b390c703349e11dfb","modified":1699534022403},{"_id":"themes/fluid/LICENSE","hash":"26f9356fd6e84b5a88df6d9014378f41b65ba209","modified":1699427989213},{"_id":"themes/fluid/.eslintrc","hash":"4bc2b19ce2b8c4d242f97d4ccf2d741e68ab0097","modified":1699427989213},{"_id":"themes/fluid/languages/de.yml","hash":"0e7d455d9e004ff15d8924b7a0c35cea25ee5b1d","modified":1699427989214},{"_id":"themes/fluid/layout/.DS_Store","hash":"b2a11e17fd6a8636246a03dff6f482f7edce2507","modified":1710394886887},{"_id":"themes/fluid/languages/zh-TW.yml","hash":"596d031dff3826ae8e4ffc8931fff28977b73247","modified":1699427989214},{"_id":"themes/fluid/languages/ja.yml","hash":"3dd6d20f8d26585a7c154a8e59fe8d5d902f4c6a","modified":1699427989214},{"_id":"themes/fluid/languages/zh-HK.yml","hash":"80ed400a7adaa92ea54fc7f5d534c9af795bed00","modified":1699427989214},{"_id":"themes/fluid/layout/categories.ejs","hash":"13859726c27b6c79b5876ec174176d0f9c1ee164","modified":1699427989217},{"_id":"themes/fluid/layout/about.ejs","hash":"163bee643e6a38912d3ae70923c83c48d57222e7","modified":1699427989217},{"_id":"themes/fluid/layout/404.ejs","hash":"b84d575c7b7f778b4cb64e89ad3d0aed4a896820","modified":1699427989214},{"_id":"themes/fluid/languages/zh-CN.yml","hash":"f96a22f989897ecddc69d5867a206e1cf6b8f610","modified":1699427989214},{"_id":"themes/fluid/layout/archive.ejs","hash":"7c1f44005849791feae4abaa10fae4cb983d3277","modified":1699427989217},{"_id":"themes/fluid/layout/links.ejs","hash":"1cac32ec4579aaf7b9fa39d317497331d4c5e1dd","modified":1699427989217},{"_id":"themes/fluid/layout/category.ejs","hash":"f099161b738a16a32253f42085b5444f902018ed","modified":1699427989217},{"_id":"themes/fluid/layout/post.ejs","hash":"75ab6958d929e92566ca580d0b8bd0eeae10649a","modified":1699427989218},{"_id":"themes/fluid/layout/tag.ejs","hash":"9d686364c4d16a1a9219471623af452035c5b966","modified":1699427989218},{"_id":"themes/fluid/layout/tags.ejs","hash":"1d06af34b6cf1d8a20d2eb565e309326ceba309f","modified":1699427989218},{"_id":"themes/fluid/layout/page.ejs","hash":"ed5007a3feb8f14d3d2843271bfb298eb0c56219","modified":1699427989217},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/bug_report.md","hash":"554c0d0e086a0784d83ee71c83f8bceeb60aecc8","modified":1699427989213},{"_id":"themes/fluid/source/.DS_Store","hash":"e54a490a72c71d83f39f52727997dd3e51cd44e2","modified":1710395097341},{"_id":"themes/fluid/layout/layout.ejs","hash":"7e0023474128fbe4d68c467704c41f1712432415","modified":1699427989217},{"_id":"themes/fluid/scripts/.DS_Store","hash":"ef6b831297656a534496549fb64500c0138e87c0","modified":1710394881869},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/question.md","hash":"ab5eab9e3ff889c4ba7fd82846e7f5b7ae15bebc","modified":1699427989213},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/feature_request_zh.md","hash":"ed08574b196447376dd74411cca664ac9227a5d4","modified":1699427989213},{"_id":"themes/fluid/layout/index.ejs","hash":"9b4c154462ce78de4c9ea7dd15dce4ca8e8c1cf8","modified":1699427989217},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/question_zh.md","hash":"fff07ce0472afc368d388637cb9d438195da9b5b","modified":1699427989213},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/bug_report_zh.md","hash":"c8b0d49c49e3c88872fd3b37909345ff5b2b6aa0","modified":1699427989213},{"_id":"themes/fluid/.github/workflows/cr.yaml","hash":"19a8a00f5ba9607d82265572fe1202b64a8b0822","modified":1699427989213},{"_id":"themes/fluid/.github/workflows/limit.yaml","hash":"f8bd2edeb4424ee7a055b31583445d5d5dff91a4","modified":1699427989213},{"_id":"themes/fluid/layout/_partials/category-chains.ejs","hash":"18309584aab83bc4deb20723ebad832149dd2e24","modified":1699427989214},{"_id":"themes/fluid/layout/_partials/archive-list.ejs","hash":"7520fbf91f762207c2ab06b2c293235cd5b23905","modified":1699427989214},{"_id":"themes/fluid/.github/workflows/publish.yaml","hash":"6f02e6440d88629229556e3fd47d0280fe2240db","modified":1699427989213},{"_id":"themes/fluid/layout/_partials/.DS_Store","hash":"d03a125a99101a6d844f63bda6e54b76a0d373c3","modified":1710394886883},{"_id":"themes/fluid/layout/_partials/comments.ejs","hash":"d707c47b2638c94e489bc43d4cfd098b7c58447f","modified":1699427989214},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/feature_request.md","hash":"c134dd57ffd269b93402ccfffe7dbe0f0b583bec","modified":1699427989213},{"_id":"themes/fluid/layout/_partials/footer.ejs","hash":"10ccfb8eef4e16182183c9a3e175c90d5b6397d3","modified":1699427989215},{"_id":"themes/fluid/layout/_partials/head.ejs","hash":"7b7b1d098726e86687a15fe3d520d178577ffcae","modified":1699427989215},{"_id":"themes/fluid/layout/_partials/scripts.ejs","hash":"da5810785105e5075861593c7ac22c7aa9665a72","modified":1699427989217},{"_id":"themes/fluid/layout/_partials/header.ejs","hash":"0d5e397d30051e5fbabe7b47cfd1f1e6a5820af1","modified":1699427989215},{"_id":"themes/fluid/layout/_partials/css.ejs","hash":"85f6e051550907681ab4ed2e268ac8f6e9ebf931","modified":1699427989215},{"_id":"themes/fluid/layout/_partials/category-list.ejs","hash":"f8d2f1907450e61968e6d54443e9be8138196a77","modified":1699427989214},{"_id":"themes/fluid/layout/_partials/search.ejs","hash":"70e1c929e084ca8a2648cedabf29b372511ea2b8","modified":1699427989217},{"_id":"themes/fluid/layout/_partials/paginator.ejs","hash":"0f38a2c238169edcb63fc46c23bfc529ff3859b7","modified":1699427989216},{"_id":"themes/fluid/scripts/filters/default-injects.js","hash":"b2013ae8e189cd07ebc8a2ff48a78e153345210f","modified":1699427989218},{"_id":"themes/fluid/scripts/filters/post-filter.js","hash":"0047666f996c54017e06668b5242ed8a311ebce0","modified":1699427989219},{"_id":"themes/fluid/scripts/generators/local-search.js","hash":"9ac5ddad06e9b0e6015ce531430018182a4bc0fa","modified":1699427989219},{"_id":"themes/fluid/scripts/generators/index-generator.js","hash":"9159fc22fa84a7b605dd15fe4104f01fe9c71147","modified":1699427989219},{"_id":"themes/fluid/scripts/helpers/date.js","hash":"9bda6382f61b40a20c24af466fe10c8366ebb74c","modified":1699427989219},{"_id":"themes/fluid/scripts/generators/pages.js","hash":"d3e75f53c59674d171309e50702954671f31f1a4","modified":1699427989219},{"_id":"themes/fluid/layout/_partials/markdown-plugins.ejs","hash":"fc4bdf7de0cf1a66d0e5e4fba1b31d6f7ed49468","modified":1699427989216},{"_id":"themes/fluid/scripts/helpers/export-config.js","hash":"8e67b522c47aa250860e3fe2c733f1f958a506c0","modified":1699427989219},{"_id":"themes/fluid/scripts/helpers/engine.js","hash":"d3a231d106795ce99cb0bc77eb65f9ae44515933","modified":1699427989219},{"_id":"themes/fluid/scripts/events/index.js","hash":"79de5a379b28cad759a49048351c7f6b8915bd7d","modified":1699427989218},{"_id":"themes/fluid/scripts/filters/locals.js","hash":"58d0fec976f6b1d35e7ea03edc45414088acf05c","modified":1699427989219},{"_id":"themes/fluid/scripts/helpers/page.js","hash":"4607607445233b3029ef20ed5e91de0da0a7f9c5","modified":1699427989220},{"_id":"themes/fluid/scripts/helpers/scope.js","hash":"d41d9d658fcb54964b388598e996747aadb85b0f","modified":1699427989220},{"_id":"themes/fluid/scripts/helpers/utils.js","hash":"226f99b465ff513de075a8e78b321d6cb62592ca","modified":1699427989220},{"_id":"themes/fluid/scripts/helpers/url.js","hash":"2a6a8288176d0e0f6ec008056bf2745a86e8943e","modified":1699427989220},{"_id":"themes/fluid/scripts/helpers/wordcount.js","hash":"4543b8954c5c2ca91191cc0d53cf071b3f26faaa","modified":1699427989220},{"_id":"themes/fluid/scripts/tags/button.js","hash":"3eb43a8cdea0a64576ad6b31b4df6c2bf5698d4c","modified":1699427989220},{"_id":"themes/fluid/scripts/tags/checkbox.js","hash":"4938610c3543a921a341bc074626d511cb1a4b45","modified":1699427989220},{"_id":"themes/fluid/scripts/tags/label.js","hash":"f05a6d32cca79535b22907dc03edb9d3fa2d8176","modified":1699427989220},{"_id":"themes/fluid/scripts/tags/note.js","hash":"e3b456a079e5dc0032473b516c865b20f83d2c26","modified":1699427989220},{"_id":"themes/fluid/scripts/tags/group-image.js","hash":"4aeebb797026f1df25646a5d69f7fde79b1bcd26","modified":1699427989220},{"_id":"themes/fluid/scripts/tags/mermaid.js","hash":"75160561e1ef3603b6d2ad2938464ab1cb77fd38","modified":1699427989220},{"_id":"themes/fluid/scripts/utils/compare-versions.js","hash":"dbbc928c914fc2bd242cd66aa0c45971aec13a5d","modified":1699427989220},{"_id":"themes/fluid/scripts/utils/object.js","hash":"33b57e4decdc5e75c518859f168c8ba80b2c665b","modified":1699427989220},{"_id":"themes/fluid/scripts/utils/resolve.js","hash":"8c4a8b62aa8608f12f1e9046231dff04859dc3e9","modified":1699427989220},{"_id":"themes/fluid/scripts/helpers/injects.js","hash":"1ad2ae6b11bd8806ee7dd6eb7140d8b54a95d613","modified":1699427989219},{"_id":"themes/fluid/source/css/.DS_Store","hash":"f70f186ce36e6863488ed142c0486c836bea03f2","modified":1710394886885},{"_id":"themes/fluid/source/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1699427989224},{"_id":"themes/fluid/source/css/highlight.styl","hash":"a9efc52a646a9e585439c768557e3e3c9e3326dc","modified":1699427989224},{"_id":"themes/fluid/source/css/main.styl","hash":"855ae5fe229c51afa57f7645f6997a27a705d7e4","modified":1699427989224},{"_id":"themes/fluid/source/css/highlight-dark.styl","hash":"45695ef75c31a4aa57324dd408b7e2327a337018","modified":1699427989224},{"_id":"themes/fluid/source/img/fluid.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1699427989225},{"_id":"themes/fluid/source/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1699427989225},{"_id":"themes/fluid/source/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1699427989226},{"_id":"themes/fluid/source/js/color-schema.js","hash":"76a198f8721352ebeaf5b2ef2f4db00612da4796","modified":1699427989226},{"_id":"themes/fluid/source/js/boot.js","hash":"38bd26c6b7acdafda86dda3560e6a3ca488d3c76","modified":1699427989226},{"_id":"themes/fluid/source/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1699427989226},{"_id":"themes/fluid/source/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1699427989226},{"_id":"themes/fluid/source/js/events.js","hash":"89e3561488a618ed0caeb9edf18e441978e29c25","modified":1699427989226},{"_id":"themes/fluid/source/js/leancloud.js","hash":"eff77c7a5c399fcaefda48884980571e15243fc9","modified":1699427989226},{"_id":"themes/fluid/scripts/utils/url-join.js","hash":"718aab5e7b2059a06b093ca738de420d9afa44ba","modified":1699427989220},{"_id":"themes/fluid/source/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1699427989226},{"_id":"themes/fluid/source/js/plugins.js","hash":"c34916291e392a774ff3e85c55badb83e8661297","modified":1699427989226},{"_id":"themes/fluid/scripts/helpers/import.js","hash":"ca53e8dbf7d44cfd372cfa79ac60f35a7d5b0076","modified":1699427989219},{"_id":"themes/fluid/source/js/utils.js","hash":"b82e7c289a66dfd36064470fd41c0e96fc598b43","modified":1699427989226},{"_id":"themes/fluid/layout/_partials/comments/disqus.ejs","hash":"aab4a4d24c55231a37db308ae94414319cecdd9b","modified":1699427989215},{"_id":"themes/fluid/layout/_partials/comments/changyan.ejs","hash":"c9b2d68ed3d375f1953e7007307d2a3f75ed6249","modified":1699427989214},{"_id":"themes/fluid/source/js/local-search.js","hash":"b9945f76f8682f3ec32edfb285b26eb559f7b7e8","modified":1699427989226},{"_id":"themes/fluid/layout/_partials/comments/discuss.ejs","hash":"98d065b58ce06b7d18bff3c974e96fa0f34ae03a","modified":1699427989215},{"_id":"themes/fluid/layout/_partials/comments/cusdis.ejs","hash":"5f9dc012be27040bbe874d0c093c0d53958cc987","modified":1699427989214},{"_id":"themes/fluid/layout/_partials/comments/giscus.ejs","hash":"95f8b866b158eff9352c381c243b332a155a5110","modified":1699427989215},{"_id":"themes/fluid/layout/_partials/comments/remark42.ejs","hash":"d4e9532feeb02aed61bd15eda536b5b631454dac","modified":1699427989215},{"_id":"themes/fluid/layout/_partials/comments/twikoo.ejs","hash":"d84bcb5ccd78470a60c067fc914ac0ac67ac8777","modified":1699427989215},{"_id":"themes/fluid/layout/_partials/comments/waline.ejs","hash":"12727da7cf3ac83443270f550be4d1c06135b52b","modified":1699427989215},{"_id":"themes/fluid/layout/_partials/comments/livere.ejs","hash":"2264758fed57542a7389c7aa9f00f1aefa17eb87","modified":1699427989215},{"_id":"themes/fluid/layout/_partials/comments/valine.ejs","hash":"19ba937553dddd317f827d682661a1066a7b1f30","modified":1699427989215},{"_id":"themes/fluid/layout/_partials/comments/utterances.ejs","hash":"c7ccf7f28308334a6da6f5425b141a24b5eca0e2","modified":1699427989215},{"_id":"themes/fluid/layout/_partials/footer/statistics.ejs","hash":"454d8dd4c39f9494ebeb03ca0746f5bc122af76a","modified":1699427989215},{"_id":"themes/fluid/layout/_partials/footer/beian.ejs","hash":"4fb9b5dd3f3e41a586d6af44e5069afe7c81fff2","modified":1699427989215},{"_id":"themes/fluid/layout/_partials/plugins/anchorjs.ejs","hash":"40181442d3a2b8734783a0ad7caf2d2522e3f2ab","modified":1699427989216},{"_id":"themes/fluid/layout/_partials/plugins/code-widget.ejs","hash":"3a505cba37942badf62a56bbb8b605b72af330aa","modified":1699427989216},{"_id":"themes/fluid/layout/_partials/plugins/highlight.ejs","hash":"7529dd215b09d3557804333942377b9e20fa554e","modified":1699427989216},{"_id":"themes/fluid/layout/_partials/comments/gitalk.ejs","hash":"843bc141a4545eb20d1c92fb63c85d459b4271ec","modified":1699427989215},{"_id":"themes/fluid/layout/_partials/plugins/encrypt.ejs","hash":"0fff24cf5bf99fbe5c56c292e2eac4a89bf29db4","modified":1699427989216},{"_id":"themes/fluid/layout/_partials/header/banner.ejs","hash":"e07757b59e7b89eea213d0e595cb5932f812fd32","modified":1699427989215},{"_id":"themes/fluid/layout/_partials/plugins/math.ejs","hash":"dcbf9a381ee76f2f1f75fcbc22c50a502ec85023","modified":1699427989216},{"_id":"themes/fluid/layout/_partials/plugins/fancybox.ejs","hash":"9d1ea2a46b8c8ad8c168594d578f40764818ef13","modified":1699427989216},{"_id":"themes/fluid/layout/_partials/header/navigation.ejs","hash":"37d750428772d7c71ba36ce0c2540780d90fadea","modified":1699427989215},{"_id":"themes/fluid/layout/_partials/plugins/analytics.ejs","hash":"4f68c80bd1395e2f6d11e373116e54de11cb62e8","modified":1699427989216},{"_id":"themes/fluid/layout/_partials/plugins/typed.ejs","hash":"f345374885cd6a334f09a11f59c443b5d577c06c","modified":1699427989216},{"_id":"themes/fluid/layout/_partials/post/meta-bottom.ejs","hash":"375974ec017696e294dc12469fb0ae257800dc2d","modified":1699427989216},{"_id":"themes/fluid/layout/_partials/plugins/nprogress.ejs","hash":"4c2d39ce816b8a6dcd6b53113c8695f8bd650a23","modified":1699427989216},{"_id":"themes/fluid/layout/_partials/post/meta-top.ejs","hash":"ce6e9f578f4faa45840abddf8f46af3f4b69c177","modified":1699427989216},{"_id":"themes/fluid/layout/_partials/post/copyright.ejs","hash":"529f3069742b3d338c769ba2d836e7f3c342a09d","modified":1699427989216},{"_id":"themes/fluid/scripts/events/lib/compatible-configs.js","hash":"ef474d1fa5bbafc52619ced0f9dc7eaf2affb363","modified":1699427989218},{"_id":"themes/fluid/layout/_partials/post/sidebar-right.ejs","hash":"d5fcc9b60e02f869a29a8c17a16a6028ecc1e6d8","modified":1699427989216},{"_id":"themes/fluid/layout/_partials/plugins/mermaid.ejs","hash":"03ac02762f801970d1c4e73d6ec8d4c503780e50","modified":1699427989216},{"_id":"themes/fluid/layout/_partials/post/sidebar-left.ejs","hash":"9992c99b3eb728ad195970e1b84d665f2c8691c4","modified":1699427989216},{"_id":"themes/fluid/scripts/events/lib/injects.js","hash":"5ae4b07204683e54b5a1b74e931702bbce2ac23e","modified":1699427989218},{"_id":"themes/fluid/scripts/events/lib/highlight.js","hash":"8d3ae1ec6660fbb0e563bc08c2f8deefde1f3bf6","modified":1699427989218},{"_id":"themes/fluid/layout/_partials/post/category-bar.ejs","hash":"8772bce97ed297e7a88523f4e939ed6436c22f87","modified":1699427989216},{"_id":"themes/fluid/scripts/events/lib/footnote.js","hash":"c19ac8050b82c3676b0332a56099ccfcc36d9d52","modified":1699427989218},{"_id":"themes/fluid/layout/_partials/post/toc.ejs","hash":"635a89060fbf72eeda066fc4bd0a97462f069417","modified":1699427989216},{"_id":"themes/fluid/scripts/events/lib/lazyload.js","hash":"9ba0d4bc224e22af8a5a48d6ff13e5a0fcfee2a4","modified":1699427989218},{"_id":"themes/fluid/scripts/events/lib/hello.js","hash":"44c5eb97b98813a07c659d6afedd17fad63b1821","modified":1699427989218},{"_id":"themes/fluid/scripts/events/lib/merge-configs.js","hash":"7c944c43b2ece5dd84859bd9d1fe955d13427387","modified":1699427989218},{"_id":"themes/fluid/source/css/_mixins/base.styl","hash":"542e306ee9494e8a78e44d6d7d409605d94caeb3","modified":1699427989221},{"_id":"themes/fluid/source/css/_functions/base.styl","hash":"2e46f3f4e2c9fe34c1ff1c598738fc7349ae8188","modified":1699427989221},{"_id":"themes/fluid/source/css/_pages/_base/base.styl","hash":"643284c567665f96915f0b64e59934dda315f74d","modified":1699427989223},{"_id":"themes/fluid/source/css/_pages/pages.styl","hash":"b8e887bc7fb3b765a1f8ec9448eff8603a41984f","modified":1699427989224},{"_id":"themes/fluid/source/css/_variables/base.styl","hash":"4ed5f0ae105ef4c7dd92eaf652ceda176c38e502","modified":1699427989224},{"_id":"themes/fluid/source/css/_pages/_about/about.styl","hash":"97fe42516ea531fdad771489b68aa8b2a7f6ae46","modified":1699427989221},{"_id":"themes/fluid/source/css/_pages/_category/category-chain.styl","hash":"0cdf7ef50dfd0669d3b257821384ff31cd81b7c9","modified":1699427989223},{"_id":"themes/fluid/source/css/_pages/_base/color-schema.styl","hash":"e413212e5a667d5b8299c4d2a39c4dfa1378d119","modified":1699427989223},{"_id":"themes/fluid/source/css/_pages/_base/keyframes.styl","hash":"94065ea50f5bef7566d184f2422f6ac20866ba22","modified":1699427989223},{"_id":"themes/fluid/source/css/_pages/_base/inline.styl","hash":"411a3fa3f924a87e00ff04d18b5c83283b049a4d","modified":1699427989223},{"_id":"themes/fluid/source/css/_pages/_category/category-bar.styl","hash":"cc6df43fef6bb3efecbfdd8b9e467424a1dea581","modified":1699427989223},{"_id":"themes/fluid/source/css/_pages/_links/links.styl","hash":"5c7f2044e3f1da05a3229537c06bd879836f8d6e","modified":1699427989224},{"_id":"themes/fluid/source/css/_pages/_category/category-list.styl","hash":"7edfe1b571ecca7d08f5f4dbcf76f4ffdcfbf0b5","modified":1699427989223},{"_id":"themes/fluid/source/css/_pages/_base/print.styl","hash":"166afbc596ea4b552bad7290ec372d25ec34db7b","modified":1699427989223},{"_id":"themes/fluid/source/css/_pages/_post/markdown.styl","hash":"1e3d3a82721e7c10bcfcecec6d81cf2979039452","modified":1699427989224},{"_id":"themes/fluid/source/css/_pages/_index/index.styl","hash":"0acbd71633bcc7191672ea4e1b2277bea350d73b","modified":1699427989224},{"_id":"themes/fluid/source/css/_pages/_archive/archive.styl","hash":"c475e6681546d30350eaed11f23081ecae80c375","modified":1699427989221},{"_id":"themes/fluid/source/css/_pages/_tag/tags.styl","hash":"65bfc01c76abc927fa1a23bf2422892b0d566c3f","modified":1699427989224},{"_id":"themes/fluid/source/css/_pages/_post/comment.styl","hash":"780f3788e7357bcd3f3262d781cb91bb53976a93","modified":1699427989224},{"_id":"themes/fluid/source/css/_pages/_post/highlight.styl","hash":"4df764d298fe556e501db4afc2b05686fe6ebcfb","modified":1699427989224},{"_id":"themes/fluid/source/css/_pages/_post/post-page.styl","hash":"ecf3488566b374d564ae985c61e08562ba908023","modified":1699427989224},{"_id":"themes/fluid/source/css/_pages/_post/post-tag.styl","hash":"27f70062415ccf66a9b6f4952db124fc1471fda5","modified":1699427989224},{"_id":"themes/fluid/source/css/_pages/_base/_widget/copyright.styl","hash":"26f71a9cd60d96bb0cb5bbdf58150b8e524d9707","modified":1699427989222},{"_id":"themes/fluid/source/css/_pages/_base/_widget/board.styl","hash":"4397037fc3f0033dbe546c33cd9dbdabd8cb1632","modified":1699427989221},{"_id":"themes/fluid/source/css/_pages/_base/_widget/code-widget.styl","hash":"b66ab013f0f37d724a149b85b3c7432afcf460ad","modified":1699427989222},{"_id":"themes/fluid/source/css/_pages/_base/_widget/footnote.styl","hash":"ae9289cc89649af2042907f8a003303b987f3404","modified":1699427989222},{"_id":"themes/fluid/source/css/_pages/_base/_widget/anchorjs.styl","hash":"e0cebda4a6f499aff75e71417d88caa7ceb13b94","modified":1699427989221},{"_id":"themes/fluid/source/css/_pages/_base/_widget/modal.styl","hash":"adf6c1e5c8e1fb41c77ce6e2258001df61245aa2","modified":1699427989222},{"_id":"themes/fluid/source/css/_pages/_base/_widget/banner.styl","hash":"7a0bd629bc234fc75e3cc8e3715ffada92f09e73","modified":1699427989221},{"_id":"themes/fluid/source/css/_pages/_base/_widget/footer.styl","hash":"2caaca71dd1ff63d583099ed817677dd267b457e","modified":1699427989222},{"_id":"themes/fluid/source/css/_pages/_base/_widget/header.styl","hash":"c4459248c66ea1326feed021179b847ae91d465f","modified":1699427989222},{"_id":"themes/fluid/source/css/_pages/_base/_widget/ngrogress.styl","hash":"5d225357b4a58d46118e6616377168336ed44cb2","modified":1699427989222},{"_id":"themes/fluid/source/css/_pages/_base/_widget/scroll-btn.styl","hash":"f0e429a27fa8a7658fcbddbb4d4dbe4afa12499a","modified":1699427989223},{"_id":"themes/fluid/source/css/_pages/_base/_widget/search.styl","hash":"10f7e91a91e681fb9fe46f9df7707b9ef78707c8","modified":1699427989223},{"_id":"themes/fluid/source/css/_pages/_base/_widget/qrcode.styl","hash":"78704a94c0436097abfb0e0a57abeb3429c749b7","modified":1699427989223},{"_id":"themes/fluid/source/css/_pages/_base/_widget/noscript.styl","hash":"0cf2f2bb44f456150d428016675d5876a9d2e2aa","modified":1699427989222},{"_id":"themes/fluid/source/css/_pages/_base/_widget/pagination.styl","hash":"8bb1b68e5f3552cb48c2ffa31edbc53646a8fb4c","modified":1699427989223},{"_id":"themes/fluid/source/css/_pages/_base/_widget/toc.styl","hash":"9e7452aa2372153f25d7a4675c9d36d281a65d24","modified":1699427989223},{"_id":"themes/fluid/source/img/favicon.jpg","hash":"1c66ec174b5a0de5eb57c1dd3ca568b2322af593","modified":1699534153902},{"_id":"themes/fluid/source/img/default.png","hash":"167a12978d80371cf578c8a2e45c24a2eb25b6fb","modified":1699427989225},{"_id":"public/atom.xml","hash":"e116f296b85710839373d20fa476c1519dabaa44","modified":1711366696394},{"_id":"public/content.json","hash":"0cc379d199eb422b83c45f6cda38a9dd540709da","modified":1711366696394},{"_id":"public/local-search.xml","hash":"93cefb5da19e2c29ede77c83885940136de46cea","modified":1711366696394},{"_id":"public/about/index.html","hash":"4400420ff70f79ac3149bc58bc8cec5219f675ae","modified":1711366696394},{"_id":"public/categories/index.html","hash":"d2ae2c9046ee1de19fda620efa8392538df7d4f6","modified":1711366696394},{"_id":"public/tags/index.html","hash":"f24f6c0e00bfb71942d5e03aeb22a0b95178c1c3","modified":1711366696394},{"_id":"public/2024/03/22/macOS查看环境变量/index.html","hash":"019be1fcdbede6d875f59b1b08ecadcf7cfd7724","modified":1711366696394},{"_id":"public/2024/03/21/DockerCompose一键部署wordpress/index.html","hash":"bf2a27d6a322f61d179ad52756d29cf129e11fce","modified":1711366696394},{"_id":"public/2024/03/17/使用JavaNIO编写一个HelloWorld程序/index.html","hash":"517640af6b7dd2433026e8cf9bceeac12cb9b6c0","modified":1711366696394},{"_id":"public/2024/03/14/Docker部署xxl-job-admin步骤/index.html","hash":"de42b3804d072a0b83e344c5e89600b886668b0b","modified":1711366696394},{"_id":"public/2023/11/12/在Mac上如何终止某个端口所在的进程？/index.html","hash":"a9b546b9b06eb1806fdc76b0e7e29ce83c350617","modified":1711366696394},{"_id":"public/2023/11/09/Java实现两台计算机之间长连接通信/index.html","hash":"a550116fb49bc8e390d2e1569b8bc9eda93825da","modified":1711366696394},{"_id":"public/2023/11/09/Java实现两台计算机之间的简单通信/index.html","hash":"1b050bb0f54650be70509f5ad0c1c15d341a7122","modified":1711366696394},{"_id":"public/2023/11/09/使用Vapor编写用户信息CRUD的API接口/index.html","hash":"4fe0277944733467faf1ea37ba49573d73a895c5","modified":1711366696394},{"_id":"public/2023/11/08/SwiftUI核心技术第15章构建一个聊天APP/index.html","hash":"05cd7a567069264c5ed096c52f466b3bc93aa109","modified":1711366696394},{"_id":"public/2023/11/08/SwiftUI核心技术第14章测试与调试/index.html","hash":"ad3041e87d73a509073fbf86d6cbd96734db9b92","modified":1711366696394},{"_id":"public/2023/11/08/SwiftUI核心技术第13章性能优化/index.html","hash":"980f295a52072add89cdb948af2e2c344bbcddb1","modified":1711366696394},{"_id":"public/2023/11/08/SwiftUI核心技术第12章Dark-Mode和Accessibility/index.html","hash":"7e49f7a4854acc194ffe4b869b22e48e25da8c92","modified":1711366696394},{"_id":"public/2023/11/08/SwiftUI核心技术第11章适配多平台/index.html","hash":"5820c832c2409eb6af5eace573a54368095966b4","modified":1711366696394},{"_id":"public/2023/11/08/SwiftUI核心技术第10章集成Core-Data和CloudKit/index.html","hash":"fedeb32782511a5a1b49005fac04ac708f6850ec","modified":1711366696394},{"_id":"public/2023/11/08/SwiftUI核心技术第9章复合视图与可复用性/index.html","hash":"24be0e459acf72f0ae12ba367be76c024fb0e386","modified":1711366696394},{"_id":"public/2023/11/08/SwiftUI核心技术第8章动画与转场/index.html","hash":"09554e60949a1ff015a2a9779a10608141694fd1","modified":1711366696394},{"_id":"public/2023/11/08/SwiftUI核心技术第7章导航与呈现/index.html","hash":"bd28421a0605cd8e5820a97e4508451ca0192937","modified":1711366696394},{"_id":"public/2023/11/08/SwiftUI核心技术第6章数据流与绑定/index.html","hash":"4e4fa8059bed2be9bb3ea3be46d6a1c09fb2cb90","modified":1711366696394},{"_id":"public/2023/11/08/SwiftUI核心技术第5章布局管理/index.html","hash":"89f371d2509ba1e4645a03469def79974b65e424","modified":1711366696394},{"_id":"public/2023/11/08/SwiftUI核心技术4章视图与控件/index.html","hash":"d07fb9cb8d7a9a05da11dc65fd9cbd6c29abd259","modified":1711366696394},{"_id":"public/2023/11/08/SwiftUI核心技术第3章环境搭建/index.html","hash":"fbc309d87bd4ebf0cfd26b306d768796877740c2","modified":1711366696394},{"_id":"public/2023/11/08/SwiftUI核心技术/index.html","hash":"18abd471221cd584d373dc40a960912744415a64","modified":1711366696394},{"_id":"public/2023/11/07/SwiftUI中ScrollView的用法/index.html","hash":"57357e04b1b888b8a177e887e23c72751db632a3","modified":1711366696394},{"_id":"public/2023/11/07/SwiftUI中List的用法/index.html","hash":"ecf36083ce86c7ca032c8edacdb0135ba2375fcd","modified":1711366696394},{"_id":"public/2023/11/07/SwiftUI中ZStack的用法/index.html","hash":"8905a09f9e13f9209540a8c016a24d3dedeb9d60","modified":1711366696394},{"_id":"public/2023/11/07/SwiftUI中VStack的用法/index.html","hash":"d7fc570ed2e5d286bceb2f803267161ab63d668b","modified":1711366696394},{"_id":"public/2023/11/07/SwiftUI中HStack的用法/index.html","hash":"86be98570c1d264caa41b0c2f0f3b6e15feff1e3","modified":1711366696394},{"_id":"public/2023/11/07/SwiftUI中的布局/index.html","hash":"b723303fc92579989f0f0d23ae103d51b159d7c9","modified":1711366696394},{"_id":"public/2023/11/07/SwiftUI中Link组件的用法/index.html","hash":"d1115e20f7f633dc0009c9039812ed692f989c6c","modified":1711366696394},{"_id":"public/2023/11/07/SwiftUI中ProgressView的用法/index.html","hash":"dc60d3eb66dbe825bc6e2a2e23e8162a192030f2","modified":1711366696394},{"_id":"public/2023/11/07/SwiftUI中的模态视图/index.html","hash":"7ea763799519f6ed42370f0b135f32840e794da9","modified":1711366696394},{"_id":"public/2023/11/07/SwiftUI中Popover控件的用法/index.html","hash":"132ceab5b2b929627a3854561fea985a66e8bdbb","modified":1711366696394},{"_id":"public/2023/11/07/SwiftUI中Sheet控件的用法/index.html","hash":"5e0468786a467bb7779429c8a6a3760fc4deeda2","modified":1711366696394},{"_id":"public/2023/11/07/SwiftUI中Alert控件的用法/index.html","hash":"5e9925986193254d55126da23eb20d268cd33101","modified":1711366696394},{"_id":"public/2023/11/07/SwiftUI中Stepper的用法/index.html","hash":"2529f2bcf195309453a399bd77535dbf40e7a0bd","modified":1711366696394},{"_id":"public/2023/11/07/SwiftUI中Slider组件的用法/index.html","hash":"270bbefb2a5fb3ff102b8061c0711a3436b7f066","modified":1711366696394},{"_id":"public/2023/11/07/SwiftUI中Picker的用法/index.html","hash":"7e6c104153477501a1aeb5d55aae77d566195e05","modified":1711366696394},{"_id":"public/2023/11/07/SwiftUI中Label的用法/index.html","hash":"a92ca063b69a614aca825eff27959823eef7727b","modified":1711366696394},{"_id":"public/2023/11/07/SwiftUI中SecureField的用法/index.html","hash":"1068cdd1c7361d7e45dc23a07af3e5ad977701ca","modified":1711366696394},{"_id":"public/2023/11/07/使用TextField开发一个记事本/index.html","hash":"ddb5c76958b4352c7d3cfcce5ca510e847122b33","modified":1711366696394},{"_id":"public/2023/11/07/SwiftUI中的TextField组件的用法/index.html","hash":"a027f82b6fea1100145e776051e70012ee727437","modified":1711366696394},{"_id":"public/2023/11/07/SwiftUI中的开关组件的用法/index.html","hash":"ceb27128fda5faf1300202118ab4eed2a39b758a","modified":1711366696394},{"_id":"public/2023/11/07/SwiftUI中的Image组件的用法/index.html","hash":"e0401479da8e705cca3258ef0c4e25f3c1cc12af","modified":1711366696394},{"_id":"public/2023/11/07/SwiftUI中的按钮组件的用法/index.html","hash":"057a5a4b3bd3f72a4b03fdd71017039518746e5f","modified":1711366696394},{"_id":"public/2023/11/07/SwiftUI中的文本控件的用法/index.html","hash":"b266f444b9a401a5c805f1a6f3d116bb3de1ad63","modified":1711366696394},{"_id":"public/2023/11/07/我现在要开发一个iOS上的APP，我应该使用SwiftUI还是UIKit呢？/index.html","hash":"35bb9e90814faae4dfcb5df5257edfc301307f74","modified":1711366696394},{"_id":"public/2023/11/07/声明式语法和命令式语法的区别/index.html","hash":"8857bb26774ea1b19953ab5f56d61fa74d72ced4","modified":1711366696394},{"_id":"public/2023/11/07/SwiftUI设计思想/index.html","hash":"8140f4f5f90d7dfa76f1a84446d7294338e4e57c","modified":1711366696394},{"_id":"public/2023/11/07/SwiftUI提供了哪些UI组件/index.html","hash":"0422787b6a7b5dc078d145e29b13d008395ea240","modified":1711366696394},{"_id":"public/2023/11/07/用SwiftUI编写一个Hello-World！/index.html","hash":"c3812e105119c7552827d91720955314fa67f3bd","modified":1711366696394},{"_id":"public/2023/11/07/对于初学者，SwiftUI和UIKit到底先学哪个？/index.html","hash":"d53f86f98a805ff6f2927b6e363b842948334638","modified":1711366696394},{"_id":"public/2023/11/07/SwiftUI和UIKit对比/index.html","hash":"e68b24cf08902027abb5a6c1569f1986f14157d3","modified":1711366696394},{"_id":"public/2023/11/07/SwiftUI简介/index.html","hash":"f1bb2cc22762fdc3e7ee241b135ea454974eb1a2","modified":1711366696394},{"_id":"public/2023/11/06/hello-world/index.html","hash":"81bf0082be9e1a95d67820f3b36bf55d16dce232","modified":1711366696394},{"_id":"public/archives/index.html","hash":"c65d4520ea6823ead05899e495dc21393421a83a","modified":1711366696394},{"_id":"public/archives/page/2/index.html","hash":"5f4c6270d0740a0ee80a591dbbc7048fab1dbd5f","modified":1711366696394},{"_id":"public/archives/2023/index.html","hash":"146e42fe0bdabeab8400b1bccb620782e82a772b","modified":1711366696394},{"_id":"public/archives/2023/11/index.html","hash":"9452bf5f8d820f5d7b05a5118be7d6c451643848","modified":1711366696394},{"_id":"public/archives/2024/index.html","hash":"c6697cdd5fe4b6dc6221c7bc8054ac416cf1dd16","modified":1711366696394},{"_id":"public/archives/2024/03/index.html","hash":"69ebe726abfa543849b435bbc207d685b86c4d2b","modified":1711366696394},{"_id":"public/categories/Java/index.html","hash":"d2518b40bf6a6c1623b1c34e99f93a978a039af2","modified":1711366696394},{"_id":"public/categories/SwiftUI/index.html","hash":"9e91bfb7866995dfff5c6367c8d50ec0e970421d","modified":1711366696394},{"_id":"public/index.html","hash":"cb7f74d16103a024c7616836ee7ad1f7247d7749","modified":1711366696394},{"_id":"public/page/2/index.html","hash":"08e24080724951e211106ffb99ae2931e969e351","modified":1711366696394},{"_id":"public/tags/Socket/index.html","hash":"f965e7599041754769a833395cfc654b72719795","modified":1711366696394},{"_id":"public/tags/ServerSocket/index.html","hash":"48f1e13bda961e875ae474e7ce7afeea54105dd9","modified":1711366696394},{"_id":"public/tags/BufferedReader/index.html","hash":"fe9713110ca28a345d2988420d00ccd1fe570368","modified":1711366696394},{"_id":"public/tags/InputStreamReader/index.html","hash":"8635ee8b98d27b61ff103fdbbb1d2a4104fd74db","modified":1711366696394},{"_id":"public/tags/PrintWriter/index.html","hash":"6d8b729701fef7147e5316468767d8c5c55acd58","modified":1711366696394},{"_id":"public/tags/Mac/index.html","hash":"fa801d2a28ebaeee7c7911c59e1fbff90c5ddff0","modified":1711366696394},{"_id":"public/404.html","hash":"dc84866c90a495b5bb9a40daa25b8790c890f128","modified":1711366696394},{"_id":"public/links/index.html","hash":"91ad1c01f039bdda89fc796bee19ed789bae14ee","modified":1711366696394},{"_id":"public/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1711366696394},{"_id":"public/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1711366696394},{"_id":"public/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1711366696394},{"_id":"public/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1711366696394},{"_id":"public/img/fluid.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1711366696394},{"_id":"public/css/highlight.css","hash":"04d4ddbb5e1d1007447c2fe293ee05aae9b9563e","modified":1711366696394},{"_id":"public/css/main.css","hash":"a0d32e1754460aaf8fda4646875e42cf2a9194ce","modified":1711366696394},{"_id":"public/css/highlight-dark.css","hash":"4720cf2051bc3580c4588d8ba4a6e09afdf92161","modified":1711366696394},{"_id":"public/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1711366696394},{"_id":"public/js/boot.js","hash":"38bd26c6b7acdafda86dda3560e6a3ca488d3c76","modified":1711366696394},{"_id":"public/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1711366696394},{"_id":"public/js/events.js","hash":"89e3561488a618ed0caeb9edf18e441978e29c25","modified":1711366696394},{"_id":"public/js/plugins.js","hash":"c34916291e392a774ff3e85c55badb83e8661297","modified":1711366696394},{"_id":"public/js/utils.js","hash":"b82e7c289a66dfd36064470fd41c0e96fc598b43","modified":1711366696394},{"_id":"public/js/local-search.js","hash":"b9945f76f8682f3ec32edfb285b26eb559f7b7e8","modified":1711366696394},{"_id":"public/js/color-schema.js","hash":"76a198f8721352ebeaf5b2ef2f4db00612da4796","modified":1711366696394},{"_id":"public/js/leancloud.js","hash":"eff77c7a5c399fcaefda48884980571e15243fc9","modified":1711366696394},{"_id":"public/img/favicon.jpg","hash":"1c66ec174b5a0de5eb57c1dd3ca568b2322af593","modified":1711366696394},{"_id":"public/img/default.png","hash":"167a12978d80371cf578c8a2e45c24a2eb25b6fb","modified":1711366696394}],"Category":[{"name":"Java","_id":"clu6up5390007z6749h2k42c8"},{"name":"SwiftUI","_id":"clu6up53c000gz6747szm6x9j"}],"Data":[],"Page":[{"title":"about","layout":"about","date":"2023-11-08T07:21:58.000Z","_content":"大家好，我是林克！\n","source":"about/index.md","raw":"---\ntitle: about\nlayout: about\ndate: 2023-11-08 15:21:58\n---\n大家好，我是林克！\n","updated":"2023-11-08T07:23:10.829Z","path":"about/index.html","comments":1,"_id":"clu6up5330000z6749bxe2zw4","content":"<p>大家好，我是林克！</p>\n","excerpt":"","more":"<p>大家好，我是林克！</p>\n"},{"layout":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"layout: categories\ncomments: false\n---","date":"2024-03-14T05:45:13.913Z","updated":"2023-11-08T10:48:45.843Z","path":"categories/index.html","title":"","_id":"clu6up5370002z674cpmreer6","content":"","excerpt":"","more":""},{"layout":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"layout: tags\ncomments: false\n---\n","date":"2024-03-14T05:45:13.912Z","updated":"2023-11-08T10:48:19.666Z","path":"tags/index.html","title":"","_id":"clu6up5380004z674he1kc597","content":"","excerpt":"","more":""}],"Post":[{"title":"DockerCompose脚本一键部署wordpress","date":"2024-03-21T07:57:06.000Z","_content":"\n```yaml\nversion: \"3\" \n# Defines which compose version to use\nservices:\n  # Services line define which Docker images to run. In this case, it will be MySQL server and WordPress image.\n  docker-mysql:\n    image: mysql:latest\n    # image: mysql:latest indicates the MySQL database container image from Docker Hub used in this installation.\n    restart: always\n    ports:\n      - \"3306:3306\"\n    volumes:\n      [\"./wordpress-mysql-data:/var/lib/mysql\"]\n    environment:\n      MYSQL_ROOT_PASSWORD: your_db_passwrod\n      MYSQL_DATABASE: wordpress\n      MYSQL_USER: your_db_user\n      MYSQL_PASSWORD: your_db_passwrod\n      # Previous four lines define the main variables needed for the MySQL container to work: database, database username, database user password, and the MySQL root password.\n  wordpress:\n    depends_on:\n      - docker-mysql\n    image: wordpress:latest\n    restart: always\n    # Restart line controls the restart mode, meaning if the container stops running for any reason, it will restart the process immediately.\n    ports:\n      - \"8000:80\"\n      # The previous line defines the port that the WordPress container will use. After successful installation, the full path will look like this: http://localhost:8000\n    environment:\n      WORDPRESS_DB_HOST: docker-mysql:3306\n      WORDPRESS_DB_USER: your_db_user\n      WORDPRESS_DB_PASSWORD: your_db_passwrod\n      WORDPRESS_DB_NAME: wordpress\n# Similar to MySQL image variables, the last four lines define the main variables needed for the WordPress container to work properly with the MySQL container.\n    volumes:\n      [\"./wordpress-html:/var/www/html\"]\nvolumes:\n  mysql: {}\n```","source":"_posts/DockerCompose一键部署wordpress.md","raw":"---\ntitle: DockerCompose脚本一键部署wordpress\ndate: 2024-03-21 15:57:06\ntags:\n---\n\n```yaml\nversion: \"3\" \n# Defines which compose version to use\nservices:\n  # Services line define which Docker images to run. In this case, it will be MySQL server and WordPress image.\n  docker-mysql:\n    image: mysql:latest\n    # image: mysql:latest indicates the MySQL database container image from Docker Hub used in this installation.\n    restart: always\n    ports:\n      - \"3306:3306\"\n    volumes:\n      [\"./wordpress-mysql-data:/var/lib/mysql\"]\n    environment:\n      MYSQL_ROOT_PASSWORD: your_db_passwrod\n      MYSQL_DATABASE: wordpress\n      MYSQL_USER: your_db_user\n      MYSQL_PASSWORD: your_db_passwrod\n      # Previous four lines define the main variables needed for the MySQL container to work: database, database username, database user password, and the MySQL root password.\n  wordpress:\n    depends_on:\n      - docker-mysql\n    image: wordpress:latest\n    restart: always\n    # Restart line controls the restart mode, meaning if the container stops running for any reason, it will restart the process immediately.\n    ports:\n      - \"8000:80\"\n      # The previous line defines the port that the WordPress container will use. After successful installation, the full path will look like this: http://localhost:8000\n    environment:\n      WORDPRESS_DB_HOST: docker-mysql:3306\n      WORDPRESS_DB_USER: your_db_user\n      WORDPRESS_DB_PASSWORD: your_db_passwrod\n      WORDPRESS_DB_NAME: wordpress\n# Similar to MySQL image variables, the last four lines define the main variables needed for the WordPress container to work properly with the MySQL container.\n    volumes:\n      [\"./wordpress-html:/var/www/html\"]\nvolumes:\n  mysql: {}\n```","slug":"DockerCompose一键部署wordpress","published":1,"updated":"2024-03-21T08:23:51.928Z","comments":1,"layout":"post","photos":[],"_id":"clu6up5350001z674987s8wev","content":"<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yaml\"><span class=\"hljs-attr\">version:</span> <span class=\"hljs-string\">&quot;3&quot;</span> <br><span class=\"hljs-comment\"># Defines which compose version to use</span><br><span class=\"hljs-attr\">services:</span><br>  <span class=\"hljs-comment\"># Services line define which Docker images to run. In this case, it will be MySQL server and WordPress image.</span><br>  <span class=\"hljs-attr\">docker-mysql:</span><br>    <span class=\"hljs-attr\">image:</span> <span class=\"hljs-string\">mysql:latest</span><br>    <span class=\"hljs-comment\"># image: mysql:latest indicates the MySQL database container image from Docker Hub used in this installation.</span><br>    <span class=\"hljs-attr\">restart:</span> <span class=\"hljs-string\">always</span><br>    <span class=\"hljs-attr\">ports:</span><br>      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">&quot;3306:3306&quot;</span><br>    <span class=\"hljs-attr\">volumes:</span><br>      [<span class=\"hljs-string\">&quot;./wordpress-mysql-data:/var/lib/mysql&quot;</span>]<br>    <span class=\"hljs-attr\">environment:</span><br>      <span class=\"hljs-attr\">MYSQL_ROOT_PASSWORD:</span> <span class=\"hljs-string\">your_db_passwrod</span><br>      <span class=\"hljs-attr\">MYSQL_DATABASE:</span> <span class=\"hljs-string\">wordpress</span><br>      <span class=\"hljs-attr\">MYSQL_USER:</span> <span class=\"hljs-string\">your_db_user</span><br>      <span class=\"hljs-attr\">MYSQL_PASSWORD:</span> <span class=\"hljs-string\">your_db_passwrod</span><br>      <span class=\"hljs-comment\"># Previous four lines define the main variables needed for the MySQL container to work: database, database username, database user password, and the MySQL root password.</span><br>  <span class=\"hljs-attr\">wordpress:</span><br>    <span class=\"hljs-attr\">depends_on:</span><br>      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">docker-mysql</span><br>    <span class=\"hljs-attr\">image:</span> <span class=\"hljs-string\">wordpress:latest</span><br>    <span class=\"hljs-attr\">restart:</span> <span class=\"hljs-string\">always</span><br>    <span class=\"hljs-comment\"># Restart line controls the restart mode, meaning if the container stops running for any reason, it will restart the process immediately.</span><br>    <span class=\"hljs-attr\">ports:</span><br>      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">&quot;8000:80&quot;</span><br>      <span class=\"hljs-comment\"># The previous line defines the port that the WordPress container will use. After successful installation, the full path will look like this: http://localhost:8000</span><br>    <span class=\"hljs-attr\">environment:</span><br>      <span class=\"hljs-attr\">WORDPRESS_DB_HOST:</span> <span class=\"hljs-string\">docker-mysql:3306</span><br>      <span class=\"hljs-attr\">WORDPRESS_DB_USER:</span> <span class=\"hljs-string\">your_db_user</span><br>      <span class=\"hljs-attr\">WORDPRESS_DB_PASSWORD:</span> <span class=\"hljs-string\">your_db_passwrod</span><br>      <span class=\"hljs-attr\">WORDPRESS_DB_NAME:</span> <span class=\"hljs-string\">wordpress</span><br><span class=\"hljs-comment\"># Similar to MySQL image variables, the last four lines define the main variables needed for the WordPress container to work properly with the MySQL container.</span><br>    <span class=\"hljs-attr\">volumes:</span><br>      [<span class=\"hljs-string\">&quot;./wordpress-html:/var/www/html&quot;</span>]<br><span class=\"hljs-attr\">volumes:</span><br>  <span class=\"hljs-attr\">mysql:</span> &#123;&#125;<br></code></pre></td></tr></table></figure>","excerpt":"","more":"<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yaml\"><span class=\"hljs-attr\">version:</span> <span class=\"hljs-string\">&quot;3&quot;</span> <br><span class=\"hljs-comment\"># Defines which compose version to use</span><br><span class=\"hljs-attr\">services:</span><br>  <span class=\"hljs-comment\"># Services line define which Docker images to run. In this case, it will be MySQL server and WordPress image.</span><br>  <span class=\"hljs-attr\">docker-mysql:</span><br>    <span class=\"hljs-attr\">image:</span> <span class=\"hljs-string\">mysql:latest</span><br>    <span class=\"hljs-comment\"># image: mysql:latest indicates the MySQL database container image from Docker Hub used in this installation.</span><br>    <span class=\"hljs-attr\">restart:</span> <span class=\"hljs-string\">always</span><br>    <span class=\"hljs-attr\">ports:</span><br>      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">&quot;3306:3306&quot;</span><br>    <span class=\"hljs-attr\">volumes:</span><br>      [<span class=\"hljs-string\">&quot;./wordpress-mysql-data:/var/lib/mysql&quot;</span>]<br>    <span class=\"hljs-attr\">environment:</span><br>      <span class=\"hljs-attr\">MYSQL_ROOT_PASSWORD:</span> <span class=\"hljs-string\">your_db_passwrod</span><br>      <span class=\"hljs-attr\">MYSQL_DATABASE:</span> <span class=\"hljs-string\">wordpress</span><br>      <span class=\"hljs-attr\">MYSQL_USER:</span> <span class=\"hljs-string\">your_db_user</span><br>      <span class=\"hljs-attr\">MYSQL_PASSWORD:</span> <span class=\"hljs-string\">your_db_passwrod</span><br>      <span class=\"hljs-comment\"># Previous four lines define the main variables needed for the MySQL container to work: database, database username, database user password, and the MySQL root password.</span><br>  <span class=\"hljs-attr\">wordpress:</span><br>    <span class=\"hljs-attr\">depends_on:</span><br>      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">docker-mysql</span><br>    <span class=\"hljs-attr\">image:</span> <span class=\"hljs-string\">wordpress:latest</span><br>    <span class=\"hljs-attr\">restart:</span> <span class=\"hljs-string\">always</span><br>    <span class=\"hljs-comment\"># Restart line controls the restart mode, meaning if the container stops running for any reason, it will restart the process immediately.</span><br>    <span class=\"hljs-attr\">ports:</span><br>      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">&quot;8000:80&quot;</span><br>      <span class=\"hljs-comment\"># The previous line defines the port that the WordPress container will use. After successful installation, the full path will look like this: http://localhost:8000</span><br>    <span class=\"hljs-attr\">environment:</span><br>      <span class=\"hljs-attr\">WORDPRESS_DB_HOST:</span> <span class=\"hljs-string\">docker-mysql:3306</span><br>      <span class=\"hljs-attr\">WORDPRESS_DB_USER:</span> <span class=\"hljs-string\">your_db_user</span><br>      <span class=\"hljs-attr\">WORDPRESS_DB_PASSWORD:</span> <span class=\"hljs-string\">your_db_passwrod</span><br>      <span class=\"hljs-attr\">WORDPRESS_DB_NAME:</span> <span class=\"hljs-string\">wordpress</span><br><span class=\"hljs-comment\"># Similar to MySQL image variables, the last four lines define the main variables needed for the WordPress container to work properly with the MySQL container.</span><br>    <span class=\"hljs-attr\">volumes:</span><br>      [<span class=\"hljs-string\">&quot;./wordpress-html:/var/www/html&quot;</span>]<br><span class=\"hljs-attr\">volumes:</span><br>  <span class=\"hljs-attr\">mysql:</span> &#123;&#125;<br></code></pre></td></tr></table></figure>"},{"title":"Docker部署xxl-job步骤","date":"2024-03-14T05:09:17.000Z","_content":"\n### 使用Docker命令创建自定义网络\n```shell\ndocker network create hdzl_net\n```\n\n### 使用Docker命令启动MySQL容器\n```shell\ndocker run -p 3306:3306 \\\n--name mysql \\\n-e MYSQL_ROOT_PASSWORD=qq490983587 \\\n--network hdzl_net \\\n-d mysql\n```\n\n### 在MySQL数据库中执行xxl-job数据库脚本\n在宿主机上使用连接mysql执行xxl-job-admin项目中提供的`tables_xxl_job.sql`脚本\n```text\n主机地址：localhost\n端口：3306\n用户名：root\n密码：qq490983587\n```\n\n### 使用Docker命令启动xxl-job-admin\n```shell\ndocker run \\\n-e PARAMS=\"--spring.datasource.url=jdbc:mysql://mysql:3306/xxl_job?useUnicode=true&characterEncoding=UTF-8&autoReconnect=true&serverTimezone=Asia/Shanghai --spring.datasource.username=root --spring.datasource.password=qq490983587\" \\\n-p 8080:8080 \\\n-v /Users/shiyanjun/logs:/data/applogs \\\n--network=hdzl_net \\\n--name xxl-job-admin \\\n-d xuxueli/xxl-job-admin:2.4.0\n```\n\n### 浏览器访问xxl-job-admin\n打开浏览器访问：http://localhost:8080/xxl-job-admin/\n登录用户名：admin\n登录密码：123456\n \n","source":"_posts/Docker部署xxl-job-admin步骤.md","raw":"---\ntitle: Docker部署xxl-job步骤\ndate: 2024-03-14 13:09:17\ntags:\n---\n\n### 使用Docker命令创建自定义网络\n```shell\ndocker network create hdzl_net\n```\n\n### 使用Docker命令启动MySQL容器\n```shell\ndocker run -p 3306:3306 \\\n--name mysql \\\n-e MYSQL_ROOT_PASSWORD=qq490983587 \\\n--network hdzl_net \\\n-d mysql\n```\n\n### 在MySQL数据库中执行xxl-job数据库脚本\n在宿主机上使用连接mysql执行xxl-job-admin项目中提供的`tables_xxl_job.sql`脚本\n```text\n主机地址：localhost\n端口：3306\n用户名：root\n密码：qq490983587\n```\n\n### 使用Docker命令启动xxl-job-admin\n```shell\ndocker run \\\n-e PARAMS=\"--spring.datasource.url=jdbc:mysql://mysql:3306/xxl_job?useUnicode=true&characterEncoding=UTF-8&autoReconnect=true&serverTimezone=Asia/Shanghai --spring.datasource.username=root --spring.datasource.password=qq490983587\" \\\n-p 8080:8080 \\\n-v /Users/shiyanjun/logs:/data/applogs \\\n--network=hdzl_net \\\n--name xxl-job-admin \\\n-d xuxueli/xxl-job-admin:2.4.0\n```\n\n### 浏览器访问xxl-job-admin\n打开浏览器访问：http://localhost:8080/xxl-job-admin/\n登录用户名：admin\n登录密码：123456\n \n","slug":"Docker部署xxl-job-admin步骤","published":1,"updated":"2024-03-14T05:23:58.635Z","comments":1,"layout":"post","photos":[],"_id":"clu6up5370003z6748nrfb99n","content":"<h3 id=\"使用Docker命令创建自定义网络\"><a href=\"#使用Docker命令创建自定义网络\" class=\"headerlink\" title=\"使用Docker命令创建自定义网络\"></a>使用Docker命令创建自定义网络</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker network create hdzl_net<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"使用Docker命令启动MySQL容器\"><a href=\"#使用Docker命令启动MySQL容器\" class=\"headerlink\" title=\"使用Docker命令启动MySQL容器\"></a>使用Docker命令启动MySQL容器</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker run -p 3306:3306 \\<br>--name mysql \\<br>-e MYSQL_ROOT_PASSWORD=qq490983587 \\<br>--network hdzl_net \\<br>-d mysql<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"在MySQL数据库中执行xxl-job数据库脚本\"><a href=\"#在MySQL数据库中执行xxl-job数据库脚本\" class=\"headerlink\" title=\"在MySQL数据库中执行xxl-job数据库脚本\"></a>在MySQL数据库中执行xxl-job数据库脚本</h3><p>在宿主机上使用连接mysql执行xxl-job-admin项目中提供的<code>tables_xxl_job.sql</code>脚本</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs text\">主机地址：localhost<br>端口：3306<br>用户名：root<br>密码：qq490983587<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"使用Docker命令启动xxl-job-admin\"><a href=\"#使用Docker命令启动xxl-job-admin\" class=\"headerlink\" title=\"使用Docker命令启动xxl-job-admin\"></a>使用Docker命令启动xxl-job-admin</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker run \\<br>-e PARAMS=&quot;--spring.datasource.url=jdbc:mysql://mysql:3306/xxl_job?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai --spring.datasource.username=root --spring.datasource.password=qq490983587&quot; \\<br>-p 8080:8080 \\<br>-v /Users/shiyanjun/logs:/data/applogs \\<br>--network=hdzl_net \\<br>--name xxl-job-admin \\<br>-d xuxueli/xxl-job-admin:2.4.0<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"浏览器访问xxl-job-admin\"><a href=\"#浏览器访问xxl-job-admin\" class=\"headerlink\" title=\"浏览器访问xxl-job-admin\"></a>浏览器访问xxl-job-admin</h3><p>打开浏览器访问：<a href=\"http://localhost:8080/xxl-job-admin/\">http://localhost:8080/xxl-job-admin/</a><br>登录用户名：admin<br>登录密码：123456</p>\n","excerpt":"","more":"<h3 id=\"使用Docker命令创建自定义网络\"><a href=\"#使用Docker命令创建自定义网络\" class=\"headerlink\" title=\"使用Docker命令创建自定义网络\"></a>使用Docker命令创建自定义网络</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker network create hdzl_net<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"使用Docker命令启动MySQL容器\"><a href=\"#使用Docker命令启动MySQL容器\" class=\"headerlink\" title=\"使用Docker命令启动MySQL容器\"></a>使用Docker命令启动MySQL容器</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker run -p 3306:3306 \\<br>--name mysql \\<br>-e MYSQL_ROOT_PASSWORD=qq490983587 \\<br>--network hdzl_net \\<br>-d mysql<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"在MySQL数据库中执行xxl-job数据库脚本\"><a href=\"#在MySQL数据库中执行xxl-job数据库脚本\" class=\"headerlink\" title=\"在MySQL数据库中执行xxl-job数据库脚本\"></a>在MySQL数据库中执行xxl-job数据库脚本</h3><p>在宿主机上使用连接mysql执行xxl-job-admin项目中提供的<code>tables_xxl_job.sql</code>脚本</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs text\">主机地址：localhost<br>端口：3306<br>用户名：root<br>密码：qq490983587<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"使用Docker命令启动xxl-job-admin\"><a href=\"#使用Docker命令启动xxl-job-admin\" class=\"headerlink\" title=\"使用Docker命令启动xxl-job-admin\"></a>使用Docker命令启动xxl-job-admin</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker run \\<br>-e PARAMS=&quot;--spring.datasource.url=jdbc:mysql://mysql:3306/xxl_job?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai --spring.datasource.username=root --spring.datasource.password=qq490983587&quot; \\<br>-p 8080:8080 \\<br>-v /Users/shiyanjun/logs:/data/applogs \\<br>--network=hdzl_net \\<br>--name xxl-job-admin \\<br>-d xuxueli/xxl-job-admin:2.4.0<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"浏览器访问xxl-job-admin\"><a href=\"#浏览器访问xxl-job-admin\" class=\"headerlink\" title=\"浏览器访问xxl-job-admin\"></a>浏览器访问xxl-job-admin</h3><p>打开浏览器访问：<a href=\"http://localhost:8080/xxl-job-admin/\">http://localhost:8080/xxl-job-admin/</a><br>登录用户名：admin<br>登录密码：123456</p>\n"},{"title":"Java实现两台计算机之间的简单通信","date":"2023-11-09T12:41:22.000Z","_content":"要在Java中实现从一台计算机（A）向另一台计算机（B）发送数据，你可以使用Java的套接字编程。这通常涉及到创建服务器端和客户端程序。服务器在B计算机上运行，监听一个端口等待连接；客户端运行在A计算机上，连接到服务器并发送数据。\n\n这里是一个简单的示例：\n\n### 服务器端（在B计算机上运行）\n\n1. 创建`ServerSocket`对象并指定一个端口。\n2. 调用`accept`方法等待客户端连接。\n3. 通过建立的连接读取数据。\n4. 关闭连接。\n\n```java\nimport java.net.*;\nimport java.io.*;\n\npublic class Server {\n    public static void main(String[] args) throws IOException {\n        int port = 1234; // 选择一个端口\n        ServerSocket serverSocket = new ServerSocket(port);\n\n        System.out.println(\"等待连接...\");\n        Socket clientSocket = serverSocket.accept();\n        System.out.println(\"连接成功！\");\n\n        BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n        String inputLine;\n        while ((inputLine = in.readLine()) != null) {\n            System.out.println(\"收到: \" + inputLine);\n        }\n\n        in.close();\n        clientSocket.close();\n        serverSocket.close();\n    }\n}\n```\n\n### 客户端（在A计算机上运行）\n\n1. 创建`Socket`对象，指定服务器地址和端口。\n2. 获取输出流并发送数据。\n3. 关闭连接。\n\n```java\nimport java.net.*;\nimport java.io.*;\n\npublic class Client {\n    public static void main(String[] args) throws IOException {\n        String serverAddress = \"服务器的IP地址\"; // 替换为B计算机的IP地址\n        int port = 1234;\n        Socket socket = new Socket(serverAddress, port);\n\n        PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n        out.println(\"你好，服务器！\");\n\n        out.close();\n        socket.close();\n    }\n}\n```\n\n注意：\n- 请确保服务器和客户端使用相同的端口号。\n- 需要处理网络异常和I/O异常。\n- 根据你的网络设置，你可能需要配置防火墙允许这些端口的通信。\n- 在实际应用中，还需要考虑安全性和效率等问题。","source":"_posts/Java实现两台计算机之间的简单通信.md","raw":"---\ntitle: Java实现两台计算机之间的简单通信\ndate: 2023-11-09 20:41:22\ncategories:\n- Java\ntags:\n- Socket\n- ServerSocket\n---\n要在Java中实现从一台计算机（A）向另一台计算机（B）发送数据，你可以使用Java的套接字编程。这通常涉及到创建服务器端和客户端程序。服务器在B计算机上运行，监听一个端口等待连接；客户端运行在A计算机上，连接到服务器并发送数据。\n\n这里是一个简单的示例：\n\n### 服务器端（在B计算机上运行）\n\n1. 创建`ServerSocket`对象并指定一个端口。\n2. 调用`accept`方法等待客户端连接。\n3. 通过建立的连接读取数据。\n4. 关闭连接。\n\n```java\nimport java.net.*;\nimport java.io.*;\n\npublic class Server {\n    public static void main(String[] args) throws IOException {\n        int port = 1234; // 选择一个端口\n        ServerSocket serverSocket = new ServerSocket(port);\n\n        System.out.println(\"等待连接...\");\n        Socket clientSocket = serverSocket.accept();\n        System.out.println(\"连接成功！\");\n\n        BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n        String inputLine;\n        while ((inputLine = in.readLine()) != null) {\n            System.out.println(\"收到: \" + inputLine);\n        }\n\n        in.close();\n        clientSocket.close();\n        serverSocket.close();\n    }\n}\n```\n\n### 客户端（在A计算机上运行）\n\n1. 创建`Socket`对象，指定服务器地址和端口。\n2. 获取输出流并发送数据。\n3. 关闭连接。\n\n```java\nimport java.net.*;\nimport java.io.*;\n\npublic class Client {\n    public static void main(String[] args) throws IOException {\n        String serverAddress = \"服务器的IP地址\"; // 替换为B计算机的IP地址\n        int port = 1234;\n        Socket socket = new Socket(serverAddress, port);\n\n        PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n        out.println(\"你好，服务器！\");\n\n        out.close();\n        socket.close();\n    }\n}\n```\n\n注意：\n- 请确保服务器和客户端使用相同的端口号。\n- 需要处理网络异常和I/O异常。\n- 根据你的网络设置，你可能需要配置防火墙允许这些端口的通信。\n- 在实际应用中，还需要考虑安全性和效率等问题。","slug":"Java实现两台计算机之间的简单通信","published":1,"updated":"2023-11-09T12:43:07.664Z","comments":1,"layout":"post","photos":[],"_id":"clu6up5380005z674ar5f7htk","content":"<p>要在Java中实现从一台计算机（A）向另一台计算机（B）发送数据，你可以使用Java的套接字编程。这通常涉及到创建服务器端和客户端程序。服务器在B计算机上运行，监听一个端口等待连接；客户端运行在A计算机上，连接到服务器并发送数据。</p>\n<p>这里是一个简单的示例：</p>\n<h3 id=\"服务器端（在B计算机上运行）\"><a href=\"#服务器端（在B计算机上运行）\" class=\"headerlink\" title=\"服务器端（在B计算机上运行）\"></a>服务器端（在B计算机上运行）</h3><ol>\n<li>创建<code>ServerSocket</code>对象并指定一个端口。</li>\n<li>调用<code>accept</code>方法等待客户端连接。</li>\n<li>通过建立的连接读取数据。</li>\n<li>关闭连接。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">import</span> java.net.*;<br><span class=\"hljs-keyword\">import</span> java.io.*;<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Server</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> <span class=\"hljs-keyword\">throws</span> IOException &#123;<br>        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">port</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1234</span>; <span class=\"hljs-comment\">// 选择一个端口</span><br>        <span class=\"hljs-type\">ServerSocket</span> <span class=\"hljs-variable\">serverSocket</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ServerSocket</span>(port);<br><br>        System.out.println(<span class=\"hljs-string\">&quot;等待连接...&quot;</span>);<br>        <span class=\"hljs-type\">Socket</span> <span class=\"hljs-variable\">clientSocket</span> <span class=\"hljs-operator\">=</span> serverSocket.accept();<br>        System.out.println(<span class=\"hljs-string\">&quot;连接成功！&quot;</span>);<br><br>        <span class=\"hljs-type\">BufferedReader</span> <span class=\"hljs-variable\">in</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BufferedReader</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">InputStreamReader</span>(clientSocket.getInputStream()));<br>        String inputLine;<br>        <span class=\"hljs-keyword\">while</span> ((inputLine = in.readLine()) != <span class=\"hljs-literal\">null</span>) &#123;<br>            System.out.println(<span class=\"hljs-string\">&quot;收到: &quot;</span> + inputLine);<br>        &#125;<br><br>        in.close();<br>        clientSocket.close();<br>        serverSocket.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"客户端（在A计算机上运行）\"><a href=\"#客户端（在A计算机上运行）\" class=\"headerlink\" title=\"客户端（在A计算机上运行）\"></a>客户端（在A计算机上运行）</h3><ol>\n<li>创建<code>Socket</code>对象，指定服务器地址和端口。</li>\n<li>获取输出流并发送数据。</li>\n<li>关闭连接。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">import</span> java.net.*;<br><span class=\"hljs-keyword\">import</span> java.io.*;<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Client</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> <span class=\"hljs-keyword\">throws</span> IOException &#123;<br>        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">serverAddress</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;服务器的IP地址&quot;</span>; <span class=\"hljs-comment\">// 替换为B计算机的IP地址</span><br>        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">port</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1234</span>;<br>        <span class=\"hljs-type\">Socket</span> <span class=\"hljs-variable\">socket</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Socket</span>(serverAddress, port);<br><br>        <span class=\"hljs-type\">PrintWriter</span> <span class=\"hljs-variable\">out</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">PrintWriter</span>(socket.getOutputStream(), <span class=\"hljs-literal\">true</span>);<br>        out.println(<span class=\"hljs-string\">&quot;你好，服务器！&quot;</span>);<br><br>        out.close();<br>        socket.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>注意：</p>\n<ul>\n<li>请确保服务器和客户端使用相同的端口号。</li>\n<li>需要处理网络异常和I&#x2F;O异常。</li>\n<li>根据你的网络设置，你可能需要配置防火墙允许这些端口的通信。</li>\n<li>在实际应用中，还需要考虑安全性和效率等问题。</li>\n</ul>\n","excerpt":"","more":"<p>要在Java中实现从一台计算机（A）向另一台计算机（B）发送数据，你可以使用Java的套接字编程。这通常涉及到创建服务器端和客户端程序。服务器在B计算机上运行，监听一个端口等待连接；客户端运行在A计算机上，连接到服务器并发送数据。</p>\n<p>这里是一个简单的示例：</p>\n<h3 id=\"服务器端（在B计算机上运行）\"><a href=\"#服务器端（在B计算机上运行）\" class=\"headerlink\" title=\"服务器端（在B计算机上运行）\"></a>服务器端（在B计算机上运行）</h3><ol>\n<li>创建<code>ServerSocket</code>对象并指定一个端口。</li>\n<li>调用<code>accept</code>方法等待客户端连接。</li>\n<li>通过建立的连接读取数据。</li>\n<li>关闭连接。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">import</span> java.net.*;<br><span class=\"hljs-keyword\">import</span> java.io.*;<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Server</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> <span class=\"hljs-keyword\">throws</span> IOException &#123;<br>        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">port</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1234</span>; <span class=\"hljs-comment\">// 选择一个端口</span><br>        <span class=\"hljs-type\">ServerSocket</span> <span class=\"hljs-variable\">serverSocket</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ServerSocket</span>(port);<br><br>        System.out.println(<span class=\"hljs-string\">&quot;等待连接...&quot;</span>);<br>        <span class=\"hljs-type\">Socket</span> <span class=\"hljs-variable\">clientSocket</span> <span class=\"hljs-operator\">=</span> serverSocket.accept();<br>        System.out.println(<span class=\"hljs-string\">&quot;连接成功！&quot;</span>);<br><br>        <span class=\"hljs-type\">BufferedReader</span> <span class=\"hljs-variable\">in</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BufferedReader</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">InputStreamReader</span>(clientSocket.getInputStream()));<br>        String inputLine;<br>        <span class=\"hljs-keyword\">while</span> ((inputLine = in.readLine()) != <span class=\"hljs-literal\">null</span>) &#123;<br>            System.out.println(<span class=\"hljs-string\">&quot;收到: &quot;</span> + inputLine);<br>        &#125;<br><br>        in.close();<br>        clientSocket.close();<br>        serverSocket.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"客户端（在A计算机上运行）\"><a href=\"#客户端（在A计算机上运行）\" class=\"headerlink\" title=\"客户端（在A计算机上运行）\"></a>客户端（在A计算机上运行）</h3><ol>\n<li>创建<code>Socket</code>对象，指定服务器地址和端口。</li>\n<li>获取输出流并发送数据。</li>\n<li>关闭连接。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">import</span> java.net.*;<br><span class=\"hljs-keyword\">import</span> java.io.*;<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Client</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> <span class=\"hljs-keyword\">throws</span> IOException &#123;<br>        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">serverAddress</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;服务器的IP地址&quot;</span>; <span class=\"hljs-comment\">// 替换为B计算机的IP地址</span><br>        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">port</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1234</span>;<br>        <span class=\"hljs-type\">Socket</span> <span class=\"hljs-variable\">socket</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Socket</span>(serverAddress, port);<br><br>        <span class=\"hljs-type\">PrintWriter</span> <span class=\"hljs-variable\">out</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">PrintWriter</span>(socket.getOutputStream(), <span class=\"hljs-literal\">true</span>);<br>        out.println(<span class=\"hljs-string\">&quot;你好，服务器！&quot;</span>);<br><br>        out.close();<br>        socket.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>注意：</p>\n<ul>\n<li>请确保服务器和客户端使用相同的端口号。</li>\n<li>需要处理网络异常和I&#x2F;O异常。</li>\n<li>根据你的网络设置，你可能需要配置防火墙允许这些端口的通信。</li>\n<li>在实际应用中，还需要考虑安全性和效率等问题。</li>\n</ul>\n"},{"title":"Java实现两台计算机之间长连接通信","date":"2023-11-09T12:54:10.000Z","_content":"要实现客户端和服务器端的长连接，即一直保持连接直到程序显式关闭，你可以在客户端和服务器端都使用循环来持续地发送和接收消息。下面是相应的代码示例：\n\n### 服务器端（B计算机）\n\n服务器端持续监听客户端发送的消息。使用`while(true)`确保服务器始终在运行，等待和处理客户端的消息。\n\n```java\nimport java.net.*;\nimport java.io.*;\n\npublic class Server {\n    public static void main(String[] args) throws IOException {\n        int port = 1234;\n        ServerSocket serverSocket = new ServerSocket(port);\n        System.out.println(\"等待连接...\");\n        Socket clientSocket = serverSocket.accept();\n        System.out.println(\"连接成功！\");\n\n        BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n\n        String inputLine;\n        while (true) { // 一直保持监听状态\n            inputLine = in.readLine();\n            if (inputLine != null) {\n                System.out.println(\"收到: \" + inputLine);\n            }\n        }\n        // 注意：实际应用中需要添加适当的退出条件和异常处理\n    }\n}\n```\n\n### 客户端（A计算机）\n\n客户端持续发送消息到服务器。在这个例子中，我们仅以发送时间作为消息的示例。\n\n```java\nimport java.net.*;\nimport java.io.*;\nimport java.util.Date;\n\npublic class Client {\n    public static void main(String[] args) throws IOException, InterruptedException {\n        String serverAddress = \"服务器的IP地址\"; // 替换为B计算机的IP地址\n        int port = 1234;\n        Socket socket = new Socket(serverAddress, port);\n\n        PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n        \n        while (true) { // 一直发送消息\n            out.println(\"当前时间: \" + new Date());\n            Thread.sleep(1000); // 每秒发送一次\n        }\n        // 注意：实际应用中需要添加适当的退出条件和异常处理\n    }\n}\n```\n\n在这两个示例中，我没有添加退出条件和异常处理，但这在实际应用中是非常重要的。你需要确保代码能够优雅地处理网络异常、I/O异常以及如何安全地关闭连接。记住，长时间保持连接会增加资源消耗，确保服务器有足够的资源来处理这些长连接。","source":"_posts/Java实现两台计算机之间长连接通信.md","raw":"---\ntitle: Java实现两台计算机之间长连接通信\ndate: 2023-11-09 20:54:10\ncategories:\n- Java\ntags:\n- Socket\n- ServerSocket\n- BufferedReader\n- InputStreamReader\n- PrintWriter\n---\n要实现客户端和服务器端的长连接，即一直保持连接直到程序显式关闭，你可以在客户端和服务器端都使用循环来持续地发送和接收消息。下面是相应的代码示例：\n\n### 服务器端（B计算机）\n\n服务器端持续监听客户端发送的消息。使用`while(true)`确保服务器始终在运行，等待和处理客户端的消息。\n\n```java\nimport java.net.*;\nimport java.io.*;\n\npublic class Server {\n    public static void main(String[] args) throws IOException {\n        int port = 1234;\n        ServerSocket serverSocket = new ServerSocket(port);\n        System.out.println(\"等待连接...\");\n        Socket clientSocket = serverSocket.accept();\n        System.out.println(\"连接成功！\");\n\n        BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n\n        String inputLine;\n        while (true) { // 一直保持监听状态\n            inputLine = in.readLine();\n            if (inputLine != null) {\n                System.out.println(\"收到: \" + inputLine);\n            }\n        }\n        // 注意：实际应用中需要添加适当的退出条件和异常处理\n    }\n}\n```\n\n### 客户端（A计算机）\n\n客户端持续发送消息到服务器。在这个例子中，我们仅以发送时间作为消息的示例。\n\n```java\nimport java.net.*;\nimport java.io.*;\nimport java.util.Date;\n\npublic class Client {\n    public static void main(String[] args) throws IOException, InterruptedException {\n        String serverAddress = \"服务器的IP地址\"; // 替换为B计算机的IP地址\n        int port = 1234;\n        Socket socket = new Socket(serverAddress, port);\n\n        PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n        \n        while (true) { // 一直发送消息\n            out.println(\"当前时间: \" + new Date());\n            Thread.sleep(1000); // 每秒发送一次\n        }\n        // 注意：实际应用中需要添加适当的退出条件和异常处理\n    }\n}\n```\n\n在这两个示例中，我没有添加退出条件和异常处理，但这在实际应用中是非常重要的。你需要确保代码能够优雅地处理网络异常、I/O异常以及如何安全地关闭连接。记住，长时间保持连接会增加资源消耗，确保服务器有足够的资源来处理这些长连接。","slug":"Java实现两台计算机之间长连接通信","published":1,"updated":"2023-11-09T12:55:57.056Z","comments":1,"layout":"post","photos":[],"_id":"clu6up5390006z674h7ywg36n","content":"<p>要实现客户端和服务器端的长连接，即一直保持连接直到程序显式关闭，你可以在客户端和服务器端都使用循环来持续地发送和接收消息。下面是相应的代码示例：</p>\n<h3 id=\"服务器端（B计算机）\"><a href=\"#服务器端（B计算机）\" class=\"headerlink\" title=\"服务器端（B计算机）\"></a>服务器端（B计算机）</h3><p>服务器端持续监听客户端发送的消息。使用<code>while(true)</code>确保服务器始终在运行，等待和处理客户端的消息。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">import</span> java.net.*;<br><span class=\"hljs-keyword\">import</span> java.io.*;<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Server</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> <span class=\"hljs-keyword\">throws</span> IOException &#123;<br>        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">port</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1234</span>;<br>        <span class=\"hljs-type\">ServerSocket</span> <span class=\"hljs-variable\">serverSocket</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ServerSocket</span>(port);<br>        System.out.println(<span class=\"hljs-string\">&quot;等待连接...&quot;</span>);<br>        <span class=\"hljs-type\">Socket</span> <span class=\"hljs-variable\">clientSocket</span> <span class=\"hljs-operator\">=</span> serverSocket.accept();<br>        System.out.println(<span class=\"hljs-string\">&quot;连接成功！&quot;</span>);<br><br>        <span class=\"hljs-type\">BufferedReader</span> <span class=\"hljs-variable\">in</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BufferedReader</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">InputStreamReader</span>(clientSocket.getInputStream()));<br><br>        String inputLine;<br>        <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>) &#123; <span class=\"hljs-comment\">// 一直保持监听状态</span><br>            inputLine = in.readLine();<br>            <span class=\"hljs-keyword\">if</span> (inputLine != <span class=\"hljs-literal\">null</span>) &#123;<br>                System.out.println(<span class=\"hljs-string\">&quot;收到: &quot;</span> + inputLine);<br>            &#125;<br>        &#125;<br>        <span class=\"hljs-comment\">// 注意：实际应用中需要添加适当的退出条件和异常处理</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"客户端（A计算机）\"><a href=\"#客户端（A计算机）\" class=\"headerlink\" title=\"客户端（A计算机）\"></a>客户端（A计算机）</h3><p>客户端持续发送消息到服务器。在这个例子中，我们仅以发送时间作为消息的示例。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">import</span> java.net.*;<br><span class=\"hljs-keyword\">import</span> java.io.*;<br><span class=\"hljs-keyword\">import</span> java.util.Date;<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Client</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> <span class=\"hljs-keyword\">throws</span> IOException, InterruptedException &#123;<br>        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">serverAddress</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;服务器的IP地址&quot;</span>; <span class=\"hljs-comment\">// 替换为B计算机的IP地址</span><br>        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">port</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1234</span>;<br>        <span class=\"hljs-type\">Socket</span> <span class=\"hljs-variable\">socket</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Socket</span>(serverAddress, port);<br><br>        <span class=\"hljs-type\">PrintWriter</span> <span class=\"hljs-variable\">out</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">PrintWriter</span>(socket.getOutputStream(), <span class=\"hljs-literal\">true</span>);<br>        <br>        <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>) &#123; <span class=\"hljs-comment\">// 一直发送消息</span><br>            out.println(<span class=\"hljs-string\">&quot;当前时间: &quot;</span> + <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Date</span>());<br>            Thread.sleep(<span class=\"hljs-number\">1000</span>); <span class=\"hljs-comment\">// 每秒发送一次</span><br>        &#125;<br>        <span class=\"hljs-comment\">// 注意：实际应用中需要添加适当的退出条件和异常处理</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在这两个示例中，我没有添加退出条件和异常处理，但这在实际应用中是非常重要的。你需要确保代码能够优雅地处理网络异常、I&#x2F;O异常以及如何安全地关闭连接。记住，长时间保持连接会增加资源消耗，确保服务器有足够的资源来处理这些长连接。</p>\n","excerpt":"","more":"<p>要实现客户端和服务器端的长连接，即一直保持连接直到程序显式关闭，你可以在客户端和服务器端都使用循环来持续地发送和接收消息。下面是相应的代码示例：</p>\n<h3 id=\"服务器端（B计算机）\"><a href=\"#服务器端（B计算机）\" class=\"headerlink\" title=\"服务器端（B计算机）\"></a>服务器端（B计算机）</h3><p>服务器端持续监听客户端发送的消息。使用<code>while(true)</code>确保服务器始终在运行，等待和处理客户端的消息。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">import</span> java.net.*;<br><span class=\"hljs-keyword\">import</span> java.io.*;<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Server</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> <span class=\"hljs-keyword\">throws</span> IOException &#123;<br>        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">port</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1234</span>;<br>        <span class=\"hljs-type\">ServerSocket</span> <span class=\"hljs-variable\">serverSocket</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ServerSocket</span>(port);<br>        System.out.println(<span class=\"hljs-string\">&quot;等待连接...&quot;</span>);<br>        <span class=\"hljs-type\">Socket</span> <span class=\"hljs-variable\">clientSocket</span> <span class=\"hljs-operator\">=</span> serverSocket.accept();<br>        System.out.println(<span class=\"hljs-string\">&quot;连接成功！&quot;</span>);<br><br>        <span class=\"hljs-type\">BufferedReader</span> <span class=\"hljs-variable\">in</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BufferedReader</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">InputStreamReader</span>(clientSocket.getInputStream()));<br><br>        String inputLine;<br>        <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>) &#123; <span class=\"hljs-comment\">// 一直保持监听状态</span><br>            inputLine = in.readLine();<br>            <span class=\"hljs-keyword\">if</span> (inputLine != <span class=\"hljs-literal\">null</span>) &#123;<br>                System.out.println(<span class=\"hljs-string\">&quot;收到: &quot;</span> + inputLine);<br>            &#125;<br>        &#125;<br>        <span class=\"hljs-comment\">// 注意：实际应用中需要添加适当的退出条件和异常处理</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"客户端（A计算机）\"><a href=\"#客户端（A计算机）\" class=\"headerlink\" title=\"客户端（A计算机）\"></a>客户端（A计算机）</h3><p>客户端持续发送消息到服务器。在这个例子中，我们仅以发送时间作为消息的示例。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">import</span> java.net.*;<br><span class=\"hljs-keyword\">import</span> java.io.*;<br><span class=\"hljs-keyword\">import</span> java.util.Date;<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Client</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> <span class=\"hljs-keyword\">throws</span> IOException, InterruptedException &#123;<br>        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">serverAddress</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;服务器的IP地址&quot;</span>; <span class=\"hljs-comment\">// 替换为B计算机的IP地址</span><br>        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">port</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1234</span>;<br>        <span class=\"hljs-type\">Socket</span> <span class=\"hljs-variable\">socket</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Socket</span>(serverAddress, port);<br><br>        <span class=\"hljs-type\">PrintWriter</span> <span class=\"hljs-variable\">out</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">PrintWriter</span>(socket.getOutputStream(), <span class=\"hljs-literal\">true</span>);<br>        <br>        <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>) &#123; <span class=\"hljs-comment\">// 一直发送消息</span><br>            out.println(<span class=\"hljs-string\">&quot;当前时间: &quot;</span> + <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Date</span>());<br>            Thread.sleep(<span class=\"hljs-number\">1000</span>); <span class=\"hljs-comment\">// 每秒发送一次</span><br>        &#125;<br>        <span class=\"hljs-comment\">// 注意：实际应用中需要添加适当的退出条件和异常处理</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在这两个示例中，我没有添加退出条件和异常处理，但这在实际应用中是非常重要的。你需要确保代码能够优雅地处理网络异常、I&#x2F;O异常以及如何安全地关闭连接。记住，长时间保持连接会增加资源消耗，确保服务器有足够的资源来处理这些长连接。</p>\n"},{"title":"SwiftUI中Alert控件的用法","date":"2023-11-07T12:58:19.000Z","_content":"在 SwiftUI 中，`Alert` 控件用来向用户显示警告或者提示信息，并且可以提供一个或多个操作供用户选择。`Alert` 通常用于提示错误信息、确认重要操作或展示信息确认。\n\n### 基础用法\n\n使用 `Alert` 需要创建一个状态变量来控制它的显示与隐藏，并且在视图的某个事件中触发这个状态变量的变化。然后，你可以使用 `.alert` 修饰符来在视图层级中添加一个 `Alert`。\n\n```swift\nstruct ContentView: View {\n    @State private var showAlert = false\n\n    var body: some View {\n        Button(\"Show Alert\") {\n            self.showAlert = true\n        }\n        .alert(\"Important message\", isPresented: $showAlert) {\n            Button(\"OK\", role: .cancel) { }\n        }\n    }\n}\n```\n\n在这个例子中，当按钮被点击时，`showAlert` 状态变为 `true`，这会触发 `.alert` 修饰符显示一个带有 \"OK\" 按钮的警告框。\n\n### 带有多个按钮的 Alert\n\n```swift\n.alert(\"Important message\", isPresented: $showAlert) {\n    Button(\"Cancel\", role: .cancel) { }\n    Button(\"Delete\", role: .destructive) { }\n    Button(\"Save\") { }\n}\n```\n\n这里，除了取消按钮外，我们还添加了一个具有破坏性的删除操作和一个普通的保存操作。\n\n### Alert 的自定义内容\n\n你还可以自定义 `Alert` 的标题、消息和按钮。例如，下面的 `Alert` 有一个标题、消息和两个按钮：\n\n```swift\n.alert(isPresented: $showAlert) {\n    Alert(\n        title: Text(\"Important message\"),\n        message: Text(\"Please read this.\"),\n        primaryButton: .default(Text(\"Got it!\")),\n        secondaryButton: .cancel()\n    )\n}\n```\n\n### 使用 `Alert` 获取用户输入\n\n在 SwiftUI 中，如果你想在 `Alert` 中获取用户的输入，你通常会使用其他视图，如 `sheet`，因为 `Alert` 本身并不支持文本输入。不过，你可以通过弹出一个带有文本字段的 `sheet` 或者使用自定义的对话框视图来模拟这个行为。\n\n### 使用 `Alert` 与 `ObservableObject`\n\n当你的视图模型遵循 `ObservableObject` 并使用 `@Published` 属性来管理状态时，你可以这样使用 `Alert`：\n\n```swift\nstruct ContentView: View {\n    @ObservedObject var viewModel = MyViewModel()\n\n    var body: some View {\n        Button(\"Show Alert\") {\n            viewModel.triggerAlert()\n        }\n        .alert(\"Important message\", isPresented: $viewModel.showAlert) {\n            Button(\"OK\", role: .cancel) { }\n        }\n    }\n}\n\nclass MyViewModel: ObservableObject {\n    @Published var showAlert = false\n\n    func triggerAlert() {\n        showAlert = true\n    }\n}\n```\n\n在上面的例子中，`MyViewModel` 控制 `showAlert` 的状态，当 `triggerAlert` 方法被调用时，会显示 `Alert`。\n\n`Alert` 在 SwiftUI 中是模态的，这意味着当它出现时，用户必须进行选择才能继续与应用交互。它的设计旨在用于必须要立即解决的情况，因此在设计用户界面时应慎用。","source":"_posts/SwiftUI中Alert控件的用法.md","raw":"---\ntitle: SwiftUI中Alert控件的用法\ndate: 2023-11-07 20:58:19\ncategories:\n- SwiftUI\ntags:\n---\n在 SwiftUI 中，`Alert` 控件用来向用户显示警告或者提示信息，并且可以提供一个或多个操作供用户选择。`Alert` 通常用于提示错误信息、确认重要操作或展示信息确认。\n\n### 基础用法\n\n使用 `Alert` 需要创建一个状态变量来控制它的显示与隐藏，并且在视图的某个事件中触发这个状态变量的变化。然后，你可以使用 `.alert` 修饰符来在视图层级中添加一个 `Alert`。\n\n```swift\nstruct ContentView: View {\n    @State private var showAlert = false\n\n    var body: some View {\n        Button(\"Show Alert\") {\n            self.showAlert = true\n        }\n        .alert(\"Important message\", isPresented: $showAlert) {\n            Button(\"OK\", role: .cancel) { }\n        }\n    }\n}\n```\n\n在这个例子中，当按钮被点击时，`showAlert` 状态变为 `true`，这会触发 `.alert` 修饰符显示一个带有 \"OK\" 按钮的警告框。\n\n### 带有多个按钮的 Alert\n\n```swift\n.alert(\"Important message\", isPresented: $showAlert) {\n    Button(\"Cancel\", role: .cancel) { }\n    Button(\"Delete\", role: .destructive) { }\n    Button(\"Save\") { }\n}\n```\n\n这里，除了取消按钮外，我们还添加了一个具有破坏性的删除操作和一个普通的保存操作。\n\n### Alert 的自定义内容\n\n你还可以自定义 `Alert` 的标题、消息和按钮。例如，下面的 `Alert` 有一个标题、消息和两个按钮：\n\n```swift\n.alert(isPresented: $showAlert) {\n    Alert(\n        title: Text(\"Important message\"),\n        message: Text(\"Please read this.\"),\n        primaryButton: .default(Text(\"Got it!\")),\n        secondaryButton: .cancel()\n    )\n}\n```\n\n### 使用 `Alert` 获取用户输入\n\n在 SwiftUI 中，如果你想在 `Alert` 中获取用户的输入，你通常会使用其他视图，如 `sheet`，因为 `Alert` 本身并不支持文本输入。不过，你可以通过弹出一个带有文本字段的 `sheet` 或者使用自定义的对话框视图来模拟这个行为。\n\n### 使用 `Alert` 与 `ObservableObject`\n\n当你的视图模型遵循 `ObservableObject` 并使用 `@Published` 属性来管理状态时，你可以这样使用 `Alert`：\n\n```swift\nstruct ContentView: View {\n    @ObservedObject var viewModel = MyViewModel()\n\n    var body: some View {\n        Button(\"Show Alert\") {\n            viewModel.triggerAlert()\n        }\n        .alert(\"Important message\", isPresented: $viewModel.showAlert) {\n            Button(\"OK\", role: .cancel) { }\n        }\n    }\n}\n\nclass MyViewModel: ObservableObject {\n    @Published var showAlert = false\n\n    func triggerAlert() {\n        showAlert = true\n    }\n}\n```\n\n在上面的例子中，`MyViewModel` 控制 `showAlert` 的状态，当 `triggerAlert` 方法被调用时，会显示 `Alert`。\n\n`Alert` 在 SwiftUI 中是模态的，这意味着当它出现时，用户必须进行选择才能继续与应用交互。它的设计旨在用于必须要立即解决的情况，因此在设计用户界面时应慎用。","slug":"SwiftUI中Alert控件的用法","published":1,"updated":"2024-03-17T06:12:42.552Z","comments":1,"layout":"post","photos":[],"_id":"clu6up53a0009z674hxz42mih","content":"<p>在 SwiftUI 中，<code>Alert</code> 控件用来向用户显示警告或者提示信息，并且可以提供一个或多个操作供用户选择。<code>Alert</code> 通常用于提示错误信息、确认重要操作或展示信息确认。</p>\n<h3 id=\"基础用法\"><a href=\"#基础用法\" class=\"headerlink\" title=\"基础用法\"></a>基础用法</h3><p>使用 <code>Alert</code> 需要创建一个状态变量来控制它的显示与隐藏，并且在视图的某个事件中触发这个状态变量的变化。然后，你可以使用 <code>.alert</code> 修饰符来在视图层级中添加一个 <code>Alert</code>。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ContentView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> showAlert <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">false</span><br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">Button</span>(<span class=\"hljs-string\">&quot;Show Alert&quot;</span>) &#123;<br>            <span class=\"hljs-keyword\">self</span>.showAlert <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">true</span><br>        &#125;<br>        .alert(<span class=\"hljs-string\">&quot;Important message&quot;</span>, isPresented: <span class=\"hljs-variable\">$showAlert</span>) &#123;<br>            <span class=\"hljs-type\">Button</span>(<span class=\"hljs-string\">&quot;OK&quot;</span>, role: .cancel) &#123; &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在这个例子中，当按钮被点击时，<code>showAlert</code> 状态变为 <code>true</code>，这会触发 <code>.alert</code> 修饰符显示一个带有 “OK” 按钮的警告框。</p>\n<h3 id=\"带有多个按钮的-Alert\"><a href=\"#带有多个按钮的-Alert\" class=\"headerlink\" title=\"带有多个按钮的 Alert\"></a>带有多个按钮的 Alert</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\">.alert(<span class=\"hljs-string\">&quot;Important message&quot;</span>, isPresented: <span class=\"hljs-variable\">$showAlert</span>) &#123;<br>    <span class=\"hljs-type\">Button</span>(<span class=\"hljs-string\">&quot;Cancel&quot;</span>, role: .cancel) &#123; &#125;<br>    <span class=\"hljs-type\">Button</span>(<span class=\"hljs-string\">&quot;Delete&quot;</span>, role: .destructive) &#123; &#125;<br>    <span class=\"hljs-type\">Button</span>(<span class=\"hljs-string\">&quot;Save&quot;</span>) &#123; &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这里，除了取消按钮外，我们还添加了一个具有破坏性的删除操作和一个普通的保存操作。</p>\n<h3 id=\"Alert-的自定义内容\"><a href=\"#Alert-的自定义内容\" class=\"headerlink\" title=\"Alert 的自定义内容\"></a>Alert 的自定义内容</h3><p>你还可以自定义 <code>Alert</code> 的标题、消息和按钮。例如，下面的 <code>Alert</code> 有一个标题、消息和两个按钮：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\">.alert(isPresented: <span class=\"hljs-variable\">$showAlert</span>) &#123;<br>    <span class=\"hljs-type\">Alert</span>(<br>        title: <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Important message&quot;</span>),<br>        message: <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Please read this.&quot;</span>),<br>        primaryButton: .default(<span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Got it!&quot;</span>)),<br>        secondaryButton: .cancel()<br>    )<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"使用-Alert-获取用户输入\"><a href=\"#使用-Alert-获取用户输入\" class=\"headerlink\" title=\"使用 Alert 获取用户输入\"></a>使用 <code>Alert</code> 获取用户输入</h3><p>在 SwiftUI 中，如果你想在 <code>Alert</code> 中获取用户的输入，你通常会使用其他视图，如 <code>sheet</code>，因为 <code>Alert</code> 本身并不支持文本输入。不过，你可以通过弹出一个带有文本字段的 <code>sheet</code> 或者使用自定义的对话框视图来模拟这个行为。</p>\n<h3 id=\"使用-Alert-与-ObservableObject\"><a href=\"#使用-Alert-与-ObservableObject\" class=\"headerlink\" title=\"使用 Alert 与 ObservableObject\"></a>使用 <code>Alert</code> 与 <code>ObservableObject</code></h3><p>当你的视图模型遵循 <code>ObservableObject</code> 并使用 <code>@Published</code> 属性来管理状态时，你可以这样使用 <code>Alert</code>：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ContentView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@ObservedObject</span> <span class=\"hljs-keyword\">var</span> viewModel <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">MyViewModel</span>()<br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">Button</span>(<span class=\"hljs-string\">&quot;Show Alert&quot;</span>) &#123;<br>            viewModel.triggerAlert()<br>        &#125;<br>        .alert(<span class=\"hljs-string\">&quot;Important message&quot;</span>, isPresented: <span class=\"hljs-variable\">$viewModel</span>.showAlert) &#123;<br>            <span class=\"hljs-type\">Button</span>(<span class=\"hljs-string\">&quot;OK&quot;</span>, role: .cancel) &#123; &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyViewModel</span>: <span class=\"hljs-title class_\">ObservableObject</span> &#123;<br>    <span class=\"hljs-meta\">@Published</span> <span class=\"hljs-keyword\">var</span> showAlert <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">false</span><br><br>    <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">triggerAlert</span>() &#123;<br>        showAlert <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">true</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在上面的例子中，<code>MyViewModel</code> 控制 <code>showAlert</code> 的状态，当 <code>triggerAlert</code> 方法被调用时，会显示 <code>Alert</code>。</p>\n<p><code>Alert</code> 在 SwiftUI 中是模态的，这意味着当它出现时，用户必须进行选择才能继续与应用交互。它的设计旨在用于必须要立即解决的情况，因此在设计用户界面时应慎用。</p>\n","excerpt":"","more":"<p>在 SwiftUI 中，<code>Alert</code> 控件用来向用户显示警告或者提示信息，并且可以提供一个或多个操作供用户选择。<code>Alert</code> 通常用于提示错误信息、确认重要操作或展示信息确认。</p>\n<h3 id=\"基础用法\"><a href=\"#基础用法\" class=\"headerlink\" title=\"基础用法\"></a>基础用法</h3><p>使用 <code>Alert</code> 需要创建一个状态变量来控制它的显示与隐藏，并且在视图的某个事件中触发这个状态变量的变化。然后，你可以使用 <code>.alert</code> 修饰符来在视图层级中添加一个 <code>Alert</code>。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ContentView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> showAlert <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">false</span><br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">Button</span>(<span class=\"hljs-string\">&quot;Show Alert&quot;</span>) &#123;<br>            <span class=\"hljs-keyword\">self</span>.showAlert <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">true</span><br>        &#125;<br>        .alert(<span class=\"hljs-string\">&quot;Important message&quot;</span>, isPresented: <span class=\"hljs-variable\">$showAlert</span>) &#123;<br>            <span class=\"hljs-type\">Button</span>(<span class=\"hljs-string\">&quot;OK&quot;</span>, role: .cancel) &#123; &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在这个例子中，当按钮被点击时，<code>showAlert</code> 状态变为 <code>true</code>，这会触发 <code>.alert</code> 修饰符显示一个带有 “OK” 按钮的警告框。</p>\n<h3 id=\"带有多个按钮的-Alert\"><a href=\"#带有多个按钮的-Alert\" class=\"headerlink\" title=\"带有多个按钮的 Alert\"></a>带有多个按钮的 Alert</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\">.alert(<span class=\"hljs-string\">&quot;Important message&quot;</span>, isPresented: <span class=\"hljs-variable\">$showAlert</span>) &#123;<br>    <span class=\"hljs-type\">Button</span>(<span class=\"hljs-string\">&quot;Cancel&quot;</span>, role: .cancel) &#123; &#125;<br>    <span class=\"hljs-type\">Button</span>(<span class=\"hljs-string\">&quot;Delete&quot;</span>, role: .destructive) &#123; &#125;<br>    <span class=\"hljs-type\">Button</span>(<span class=\"hljs-string\">&quot;Save&quot;</span>) &#123; &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这里，除了取消按钮外，我们还添加了一个具有破坏性的删除操作和一个普通的保存操作。</p>\n<h3 id=\"Alert-的自定义内容\"><a href=\"#Alert-的自定义内容\" class=\"headerlink\" title=\"Alert 的自定义内容\"></a>Alert 的自定义内容</h3><p>你还可以自定义 <code>Alert</code> 的标题、消息和按钮。例如，下面的 <code>Alert</code> 有一个标题、消息和两个按钮：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\">.alert(isPresented: <span class=\"hljs-variable\">$showAlert</span>) &#123;<br>    <span class=\"hljs-type\">Alert</span>(<br>        title: <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Important message&quot;</span>),<br>        message: <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Please read this.&quot;</span>),<br>        primaryButton: .default(<span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Got it!&quot;</span>)),<br>        secondaryButton: .cancel()<br>    )<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"使用-Alert-获取用户输入\"><a href=\"#使用-Alert-获取用户输入\" class=\"headerlink\" title=\"使用 Alert 获取用户输入\"></a>使用 <code>Alert</code> 获取用户输入</h3><p>在 SwiftUI 中，如果你想在 <code>Alert</code> 中获取用户的输入，你通常会使用其他视图，如 <code>sheet</code>，因为 <code>Alert</code> 本身并不支持文本输入。不过，你可以通过弹出一个带有文本字段的 <code>sheet</code> 或者使用自定义的对话框视图来模拟这个行为。</p>\n<h3 id=\"使用-Alert-与-ObservableObject\"><a href=\"#使用-Alert-与-ObservableObject\" class=\"headerlink\" title=\"使用 Alert 与 ObservableObject\"></a>使用 <code>Alert</code> 与 <code>ObservableObject</code></h3><p>当你的视图模型遵循 <code>ObservableObject</code> 并使用 <code>@Published</code> 属性来管理状态时，你可以这样使用 <code>Alert</code>：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ContentView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@ObservedObject</span> <span class=\"hljs-keyword\">var</span> viewModel <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">MyViewModel</span>()<br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">Button</span>(<span class=\"hljs-string\">&quot;Show Alert&quot;</span>) &#123;<br>            viewModel.triggerAlert()<br>        &#125;<br>        .alert(<span class=\"hljs-string\">&quot;Important message&quot;</span>, isPresented: <span class=\"hljs-variable\">$viewModel</span>.showAlert) &#123;<br>            <span class=\"hljs-type\">Button</span>(<span class=\"hljs-string\">&quot;OK&quot;</span>, role: .cancel) &#123; &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyViewModel</span>: <span class=\"hljs-title class_\">ObservableObject</span> &#123;<br>    <span class=\"hljs-meta\">@Published</span> <span class=\"hljs-keyword\">var</span> showAlert <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">false</span><br><br>    <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">triggerAlert</span>() &#123;<br>        showAlert <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">true</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在上面的例子中，<code>MyViewModel</code> 控制 <code>showAlert</code> 的状态，当 <code>triggerAlert</code> 方法被调用时，会显示 <code>Alert</code>。</p>\n<p><code>Alert</code> 在 SwiftUI 中是模态的，这意味着当它出现时，用户必须进行选择才能继续与应用交互。它的设计旨在用于必须要立即解决的情况，因此在设计用户界面时应慎用。</p>\n"},{"title":"SwiftUI中Label的用法","date":"2023-11-07T12:43:44.000Z","_content":"在 SwiftUI 中，`Label` 是用于展示一个文本和一个图标（icon）的用户界面控件。这对于清晰表达控件或动作的目的非常有用，尤其是在列表、菜单和导航栏中。\n\n### 基础用法\n\n最简单的 `Label` 用法是提供文本和系统图标的名称：\n\n```swift\nLabel(\"Add Item\", systemImage: \"plus\")\n```\n\n### 使用自定义图像\n\n你也可以使用自定义图像来创建一个 `Label`：\n\n```swift\nLabel(\"Edit\", image: \"customIconName\")\n```\n\n这里 `\"customIconName\"` 是你的资产目录中的图像的名称。\n\n### 使用 SF Symbols\n\nSwiftUI 和 SF Symbols 集成，允许你方便地使用数千种符号图标：\n\n```swift\nLabel(\"Message\", systemImage: \"message.fill\")\n```\n\n### 自定义视图\n\n如果你需要对 `Label` 的文本或图标部分进行更多的自定义，你可以提供自定义视图：\n\n```swift\nLabel {\n    Text(\"Settings\")\n        .foregroundColor(.primary)\n        .font(.body)\n        .padding()\n        .background(Color.gray.opacity(0.2))\n        .cornerRadius(5)\n} icon: {\n    Image(systemName: \"gear\")\n        .foregroundColor(.blue)\n        .padding()\n        .background(Color.gray.opacity(0.2))\n        .cornerRadius(5)\n}\n```\n\n### 嵌套在其他视图中\n\n`Label` 可以嵌套在列表、按钮和其他容器视图中。例如，在一个 `List` 中：\n\n```swift\nList {\n    Label(\"Notifications\", systemImage: \"bell\")\n    Label(\"Privacy\", systemImage: \"hand.raised\")\n    Label(\"General\", systemImage: \"wrench\")\n}\n```\n\n### 样式\n\n`Label` 还可以使用不同的样式，例如：`iconOnlyLabelStyle` 或 `titleOnlyLabelStyle`。\n\n```swift\nLabel(\"Airplane Mode\", systemImage: \"airplane\")\n    .labelStyle(TitleOnlyLabelStyle())\n\nLabel(\"WiFi\", systemImage: \"wifi\")\n    .labelStyle(IconOnlyLabelStyle())\n```\n\n### 无障碍\n\n不要忘了考虑无障碍需求，你可以添加描述来帮助辅助技术，如 VoiceOver，更好地解释 `Label` 的内容：\n\n```swift\nLabel(\"Delete\", systemImage: \"trash\")\n    .accessibilityLabel(Text(\"Delete\"))\n    .accessibilityHint(Text(\"Double tap to remove the item\"))\n```\n\n### 使用场景\n\n- 在 `NavigationView` 和工具栏按钮中展示图标和文本。\n- 在列表或菜单中作为条目显示，既要展示图标也要展示文本。\n- 在用户界面的其他任何地方，当你需要在文本旁边显示图标以提高识别度时。\n\n`Label` 由于其多功能性和易用性，在 SwiftUI 中是一个很受欢迎的组件。通过组合使用文本和图标，你可以创建既美观又直观的用户界面元素。","source":"_posts/SwiftUI中Label的用法.md","raw":"---\ntitle: SwiftUI中Label的用法\ndate: 2023-11-07 20:43:44\ncategories:\n- SwiftUI\ntags:\n---\n在 SwiftUI 中，`Label` 是用于展示一个文本和一个图标（icon）的用户界面控件。这对于清晰表达控件或动作的目的非常有用，尤其是在列表、菜单和导航栏中。\n\n### 基础用法\n\n最简单的 `Label` 用法是提供文本和系统图标的名称：\n\n```swift\nLabel(\"Add Item\", systemImage: \"plus\")\n```\n\n### 使用自定义图像\n\n你也可以使用自定义图像来创建一个 `Label`：\n\n```swift\nLabel(\"Edit\", image: \"customIconName\")\n```\n\n这里 `\"customIconName\"` 是你的资产目录中的图像的名称。\n\n### 使用 SF Symbols\n\nSwiftUI 和 SF Symbols 集成，允许你方便地使用数千种符号图标：\n\n```swift\nLabel(\"Message\", systemImage: \"message.fill\")\n```\n\n### 自定义视图\n\n如果你需要对 `Label` 的文本或图标部分进行更多的自定义，你可以提供自定义视图：\n\n```swift\nLabel {\n    Text(\"Settings\")\n        .foregroundColor(.primary)\n        .font(.body)\n        .padding()\n        .background(Color.gray.opacity(0.2))\n        .cornerRadius(5)\n} icon: {\n    Image(systemName: \"gear\")\n        .foregroundColor(.blue)\n        .padding()\n        .background(Color.gray.opacity(0.2))\n        .cornerRadius(5)\n}\n```\n\n### 嵌套在其他视图中\n\n`Label` 可以嵌套在列表、按钮和其他容器视图中。例如，在一个 `List` 中：\n\n```swift\nList {\n    Label(\"Notifications\", systemImage: \"bell\")\n    Label(\"Privacy\", systemImage: \"hand.raised\")\n    Label(\"General\", systemImage: \"wrench\")\n}\n```\n\n### 样式\n\n`Label` 还可以使用不同的样式，例如：`iconOnlyLabelStyle` 或 `titleOnlyLabelStyle`。\n\n```swift\nLabel(\"Airplane Mode\", systemImage: \"airplane\")\n    .labelStyle(TitleOnlyLabelStyle())\n\nLabel(\"WiFi\", systemImage: \"wifi\")\n    .labelStyle(IconOnlyLabelStyle())\n```\n\n### 无障碍\n\n不要忘了考虑无障碍需求，你可以添加描述来帮助辅助技术，如 VoiceOver，更好地解释 `Label` 的内容：\n\n```swift\nLabel(\"Delete\", systemImage: \"trash\")\n    .accessibilityLabel(Text(\"Delete\"))\n    .accessibilityHint(Text(\"Double tap to remove the item\"))\n```\n\n### 使用场景\n\n- 在 `NavigationView` 和工具栏按钮中展示图标和文本。\n- 在列表或菜单中作为条目显示，既要展示图标也要展示文本。\n- 在用户界面的其他任何地方，当你需要在文本旁边显示图标以提高识别度时。\n\n`Label` 由于其多功能性和易用性，在 SwiftUI 中是一个很受欢迎的组件。通过组合使用文本和图标，你可以创建既美观又直观的用户界面元素。","slug":"SwiftUI中Label的用法","published":1,"updated":"2024-03-17T06:12:48.736Z","comments":1,"layout":"post","photos":[],"_id":"clu6up53a000az6743uqc00i4","content":"<p>在 SwiftUI 中，<code>Label</code> 是用于展示一个文本和一个图标（icon）的用户界面控件。这对于清晰表达控件或动作的目的非常有用，尤其是在列表、菜单和导航栏中。</p>\n<h3 id=\"基础用法\"><a href=\"#基础用法\" class=\"headerlink\" title=\"基础用法\"></a>基础用法</h3><p>最简单的 <code>Label</code> 用法是提供文本和系统图标的名称：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Label</span>(<span class=\"hljs-string\">&quot;Add Item&quot;</span>, systemImage: <span class=\"hljs-string\">&quot;plus&quot;</span>)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"使用自定义图像\"><a href=\"#使用自定义图像\" class=\"headerlink\" title=\"使用自定义图像\"></a>使用自定义图像</h3><p>你也可以使用自定义图像来创建一个 <code>Label</code>：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Label</span>(<span class=\"hljs-string\">&quot;Edit&quot;</span>, image: <span class=\"hljs-string\">&quot;customIconName&quot;</span>)<br></code></pre></td></tr></table></figure>\n\n<p>这里 <code>&quot;customIconName&quot;</code> 是你的资产目录中的图像的名称。</p>\n<h3 id=\"使用-SF-Symbols\"><a href=\"#使用-SF-Symbols\" class=\"headerlink\" title=\"使用 SF Symbols\"></a>使用 SF Symbols</h3><p>SwiftUI 和 SF Symbols 集成，允许你方便地使用数千种符号图标：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Label</span>(<span class=\"hljs-string\">&quot;Message&quot;</span>, systemImage: <span class=\"hljs-string\">&quot;message.fill&quot;</span>)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"自定义视图\"><a href=\"#自定义视图\" class=\"headerlink\" title=\"自定义视图\"></a>自定义视图</h3><p>如果你需要对 <code>Label</code> 的文本或图标部分进行更多的自定义，你可以提供自定义视图：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Label</span> &#123;<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Settings&quot;</span>)<br>        .foregroundColor(.primary)<br>        .font(.body)<br>        .padding()<br>        .background(<span class=\"hljs-type\">Color</span>.gray.opacity(<span class=\"hljs-number\">0.2</span>))<br>        .cornerRadius(<span class=\"hljs-number\">5</span>)<br>&#125; icon: &#123;<br>    <span class=\"hljs-type\">Image</span>(systemName: <span class=\"hljs-string\">&quot;gear&quot;</span>)<br>        .foregroundColor(.blue)<br>        .padding()<br>        .background(<span class=\"hljs-type\">Color</span>.gray.opacity(<span class=\"hljs-number\">0.2</span>))<br>        .cornerRadius(<span class=\"hljs-number\">5</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"嵌套在其他视图中\"><a href=\"#嵌套在其他视图中\" class=\"headerlink\" title=\"嵌套在其他视图中\"></a>嵌套在其他视图中</h3><p><code>Label</code> 可以嵌套在列表、按钮和其他容器视图中。例如，在一个 <code>List</code> 中：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">List</span> &#123;<br>    <span class=\"hljs-type\">Label</span>(<span class=\"hljs-string\">&quot;Notifications&quot;</span>, systemImage: <span class=\"hljs-string\">&quot;bell&quot;</span>)<br>    <span class=\"hljs-type\">Label</span>(<span class=\"hljs-string\">&quot;Privacy&quot;</span>, systemImage: <span class=\"hljs-string\">&quot;hand.raised&quot;</span>)<br>    <span class=\"hljs-type\">Label</span>(<span class=\"hljs-string\">&quot;General&quot;</span>, systemImage: <span class=\"hljs-string\">&quot;wrench&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"样式\"><a href=\"#样式\" class=\"headerlink\" title=\"样式\"></a>样式</h3><p><code>Label</code> 还可以使用不同的样式，例如：<code>iconOnlyLabelStyle</code> 或 <code>titleOnlyLabelStyle</code>。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Label</span>(<span class=\"hljs-string\">&quot;Airplane Mode&quot;</span>, systemImage: <span class=\"hljs-string\">&quot;airplane&quot;</span>)<br>    .labelStyle(<span class=\"hljs-type\">TitleOnlyLabelStyle</span>())<br><br><span class=\"hljs-type\">Label</span>(<span class=\"hljs-string\">&quot;WiFi&quot;</span>, systemImage: <span class=\"hljs-string\">&quot;wifi&quot;</span>)<br>    .labelStyle(<span class=\"hljs-type\">IconOnlyLabelStyle</span>())<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"无障碍\"><a href=\"#无障碍\" class=\"headerlink\" title=\"无障碍\"></a>无障碍</h3><p>不要忘了考虑无障碍需求，你可以添加描述来帮助辅助技术，如 VoiceOver，更好地解释 <code>Label</code> 的内容：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Label</span>(<span class=\"hljs-string\">&quot;Delete&quot;</span>, systemImage: <span class=\"hljs-string\">&quot;trash&quot;</span>)<br>    .accessibilityLabel(<span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Delete&quot;</span>))<br>    .accessibilityHint(<span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Double tap to remove the item&quot;</span>))<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h3><ul>\n<li>在 <code>NavigationView</code> 和工具栏按钮中展示图标和文本。</li>\n<li>在列表或菜单中作为条目显示，既要展示图标也要展示文本。</li>\n<li>在用户界面的其他任何地方，当你需要在文本旁边显示图标以提高识别度时。</li>\n</ul>\n<p><code>Label</code> 由于其多功能性和易用性，在 SwiftUI 中是一个很受欢迎的组件。通过组合使用文本和图标，你可以创建既美观又直观的用户界面元素。</p>\n","excerpt":"","more":"<p>在 SwiftUI 中，<code>Label</code> 是用于展示一个文本和一个图标（icon）的用户界面控件。这对于清晰表达控件或动作的目的非常有用，尤其是在列表、菜单和导航栏中。</p>\n<h3 id=\"基础用法\"><a href=\"#基础用法\" class=\"headerlink\" title=\"基础用法\"></a>基础用法</h3><p>最简单的 <code>Label</code> 用法是提供文本和系统图标的名称：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Label</span>(<span class=\"hljs-string\">&quot;Add Item&quot;</span>, systemImage: <span class=\"hljs-string\">&quot;plus&quot;</span>)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"使用自定义图像\"><a href=\"#使用自定义图像\" class=\"headerlink\" title=\"使用自定义图像\"></a>使用自定义图像</h3><p>你也可以使用自定义图像来创建一个 <code>Label</code>：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Label</span>(<span class=\"hljs-string\">&quot;Edit&quot;</span>, image: <span class=\"hljs-string\">&quot;customIconName&quot;</span>)<br></code></pre></td></tr></table></figure>\n\n<p>这里 <code>&quot;customIconName&quot;</code> 是你的资产目录中的图像的名称。</p>\n<h3 id=\"使用-SF-Symbols\"><a href=\"#使用-SF-Symbols\" class=\"headerlink\" title=\"使用 SF Symbols\"></a>使用 SF Symbols</h3><p>SwiftUI 和 SF Symbols 集成，允许你方便地使用数千种符号图标：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Label</span>(<span class=\"hljs-string\">&quot;Message&quot;</span>, systemImage: <span class=\"hljs-string\">&quot;message.fill&quot;</span>)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"自定义视图\"><a href=\"#自定义视图\" class=\"headerlink\" title=\"自定义视图\"></a>自定义视图</h3><p>如果你需要对 <code>Label</code> 的文本或图标部分进行更多的自定义，你可以提供自定义视图：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Label</span> &#123;<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Settings&quot;</span>)<br>        .foregroundColor(.primary)<br>        .font(.body)<br>        .padding()<br>        .background(<span class=\"hljs-type\">Color</span>.gray.opacity(<span class=\"hljs-number\">0.2</span>))<br>        .cornerRadius(<span class=\"hljs-number\">5</span>)<br>&#125; icon: &#123;<br>    <span class=\"hljs-type\">Image</span>(systemName: <span class=\"hljs-string\">&quot;gear&quot;</span>)<br>        .foregroundColor(.blue)<br>        .padding()<br>        .background(<span class=\"hljs-type\">Color</span>.gray.opacity(<span class=\"hljs-number\">0.2</span>))<br>        .cornerRadius(<span class=\"hljs-number\">5</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"嵌套在其他视图中\"><a href=\"#嵌套在其他视图中\" class=\"headerlink\" title=\"嵌套在其他视图中\"></a>嵌套在其他视图中</h3><p><code>Label</code> 可以嵌套在列表、按钮和其他容器视图中。例如，在一个 <code>List</code> 中：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">List</span> &#123;<br>    <span class=\"hljs-type\">Label</span>(<span class=\"hljs-string\">&quot;Notifications&quot;</span>, systemImage: <span class=\"hljs-string\">&quot;bell&quot;</span>)<br>    <span class=\"hljs-type\">Label</span>(<span class=\"hljs-string\">&quot;Privacy&quot;</span>, systemImage: <span class=\"hljs-string\">&quot;hand.raised&quot;</span>)<br>    <span class=\"hljs-type\">Label</span>(<span class=\"hljs-string\">&quot;General&quot;</span>, systemImage: <span class=\"hljs-string\">&quot;wrench&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"样式\"><a href=\"#样式\" class=\"headerlink\" title=\"样式\"></a>样式</h3><p><code>Label</code> 还可以使用不同的样式，例如：<code>iconOnlyLabelStyle</code> 或 <code>titleOnlyLabelStyle</code>。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Label</span>(<span class=\"hljs-string\">&quot;Airplane Mode&quot;</span>, systemImage: <span class=\"hljs-string\">&quot;airplane&quot;</span>)<br>    .labelStyle(<span class=\"hljs-type\">TitleOnlyLabelStyle</span>())<br><br><span class=\"hljs-type\">Label</span>(<span class=\"hljs-string\">&quot;WiFi&quot;</span>, systemImage: <span class=\"hljs-string\">&quot;wifi&quot;</span>)<br>    .labelStyle(<span class=\"hljs-type\">IconOnlyLabelStyle</span>())<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"无障碍\"><a href=\"#无障碍\" class=\"headerlink\" title=\"无障碍\"></a>无障碍</h3><p>不要忘了考虑无障碍需求，你可以添加描述来帮助辅助技术，如 VoiceOver，更好地解释 <code>Label</code> 的内容：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Label</span>(<span class=\"hljs-string\">&quot;Delete&quot;</span>, systemImage: <span class=\"hljs-string\">&quot;trash&quot;</span>)<br>    .accessibilityLabel(<span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Delete&quot;</span>))<br>    .accessibilityHint(<span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Double tap to remove the item&quot;</span>))<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h3><ul>\n<li>在 <code>NavigationView</code> 和工具栏按钮中展示图标和文本。</li>\n<li>在列表或菜单中作为条目显示，既要展示图标也要展示文本。</li>\n<li>在用户界面的其他任何地方，当你需要在文本旁边显示图标以提高识别度时。</li>\n</ul>\n<p><code>Label</code> 由于其多功能性和易用性，在 SwiftUI 中是一个很受欢迎的组件。通过组合使用文本和图标，你可以创建既美观又直观的用户界面元素。</p>\n"},{"title":"SwiftUI中List的用法","date":"2023-11-07T14:05:28.000Z","_content":"在 SwiftUI 中，`List` 是一个用来展示数据集合的滚动列表视图。它类似于 UIKit 中的 `UITableView`，可以显示静态或动态的数据集合。`List` 可以和 `ForEach` 一起使用来显示动态数据，也可以直接放入静态视图。\n\n以下是使用 `List` 的几种常见方法：\n\n### 显示静态内容\n\n```swift\nimport SwiftUI\n\nstruct StaticListView: View {\n    var body: some View {\n        List {\n            Text(\"Item 1\")\n            Text(\"Item 2\")\n            Text(\"Item 3\")\n        }\n    }\n}\n\nstruct StaticListView_Previews: PreviewProvider {\n    static var previews: some View {\n        StaticListView()\n    }\n}\n```\n\n### 显示动态数据\n\n当你有一组动态数据时，可以使用 `ForEach` 来创建列表的每一行。\n\n```swift\nimport SwiftUI\n\nstruct DynamicListView: View {\n    let items = [\"Apple\", \"Banana\", \"Cherry\"]\n\n    var body: some View {\n        List {\n            ForEach(items, id: \\.self) { item in\n                Text(item)\n            }\n        }\n    }\n}\n\nstruct DynamicListView_Previews: PreviewProvider {\n    static var previews: some View {\n        DynamicListView()\n    }\n}\n```\n\n### 使用 `Identifiable` 数据模型\n\n当你的数据模型遵守 `Identifiable` 协议时，你不需要指定 `id`。\n\n```swift\nimport SwiftUI\n\nstruct Item: Identifiable {\n    let id = UUID()\n    let name: String\n}\n\nstruct IdentifiableListView: View {\n    let items = [Item(name: \"Apple\"), Item(name: \"Banana\"), Item(name: \"Cherry\")]\n\n    var body: some View {\n        List(items) { item in\n            Text(item.name)\n        }\n    }\n}\n\nstruct IdentifiableListView_Previews: PreviewProvider {\n    static var previews: some View {\n        IdentifiableListView()\n    }\n}\n```\n\n### 添加和删除操作\n\n你可以通过在 `ForEach` 上调用 `.onDelete()` 和 `.onMove()` 方法来添加对列表的删除和移动操作的支持。\n\n```swift\nimport SwiftUI\n\nstruct EditableListView: View {\n    @State private var items = [\"Apple\", \"Banana\", \"Cherry\"]\n\n    var body: some View {\n        NavigationView {\n            List {\n                ForEach(items, id: \\.self) { item in\n                    Text(item)\n                }\n                .onDelete(perform: delete)\n                .onMove(perform: move)\n            }\n            .navigationBarItems(trailing: EditButton())\n        }\n    }\n\n    func delete(at offsets: IndexSet) {\n        items.remove(atOffsets: offsets)\n    }\n\n    func move(from source: IndexSet, to destination: Int) {\n        items.move(fromOffsets: source, toOffset: destination)\n    }\n}\n\nstruct EditableListView_Previews: PreviewProvider {\n    static var previews: some View {\n        EditableListView()\n    }\n}\n```\n\n### 自定义行\n\n你可以在 `List` 中自定义行，比如添加图标和导航链接。\n\n```swift\nimport SwiftUI\n\nstruct CustomRowListView: View {\n    var body: some View {\n        List {\n            NavigationLink(destination: Text(\"Destination\")) {\n                HStack {\n                    Image(systemName: \"folder\")\n                    Text(\"Files\")\n                }\n            }\n        }\n    }\n}\n\nstruct CustomRowListView_Previews: PreviewProvider {\n    static var previews: some View {\n        CustomRowListView()\n    }\n}\n```\n\n### 使用 `List` 的选择模式\n\n你还可以使用 `List` 的选择模式来创建可以选择单个或多个项的列表。\n\n```swift\nimport SwiftUI\n\nstruct SelectableListView: View {\n    let items = [\"Apple\", \"Banana\", \"Cherry\"]\n    @State private var selectedItems = Set<String>()\n\n    var body: some View {\n        List(items, id: \\.self, selection: $selectedItems) { item in\n            Text(item)\n        }\n        .toolbar {\n            EditButton()\n        }\n        .environment(\\.editMode, .constant(.active)) // 使得列表始终处于编辑模式\n    }\n}\n\nstruct SelectableListView_Previews: PreviewProvider {\n    static var previews: some View {\n        SelectableListView()\n    }\n}\n```\n\n在 SwiftUI 中，`List` 是一个非常强大的构建用户界面的工具，可以通过上述的各种方式灵活地显示和管理集合数据。","source":"_posts/SwiftUI中List的用法.md","raw":"---\ntitle: SwiftUI中List的用法\ndate: 2023-11-07 22:05:28\ncategories:\n- SwiftUI\ntags:\n---\n在 SwiftUI 中，`List` 是一个用来展示数据集合的滚动列表视图。它类似于 UIKit 中的 `UITableView`，可以显示静态或动态的数据集合。`List` 可以和 `ForEach` 一起使用来显示动态数据，也可以直接放入静态视图。\n\n以下是使用 `List` 的几种常见方法：\n\n### 显示静态内容\n\n```swift\nimport SwiftUI\n\nstruct StaticListView: View {\n    var body: some View {\n        List {\n            Text(\"Item 1\")\n            Text(\"Item 2\")\n            Text(\"Item 3\")\n        }\n    }\n}\n\nstruct StaticListView_Previews: PreviewProvider {\n    static var previews: some View {\n        StaticListView()\n    }\n}\n```\n\n### 显示动态数据\n\n当你有一组动态数据时，可以使用 `ForEach` 来创建列表的每一行。\n\n```swift\nimport SwiftUI\n\nstruct DynamicListView: View {\n    let items = [\"Apple\", \"Banana\", \"Cherry\"]\n\n    var body: some View {\n        List {\n            ForEach(items, id: \\.self) { item in\n                Text(item)\n            }\n        }\n    }\n}\n\nstruct DynamicListView_Previews: PreviewProvider {\n    static var previews: some View {\n        DynamicListView()\n    }\n}\n```\n\n### 使用 `Identifiable` 数据模型\n\n当你的数据模型遵守 `Identifiable` 协议时，你不需要指定 `id`。\n\n```swift\nimport SwiftUI\n\nstruct Item: Identifiable {\n    let id = UUID()\n    let name: String\n}\n\nstruct IdentifiableListView: View {\n    let items = [Item(name: \"Apple\"), Item(name: \"Banana\"), Item(name: \"Cherry\")]\n\n    var body: some View {\n        List(items) { item in\n            Text(item.name)\n        }\n    }\n}\n\nstruct IdentifiableListView_Previews: PreviewProvider {\n    static var previews: some View {\n        IdentifiableListView()\n    }\n}\n```\n\n### 添加和删除操作\n\n你可以通过在 `ForEach` 上调用 `.onDelete()` 和 `.onMove()` 方法来添加对列表的删除和移动操作的支持。\n\n```swift\nimport SwiftUI\n\nstruct EditableListView: View {\n    @State private var items = [\"Apple\", \"Banana\", \"Cherry\"]\n\n    var body: some View {\n        NavigationView {\n            List {\n                ForEach(items, id: \\.self) { item in\n                    Text(item)\n                }\n                .onDelete(perform: delete)\n                .onMove(perform: move)\n            }\n            .navigationBarItems(trailing: EditButton())\n        }\n    }\n\n    func delete(at offsets: IndexSet) {\n        items.remove(atOffsets: offsets)\n    }\n\n    func move(from source: IndexSet, to destination: Int) {\n        items.move(fromOffsets: source, toOffset: destination)\n    }\n}\n\nstruct EditableListView_Previews: PreviewProvider {\n    static var previews: some View {\n        EditableListView()\n    }\n}\n```\n\n### 自定义行\n\n你可以在 `List` 中自定义行，比如添加图标和导航链接。\n\n```swift\nimport SwiftUI\n\nstruct CustomRowListView: View {\n    var body: some View {\n        List {\n            NavigationLink(destination: Text(\"Destination\")) {\n                HStack {\n                    Image(systemName: \"folder\")\n                    Text(\"Files\")\n                }\n            }\n        }\n    }\n}\n\nstruct CustomRowListView_Previews: PreviewProvider {\n    static var previews: some View {\n        CustomRowListView()\n    }\n}\n```\n\n### 使用 `List` 的选择模式\n\n你还可以使用 `List` 的选择模式来创建可以选择单个或多个项的列表。\n\n```swift\nimport SwiftUI\n\nstruct SelectableListView: View {\n    let items = [\"Apple\", \"Banana\", \"Cherry\"]\n    @State private var selectedItems = Set<String>()\n\n    var body: some View {\n        List(items, id: \\.self, selection: $selectedItems) { item in\n            Text(item)\n        }\n        .toolbar {\n            EditButton()\n        }\n        .environment(\\.editMode, .constant(.active)) // 使得列表始终处于编辑模式\n    }\n}\n\nstruct SelectableListView_Previews: PreviewProvider {\n    static var previews: some View {\n        SelectableListView()\n    }\n}\n```\n\n在 SwiftUI 中，`List` 是一个非常强大的构建用户界面的工具，可以通过上述的各种方式灵活地显示和管理集合数据。","slug":"SwiftUI中List的用法","published":1,"updated":"2024-03-17T06:12:55.248Z","comments":1,"layout":"post","photos":[],"_id":"clu6up53a000bz674f61e3778","content":"<p>在 SwiftUI 中，<code>List</code> 是一个用来展示数据集合的滚动列表视图。它类似于 UIKit 中的 <code>UITableView</code>，可以显示静态或动态的数据集合。<code>List</code> 可以和 <code>ForEach</code> 一起使用来显示动态数据，也可以直接放入静态视图。</p>\n<p>以下是使用 <code>List</code> 的几种常见方法：</p>\n<h3 id=\"显示静态内容\"><a href=\"#显示静态内容\" class=\"headerlink\" title=\"显示静态内容\"></a>显示静态内容</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">import</span> SwiftUI<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">StaticListView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">List</span> &#123;<br>            <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Item 1&quot;</span>)<br>            <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Item 2&quot;</span>)<br>            <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Item 3&quot;</span>)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">StaticListView_Previews</span>: <span class=\"hljs-title class_\">PreviewProvider</span> &#123;<br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">var</span> previews: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">StaticListView</span>()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"显示动态数据\"><a href=\"#显示动态数据\" class=\"headerlink\" title=\"显示动态数据\"></a>显示动态数据</h3><p>当你有一组动态数据时，可以使用 <code>ForEach</code> 来创建列表的每一行。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">import</span> SwiftUI<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">DynamicListView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-keyword\">let</span> items <span class=\"hljs-operator\">=</span> [<span class=\"hljs-string\">&quot;Apple&quot;</span>, <span class=\"hljs-string\">&quot;Banana&quot;</span>, <span class=\"hljs-string\">&quot;Cherry&quot;</span>]<br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">List</span> &#123;<br>            <span class=\"hljs-type\">ForEach</span>(items, id: \\.<span class=\"hljs-keyword\">self</span>) &#123; item <span class=\"hljs-keyword\">in</span><br>                <span class=\"hljs-type\">Text</span>(item)<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">DynamicListView_Previews</span>: <span class=\"hljs-title class_\">PreviewProvider</span> &#123;<br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">var</span> previews: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">DynamicListView</span>()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"使用-Identifiable-数据模型\"><a href=\"#使用-Identifiable-数据模型\" class=\"headerlink\" title=\"使用 Identifiable 数据模型\"></a>使用 <code>Identifiable</code> 数据模型</h3><p>当你的数据模型遵守 <code>Identifiable</code> 协议时，你不需要指定 <code>id</code>。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">import</span> SwiftUI<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Item</span>: <span class=\"hljs-title class_\">Identifiable</span> &#123;<br>    <span class=\"hljs-keyword\">let</span> id <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">UUID</span>()<br>    <span class=\"hljs-keyword\">let</span> name: <span class=\"hljs-type\">String</span><br>&#125;<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">IdentifiableListView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-keyword\">let</span> items <span class=\"hljs-operator\">=</span> [<span class=\"hljs-type\">Item</span>(name: <span class=\"hljs-string\">&quot;Apple&quot;</span>), <span class=\"hljs-type\">Item</span>(name: <span class=\"hljs-string\">&quot;Banana&quot;</span>), <span class=\"hljs-type\">Item</span>(name: <span class=\"hljs-string\">&quot;Cherry&quot;</span>)]<br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">List</span>(items) &#123; item <span class=\"hljs-keyword\">in</span><br>            <span class=\"hljs-type\">Text</span>(item.name)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">IdentifiableListView_Previews</span>: <span class=\"hljs-title class_\">PreviewProvider</span> &#123;<br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">var</span> previews: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">IdentifiableListView</span>()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"添加和删除操作\"><a href=\"#添加和删除操作\" class=\"headerlink\" title=\"添加和删除操作\"></a>添加和删除操作</h3><p>你可以通过在 <code>ForEach</code> 上调用 <code>.onDelete()</code> 和 <code>.onMove()</code> 方法来添加对列表的删除和移动操作的支持。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">import</span> SwiftUI<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">EditableListView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> items <span class=\"hljs-operator\">=</span> [<span class=\"hljs-string\">&quot;Apple&quot;</span>, <span class=\"hljs-string\">&quot;Banana&quot;</span>, <span class=\"hljs-string\">&quot;Cherry&quot;</span>]<br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">NavigationView</span> &#123;<br>            <span class=\"hljs-type\">List</span> &#123;<br>                <span class=\"hljs-type\">ForEach</span>(items, id: \\.<span class=\"hljs-keyword\">self</span>) &#123; item <span class=\"hljs-keyword\">in</span><br>                    <span class=\"hljs-type\">Text</span>(item)<br>                &#125;<br>                .onDelete(perform: delete)<br>                .onMove(perform: move)<br>            &#125;<br>            .navigationBarItems(trailing: <span class=\"hljs-type\">EditButton</span>())<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">delete</span>(<span class=\"hljs-params\">at</span> <span class=\"hljs-params\">offsets</span>: <span class=\"hljs-type\">IndexSet</span>) &#123;<br>        items.remove(atOffsets: offsets)<br>    &#125;<br><br>    <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">move</span>(<span class=\"hljs-params\">from</span> <span class=\"hljs-params\">source</span>: <span class=\"hljs-type\">IndexSet</span>, <span class=\"hljs-params\">to</span> <span class=\"hljs-params\">destination</span>: <span class=\"hljs-type\">Int</span>) &#123;<br>        items.move(fromOffsets: source, toOffset: destination)<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">EditableListView_Previews</span>: <span class=\"hljs-title class_\">PreviewProvider</span> &#123;<br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">var</span> previews: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">EditableListView</span>()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"自定义行\"><a href=\"#自定义行\" class=\"headerlink\" title=\"自定义行\"></a>自定义行</h3><p>你可以在 <code>List</code> 中自定义行，比如添加图标和导航链接。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">import</span> SwiftUI<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">CustomRowListView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">List</span> &#123;<br>            <span class=\"hljs-type\">NavigationLink</span>(destination: <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Destination&quot;</span>)) &#123;<br>                <span class=\"hljs-type\">HStack</span> &#123;<br>                    <span class=\"hljs-type\">Image</span>(systemName: <span class=\"hljs-string\">&quot;folder&quot;</span>)<br>                    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Files&quot;</span>)<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">CustomRowListView_Previews</span>: <span class=\"hljs-title class_\">PreviewProvider</span> &#123;<br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">var</span> previews: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">CustomRowListView</span>()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"使用-List-的选择模式\"><a href=\"#使用-List-的选择模式\" class=\"headerlink\" title=\"使用 List 的选择模式\"></a>使用 <code>List</code> 的选择模式</h3><p>你还可以使用 <code>List</code> 的选择模式来创建可以选择单个或多个项的列表。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">import</span> SwiftUI<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">SelectableListView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-keyword\">let</span> items <span class=\"hljs-operator\">=</span> [<span class=\"hljs-string\">&quot;Apple&quot;</span>, <span class=\"hljs-string\">&quot;Banana&quot;</span>, <span class=\"hljs-string\">&quot;Cherry&quot;</span>]<br>    <span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> selectedItems <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">Set</span>&lt;<span class=\"hljs-type\">String</span>&gt;()<br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">List</span>(items, id: \\.<span class=\"hljs-keyword\">self</span>, selection: <span class=\"hljs-variable\">$selectedItems</span>) &#123; item <span class=\"hljs-keyword\">in</span><br>            <span class=\"hljs-type\">Text</span>(item)<br>        &#125;<br>        .toolbar &#123;<br>            <span class=\"hljs-type\">EditButton</span>()<br>        &#125;<br>        .environment(\\.editMode, .constant(.active)) <span class=\"hljs-comment\">// 使得列表始终处于编辑模式</span><br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">SelectableListView_Previews</span>: <span class=\"hljs-title class_\">PreviewProvider</span> &#123;<br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">var</span> previews: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">SelectableListView</span>()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在 SwiftUI 中，<code>List</code> 是一个非常强大的构建用户界面的工具，可以通过上述的各种方式灵活地显示和管理集合数据。</p>\n","excerpt":"","more":"<p>在 SwiftUI 中，<code>List</code> 是一个用来展示数据集合的滚动列表视图。它类似于 UIKit 中的 <code>UITableView</code>，可以显示静态或动态的数据集合。<code>List</code> 可以和 <code>ForEach</code> 一起使用来显示动态数据，也可以直接放入静态视图。</p>\n<p>以下是使用 <code>List</code> 的几种常见方法：</p>\n<h3 id=\"显示静态内容\"><a href=\"#显示静态内容\" class=\"headerlink\" title=\"显示静态内容\"></a>显示静态内容</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">import</span> SwiftUI<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">StaticListView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">List</span> &#123;<br>            <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Item 1&quot;</span>)<br>            <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Item 2&quot;</span>)<br>            <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Item 3&quot;</span>)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">StaticListView_Previews</span>: <span class=\"hljs-title class_\">PreviewProvider</span> &#123;<br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">var</span> previews: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">StaticListView</span>()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"显示动态数据\"><a href=\"#显示动态数据\" class=\"headerlink\" title=\"显示动态数据\"></a>显示动态数据</h3><p>当你有一组动态数据时，可以使用 <code>ForEach</code> 来创建列表的每一行。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">import</span> SwiftUI<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">DynamicListView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-keyword\">let</span> items <span class=\"hljs-operator\">=</span> [<span class=\"hljs-string\">&quot;Apple&quot;</span>, <span class=\"hljs-string\">&quot;Banana&quot;</span>, <span class=\"hljs-string\">&quot;Cherry&quot;</span>]<br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">List</span> &#123;<br>            <span class=\"hljs-type\">ForEach</span>(items, id: \\.<span class=\"hljs-keyword\">self</span>) &#123; item <span class=\"hljs-keyword\">in</span><br>                <span class=\"hljs-type\">Text</span>(item)<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">DynamicListView_Previews</span>: <span class=\"hljs-title class_\">PreviewProvider</span> &#123;<br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">var</span> previews: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">DynamicListView</span>()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"使用-Identifiable-数据模型\"><a href=\"#使用-Identifiable-数据模型\" class=\"headerlink\" title=\"使用 Identifiable 数据模型\"></a>使用 <code>Identifiable</code> 数据模型</h3><p>当你的数据模型遵守 <code>Identifiable</code> 协议时，你不需要指定 <code>id</code>。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">import</span> SwiftUI<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Item</span>: <span class=\"hljs-title class_\">Identifiable</span> &#123;<br>    <span class=\"hljs-keyword\">let</span> id <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">UUID</span>()<br>    <span class=\"hljs-keyword\">let</span> name: <span class=\"hljs-type\">String</span><br>&#125;<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">IdentifiableListView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-keyword\">let</span> items <span class=\"hljs-operator\">=</span> [<span class=\"hljs-type\">Item</span>(name: <span class=\"hljs-string\">&quot;Apple&quot;</span>), <span class=\"hljs-type\">Item</span>(name: <span class=\"hljs-string\">&quot;Banana&quot;</span>), <span class=\"hljs-type\">Item</span>(name: <span class=\"hljs-string\">&quot;Cherry&quot;</span>)]<br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">List</span>(items) &#123; item <span class=\"hljs-keyword\">in</span><br>            <span class=\"hljs-type\">Text</span>(item.name)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">IdentifiableListView_Previews</span>: <span class=\"hljs-title class_\">PreviewProvider</span> &#123;<br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">var</span> previews: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">IdentifiableListView</span>()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"添加和删除操作\"><a href=\"#添加和删除操作\" class=\"headerlink\" title=\"添加和删除操作\"></a>添加和删除操作</h3><p>你可以通过在 <code>ForEach</code> 上调用 <code>.onDelete()</code> 和 <code>.onMove()</code> 方法来添加对列表的删除和移动操作的支持。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">import</span> SwiftUI<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">EditableListView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> items <span class=\"hljs-operator\">=</span> [<span class=\"hljs-string\">&quot;Apple&quot;</span>, <span class=\"hljs-string\">&quot;Banana&quot;</span>, <span class=\"hljs-string\">&quot;Cherry&quot;</span>]<br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">NavigationView</span> &#123;<br>            <span class=\"hljs-type\">List</span> &#123;<br>                <span class=\"hljs-type\">ForEach</span>(items, id: \\.<span class=\"hljs-keyword\">self</span>) &#123; item <span class=\"hljs-keyword\">in</span><br>                    <span class=\"hljs-type\">Text</span>(item)<br>                &#125;<br>                .onDelete(perform: delete)<br>                .onMove(perform: move)<br>            &#125;<br>            .navigationBarItems(trailing: <span class=\"hljs-type\">EditButton</span>())<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">delete</span>(<span class=\"hljs-params\">at</span> <span class=\"hljs-params\">offsets</span>: <span class=\"hljs-type\">IndexSet</span>) &#123;<br>        items.remove(atOffsets: offsets)<br>    &#125;<br><br>    <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">move</span>(<span class=\"hljs-params\">from</span> <span class=\"hljs-params\">source</span>: <span class=\"hljs-type\">IndexSet</span>, <span class=\"hljs-params\">to</span> <span class=\"hljs-params\">destination</span>: <span class=\"hljs-type\">Int</span>) &#123;<br>        items.move(fromOffsets: source, toOffset: destination)<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">EditableListView_Previews</span>: <span class=\"hljs-title class_\">PreviewProvider</span> &#123;<br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">var</span> previews: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">EditableListView</span>()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"自定义行\"><a href=\"#自定义行\" class=\"headerlink\" title=\"自定义行\"></a>自定义行</h3><p>你可以在 <code>List</code> 中自定义行，比如添加图标和导航链接。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">import</span> SwiftUI<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">CustomRowListView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">List</span> &#123;<br>            <span class=\"hljs-type\">NavigationLink</span>(destination: <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Destination&quot;</span>)) &#123;<br>                <span class=\"hljs-type\">HStack</span> &#123;<br>                    <span class=\"hljs-type\">Image</span>(systemName: <span class=\"hljs-string\">&quot;folder&quot;</span>)<br>                    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Files&quot;</span>)<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">CustomRowListView_Previews</span>: <span class=\"hljs-title class_\">PreviewProvider</span> &#123;<br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">var</span> previews: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">CustomRowListView</span>()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"使用-List-的选择模式\"><a href=\"#使用-List-的选择模式\" class=\"headerlink\" title=\"使用 List 的选择模式\"></a>使用 <code>List</code> 的选择模式</h3><p>你还可以使用 <code>List</code> 的选择模式来创建可以选择单个或多个项的列表。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">import</span> SwiftUI<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">SelectableListView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-keyword\">let</span> items <span class=\"hljs-operator\">=</span> [<span class=\"hljs-string\">&quot;Apple&quot;</span>, <span class=\"hljs-string\">&quot;Banana&quot;</span>, <span class=\"hljs-string\">&quot;Cherry&quot;</span>]<br>    <span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> selectedItems <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">Set</span>&lt;<span class=\"hljs-type\">String</span>&gt;()<br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">List</span>(items, id: \\.<span class=\"hljs-keyword\">self</span>, selection: <span class=\"hljs-variable\">$selectedItems</span>) &#123; item <span class=\"hljs-keyword\">in</span><br>            <span class=\"hljs-type\">Text</span>(item)<br>        &#125;<br>        .toolbar &#123;<br>            <span class=\"hljs-type\">EditButton</span>()<br>        &#125;<br>        .environment(\\.editMode, .constant(.active)) <span class=\"hljs-comment\">// 使得列表始终处于编辑模式</span><br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">SelectableListView_Previews</span>: <span class=\"hljs-title class_\">PreviewProvider</span> &#123;<br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">var</span> previews: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">SelectableListView</span>()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在 SwiftUI 中，<code>List</code> 是一个非常强大的构建用户界面的工具，可以通过上述的各种方式灵活地显示和管理集合数据。</p>\n"},{"title":"SwiftUI中Link组件的用法","date":"2023-11-07T13:40:26.000Z","_content":"在 SwiftUI 中，`Link` 是一个用于创建可导航的超链接的视图。它可以让你在应用内打开一个网页链接，或者在支持深度链接的应用之间进行跳转。\n\n以下是 `Link` 的几种基本用法：\n\n### 打开网页链接\n\n使用 `Link`，你可以打开一个 URL。以下是一个简单的例子，展示了如何使用 `Link` 来打开一个网页：\n\n```swift\nstruct ContentView: View {\n    var body: some View {\n        Link(\"Visit OpenAI\", destination: URL(string: \"https://www.openai.com\")!)\n    }\n}\n```\n\n在这个例子中，点击文本 \"Visit OpenAI\" 会尝试在默认浏览器中打开链接。\n\n### 自定义链接外观\n\n你可以自定义 `Link` 的外观，将它包装在其它视图中。例如，你可以使用一个按钮样式的链接：\n\n```swift\nstruct ContentView: View {\n    var body: some View {\n        Link(destination: URL(string: \"https://www.openai.com\")!) {\n            Text(\"Visit OpenAI\")\n                .padding()\n                .background(Color.blue)\n                .foregroundColor(.white)\n                .cornerRadius(10)\n        }\n    }\n}\n```\n\n在这个例子中，链接看起来更像是一个按钮，带有蓝色背景和圆角。\n\n### 在列表中使用链接\n\n`Link` 可以和列表结合使用，作为列表项的一部分，提供导航功能。\n\n```swift\nstruct ContentView: View {\n    var body: some View {\n        NavigationView {\n            List {\n                Link(\"OpenAI Website\", destination: URL(string: \"https://www.openai.com\")!)\n                Link(\"OpenAI Twitter\", destination: URL(string: \"https://twitter.com/openai\")!)\n            }\n            .navigationTitle(\"OpenAI Links\")\n        }\n    }\n}\n```\n\n这个例子创建了一个包含两个链接的列表。点击这些链接会打开相应的网页。\n\n### 使用深度链接在应用间导航\n\n如果其他应用支持 URL Scheme，你可以使用 `Link` 进行应用间的深度链接导航。例如，以下代码尝试打开 Twitter 应用的 OpenAI 页面（如果用户安装了支持的应用）：\n\n```swift\nstruct ContentView: View {\n    var body: some View {\n        Link(\"Open OpenAI Twitter in App\", destination: URL(string: \"twitter://user?screen_name=openai\")!)\n    }\n}\n```\n\n在使用 `Link` 时，请确保提供有效的 URL，并在可能的情况下处理无法打开链接的情况（例如，用户设备上没有安装相应的应用）。","source":"_posts/SwiftUI中Link组件的用法.md","raw":"---\ntitle: SwiftUI中Link组件的用法\ndate: 2023-11-07 21:40:26\ncategories:\n- SwiftUI\ntags:\n---\n在 SwiftUI 中，`Link` 是一个用于创建可导航的超链接的视图。它可以让你在应用内打开一个网页链接，或者在支持深度链接的应用之间进行跳转。\n\n以下是 `Link` 的几种基本用法：\n\n### 打开网页链接\n\n使用 `Link`，你可以打开一个 URL。以下是一个简单的例子，展示了如何使用 `Link` 来打开一个网页：\n\n```swift\nstruct ContentView: View {\n    var body: some View {\n        Link(\"Visit OpenAI\", destination: URL(string: \"https://www.openai.com\")!)\n    }\n}\n```\n\n在这个例子中，点击文本 \"Visit OpenAI\" 会尝试在默认浏览器中打开链接。\n\n### 自定义链接外观\n\n你可以自定义 `Link` 的外观，将它包装在其它视图中。例如，你可以使用一个按钮样式的链接：\n\n```swift\nstruct ContentView: View {\n    var body: some View {\n        Link(destination: URL(string: \"https://www.openai.com\")!) {\n            Text(\"Visit OpenAI\")\n                .padding()\n                .background(Color.blue)\n                .foregroundColor(.white)\n                .cornerRadius(10)\n        }\n    }\n}\n```\n\n在这个例子中，链接看起来更像是一个按钮，带有蓝色背景和圆角。\n\n### 在列表中使用链接\n\n`Link` 可以和列表结合使用，作为列表项的一部分，提供导航功能。\n\n```swift\nstruct ContentView: View {\n    var body: some View {\n        NavigationView {\n            List {\n                Link(\"OpenAI Website\", destination: URL(string: \"https://www.openai.com\")!)\n                Link(\"OpenAI Twitter\", destination: URL(string: \"https://twitter.com/openai\")!)\n            }\n            .navigationTitle(\"OpenAI Links\")\n        }\n    }\n}\n```\n\n这个例子创建了一个包含两个链接的列表。点击这些链接会打开相应的网页。\n\n### 使用深度链接在应用间导航\n\n如果其他应用支持 URL Scheme，你可以使用 `Link` 进行应用间的深度链接导航。例如，以下代码尝试打开 Twitter 应用的 OpenAI 页面（如果用户安装了支持的应用）：\n\n```swift\nstruct ContentView: View {\n    var body: some View {\n        Link(\"Open OpenAI Twitter in App\", destination: URL(string: \"twitter://user?screen_name=openai\")!)\n    }\n}\n```\n\n在使用 `Link` 时，请确保提供有效的 URL，并在可能的情况下处理无法打开链接的情况（例如，用户设备上没有安装相应的应用）。","slug":"SwiftUI中Link组件的用法","published":1,"updated":"2024-03-17T06:12:52.439Z","comments":1,"layout":"post","photos":[],"_id":"clu6up53b000ez6745ekbh5gy","content":"<p>在 SwiftUI 中，<code>Link</code> 是一个用于创建可导航的超链接的视图。它可以让你在应用内打开一个网页链接，或者在支持深度链接的应用之间进行跳转。</p>\n<p>以下是 <code>Link</code> 的几种基本用法：</p>\n<h3 id=\"打开网页链接\"><a href=\"#打开网页链接\" class=\"headerlink\" title=\"打开网页链接\"></a>打开网页链接</h3><p>使用 <code>Link</code>，你可以打开一个 URL。以下是一个简单的例子，展示了如何使用 <code>Link</code> 来打开一个网页：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ContentView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">Link</span>(<span class=\"hljs-string\">&quot;Visit OpenAI&quot;</span>, destination: <span class=\"hljs-type\">URL</span>(string: <span class=\"hljs-string\">&quot;https://www.openai.com&quot;</span>)<span class=\"hljs-operator\">!</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在这个例子中，点击文本 “Visit OpenAI” 会尝试在默认浏览器中打开链接。</p>\n<h3 id=\"自定义链接外观\"><a href=\"#自定义链接外观\" class=\"headerlink\" title=\"自定义链接外观\"></a>自定义链接外观</h3><p>你可以自定义 <code>Link</code> 的外观，将它包装在其它视图中。例如，你可以使用一个按钮样式的链接：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ContentView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">Link</span>(destination: <span class=\"hljs-type\">URL</span>(string: <span class=\"hljs-string\">&quot;https://www.openai.com&quot;</span>)<span class=\"hljs-operator\">!</span>) &#123;<br>            <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Visit OpenAI&quot;</span>)<br>                .padding()<br>                .background(<span class=\"hljs-type\">Color</span>.blue)<br>                .foregroundColor(.white)<br>                .cornerRadius(<span class=\"hljs-number\">10</span>)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在这个例子中，链接看起来更像是一个按钮，带有蓝色背景和圆角。</p>\n<h3 id=\"在列表中使用链接\"><a href=\"#在列表中使用链接\" class=\"headerlink\" title=\"在列表中使用链接\"></a>在列表中使用链接</h3><p><code>Link</code> 可以和列表结合使用，作为列表项的一部分，提供导航功能。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ContentView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">NavigationView</span> &#123;<br>            <span class=\"hljs-type\">List</span> &#123;<br>                <span class=\"hljs-type\">Link</span>(<span class=\"hljs-string\">&quot;OpenAI Website&quot;</span>, destination: <span class=\"hljs-type\">URL</span>(string: <span class=\"hljs-string\">&quot;https://www.openai.com&quot;</span>)<span class=\"hljs-operator\">!</span>)<br>                <span class=\"hljs-type\">Link</span>(<span class=\"hljs-string\">&quot;OpenAI Twitter&quot;</span>, destination: <span class=\"hljs-type\">URL</span>(string: <span class=\"hljs-string\">&quot;https://twitter.com/openai&quot;</span>)<span class=\"hljs-operator\">!</span>)<br>            &#125;<br>            .navigationTitle(<span class=\"hljs-string\">&quot;OpenAI Links&quot;</span>)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这个例子创建了一个包含两个链接的列表。点击这些链接会打开相应的网页。</p>\n<h3 id=\"使用深度链接在应用间导航\"><a href=\"#使用深度链接在应用间导航\" class=\"headerlink\" title=\"使用深度链接在应用间导航\"></a>使用深度链接在应用间导航</h3><p>如果其他应用支持 URL Scheme，你可以使用 <code>Link</code> 进行应用间的深度链接导航。例如，以下代码尝试打开 Twitter 应用的 OpenAI 页面（如果用户安装了支持的应用）：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ContentView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">Link</span>(<span class=\"hljs-string\">&quot;Open OpenAI Twitter in App&quot;</span>, destination: <span class=\"hljs-type\">URL</span>(string: <span class=\"hljs-string\">&quot;twitter://user?screen_name=openai&quot;</span>)<span class=\"hljs-operator\">!</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在使用 <code>Link</code> 时，请确保提供有效的 URL，并在可能的情况下处理无法打开链接的情况（例如，用户设备上没有安装相应的应用）。</p>\n","excerpt":"","more":"<p>在 SwiftUI 中，<code>Link</code> 是一个用于创建可导航的超链接的视图。它可以让你在应用内打开一个网页链接，或者在支持深度链接的应用之间进行跳转。</p>\n<p>以下是 <code>Link</code> 的几种基本用法：</p>\n<h3 id=\"打开网页链接\"><a href=\"#打开网页链接\" class=\"headerlink\" title=\"打开网页链接\"></a>打开网页链接</h3><p>使用 <code>Link</code>，你可以打开一个 URL。以下是一个简单的例子，展示了如何使用 <code>Link</code> 来打开一个网页：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ContentView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">Link</span>(<span class=\"hljs-string\">&quot;Visit OpenAI&quot;</span>, destination: <span class=\"hljs-type\">URL</span>(string: <span class=\"hljs-string\">&quot;https://www.openai.com&quot;</span>)<span class=\"hljs-operator\">!</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在这个例子中，点击文本 “Visit OpenAI” 会尝试在默认浏览器中打开链接。</p>\n<h3 id=\"自定义链接外观\"><a href=\"#自定义链接外观\" class=\"headerlink\" title=\"自定义链接外观\"></a>自定义链接外观</h3><p>你可以自定义 <code>Link</code> 的外观，将它包装在其它视图中。例如，你可以使用一个按钮样式的链接：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ContentView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">Link</span>(destination: <span class=\"hljs-type\">URL</span>(string: <span class=\"hljs-string\">&quot;https://www.openai.com&quot;</span>)<span class=\"hljs-operator\">!</span>) &#123;<br>            <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Visit OpenAI&quot;</span>)<br>                .padding()<br>                .background(<span class=\"hljs-type\">Color</span>.blue)<br>                .foregroundColor(.white)<br>                .cornerRadius(<span class=\"hljs-number\">10</span>)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在这个例子中，链接看起来更像是一个按钮，带有蓝色背景和圆角。</p>\n<h3 id=\"在列表中使用链接\"><a href=\"#在列表中使用链接\" class=\"headerlink\" title=\"在列表中使用链接\"></a>在列表中使用链接</h3><p><code>Link</code> 可以和列表结合使用，作为列表项的一部分，提供导航功能。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ContentView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">NavigationView</span> &#123;<br>            <span class=\"hljs-type\">List</span> &#123;<br>                <span class=\"hljs-type\">Link</span>(<span class=\"hljs-string\">&quot;OpenAI Website&quot;</span>, destination: <span class=\"hljs-type\">URL</span>(string: <span class=\"hljs-string\">&quot;https://www.openai.com&quot;</span>)<span class=\"hljs-operator\">!</span>)<br>                <span class=\"hljs-type\">Link</span>(<span class=\"hljs-string\">&quot;OpenAI Twitter&quot;</span>, destination: <span class=\"hljs-type\">URL</span>(string: <span class=\"hljs-string\">&quot;https://twitter.com/openai&quot;</span>)<span class=\"hljs-operator\">!</span>)<br>            &#125;<br>            .navigationTitle(<span class=\"hljs-string\">&quot;OpenAI Links&quot;</span>)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这个例子创建了一个包含两个链接的列表。点击这些链接会打开相应的网页。</p>\n<h3 id=\"使用深度链接在应用间导航\"><a href=\"#使用深度链接在应用间导航\" class=\"headerlink\" title=\"使用深度链接在应用间导航\"></a>使用深度链接在应用间导航</h3><p>如果其他应用支持 URL Scheme，你可以使用 <code>Link</code> 进行应用间的深度链接导航。例如，以下代码尝试打开 Twitter 应用的 OpenAI 页面（如果用户安装了支持的应用）：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ContentView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">Link</span>(<span class=\"hljs-string\">&quot;Open OpenAI Twitter in App&quot;</span>, destination: <span class=\"hljs-type\">URL</span>(string: <span class=\"hljs-string\">&quot;twitter://user?screen_name=openai&quot;</span>)<span class=\"hljs-operator\">!</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在使用 <code>Link</code> 时，请确保提供有效的 URL，并在可能的情况下处理无法打开链接的情况（例如，用户设备上没有安装相应的应用）。</p>\n"},{"title":"SwiftUI中Picker的用法","date":"2023-11-07T12:47:14.000Z","_content":"在 SwiftUI 中，`Picker` 是一个可以让用户从一组选项中选择一个选项的控件。它可以采用多种样式，如轮盘、菜单或段控制（segmented control）。\n\n### 基础用法\n\n最基本的 `Picker` 使用时需要配合 `@State` 属性来绑定选择的值。以下是一个简单的 `Picker` 示例：\n\n```swift\nstruct ContentView: View {\n    @State private var selectedFruit: String = \"Apple\"\n\n    var fruits = [\"Apple\", \"Banana\", \"Cherry\", \"Date\"]\n\n    var body: some View {\n        Picker(\"Select a fruit\", selection: $selectedFruit) {\n            ForEach(fruits, id: \\.self) { fruit in\n                Text(fruit).tag(fruit)\n            }\n        }\n    }\n}\n```\n\n### 在表单中使用\n\n`Picker` 常常用在 `Form` 中，这会自动采用最适合表单样式的方式显示：\n\n```swift\nstruct ContentView: View {\n    @State private var selectedFruit: String = \"Apple\"\n\n    var fruits = [\"Apple\", \"Banana\", \"Cherry\", \"Date\"]\n\n    var body: some View {\n        Form {\n            Picker(\"Select a fruit\", selection: $selectedFruit) {\n                ForEach(fruits, id: \\.self) { fruit in\n                    Text(fruit).tag(fruit)\n                }\n            }\n        }\n    }\n}\n```\n\n### 使用 `PickerStyle`\n\n可以使用 `PickerStyle` 来改变 `Picker` 的外观和感觉：\n\n```swift\nPicker(\"Select a fruit\", selection: $selectedFruit) {\n    ForEach(fruits, id: \\.self) { fruit in\n        Text(fruit).tag(fruit)\n    }\n}\n.pickerStyle(SegmentedPickerStyle())\n```\n\nSwiftUI 提供的 `PickerStyle` 有：\n\n- `DefaultPickerStyle`\n- `SegmentedPickerStyle`\n- `WheelPickerStyle`\n- `InlinePickerStyle`\n- `MenuPickerStyle`\n- `AutomaticPickerStyle`\n\n不同的 `PickerStyle` 在不同的平台和上下文中有不同的外观和行为。\n\n### 在导航视图中使用\n\n在导航视图中，`Picker` 通常会显示为可以导航到另一个视图选择项的列表：\n\n```swift\nstruct ContentView: View {\n    @State private var selectedFruit: String = \"Apple\"\n\n    var fruits = [\"Apple\", \"Banana\", \"Cherry\", \"Date\"]\n\n    var body: some View {\n        NavigationView {\n            Form {\n                Picker(\"Select a fruit\", selection: $selectedFruit) {\n                    ForEach(fruits, id: \\.self) { fruit in\n                        Text(fruit).tag(fruit)\n                    }\n                }\n                .navigationTitle(\"Fruits\")\n            }\n        }\n    }\n}\n```\n\n在 iOS 上，`Picker` 会自动跳转到一个新的屏幕，用户可以选择一个选项后返回。\n\n### 结合使用 `ForEach` 和 `Identifiable`\n\n如果你的数据模型遵循 `Identifiable` 协议，你可以更简洁地使用 `ForEach`：\n\n```swift\nstruct Fruit: Identifiable {\n    let id = UUID()\n    let name: String\n}\n\nstruct ContentView: View {\n    @State private var selectedFruit: Fruit?\n    var fruits = [Fruit(name: \"Apple\"), Fruit(name: \"Banana\"), Fruit(name: \"Cherry\"), Fruit(name: \"Date\")]\n\n    var body: some View {\n        Picker(\"Select a fruit\", selection: $selectedFruit) {\n            ForEach(fruits) { fruit in\n                Text(fruit.name).tag(fruit as Fruit?)\n            }\n        }\n    }\n}\n```\n\n注意，当使用自定义数据类型作为 `Picker` 的 `tag` 值时，需要将 `selectedFruit` 类型设置为可选的 (`Fruit?`)，因为 `Picker` 的 `tag` 需要能够匹配未选择任何值的情况。\n\nSwiftUI 的 `Picker` 是一个强大的控件，提供了灵活的接口来适应各种选择需求，并且能够很好地与其他 UI 控件集成，创建直观且有效的用户界面。","source":"_posts/SwiftUI中Picker的用法.md","raw":"---\ntitle: SwiftUI中Picker的用法\ndate: 2023-11-07 20:47:14\ncategories:\n- SwiftUI\ntags:\n---\n在 SwiftUI 中，`Picker` 是一个可以让用户从一组选项中选择一个选项的控件。它可以采用多种样式，如轮盘、菜单或段控制（segmented control）。\n\n### 基础用法\n\n最基本的 `Picker` 使用时需要配合 `@State` 属性来绑定选择的值。以下是一个简单的 `Picker` 示例：\n\n```swift\nstruct ContentView: View {\n    @State private var selectedFruit: String = \"Apple\"\n\n    var fruits = [\"Apple\", \"Banana\", \"Cherry\", \"Date\"]\n\n    var body: some View {\n        Picker(\"Select a fruit\", selection: $selectedFruit) {\n            ForEach(fruits, id: \\.self) { fruit in\n                Text(fruit).tag(fruit)\n            }\n        }\n    }\n}\n```\n\n### 在表单中使用\n\n`Picker` 常常用在 `Form` 中，这会自动采用最适合表单样式的方式显示：\n\n```swift\nstruct ContentView: View {\n    @State private var selectedFruit: String = \"Apple\"\n\n    var fruits = [\"Apple\", \"Banana\", \"Cherry\", \"Date\"]\n\n    var body: some View {\n        Form {\n            Picker(\"Select a fruit\", selection: $selectedFruit) {\n                ForEach(fruits, id: \\.self) { fruit in\n                    Text(fruit).tag(fruit)\n                }\n            }\n        }\n    }\n}\n```\n\n### 使用 `PickerStyle`\n\n可以使用 `PickerStyle` 来改变 `Picker` 的外观和感觉：\n\n```swift\nPicker(\"Select a fruit\", selection: $selectedFruit) {\n    ForEach(fruits, id: \\.self) { fruit in\n        Text(fruit).tag(fruit)\n    }\n}\n.pickerStyle(SegmentedPickerStyle())\n```\n\nSwiftUI 提供的 `PickerStyle` 有：\n\n- `DefaultPickerStyle`\n- `SegmentedPickerStyle`\n- `WheelPickerStyle`\n- `InlinePickerStyle`\n- `MenuPickerStyle`\n- `AutomaticPickerStyle`\n\n不同的 `PickerStyle` 在不同的平台和上下文中有不同的外观和行为。\n\n### 在导航视图中使用\n\n在导航视图中，`Picker` 通常会显示为可以导航到另一个视图选择项的列表：\n\n```swift\nstruct ContentView: View {\n    @State private var selectedFruit: String = \"Apple\"\n\n    var fruits = [\"Apple\", \"Banana\", \"Cherry\", \"Date\"]\n\n    var body: some View {\n        NavigationView {\n            Form {\n                Picker(\"Select a fruit\", selection: $selectedFruit) {\n                    ForEach(fruits, id: \\.self) { fruit in\n                        Text(fruit).tag(fruit)\n                    }\n                }\n                .navigationTitle(\"Fruits\")\n            }\n        }\n    }\n}\n```\n\n在 iOS 上，`Picker` 会自动跳转到一个新的屏幕，用户可以选择一个选项后返回。\n\n### 结合使用 `ForEach` 和 `Identifiable`\n\n如果你的数据模型遵循 `Identifiable` 协议，你可以更简洁地使用 `ForEach`：\n\n```swift\nstruct Fruit: Identifiable {\n    let id = UUID()\n    let name: String\n}\n\nstruct ContentView: View {\n    @State private var selectedFruit: Fruit?\n    var fruits = [Fruit(name: \"Apple\"), Fruit(name: \"Banana\"), Fruit(name: \"Cherry\"), Fruit(name: \"Date\")]\n\n    var body: some View {\n        Picker(\"Select a fruit\", selection: $selectedFruit) {\n            ForEach(fruits) { fruit in\n                Text(fruit.name).tag(fruit as Fruit?)\n            }\n        }\n    }\n}\n```\n\n注意，当使用自定义数据类型作为 `Picker` 的 `tag` 值时，需要将 `selectedFruit` 类型设置为可选的 (`Fruit?`)，因为 `Picker` 的 `tag` 需要能够匹配未选择任何值的情况。\n\nSwiftUI 的 `Picker` 是一个强大的控件，提供了灵活的接口来适应各种选择需求，并且能够很好地与其他 UI 控件集成，创建直观且有效的用户界面。","slug":"SwiftUI中Picker的用法","published":1,"updated":"2024-03-17T06:12:58.066Z","comments":1,"layout":"post","photos":[],"_id":"clu6up53b000fz6741s5e3hh3","content":"<p>在 SwiftUI 中，<code>Picker</code> 是一个可以让用户从一组选项中选择一个选项的控件。它可以采用多种样式，如轮盘、菜单或段控制（segmented control）。</p>\n<h3 id=\"基础用法\"><a href=\"#基础用法\" class=\"headerlink\" title=\"基础用法\"></a>基础用法</h3><p>最基本的 <code>Picker</code> 使用时需要配合 <code>@State</code> 属性来绑定选择的值。以下是一个简单的 <code>Picker</code> 示例：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ContentView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> selectedFruit: <span class=\"hljs-type\">String</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;Apple&quot;</span><br><br>    <span class=\"hljs-keyword\">var</span> fruits <span class=\"hljs-operator\">=</span> [<span class=\"hljs-string\">&quot;Apple&quot;</span>, <span class=\"hljs-string\">&quot;Banana&quot;</span>, <span class=\"hljs-string\">&quot;Cherry&quot;</span>, <span class=\"hljs-string\">&quot;Date&quot;</span>]<br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">Picker</span>(<span class=\"hljs-string\">&quot;Select a fruit&quot;</span>, selection: <span class=\"hljs-variable\">$selectedFruit</span>) &#123;<br>            <span class=\"hljs-type\">ForEach</span>(fruits, id: \\.<span class=\"hljs-keyword\">self</span>) &#123; fruit <span class=\"hljs-keyword\">in</span><br>                <span class=\"hljs-type\">Text</span>(fruit).tag(fruit)<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"在表单中使用\"><a href=\"#在表单中使用\" class=\"headerlink\" title=\"在表单中使用\"></a>在表单中使用</h3><p><code>Picker</code> 常常用在 <code>Form</code> 中，这会自动采用最适合表单样式的方式显示：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ContentView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> selectedFruit: <span class=\"hljs-type\">String</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;Apple&quot;</span><br><br>    <span class=\"hljs-keyword\">var</span> fruits <span class=\"hljs-operator\">=</span> [<span class=\"hljs-string\">&quot;Apple&quot;</span>, <span class=\"hljs-string\">&quot;Banana&quot;</span>, <span class=\"hljs-string\">&quot;Cherry&quot;</span>, <span class=\"hljs-string\">&quot;Date&quot;</span>]<br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">Form</span> &#123;<br>            <span class=\"hljs-type\">Picker</span>(<span class=\"hljs-string\">&quot;Select a fruit&quot;</span>, selection: <span class=\"hljs-variable\">$selectedFruit</span>) &#123;<br>                <span class=\"hljs-type\">ForEach</span>(fruits, id: \\.<span class=\"hljs-keyword\">self</span>) &#123; fruit <span class=\"hljs-keyword\">in</span><br>                    <span class=\"hljs-type\">Text</span>(fruit).tag(fruit)<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"使用-PickerStyle\"><a href=\"#使用-PickerStyle\" class=\"headerlink\" title=\"使用 PickerStyle\"></a>使用 <code>PickerStyle</code></h3><p>可以使用 <code>PickerStyle</code> 来改变 <code>Picker</code> 的外观和感觉：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Picker</span>(<span class=\"hljs-string\">&quot;Select a fruit&quot;</span>, selection: <span class=\"hljs-variable\">$selectedFruit</span>) &#123;<br>    <span class=\"hljs-type\">ForEach</span>(fruits, id: \\.<span class=\"hljs-keyword\">self</span>) &#123; fruit <span class=\"hljs-keyword\">in</span><br>        <span class=\"hljs-type\">Text</span>(fruit).tag(fruit)<br>    &#125;<br>&#125;<br>.pickerStyle(<span class=\"hljs-type\">SegmentedPickerStyle</span>())<br></code></pre></td></tr></table></figure>\n\n<p>SwiftUI 提供的 <code>PickerStyle</code> 有：</p>\n<ul>\n<li><code>DefaultPickerStyle</code></li>\n<li><code>SegmentedPickerStyle</code></li>\n<li><code>WheelPickerStyle</code></li>\n<li><code>InlinePickerStyle</code></li>\n<li><code>MenuPickerStyle</code></li>\n<li><code>AutomaticPickerStyle</code></li>\n</ul>\n<p>不同的 <code>PickerStyle</code> 在不同的平台和上下文中有不同的外观和行为。</p>\n<h3 id=\"在导航视图中使用\"><a href=\"#在导航视图中使用\" class=\"headerlink\" title=\"在导航视图中使用\"></a>在导航视图中使用</h3><p>在导航视图中，<code>Picker</code> 通常会显示为可以导航到另一个视图选择项的列表：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ContentView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> selectedFruit: <span class=\"hljs-type\">String</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;Apple&quot;</span><br><br>    <span class=\"hljs-keyword\">var</span> fruits <span class=\"hljs-operator\">=</span> [<span class=\"hljs-string\">&quot;Apple&quot;</span>, <span class=\"hljs-string\">&quot;Banana&quot;</span>, <span class=\"hljs-string\">&quot;Cherry&quot;</span>, <span class=\"hljs-string\">&quot;Date&quot;</span>]<br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">NavigationView</span> &#123;<br>            <span class=\"hljs-type\">Form</span> &#123;<br>                <span class=\"hljs-type\">Picker</span>(<span class=\"hljs-string\">&quot;Select a fruit&quot;</span>, selection: <span class=\"hljs-variable\">$selectedFruit</span>) &#123;<br>                    <span class=\"hljs-type\">ForEach</span>(fruits, id: \\.<span class=\"hljs-keyword\">self</span>) &#123; fruit <span class=\"hljs-keyword\">in</span><br>                        <span class=\"hljs-type\">Text</span>(fruit).tag(fruit)<br>                    &#125;<br>                &#125;<br>                .navigationTitle(<span class=\"hljs-string\">&quot;Fruits&quot;</span>)<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在 iOS 上，<code>Picker</code> 会自动跳转到一个新的屏幕，用户可以选择一个选项后返回。</p>\n<h3 id=\"结合使用-ForEach-和-Identifiable\"><a href=\"#结合使用-ForEach-和-Identifiable\" class=\"headerlink\" title=\"结合使用 ForEach 和 Identifiable\"></a>结合使用 <code>ForEach</code> 和 <code>Identifiable</code></h3><p>如果你的数据模型遵循 <code>Identifiable</code> 协议，你可以更简洁地使用 <code>ForEach</code>：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Fruit</span>: <span class=\"hljs-title class_\">Identifiable</span> &#123;<br>    <span class=\"hljs-keyword\">let</span> id <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">UUID</span>()<br>    <span class=\"hljs-keyword\">let</span> name: <span class=\"hljs-type\">String</span><br>&#125;<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ContentView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> selectedFruit: <span class=\"hljs-type\">Fruit</span>?<br>    <span class=\"hljs-keyword\">var</span> fruits <span class=\"hljs-operator\">=</span> [<span class=\"hljs-type\">Fruit</span>(name: <span class=\"hljs-string\">&quot;Apple&quot;</span>), <span class=\"hljs-type\">Fruit</span>(name: <span class=\"hljs-string\">&quot;Banana&quot;</span>), <span class=\"hljs-type\">Fruit</span>(name: <span class=\"hljs-string\">&quot;Cherry&quot;</span>), <span class=\"hljs-type\">Fruit</span>(name: <span class=\"hljs-string\">&quot;Date&quot;</span>)]<br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">Picker</span>(<span class=\"hljs-string\">&quot;Select a fruit&quot;</span>, selection: <span class=\"hljs-variable\">$selectedFruit</span>) &#123;<br>            <span class=\"hljs-type\">ForEach</span>(fruits) &#123; fruit <span class=\"hljs-keyword\">in</span><br>                <span class=\"hljs-type\">Text</span>(fruit.name).tag(fruit <span class=\"hljs-keyword\">as</span> <span class=\"hljs-type\">Fruit</span>?)<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>注意，当使用自定义数据类型作为 <code>Picker</code> 的 <code>tag</code> 值时，需要将 <code>selectedFruit</code> 类型设置为可选的 (<code>Fruit?</code>)，因为 <code>Picker</code> 的 <code>tag</code> 需要能够匹配未选择任何值的情况。</p>\n<p>SwiftUI 的 <code>Picker</code> 是一个强大的控件，提供了灵活的接口来适应各种选择需求，并且能够很好地与其他 UI 控件集成，创建直观且有效的用户界面。</p>\n","excerpt":"","more":"<p>在 SwiftUI 中，<code>Picker</code> 是一个可以让用户从一组选项中选择一个选项的控件。它可以采用多种样式，如轮盘、菜单或段控制（segmented control）。</p>\n<h3 id=\"基础用法\"><a href=\"#基础用法\" class=\"headerlink\" title=\"基础用法\"></a>基础用法</h3><p>最基本的 <code>Picker</code> 使用时需要配合 <code>@State</code> 属性来绑定选择的值。以下是一个简单的 <code>Picker</code> 示例：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ContentView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> selectedFruit: <span class=\"hljs-type\">String</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;Apple&quot;</span><br><br>    <span class=\"hljs-keyword\">var</span> fruits <span class=\"hljs-operator\">=</span> [<span class=\"hljs-string\">&quot;Apple&quot;</span>, <span class=\"hljs-string\">&quot;Banana&quot;</span>, <span class=\"hljs-string\">&quot;Cherry&quot;</span>, <span class=\"hljs-string\">&quot;Date&quot;</span>]<br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">Picker</span>(<span class=\"hljs-string\">&quot;Select a fruit&quot;</span>, selection: <span class=\"hljs-variable\">$selectedFruit</span>) &#123;<br>            <span class=\"hljs-type\">ForEach</span>(fruits, id: \\.<span class=\"hljs-keyword\">self</span>) &#123; fruit <span class=\"hljs-keyword\">in</span><br>                <span class=\"hljs-type\">Text</span>(fruit).tag(fruit)<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"在表单中使用\"><a href=\"#在表单中使用\" class=\"headerlink\" title=\"在表单中使用\"></a>在表单中使用</h3><p><code>Picker</code> 常常用在 <code>Form</code> 中，这会自动采用最适合表单样式的方式显示：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ContentView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> selectedFruit: <span class=\"hljs-type\">String</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;Apple&quot;</span><br><br>    <span class=\"hljs-keyword\">var</span> fruits <span class=\"hljs-operator\">=</span> [<span class=\"hljs-string\">&quot;Apple&quot;</span>, <span class=\"hljs-string\">&quot;Banana&quot;</span>, <span class=\"hljs-string\">&quot;Cherry&quot;</span>, <span class=\"hljs-string\">&quot;Date&quot;</span>]<br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">Form</span> &#123;<br>            <span class=\"hljs-type\">Picker</span>(<span class=\"hljs-string\">&quot;Select a fruit&quot;</span>, selection: <span class=\"hljs-variable\">$selectedFruit</span>) &#123;<br>                <span class=\"hljs-type\">ForEach</span>(fruits, id: \\.<span class=\"hljs-keyword\">self</span>) &#123; fruit <span class=\"hljs-keyword\">in</span><br>                    <span class=\"hljs-type\">Text</span>(fruit).tag(fruit)<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"使用-PickerStyle\"><a href=\"#使用-PickerStyle\" class=\"headerlink\" title=\"使用 PickerStyle\"></a>使用 <code>PickerStyle</code></h3><p>可以使用 <code>PickerStyle</code> 来改变 <code>Picker</code> 的外观和感觉：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Picker</span>(<span class=\"hljs-string\">&quot;Select a fruit&quot;</span>, selection: <span class=\"hljs-variable\">$selectedFruit</span>) &#123;<br>    <span class=\"hljs-type\">ForEach</span>(fruits, id: \\.<span class=\"hljs-keyword\">self</span>) &#123; fruit <span class=\"hljs-keyword\">in</span><br>        <span class=\"hljs-type\">Text</span>(fruit).tag(fruit)<br>    &#125;<br>&#125;<br>.pickerStyle(<span class=\"hljs-type\">SegmentedPickerStyle</span>())<br></code></pre></td></tr></table></figure>\n\n<p>SwiftUI 提供的 <code>PickerStyle</code> 有：</p>\n<ul>\n<li><code>DefaultPickerStyle</code></li>\n<li><code>SegmentedPickerStyle</code></li>\n<li><code>WheelPickerStyle</code></li>\n<li><code>InlinePickerStyle</code></li>\n<li><code>MenuPickerStyle</code></li>\n<li><code>AutomaticPickerStyle</code></li>\n</ul>\n<p>不同的 <code>PickerStyle</code> 在不同的平台和上下文中有不同的外观和行为。</p>\n<h3 id=\"在导航视图中使用\"><a href=\"#在导航视图中使用\" class=\"headerlink\" title=\"在导航视图中使用\"></a>在导航视图中使用</h3><p>在导航视图中，<code>Picker</code> 通常会显示为可以导航到另一个视图选择项的列表：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ContentView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> selectedFruit: <span class=\"hljs-type\">String</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;Apple&quot;</span><br><br>    <span class=\"hljs-keyword\">var</span> fruits <span class=\"hljs-operator\">=</span> [<span class=\"hljs-string\">&quot;Apple&quot;</span>, <span class=\"hljs-string\">&quot;Banana&quot;</span>, <span class=\"hljs-string\">&quot;Cherry&quot;</span>, <span class=\"hljs-string\">&quot;Date&quot;</span>]<br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">NavigationView</span> &#123;<br>            <span class=\"hljs-type\">Form</span> &#123;<br>                <span class=\"hljs-type\">Picker</span>(<span class=\"hljs-string\">&quot;Select a fruit&quot;</span>, selection: <span class=\"hljs-variable\">$selectedFruit</span>) &#123;<br>                    <span class=\"hljs-type\">ForEach</span>(fruits, id: \\.<span class=\"hljs-keyword\">self</span>) &#123; fruit <span class=\"hljs-keyword\">in</span><br>                        <span class=\"hljs-type\">Text</span>(fruit).tag(fruit)<br>                    &#125;<br>                &#125;<br>                .navigationTitle(<span class=\"hljs-string\">&quot;Fruits&quot;</span>)<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在 iOS 上，<code>Picker</code> 会自动跳转到一个新的屏幕，用户可以选择一个选项后返回。</p>\n<h3 id=\"结合使用-ForEach-和-Identifiable\"><a href=\"#结合使用-ForEach-和-Identifiable\" class=\"headerlink\" title=\"结合使用 ForEach 和 Identifiable\"></a>结合使用 <code>ForEach</code> 和 <code>Identifiable</code></h3><p>如果你的数据模型遵循 <code>Identifiable</code> 协议，你可以更简洁地使用 <code>ForEach</code>：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Fruit</span>: <span class=\"hljs-title class_\">Identifiable</span> &#123;<br>    <span class=\"hljs-keyword\">let</span> id <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">UUID</span>()<br>    <span class=\"hljs-keyword\">let</span> name: <span class=\"hljs-type\">String</span><br>&#125;<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ContentView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> selectedFruit: <span class=\"hljs-type\">Fruit</span>?<br>    <span class=\"hljs-keyword\">var</span> fruits <span class=\"hljs-operator\">=</span> [<span class=\"hljs-type\">Fruit</span>(name: <span class=\"hljs-string\">&quot;Apple&quot;</span>), <span class=\"hljs-type\">Fruit</span>(name: <span class=\"hljs-string\">&quot;Banana&quot;</span>), <span class=\"hljs-type\">Fruit</span>(name: <span class=\"hljs-string\">&quot;Cherry&quot;</span>), <span class=\"hljs-type\">Fruit</span>(name: <span class=\"hljs-string\">&quot;Date&quot;</span>)]<br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">Picker</span>(<span class=\"hljs-string\">&quot;Select a fruit&quot;</span>, selection: <span class=\"hljs-variable\">$selectedFruit</span>) &#123;<br>            <span class=\"hljs-type\">ForEach</span>(fruits) &#123; fruit <span class=\"hljs-keyword\">in</span><br>                <span class=\"hljs-type\">Text</span>(fruit.name).tag(fruit <span class=\"hljs-keyword\">as</span> <span class=\"hljs-type\">Fruit</span>?)<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>注意，当使用自定义数据类型作为 <code>Picker</code> 的 <code>tag</code> 值时，需要将 <code>selectedFruit</code> 类型设置为可选的 (<code>Fruit?</code>)，因为 <code>Picker</code> 的 <code>tag</code> 需要能够匹配未选择任何值的情况。</p>\n<p>SwiftUI 的 <code>Picker</code> 是一个强大的控件，提供了灵活的接口来适应各种选择需求，并且能够很好地与其他 UI 控件集成，创建直观且有效的用户界面。</p>\n"},{"title":"SwiftUI中HStack的用法","date":"2023-11-07T13:52:20.000Z","_content":"`HStack` 是 SwiftUI 中一个非常基础和常用的布局工具，用于在水平方向上堆叠视图。以下是 `HStack` 的一些基本用法：\n\n### 创建一个基础的 HStack\n\n```swift\nHStack {\n    Text(\"Left\")\n    Text(\"Center\")\n    Text(\"Right\")\n}\n```\n这会将三个文本视图水平排列在一行内。\n\n### 调整间距\n\n```swift\nHStack(spacing: 20) {\n    Text(\"Left\")\n    Text(\"Center\")\n    Text(\"Right\")\n}\n```\n这将会在子视图之间设置为20点的间距。\n\n### 对齐\n\n`HStack` 默认在垂直方向上是居中对齐的，但你可以改变这个对齐方式：\n\n```swift\nHStack(alignment: .top) {\n    Text(\"Top\")\n    Text(\"Aligned\")\n    Text(\"Text\")\n}\n```\n这会在垂直方向上将文本对齐到顶部。\n\n### 使用 Spacer\n\n```swift\nHStack {\n    Text(\"Left\")\n    Spacer() // 使用 Spacer 会推动两侧的文本到左右边缘\n    Text(\"Right\")\n}\n```\n`Spacer` 占据所有可用的空间，这里将会使两个文本视图分别对齐到左右边缘。\n\n### 嵌套 HStack\n\n`HStack` 可以嵌套使用，以创建更复杂的布局：\n\n```swift\nHStack {\n    VStack {\n        Text(\"Top Left\")\n        Text(\"Bottom Left\")\n    }\n    VStack {\n        Text(\"Top Right\")\n        Text(\"Bottom Right\")\n    }\n}\n```\n这将在水平方向上创建两个垂直堆叠，每个堆叠包含两个文本视图。\n\n### 结合使用 Frame 和 Alignment\n\n```swift\nHStack(alignment: .bottom) {\n    Text(\"Bottom\")\n        .frame(width: 100)\n    Text(\"Aligned\")\n        .frame(width: 100, alignment: .trailing)\n}\n```\n这将设置每个文本视图的宽度，并在底部对齐它们。\n\n### 在实际应用中\n\n`HStack` 通常与其它布局视图（如 `VStack`, `ZStack`, `ScrollView`）一起使用，以实现复杂的用户界面布局。下面是一个常见的例子，结合 `HStack` 和 `VStack`：\n\n```swift\nVStack {\n    HStack {\n        Image(systemName: \"star.fill\")\n            .foregroundColor(.yellow)\n        Text(\"Favorite\")\n            .font(.headline)\n        Spacer()\n    }\n    .padding()\n    \n    Divider()\n    \n    // 其他内容\n}\n```\n这会创建一个包含星形图标和标题的水平布局，并将其包裹在垂直布局中，通常这会作为列表的一部分。使用 `Divider` 来分隔列表项是常见的做法。","source":"_posts/SwiftUI中HStack的用法.md","raw":"---\ntitle: SwiftUI中HStack的用法\ndate: 2023-11-07 21:52:20\ncategories:\n- SwiftUI\ntags:\n---\n`HStack` 是 SwiftUI 中一个非常基础和常用的布局工具，用于在水平方向上堆叠视图。以下是 `HStack` 的一些基本用法：\n\n### 创建一个基础的 HStack\n\n```swift\nHStack {\n    Text(\"Left\")\n    Text(\"Center\")\n    Text(\"Right\")\n}\n```\n这会将三个文本视图水平排列在一行内。\n\n### 调整间距\n\n```swift\nHStack(spacing: 20) {\n    Text(\"Left\")\n    Text(\"Center\")\n    Text(\"Right\")\n}\n```\n这将会在子视图之间设置为20点的间距。\n\n### 对齐\n\n`HStack` 默认在垂直方向上是居中对齐的，但你可以改变这个对齐方式：\n\n```swift\nHStack(alignment: .top) {\n    Text(\"Top\")\n    Text(\"Aligned\")\n    Text(\"Text\")\n}\n```\n这会在垂直方向上将文本对齐到顶部。\n\n### 使用 Spacer\n\n```swift\nHStack {\n    Text(\"Left\")\n    Spacer() // 使用 Spacer 会推动两侧的文本到左右边缘\n    Text(\"Right\")\n}\n```\n`Spacer` 占据所有可用的空间，这里将会使两个文本视图分别对齐到左右边缘。\n\n### 嵌套 HStack\n\n`HStack` 可以嵌套使用，以创建更复杂的布局：\n\n```swift\nHStack {\n    VStack {\n        Text(\"Top Left\")\n        Text(\"Bottom Left\")\n    }\n    VStack {\n        Text(\"Top Right\")\n        Text(\"Bottom Right\")\n    }\n}\n```\n这将在水平方向上创建两个垂直堆叠，每个堆叠包含两个文本视图。\n\n### 结合使用 Frame 和 Alignment\n\n```swift\nHStack(alignment: .bottom) {\n    Text(\"Bottom\")\n        .frame(width: 100)\n    Text(\"Aligned\")\n        .frame(width: 100, alignment: .trailing)\n}\n```\n这将设置每个文本视图的宽度，并在底部对齐它们。\n\n### 在实际应用中\n\n`HStack` 通常与其它布局视图（如 `VStack`, `ZStack`, `ScrollView`）一起使用，以实现复杂的用户界面布局。下面是一个常见的例子，结合 `HStack` 和 `VStack`：\n\n```swift\nVStack {\n    HStack {\n        Image(systemName: \"star.fill\")\n            .foregroundColor(.yellow)\n        Text(\"Favorite\")\n            .font(.headline)\n        Spacer()\n    }\n    .padding()\n    \n    Divider()\n    \n    // 其他内容\n}\n```\n这会创建一个包含星形图标和标题的水平布局，并将其包裹在垂直布局中，通常这会作为列表的一部分。使用 `Divider` 来分隔列表项是常见的做法。","slug":"SwiftUI中HStack的用法","published":1,"updated":"2024-03-17T06:12:45.636Z","comments":1,"layout":"post","photos":[],"_id":"clu6up53c000jz6740fba918w","content":"<p><code>HStack</code> 是 SwiftUI 中一个非常基础和常用的布局工具，用于在水平方向上堆叠视图。以下是 <code>HStack</code> 的一些基本用法：</p>\n<h3 id=\"创建一个基础的-HStack\"><a href=\"#创建一个基础的-HStack\" class=\"headerlink\" title=\"创建一个基础的 HStack\"></a>创建一个基础的 HStack</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">HStack</span> &#123;<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Left&quot;</span>)<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Center&quot;</span>)<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Right&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>这会将三个文本视图水平排列在一行内。</p>\n<h3 id=\"调整间距\"><a href=\"#调整间距\" class=\"headerlink\" title=\"调整间距\"></a>调整间距</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">HStack</span>(spacing: <span class=\"hljs-number\">20</span>) &#123;<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Left&quot;</span>)<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Center&quot;</span>)<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Right&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>这将会在子视图之间设置为20点的间距。</p>\n<h3 id=\"对齐\"><a href=\"#对齐\" class=\"headerlink\" title=\"对齐\"></a>对齐</h3><p><code>HStack</code> 默认在垂直方向上是居中对齐的，但你可以改变这个对齐方式：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">HStack</span>(alignment: .top) &#123;<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Top&quot;</span>)<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Aligned&quot;</span>)<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Text&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>这会在垂直方向上将文本对齐到顶部。</p>\n<h3 id=\"使用-Spacer\"><a href=\"#使用-Spacer\" class=\"headerlink\" title=\"使用 Spacer\"></a>使用 Spacer</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">HStack</span> &#123;<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Left&quot;</span>)<br>    <span class=\"hljs-type\">Spacer</span>() <span class=\"hljs-comment\">// 使用 Spacer 会推动两侧的文本到左右边缘</span><br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Right&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n<p><code>Spacer</code> 占据所有可用的空间，这里将会使两个文本视图分别对齐到左右边缘。</p>\n<h3 id=\"嵌套-HStack\"><a href=\"#嵌套-HStack\" class=\"headerlink\" title=\"嵌套 HStack\"></a>嵌套 HStack</h3><p><code>HStack</code> 可以嵌套使用，以创建更复杂的布局：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">HStack</span> &#123;<br>    <span class=\"hljs-type\">VStack</span> &#123;<br>        <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Top Left&quot;</span>)<br>        <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Bottom Left&quot;</span>)<br>    &#125;<br>    <span class=\"hljs-type\">VStack</span> &#123;<br>        <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Top Right&quot;</span>)<br>        <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Bottom Right&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>这将在水平方向上创建两个垂直堆叠，每个堆叠包含两个文本视图。</p>\n<h3 id=\"结合使用-Frame-和-Alignment\"><a href=\"#结合使用-Frame-和-Alignment\" class=\"headerlink\" title=\"结合使用 Frame 和 Alignment\"></a>结合使用 Frame 和 Alignment</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">HStack</span>(alignment: .bottom) &#123;<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Bottom&quot;</span>)<br>        .frame(width: <span class=\"hljs-number\">100</span>)<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Aligned&quot;</span>)<br>        .frame(width: <span class=\"hljs-number\">100</span>, alignment: .trailing)<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>这将设置每个文本视图的宽度，并在底部对齐它们。</p>\n<h3 id=\"在实际应用中\"><a href=\"#在实际应用中\" class=\"headerlink\" title=\"在实际应用中\"></a>在实际应用中</h3><p><code>HStack</code> 通常与其它布局视图（如 <code>VStack</code>, <code>ZStack</code>, <code>ScrollView</code>）一起使用，以实现复杂的用户界面布局。下面是一个常见的例子，结合 <code>HStack</code> 和 <code>VStack</code>：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">VStack</span> &#123;<br>    <span class=\"hljs-type\">HStack</span> &#123;<br>        <span class=\"hljs-type\">Image</span>(systemName: <span class=\"hljs-string\">&quot;star.fill&quot;</span>)<br>            .foregroundColor(.yellow)<br>        <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Favorite&quot;</span>)<br>            .font(.headline)<br>        <span class=\"hljs-type\">Spacer</span>()<br>    &#125;<br>    .padding()<br>    <br>    <span class=\"hljs-type\">Divider</span>()<br>    <br>    <span class=\"hljs-comment\">// 其他内容</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<p>这会创建一个包含星形图标和标题的水平布局，并将其包裹在垂直布局中，通常这会作为列表的一部分。使用 <code>Divider</code> 来分隔列表项是常见的做法。</p>\n","excerpt":"","more":"<p><code>HStack</code> 是 SwiftUI 中一个非常基础和常用的布局工具，用于在水平方向上堆叠视图。以下是 <code>HStack</code> 的一些基本用法：</p>\n<h3 id=\"创建一个基础的-HStack\"><a href=\"#创建一个基础的-HStack\" class=\"headerlink\" title=\"创建一个基础的 HStack\"></a>创建一个基础的 HStack</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">HStack</span> &#123;<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Left&quot;</span>)<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Center&quot;</span>)<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Right&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>这会将三个文本视图水平排列在一行内。</p>\n<h3 id=\"调整间距\"><a href=\"#调整间距\" class=\"headerlink\" title=\"调整间距\"></a>调整间距</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">HStack</span>(spacing: <span class=\"hljs-number\">20</span>) &#123;<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Left&quot;</span>)<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Center&quot;</span>)<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Right&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>这将会在子视图之间设置为20点的间距。</p>\n<h3 id=\"对齐\"><a href=\"#对齐\" class=\"headerlink\" title=\"对齐\"></a>对齐</h3><p><code>HStack</code> 默认在垂直方向上是居中对齐的，但你可以改变这个对齐方式：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">HStack</span>(alignment: .top) &#123;<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Top&quot;</span>)<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Aligned&quot;</span>)<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Text&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>这会在垂直方向上将文本对齐到顶部。</p>\n<h3 id=\"使用-Spacer\"><a href=\"#使用-Spacer\" class=\"headerlink\" title=\"使用 Spacer\"></a>使用 Spacer</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">HStack</span> &#123;<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Left&quot;</span>)<br>    <span class=\"hljs-type\">Spacer</span>() <span class=\"hljs-comment\">// 使用 Spacer 会推动两侧的文本到左右边缘</span><br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Right&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n<p><code>Spacer</code> 占据所有可用的空间，这里将会使两个文本视图分别对齐到左右边缘。</p>\n<h3 id=\"嵌套-HStack\"><a href=\"#嵌套-HStack\" class=\"headerlink\" title=\"嵌套 HStack\"></a>嵌套 HStack</h3><p><code>HStack</code> 可以嵌套使用，以创建更复杂的布局：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">HStack</span> &#123;<br>    <span class=\"hljs-type\">VStack</span> &#123;<br>        <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Top Left&quot;</span>)<br>        <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Bottom Left&quot;</span>)<br>    &#125;<br>    <span class=\"hljs-type\">VStack</span> &#123;<br>        <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Top Right&quot;</span>)<br>        <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Bottom Right&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>这将在水平方向上创建两个垂直堆叠，每个堆叠包含两个文本视图。</p>\n<h3 id=\"结合使用-Frame-和-Alignment\"><a href=\"#结合使用-Frame-和-Alignment\" class=\"headerlink\" title=\"结合使用 Frame 和 Alignment\"></a>结合使用 Frame 和 Alignment</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">HStack</span>(alignment: .bottom) &#123;<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Bottom&quot;</span>)<br>        .frame(width: <span class=\"hljs-number\">100</span>)<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Aligned&quot;</span>)<br>        .frame(width: <span class=\"hljs-number\">100</span>, alignment: .trailing)<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>这将设置每个文本视图的宽度，并在底部对齐它们。</p>\n<h3 id=\"在实际应用中\"><a href=\"#在实际应用中\" class=\"headerlink\" title=\"在实际应用中\"></a>在实际应用中</h3><p><code>HStack</code> 通常与其它布局视图（如 <code>VStack</code>, <code>ZStack</code>, <code>ScrollView</code>）一起使用，以实现复杂的用户界面布局。下面是一个常见的例子，结合 <code>HStack</code> 和 <code>VStack</code>：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">VStack</span> &#123;<br>    <span class=\"hljs-type\">HStack</span> &#123;<br>        <span class=\"hljs-type\">Image</span>(systemName: <span class=\"hljs-string\">&quot;star.fill&quot;</span>)<br>            .foregroundColor(.yellow)<br>        <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Favorite&quot;</span>)<br>            .font(.headline)<br>        <span class=\"hljs-type\">Spacer</span>()<br>    &#125;<br>    .padding()<br>    <br>    <span class=\"hljs-type\">Divider</span>()<br>    <br>    <span class=\"hljs-comment\">// 其他内容</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<p>这会创建一个包含星形图标和标题的水平布局，并将其包裹在垂直布局中，通常这会作为列表的一部分。使用 <code>Divider</code> 来分隔列表项是常见的做法。</p>\n"},{"title":"SwiftUI中ProgressView的用法","date":"2023-11-07T13:12:20.000Z","_content":"`ProgressView` 在 SwiftUI 中被用来表示一个任务的进度。它可以展示为一个旋转的指示器，用来表示正在进行的工作，但具体的进度未知，也可以显示为一个水平的进度条，用来表示可确定进度的任务。\n\n以下是 `ProgressView` 的几种用法：\n\n### 不确定进度的指示器\n\n当你没有具体进度值时，可以使用不带参数的 `ProgressView`，它会显示为一个旋转的活动指示器。\n\n```swift\nstruct ContentView: View {\n    var body: some View {\n        ProgressView()\n            .progressViewStyle(CircularProgressViewStyle()) // 在iOS上默认样式，可省略\n    }\n}\n```\n\n### 确定进度的进度条\n\n如果你有具体的进度值，你可以通过设置一个 `0.0` 到 `1.0` 之间的值来创建一个进度条。\n\n```swift\nstruct ContentView: View {\n    @State private var progress = 0.5\n\n    var body: some View {\n        ProgressView(value: progress, total: 1.0)\n    }\n}\n```\n\n你可以通过定时器或者其他事件更新进度值，进度条会反映这些变化。\n\n### 带有标签和描述的进度条\n\n`ProgressView` 还可以提供更多的上下文信息，比如一个标签或者一个描述性文本。\n\n```swift\nstruct ContentView: View {\n    @State private var progress = 0.5\n\n    var body: some View {\n        VStack {\n            ProgressView(\"Downloading...\", value: progress, total: 1.0)\n            \n            // 或者使用标签和系统图标\n            ProgressView(value: progress) {\n                Label(\"Downloading\", systemImage: \"arrow.down.doc\")\n            }\n            // 添加描述性文本\n            .progressViewStyle(LinearProgressViewStyle()) // 水平进度条\n            .accessibilityValue(\"\\(Int(progress * 100)) percent\")\n        }\n    }\n}\n```\n\n### 自定义进度条样式\n\n你可以通过 `progressViewStyle` 修饰符来自定义进度条的样式。\n\n```swift\nstruct ContentView: View {\n    @State private var progress = 0.5\n\n    var body: some View {\n        ProgressView(value: progress)\n            .progressViewStyle(LinearProgressViewStyle(tint: .blue)) // 自定义颜色\n    }\n}\n```\n\n使用 `ProgressView` 的时候要注意，它需要在应用的适当位置显示，以避免阻碍用户操作，尤其是当使用不确定进度的指示器时。确保当任务完成或不再相关时，从界面上移除进度指示器。","source":"_posts/SwiftUI中ProgressView的用法.md","raw":"---\ntitle: SwiftUI中ProgressView的用法\ndate: 2023-11-07 21:12:20\ncategories:\n- SwiftUI\ntags:\n---\n`ProgressView` 在 SwiftUI 中被用来表示一个任务的进度。它可以展示为一个旋转的指示器，用来表示正在进行的工作，但具体的进度未知，也可以显示为一个水平的进度条，用来表示可确定进度的任务。\n\n以下是 `ProgressView` 的几种用法：\n\n### 不确定进度的指示器\n\n当你没有具体进度值时，可以使用不带参数的 `ProgressView`，它会显示为一个旋转的活动指示器。\n\n```swift\nstruct ContentView: View {\n    var body: some View {\n        ProgressView()\n            .progressViewStyle(CircularProgressViewStyle()) // 在iOS上默认样式，可省略\n    }\n}\n```\n\n### 确定进度的进度条\n\n如果你有具体的进度值，你可以通过设置一个 `0.0` 到 `1.0` 之间的值来创建一个进度条。\n\n```swift\nstruct ContentView: View {\n    @State private var progress = 0.5\n\n    var body: some View {\n        ProgressView(value: progress, total: 1.0)\n    }\n}\n```\n\n你可以通过定时器或者其他事件更新进度值，进度条会反映这些变化。\n\n### 带有标签和描述的进度条\n\n`ProgressView` 还可以提供更多的上下文信息，比如一个标签或者一个描述性文本。\n\n```swift\nstruct ContentView: View {\n    @State private var progress = 0.5\n\n    var body: some View {\n        VStack {\n            ProgressView(\"Downloading...\", value: progress, total: 1.0)\n            \n            // 或者使用标签和系统图标\n            ProgressView(value: progress) {\n                Label(\"Downloading\", systemImage: \"arrow.down.doc\")\n            }\n            // 添加描述性文本\n            .progressViewStyle(LinearProgressViewStyle()) // 水平进度条\n            .accessibilityValue(\"\\(Int(progress * 100)) percent\")\n        }\n    }\n}\n```\n\n### 自定义进度条样式\n\n你可以通过 `progressViewStyle` 修饰符来自定义进度条的样式。\n\n```swift\nstruct ContentView: View {\n    @State private var progress = 0.5\n\n    var body: some View {\n        ProgressView(value: progress)\n            .progressViewStyle(LinearProgressViewStyle(tint: .blue)) // 自定义颜色\n    }\n}\n```\n\n使用 `ProgressView` 的时候要注意，它需要在应用的适当位置显示，以避免阻碍用户操作，尤其是当使用不确定进度的指示器时。确保当任务完成或不再相关时，从界面上移除进度指示器。","slug":"SwiftUI中ProgressView的用法","published":1,"updated":"2024-03-17T06:13:04.783Z","comments":1,"layout":"post","photos":[],"_id":"clu6up53c000lz674djerf10c","content":"<p><code>ProgressView</code> 在 SwiftUI 中被用来表示一个任务的进度。它可以展示为一个旋转的指示器，用来表示正在进行的工作，但具体的进度未知，也可以显示为一个水平的进度条，用来表示可确定进度的任务。</p>\n<p>以下是 <code>ProgressView</code> 的几种用法：</p>\n<h3 id=\"不确定进度的指示器\"><a href=\"#不确定进度的指示器\" class=\"headerlink\" title=\"不确定进度的指示器\"></a>不确定进度的指示器</h3><p>当你没有具体进度值时，可以使用不带参数的 <code>ProgressView</code>，它会显示为一个旋转的活动指示器。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ContentView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">ProgressView</span>()<br>            .progressViewStyle(<span class=\"hljs-type\">CircularProgressViewStyle</span>()) <span class=\"hljs-comment\">// 在iOS上默认样式，可省略</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"确定进度的进度条\"><a href=\"#确定进度的进度条\" class=\"headerlink\" title=\"确定进度的进度条\"></a>确定进度的进度条</h3><p>如果你有具体的进度值，你可以通过设置一个 <code>0.0</code> 到 <code>1.0</code> 之间的值来创建一个进度条。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ContentView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> progress <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0.5</span><br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">ProgressView</span>(value: progress, total: <span class=\"hljs-number\">1.0</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>你可以通过定时器或者其他事件更新进度值，进度条会反映这些变化。</p>\n<h3 id=\"带有标签和描述的进度条\"><a href=\"#带有标签和描述的进度条\" class=\"headerlink\" title=\"带有标签和描述的进度条\"></a>带有标签和描述的进度条</h3><p><code>ProgressView</code> 还可以提供更多的上下文信息，比如一个标签或者一个描述性文本。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ContentView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> progress <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0.5</span><br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">VStack</span> &#123;<br>            <span class=\"hljs-type\">ProgressView</span>(<span class=\"hljs-string\">&quot;Downloading...&quot;</span>, value: progress, total: <span class=\"hljs-number\">1.0</span>)<br>            <br>            <span class=\"hljs-comment\">// 或者使用标签和系统图标</span><br>            <span class=\"hljs-type\">ProgressView</span>(value: progress) &#123;<br>                <span class=\"hljs-type\">Label</span>(<span class=\"hljs-string\">&quot;Downloading&quot;</span>, systemImage: <span class=\"hljs-string\">&quot;arrow.down.doc&quot;</span>)<br>            &#125;<br>            <span class=\"hljs-comment\">// 添加描述性文本</span><br>            .progressViewStyle(<span class=\"hljs-type\">LinearProgressViewStyle</span>()) <span class=\"hljs-comment\">// 水平进度条</span><br>            .accessibilityValue(<span class=\"hljs-string\">&quot;<span class=\"hljs-subst\">\\(Int(progress <span class=\"hljs-operator\">*</span> <span class=\"hljs-number\">100</span>))</span> percent&quot;</span>)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"自定义进度条样式\"><a href=\"#自定义进度条样式\" class=\"headerlink\" title=\"自定义进度条样式\"></a>自定义进度条样式</h3><p>你可以通过 <code>progressViewStyle</code> 修饰符来自定义进度条的样式。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ContentView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> progress <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0.5</span><br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">ProgressView</span>(value: progress)<br>            .progressViewStyle(<span class=\"hljs-type\">LinearProgressViewStyle</span>(tint: .blue)) <span class=\"hljs-comment\">// 自定义颜色</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>使用 <code>ProgressView</code> 的时候要注意，它需要在应用的适当位置显示，以避免阻碍用户操作，尤其是当使用不确定进度的指示器时。确保当任务完成或不再相关时，从界面上移除进度指示器。</p>\n","excerpt":"","more":"<p><code>ProgressView</code> 在 SwiftUI 中被用来表示一个任务的进度。它可以展示为一个旋转的指示器，用来表示正在进行的工作，但具体的进度未知，也可以显示为一个水平的进度条，用来表示可确定进度的任务。</p>\n<p>以下是 <code>ProgressView</code> 的几种用法：</p>\n<h3 id=\"不确定进度的指示器\"><a href=\"#不确定进度的指示器\" class=\"headerlink\" title=\"不确定进度的指示器\"></a>不确定进度的指示器</h3><p>当你没有具体进度值时，可以使用不带参数的 <code>ProgressView</code>，它会显示为一个旋转的活动指示器。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ContentView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">ProgressView</span>()<br>            .progressViewStyle(<span class=\"hljs-type\">CircularProgressViewStyle</span>()) <span class=\"hljs-comment\">// 在iOS上默认样式，可省略</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"确定进度的进度条\"><a href=\"#确定进度的进度条\" class=\"headerlink\" title=\"确定进度的进度条\"></a>确定进度的进度条</h3><p>如果你有具体的进度值，你可以通过设置一个 <code>0.0</code> 到 <code>1.0</code> 之间的值来创建一个进度条。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ContentView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> progress <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0.5</span><br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">ProgressView</span>(value: progress, total: <span class=\"hljs-number\">1.0</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>你可以通过定时器或者其他事件更新进度值，进度条会反映这些变化。</p>\n<h3 id=\"带有标签和描述的进度条\"><a href=\"#带有标签和描述的进度条\" class=\"headerlink\" title=\"带有标签和描述的进度条\"></a>带有标签和描述的进度条</h3><p><code>ProgressView</code> 还可以提供更多的上下文信息，比如一个标签或者一个描述性文本。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ContentView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> progress <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0.5</span><br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">VStack</span> &#123;<br>            <span class=\"hljs-type\">ProgressView</span>(<span class=\"hljs-string\">&quot;Downloading...&quot;</span>, value: progress, total: <span class=\"hljs-number\">1.0</span>)<br>            <br>            <span class=\"hljs-comment\">// 或者使用标签和系统图标</span><br>            <span class=\"hljs-type\">ProgressView</span>(value: progress) &#123;<br>                <span class=\"hljs-type\">Label</span>(<span class=\"hljs-string\">&quot;Downloading&quot;</span>, systemImage: <span class=\"hljs-string\">&quot;arrow.down.doc&quot;</span>)<br>            &#125;<br>            <span class=\"hljs-comment\">// 添加描述性文本</span><br>            .progressViewStyle(<span class=\"hljs-type\">LinearProgressViewStyle</span>()) <span class=\"hljs-comment\">// 水平进度条</span><br>            .accessibilityValue(<span class=\"hljs-string\">&quot;<span class=\"hljs-subst\">\\(Int(progress <span class=\"hljs-operator\">*</span> <span class=\"hljs-number\">100</span>))</span> percent&quot;</span>)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"自定义进度条样式\"><a href=\"#自定义进度条样式\" class=\"headerlink\" title=\"自定义进度条样式\"></a>自定义进度条样式</h3><p>你可以通过 <code>progressViewStyle</code> 修饰符来自定义进度条的样式。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ContentView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> progress <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0.5</span><br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">ProgressView</span>(value: progress)<br>            .progressViewStyle(<span class=\"hljs-type\">LinearProgressViewStyle</span>(tint: .blue)) <span class=\"hljs-comment\">// 自定义颜色</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>使用 <code>ProgressView</code> 的时候要注意，它需要在应用的适当位置显示，以避免阻碍用户操作，尤其是当使用不确定进度的指示器时。确保当任务完成或不再相关时，从界面上移除进度指示器。</p>\n"},{"title":"SwiftUI中ScrollView的用法","date":"2023-11-07T14:08:11.000Z","_content":"在 SwiftUI 中，`ScrollView` 是一个可以滚动显示其子视图的容器。使用 `ScrollView`，你可以创建一个可以纵向或横向滚动的区域，这对于构建超出屏幕限制的内容是非常有用的。\n\n### 基本用法\n\n默认情况下，`ScrollView` 滚动方向是垂直的。\n\n```swift\nimport SwiftUI\n\nstruct BasicScrollView: View {\n    var body: some View {\n        ScrollView {\n            VStack(spacing: 20) {\n                ForEach(0..<50) { index in\n                    Text(\"Row \\(index)\")\n                }\n            }\n        }\n    }\n}\n\nstruct BasicScrollView_Previews: PreviewProvider {\n    static var previews: some View {\n        BasicScrollView()\n    }\n}\n```\n\n### 水平滚动\n\n要创建一个水平滚动视图，需要设置 `ScrollView` 的 `axis` 参数。\n\n```swift\nimport SwiftUI\n\nstruct HorizontalScrollView: View {\n    var body: some View {\n        ScrollView(.horizontal, showsIndicators: false) {\n            HStack(spacing: 20) {\n                ForEach(0..<50) { index in\n                    Text(\"Column \\(index)\")\n                        .frame(width: 200, height: 200)\n                        .background(Color.blue)\n                        .foregroundColor(.white)\n                        .cornerRadius(10)\n                }\n            }\n        }\n    }\n}\n\nstruct HorizontalScrollView_Previews: PreviewProvider {\n    static var previews: some View {\n        HorizontalScrollView()\n    }\n}\n```\n\n### 同时水平和垂直滚动\n\n可以通过在 `ScrollView` 中嵌套另一个 `ScrollView` 来创建同时支持水平和垂直滚动的视图。\n\n```swift\nimport SwiftUI\n\nstruct BothDirectionsScrollView: View {\n    var body: some View {\n        ScrollView {\n            VStack(spacing: 20) {\n                ForEach(0..<10) { index in\n                    ScrollView(.horizontal, showsIndicators: true) {\n                        HStack(spacing: 20) {\n                            ForEach(0..<10) { index in\n                                Text(\"Item \\(index)\")\n                                    .frame(width: 100, height: 100)\n                                    .background(Color.green)\n                                    .cornerRadius(10)\n                            }\n                        }\n                    }\n                    .frame(height: 100)\n                }\n            }\n        }\n    }\n}\n\nstruct BothDirectionsScrollView_Previews: PreviewProvider {\n    static var previews: some View {\n        BothDirectionsScrollView()\n    }\n}\n```\n\n### 添加滚动条指示器\n\n`ScrollView` 的 `showsIndicators` 参数可以控制是否显示滚动条指示器。\n\n### 响应滚动事件\n\nSwiftUI `ScrollView` 没有像 UIKit 的 `UIScrollView` 那样直接提供滚动事件的回调。但是，你可以通过在 `ScrollView` 内部放置一个 `GeometryReader` 来读取滚动偏移量。\n\n### 使用 `ScrollViewReader`\n\n`ScrollViewReader` 可以用来在 `ScrollView` 内部进行编程式导航（比如滚动到特定的子视图）。\n\n```swift\nimport SwiftUI\n\nstruct ScrollViewReaderExample: View {\n    var body: some View {\n        ScrollViewReader { proxy in\n            ScrollView {\n                VStack(spacing: 10) {\n                    ForEach(0..<100) { index in\n                        Text(\"Item \\(index)\")\n                            .id(index)\n                    }\n                }\n                \n                Button(\"Jump to Item 50\") {\n                    withAnimation {\n                        proxy.scrollTo(50, anchor: .top)\n                    }\n                }\n            }\n        }\n    }\n}\n\nstruct ScrollViewReaderExample_Previews: PreviewProvider {\n    static var previews: some View {\n        ScrollViewReaderExample()\n    }\n}\n```\n\n在这个例子中，点击按钮会自动滚动到第 50 个元素。`ScrollViewReader` 提供了一个 `proxy` 对象，它有一个 `scrollTo(_:anchor:)` 方法可以使用，其中 `id` 参数对应子视图的 `id`。","source":"_posts/SwiftUI中ScrollView的用法.md","raw":"---\ntitle: SwiftUI中ScrollView的用法\ndate: 2023-11-07 22:08:11\ncategories:\n- SwiftUI\ntags:\n---\n在 SwiftUI 中，`ScrollView` 是一个可以滚动显示其子视图的容器。使用 `ScrollView`，你可以创建一个可以纵向或横向滚动的区域，这对于构建超出屏幕限制的内容是非常有用的。\n\n### 基本用法\n\n默认情况下，`ScrollView` 滚动方向是垂直的。\n\n```swift\nimport SwiftUI\n\nstruct BasicScrollView: View {\n    var body: some View {\n        ScrollView {\n            VStack(spacing: 20) {\n                ForEach(0..<50) { index in\n                    Text(\"Row \\(index)\")\n                }\n            }\n        }\n    }\n}\n\nstruct BasicScrollView_Previews: PreviewProvider {\n    static var previews: some View {\n        BasicScrollView()\n    }\n}\n```\n\n### 水平滚动\n\n要创建一个水平滚动视图，需要设置 `ScrollView` 的 `axis` 参数。\n\n```swift\nimport SwiftUI\n\nstruct HorizontalScrollView: View {\n    var body: some View {\n        ScrollView(.horizontal, showsIndicators: false) {\n            HStack(spacing: 20) {\n                ForEach(0..<50) { index in\n                    Text(\"Column \\(index)\")\n                        .frame(width: 200, height: 200)\n                        .background(Color.blue)\n                        .foregroundColor(.white)\n                        .cornerRadius(10)\n                }\n            }\n        }\n    }\n}\n\nstruct HorizontalScrollView_Previews: PreviewProvider {\n    static var previews: some View {\n        HorizontalScrollView()\n    }\n}\n```\n\n### 同时水平和垂直滚动\n\n可以通过在 `ScrollView` 中嵌套另一个 `ScrollView` 来创建同时支持水平和垂直滚动的视图。\n\n```swift\nimport SwiftUI\n\nstruct BothDirectionsScrollView: View {\n    var body: some View {\n        ScrollView {\n            VStack(spacing: 20) {\n                ForEach(0..<10) { index in\n                    ScrollView(.horizontal, showsIndicators: true) {\n                        HStack(spacing: 20) {\n                            ForEach(0..<10) { index in\n                                Text(\"Item \\(index)\")\n                                    .frame(width: 100, height: 100)\n                                    .background(Color.green)\n                                    .cornerRadius(10)\n                            }\n                        }\n                    }\n                    .frame(height: 100)\n                }\n            }\n        }\n    }\n}\n\nstruct BothDirectionsScrollView_Previews: PreviewProvider {\n    static var previews: some View {\n        BothDirectionsScrollView()\n    }\n}\n```\n\n### 添加滚动条指示器\n\n`ScrollView` 的 `showsIndicators` 参数可以控制是否显示滚动条指示器。\n\n### 响应滚动事件\n\nSwiftUI `ScrollView` 没有像 UIKit 的 `UIScrollView` 那样直接提供滚动事件的回调。但是，你可以通过在 `ScrollView` 内部放置一个 `GeometryReader` 来读取滚动偏移量。\n\n### 使用 `ScrollViewReader`\n\n`ScrollViewReader` 可以用来在 `ScrollView` 内部进行编程式导航（比如滚动到特定的子视图）。\n\n```swift\nimport SwiftUI\n\nstruct ScrollViewReaderExample: View {\n    var body: some View {\n        ScrollViewReader { proxy in\n            ScrollView {\n                VStack(spacing: 10) {\n                    ForEach(0..<100) { index in\n                        Text(\"Item \\(index)\")\n                            .id(index)\n                    }\n                }\n                \n                Button(\"Jump to Item 50\") {\n                    withAnimation {\n                        proxy.scrollTo(50, anchor: .top)\n                    }\n                }\n            }\n        }\n    }\n}\n\nstruct ScrollViewReaderExample_Previews: PreviewProvider {\n    static var previews: some View {\n        ScrollViewReaderExample()\n    }\n}\n```\n\n在这个例子中，点击按钮会自动滚动到第 50 个元素。`ScrollViewReader` 提供了一个 `proxy` 对象，它有一个 `scrollTo(_:anchor:)` 方法可以使用，其中 `id` 参数对应子视图的 `id`。","slug":"SwiftUI中ScrollView的用法","published":1,"updated":"2024-03-17T06:13:07.568Z","comments":1,"layout":"post","photos":[],"_id":"clu6up53d000qz674ay95cu9h","content":"<p>在 SwiftUI 中，<code>ScrollView</code> 是一个可以滚动显示其子视图的容器。使用 <code>ScrollView</code>，你可以创建一个可以纵向或横向滚动的区域，这对于构建超出屏幕限制的内容是非常有用的。</p>\n<h3 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><p>默认情况下，<code>ScrollView</code> 滚动方向是垂直的。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">import</span> SwiftUI<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">BasicScrollView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">ScrollView</span> &#123;<br>            <span class=\"hljs-type\">VStack</span>(spacing: <span class=\"hljs-number\">20</span>) &#123;<br>                <span class=\"hljs-type\">ForEach</span>(<span class=\"hljs-number\">0</span><span class=\"hljs-operator\">..&lt;</span><span class=\"hljs-number\">50</span>) &#123; index <span class=\"hljs-keyword\">in</span><br>                    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Row <span class=\"hljs-subst\">\\(index)</span>&quot;</span>)<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">BasicScrollView_Previews</span>: <span class=\"hljs-title class_\">PreviewProvider</span> &#123;<br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">var</span> previews: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">BasicScrollView</span>()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"水平滚动\"><a href=\"#水平滚动\" class=\"headerlink\" title=\"水平滚动\"></a>水平滚动</h3><p>要创建一个水平滚动视图，需要设置 <code>ScrollView</code> 的 <code>axis</code> 参数。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">import</span> SwiftUI<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">HorizontalScrollView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">ScrollView</span>(.horizontal, showsIndicators: <span class=\"hljs-literal\">false</span>) &#123;<br>            <span class=\"hljs-type\">HStack</span>(spacing: <span class=\"hljs-number\">20</span>) &#123;<br>                <span class=\"hljs-type\">ForEach</span>(<span class=\"hljs-number\">0</span><span class=\"hljs-operator\">..&lt;</span><span class=\"hljs-number\">50</span>) &#123; index <span class=\"hljs-keyword\">in</span><br>                    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Column <span class=\"hljs-subst\">\\(index)</span>&quot;</span>)<br>                        .frame(width: <span class=\"hljs-number\">200</span>, height: <span class=\"hljs-number\">200</span>)<br>                        .background(<span class=\"hljs-type\">Color</span>.blue)<br>                        .foregroundColor(.white)<br>                        .cornerRadius(<span class=\"hljs-number\">10</span>)<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">HorizontalScrollView_Previews</span>: <span class=\"hljs-title class_\">PreviewProvider</span> &#123;<br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">var</span> previews: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">HorizontalScrollView</span>()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"同时水平和垂直滚动\"><a href=\"#同时水平和垂直滚动\" class=\"headerlink\" title=\"同时水平和垂直滚动\"></a>同时水平和垂直滚动</h3><p>可以通过在 <code>ScrollView</code> 中嵌套另一个 <code>ScrollView</code> 来创建同时支持水平和垂直滚动的视图。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">import</span> SwiftUI<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">BothDirectionsScrollView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">ScrollView</span> &#123;<br>            <span class=\"hljs-type\">VStack</span>(spacing: <span class=\"hljs-number\">20</span>) &#123;<br>                <span class=\"hljs-type\">ForEach</span>(<span class=\"hljs-number\">0</span><span class=\"hljs-operator\">..&lt;</span><span class=\"hljs-number\">10</span>) &#123; index <span class=\"hljs-keyword\">in</span><br>                    <span class=\"hljs-type\">ScrollView</span>(.horizontal, showsIndicators: <span class=\"hljs-literal\">true</span>) &#123;<br>                        <span class=\"hljs-type\">HStack</span>(spacing: <span class=\"hljs-number\">20</span>) &#123;<br>                            <span class=\"hljs-type\">ForEach</span>(<span class=\"hljs-number\">0</span><span class=\"hljs-operator\">..&lt;</span><span class=\"hljs-number\">10</span>) &#123; index <span class=\"hljs-keyword\">in</span><br>                                <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Item <span class=\"hljs-subst\">\\(index)</span>&quot;</span>)<br>                                    .frame(width: <span class=\"hljs-number\">100</span>, height: <span class=\"hljs-number\">100</span>)<br>                                    .background(<span class=\"hljs-type\">Color</span>.green)<br>                                    .cornerRadius(<span class=\"hljs-number\">10</span>)<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                    .frame(height: <span class=\"hljs-number\">100</span>)<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">BothDirectionsScrollView_Previews</span>: <span class=\"hljs-title class_\">PreviewProvider</span> &#123;<br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">var</span> previews: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">BothDirectionsScrollView</span>()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"添加滚动条指示器\"><a href=\"#添加滚动条指示器\" class=\"headerlink\" title=\"添加滚动条指示器\"></a>添加滚动条指示器</h3><p><code>ScrollView</code> 的 <code>showsIndicators</code> 参数可以控制是否显示滚动条指示器。</p>\n<h3 id=\"响应滚动事件\"><a href=\"#响应滚动事件\" class=\"headerlink\" title=\"响应滚动事件\"></a>响应滚动事件</h3><p>SwiftUI <code>ScrollView</code> 没有像 UIKit 的 <code>UIScrollView</code> 那样直接提供滚动事件的回调。但是，你可以通过在 <code>ScrollView</code> 内部放置一个 <code>GeometryReader</code> 来读取滚动偏移量。</p>\n<h3 id=\"使用-ScrollViewReader\"><a href=\"#使用-ScrollViewReader\" class=\"headerlink\" title=\"使用 ScrollViewReader\"></a>使用 <code>ScrollViewReader</code></h3><p><code>ScrollViewReader</code> 可以用来在 <code>ScrollView</code> 内部进行编程式导航（比如滚动到特定的子视图）。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">import</span> SwiftUI<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ScrollViewReaderExample</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">ScrollViewReader</span> &#123; proxy <span class=\"hljs-keyword\">in</span><br>            <span class=\"hljs-type\">ScrollView</span> &#123;<br>                <span class=\"hljs-type\">VStack</span>(spacing: <span class=\"hljs-number\">10</span>) &#123;<br>                    <span class=\"hljs-type\">ForEach</span>(<span class=\"hljs-number\">0</span><span class=\"hljs-operator\">..&lt;</span><span class=\"hljs-number\">100</span>) &#123; index <span class=\"hljs-keyword\">in</span><br>                        <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Item <span class=\"hljs-subst\">\\(index)</span>&quot;</span>)<br>                            .id(index)<br>                    &#125;<br>                &#125;<br>                <br>                <span class=\"hljs-type\">Button</span>(<span class=\"hljs-string\">&quot;Jump to Item 50&quot;</span>) &#123;<br>                    withAnimation &#123;<br>                        proxy.scrollTo(<span class=\"hljs-number\">50</span>, anchor: .top)<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ScrollViewReaderExample_Previews</span>: <span class=\"hljs-title class_\">PreviewProvider</span> &#123;<br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">var</span> previews: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">ScrollViewReaderExample</span>()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在这个例子中，点击按钮会自动滚动到第 50 个元素。<code>ScrollViewReader</code> 提供了一个 <code>proxy</code> 对象，它有一个 <code>scrollTo(_:anchor:)</code> 方法可以使用，其中 <code>id</code> 参数对应子视图的 <code>id</code>。</p>\n","excerpt":"","more":"<p>在 SwiftUI 中，<code>ScrollView</code> 是一个可以滚动显示其子视图的容器。使用 <code>ScrollView</code>，你可以创建一个可以纵向或横向滚动的区域，这对于构建超出屏幕限制的内容是非常有用的。</p>\n<h3 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><p>默认情况下，<code>ScrollView</code> 滚动方向是垂直的。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">import</span> SwiftUI<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">BasicScrollView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">ScrollView</span> &#123;<br>            <span class=\"hljs-type\">VStack</span>(spacing: <span class=\"hljs-number\">20</span>) &#123;<br>                <span class=\"hljs-type\">ForEach</span>(<span class=\"hljs-number\">0</span><span class=\"hljs-operator\">..&lt;</span><span class=\"hljs-number\">50</span>) &#123; index <span class=\"hljs-keyword\">in</span><br>                    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Row <span class=\"hljs-subst\">\\(index)</span>&quot;</span>)<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">BasicScrollView_Previews</span>: <span class=\"hljs-title class_\">PreviewProvider</span> &#123;<br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">var</span> previews: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">BasicScrollView</span>()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"水平滚动\"><a href=\"#水平滚动\" class=\"headerlink\" title=\"水平滚动\"></a>水平滚动</h3><p>要创建一个水平滚动视图，需要设置 <code>ScrollView</code> 的 <code>axis</code> 参数。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">import</span> SwiftUI<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">HorizontalScrollView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">ScrollView</span>(.horizontal, showsIndicators: <span class=\"hljs-literal\">false</span>) &#123;<br>            <span class=\"hljs-type\">HStack</span>(spacing: <span class=\"hljs-number\">20</span>) &#123;<br>                <span class=\"hljs-type\">ForEach</span>(<span class=\"hljs-number\">0</span><span class=\"hljs-operator\">..&lt;</span><span class=\"hljs-number\">50</span>) &#123; index <span class=\"hljs-keyword\">in</span><br>                    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Column <span class=\"hljs-subst\">\\(index)</span>&quot;</span>)<br>                        .frame(width: <span class=\"hljs-number\">200</span>, height: <span class=\"hljs-number\">200</span>)<br>                        .background(<span class=\"hljs-type\">Color</span>.blue)<br>                        .foregroundColor(.white)<br>                        .cornerRadius(<span class=\"hljs-number\">10</span>)<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">HorizontalScrollView_Previews</span>: <span class=\"hljs-title class_\">PreviewProvider</span> &#123;<br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">var</span> previews: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">HorizontalScrollView</span>()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"同时水平和垂直滚动\"><a href=\"#同时水平和垂直滚动\" class=\"headerlink\" title=\"同时水平和垂直滚动\"></a>同时水平和垂直滚动</h3><p>可以通过在 <code>ScrollView</code> 中嵌套另一个 <code>ScrollView</code> 来创建同时支持水平和垂直滚动的视图。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">import</span> SwiftUI<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">BothDirectionsScrollView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">ScrollView</span> &#123;<br>            <span class=\"hljs-type\">VStack</span>(spacing: <span class=\"hljs-number\">20</span>) &#123;<br>                <span class=\"hljs-type\">ForEach</span>(<span class=\"hljs-number\">0</span><span class=\"hljs-operator\">..&lt;</span><span class=\"hljs-number\">10</span>) &#123; index <span class=\"hljs-keyword\">in</span><br>                    <span class=\"hljs-type\">ScrollView</span>(.horizontal, showsIndicators: <span class=\"hljs-literal\">true</span>) &#123;<br>                        <span class=\"hljs-type\">HStack</span>(spacing: <span class=\"hljs-number\">20</span>) &#123;<br>                            <span class=\"hljs-type\">ForEach</span>(<span class=\"hljs-number\">0</span><span class=\"hljs-operator\">..&lt;</span><span class=\"hljs-number\">10</span>) &#123; index <span class=\"hljs-keyword\">in</span><br>                                <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Item <span class=\"hljs-subst\">\\(index)</span>&quot;</span>)<br>                                    .frame(width: <span class=\"hljs-number\">100</span>, height: <span class=\"hljs-number\">100</span>)<br>                                    .background(<span class=\"hljs-type\">Color</span>.green)<br>                                    .cornerRadius(<span class=\"hljs-number\">10</span>)<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                    .frame(height: <span class=\"hljs-number\">100</span>)<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">BothDirectionsScrollView_Previews</span>: <span class=\"hljs-title class_\">PreviewProvider</span> &#123;<br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">var</span> previews: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">BothDirectionsScrollView</span>()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"添加滚动条指示器\"><a href=\"#添加滚动条指示器\" class=\"headerlink\" title=\"添加滚动条指示器\"></a>添加滚动条指示器</h3><p><code>ScrollView</code> 的 <code>showsIndicators</code> 参数可以控制是否显示滚动条指示器。</p>\n<h3 id=\"响应滚动事件\"><a href=\"#响应滚动事件\" class=\"headerlink\" title=\"响应滚动事件\"></a>响应滚动事件</h3><p>SwiftUI <code>ScrollView</code> 没有像 UIKit 的 <code>UIScrollView</code> 那样直接提供滚动事件的回调。但是，你可以通过在 <code>ScrollView</code> 内部放置一个 <code>GeometryReader</code> 来读取滚动偏移量。</p>\n<h3 id=\"使用-ScrollViewReader\"><a href=\"#使用-ScrollViewReader\" class=\"headerlink\" title=\"使用 ScrollViewReader\"></a>使用 <code>ScrollViewReader</code></h3><p><code>ScrollViewReader</code> 可以用来在 <code>ScrollView</code> 内部进行编程式导航（比如滚动到特定的子视图）。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">import</span> SwiftUI<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ScrollViewReaderExample</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">ScrollViewReader</span> &#123; proxy <span class=\"hljs-keyword\">in</span><br>            <span class=\"hljs-type\">ScrollView</span> &#123;<br>                <span class=\"hljs-type\">VStack</span>(spacing: <span class=\"hljs-number\">10</span>) &#123;<br>                    <span class=\"hljs-type\">ForEach</span>(<span class=\"hljs-number\">0</span><span class=\"hljs-operator\">..&lt;</span><span class=\"hljs-number\">100</span>) &#123; index <span class=\"hljs-keyword\">in</span><br>                        <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Item <span class=\"hljs-subst\">\\(index)</span>&quot;</span>)<br>                            .id(index)<br>                    &#125;<br>                &#125;<br>                <br>                <span class=\"hljs-type\">Button</span>(<span class=\"hljs-string\">&quot;Jump to Item 50&quot;</span>) &#123;<br>                    withAnimation &#123;<br>                        proxy.scrollTo(<span class=\"hljs-number\">50</span>, anchor: .top)<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ScrollViewReaderExample_Previews</span>: <span class=\"hljs-title class_\">PreviewProvider</span> &#123;<br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">var</span> previews: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">ScrollViewReaderExample</span>()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在这个例子中，点击按钮会自动滚动到第 50 个元素。<code>ScrollViewReader</code> 提供了一个 <code>proxy</code> 对象，它有一个 <code>scrollTo(_:anchor:)</code> 方法可以使用，其中 <code>id</code> 参数对应子视图的 <code>id</code>。</p>\n"},{"title":"SwiftUI中SecureField的用法","date":"2023-11-07T12:40:52.000Z","_content":"在 SwiftUI 中，`SecureField` 用于输入敏感信息，如密码，它会自动遮蔽输入的文字。`SecureField` 的 API 使用起来和 `TextField` 非常相似。\n\n### 基础用法\n\n下面是一个简单的 `SecureField` 示例：\n\n```swift\nstruct ContentView: View {\n    @State private var password: String = \"\"\n\n    var body: some View {\n        SecureField(\"Enter your password\", text: $password)\n            .textFieldStyle(RoundedBorderTextFieldStyle())\n            .padding()\n    }\n}\n```\n\n在这个例子中，用户输入的文本会被遮蔽，不会直接显示在屏幕上。\n\n### 与 `TextField` 结合\n\n通常，在一个表单中，你可能会将 `TextField` 用于用户名输入，而将 `SecureField` 用于密码输入：\n\n```swift\nstruct ContentView: View {\n    @State private var username: String = \"\"\n    @State private var password: String = \"\"\n\n    var body: some View {\n        VStack {\n            TextField(\"Username\", text: $username)\n                .textFieldStyle(RoundedBorderTextFieldStyle())\n                .autocapitalization(.none)\n                .disableAutocorrection(true)\n                .padding()\n\n            SecureField(\"Password\", text: $password)\n                .textFieldStyle(RoundedBorderTextFieldStyle())\n                .padding()\n\n            Button(\"Login\") {\n                // Perform login action\n            }\n            .disabled(username.isEmpty || password.isEmpty)\n        }\n        .padding()\n    }\n}\n```\n\n在上面的代码中，登录按钮会在用户名或密码字段为空时被禁用。\n\n### 自定义外观\n\n和 `TextField` 一样，你可以使用修饰符来自定义 `SecureField` 的外观：\n\n```swift\nSecureField(\"Password\", text: $password)\n    .padding()\n    .background(Color.gray.opacity(0.2))\n    .cornerRadius(5)\n    .padding(.horizontal)\n```\n\n### 响应提交事件\n\n如果你想要在用户提交密码时做出响应（例如，按下键盘的 return 键），你可以使用 `onCommit` 闭包：\n\n```swift\nSecureField(\"Password\", text: $password, onCommit: {\n    // Perform an action when the user submits the password\n    loginUser()\n})\n.textFieldStyle(RoundedBorderTextFieldStyle())\n.padding()\n```\n\n在这个示例中，`loginUser()` 函数会在用户按下 return 键后被调用。\n\n`SecureField` 是构建安全文本输入场景的基础组件，它可以与你的验证逻辑、用户认证服务以及其他 UI 组件结合使用，以创建安全的用户体验。","source":"_posts/SwiftUI中SecureField的用法.md","raw":"---\ntitle: SwiftUI中SecureField的用法\ndate: 2023-11-07 20:40:52\ncategories:\n- SwiftUI\ntags:\n---\n在 SwiftUI 中，`SecureField` 用于输入敏感信息，如密码，它会自动遮蔽输入的文字。`SecureField` 的 API 使用起来和 `TextField` 非常相似。\n\n### 基础用法\n\n下面是一个简单的 `SecureField` 示例：\n\n```swift\nstruct ContentView: View {\n    @State private var password: String = \"\"\n\n    var body: some View {\n        SecureField(\"Enter your password\", text: $password)\n            .textFieldStyle(RoundedBorderTextFieldStyle())\n            .padding()\n    }\n}\n```\n\n在这个例子中，用户输入的文本会被遮蔽，不会直接显示在屏幕上。\n\n### 与 `TextField` 结合\n\n通常，在一个表单中，你可能会将 `TextField` 用于用户名输入，而将 `SecureField` 用于密码输入：\n\n```swift\nstruct ContentView: View {\n    @State private var username: String = \"\"\n    @State private var password: String = \"\"\n\n    var body: some View {\n        VStack {\n            TextField(\"Username\", text: $username)\n                .textFieldStyle(RoundedBorderTextFieldStyle())\n                .autocapitalization(.none)\n                .disableAutocorrection(true)\n                .padding()\n\n            SecureField(\"Password\", text: $password)\n                .textFieldStyle(RoundedBorderTextFieldStyle())\n                .padding()\n\n            Button(\"Login\") {\n                // Perform login action\n            }\n            .disabled(username.isEmpty || password.isEmpty)\n        }\n        .padding()\n    }\n}\n```\n\n在上面的代码中，登录按钮会在用户名或密码字段为空时被禁用。\n\n### 自定义外观\n\n和 `TextField` 一样，你可以使用修饰符来自定义 `SecureField` 的外观：\n\n```swift\nSecureField(\"Password\", text: $password)\n    .padding()\n    .background(Color.gray.opacity(0.2))\n    .cornerRadius(5)\n    .padding(.horizontal)\n```\n\n### 响应提交事件\n\n如果你想要在用户提交密码时做出响应（例如，按下键盘的 return 键），你可以使用 `onCommit` 闭包：\n\n```swift\nSecureField(\"Password\", text: $password, onCommit: {\n    // Perform an action when the user submits the password\n    loginUser()\n})\n.textFieldStyle(RoundedBorderTextFieldStyle())\n.padding()\n```\n\n在这个示例中，`loginUser()` 函数会在用户按下 return 键后被调用。\n\n`SecureField` 是构建安全文本输入场景的基础组件，它可以与你的验证逻辑、用户认证服务以及其他 UI 组件结合使用，以创建安全的用户体验。","slug":"SwiftUI中SecureField的用法","published":1,"updated":"2024-03-17T06:13:11.125Z","comments":1,"layout":"post","photos":[],"_id":"clu6up53d000rz67478ek61nv","content":"<p>在 SwiftUI 中，<code>SecureField</code> 用于输入敏感信息，如密码，它会自动遮蔽输入的文字。<code>SecureField</code> 的 API 使用起来和 <code>TextField</code> 非常相似。</p>\n<h3 id=\"基础用法\"><a href=\"#基础用法\" class=\"headerlink\" title=\"基础用法\"></a>基础用法</h3><p>下面是一个简单的 <code>SecureField</code> 示例：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ContentView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> password: <span class=\"hljs-type\">String</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;&quot;</span><br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">SecureField</span>(<span class=\"hljs-string\">&quot;Enter your password&quot;</span>, text: <span class=\"hljs-variable\">$password</span>)<br>            .textFieldStyle(<span class=\"hljs-type\">RoundedBorderTextFieldStyle</span>())<br>            .padding()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在这个例子中，用户输入的文本会被遮蔽，不会直接显示在屏幕上。</p>\n<h3 id=\"与-TextField-结合\"><a href=\"#与-TextField-结合\" class=\"headerlink\" title=\"与 TextField 结合\"></a>与 <code>TextField</code> 结合</h3><p>通常，在一个表单中，你可能会将 <code>TextField</code> 用于用户名输入，而将 <code>SecureField</code> 用于密码输入：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ContentView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> username: <span class=\"hljs-type\">String</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;&quot;</span><br>    <span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> password: <span class=\"hljs-type\">String</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;&quot;</span><br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">VStack</span> &#123;<br>            <span class=\"hljs-type\">TextField</span>(<span class=\"hljs-string\">&quot;Username&quot;</span>, text: <span class=\"hljs-variable\">$username</span>)<br>                .textFieldStyle(<span class=\"hljs-type\">RoundedBorderTextFieldStyle</span>())<br>                .autocapitalization(.none)<br>                .disableAutocorrection(<span class=\"hljs-literal\">true</span>)<br>                .padding()<br><br>            <span class=\"hljs-type\">SecureField</span>(<span class=\"hljs-string\">&quot;Password&quot;</span>, text: <span class=\"hljs-variable\">$password</span>)<br>                .textFieldStyle(<span class=\"hljs-type\">RoundedBorderTextFieldStyle</span>())<br>                .padding()<br><br>            <span class=\"hljs-type\">Button</span>(<span class=\"hljs-string\">&quot;Login&quot;</span>) &#123;<br>                <span class=\"hljs-comment\">// Perform login action</span><br>            &#125;<br>            .disabled(username.isEmpty <span class=\"hljs-operator\">||</span> password.isEmpty)<br>        &#125;<br>        .padding()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在上面的代码中，登录按钮会在用户名或密码字段为空时被禁用。</p>\n<h3 id=\"自定义外观\"><a href=\"#自定义外观\" class=\"headerlink\" title=\"自定义外观\"></a>自定义外观</h3><p>和 <code>TextField</code> 一样，你可以使用修饰符来自定义 <code>SecureField</code> 的外观：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">SecureField</span>(<span class=\"hljs-string\">&quot;Password&quot;</span>, text: <span class=\"hljs-variable\">$password</span>)<br>    .padding()<br>    .background(<span class=\"hljs-type\">Color</span>.gray.opacity(<span class=\"hljs-number\">0.2</span>))<br>    .cornerRadius(<span class=\"hljs-number\">5</span>)<br>    .padding(.horizontal)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"响应提交事件\"><a href=\"#响应提交事件\" class=\"headerlink\" title=\"响应提交事件\"></a>响应提交事件</h3><p>如果你想要在用户提交密码时做出响应（例如，按下键盘的 return 键），你可以使用 <code>onCommit</code> 闭包：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">SecureField</span>(<span class=\"hljs-string\">&quot;Password&quot;</span>, text: <span class=\"hljs-variable\">$password</span>, onCommit: &#123;<br>    <span class=\"hljs-comment\">// Perform an action when the user submits the password</span><br>    loginUser()<br>&#125;)<br>.textFieldStyle(<span class=\"hljs-type\">RoundedBorderTextFieldStyle</span>())<br>.padding()<br></code></pre></td></tr></table></figure>\n\n<p>在这个示例中，<code>loginUser()</code> 函数会在用户按下 return 键后被调用。</p>\n<p><code>SecureField</code> 是构建安全文本输入场景的基础组件，它可以与你的验证逻辑、用户认证服务以及其他 UI 组件结合使用，以创建安全的用户体验。</p>\n","excerpt":"","more":"<p>在 SwiftUI 中，<code>SecureField</code> 用于输入敏感信息，如密码，它会自动遮蔽输入的文字。<code>SecureField</code> 的 API 使用起来和 <code>TextField</code> 非常相似。</p>\n<h3 id=\"基础用法\"><a href=\"#基础用法\" class=\"headerlink\" title=\"基础用法\"></a>基础用法</h3><p>下面是一个简单的 <code>SecureField</code> 示例：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ContentView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> password: <span class=\"hljs-type\">String</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;&quot;</span><br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">SecureField</span>(<span class=\"hljs-string\">&quot;Enter your password&quot;</span>, text: <span class=\"hljs-variable\">$password</span>)<br>            .textFieldStyle(<span class=\"hljs-type\">RoundedBorderTextFieldStyle</span>())<br>            .padding()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在这个例子中，用户输入的文本会被遮蔽，不会直接显示在屏幕上。</p>\n<h3 id=\"与-TextField-结合\"><a href=\"#与-TextField-结合\" class=\"headerlink\" title=\"与 TextField 结合\"></a>与 <code>TextField</code> 结合</h3><p>通常，在一个表单中，你可能会将 <code>TextField</code> 用于用户名输入，而将 <code>SecureField</code> 用于密码输入：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ContentView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> username: <span class=\"hljs-type\">String</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;&quot;</span><br>    <span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> password: <span class=\"hljs-type\">String</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;&quot;</span><br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">VStack</span> &#123;<br>            <span class=\"hljs-type\">TextField</span>(<span class=\"hljs-string\">&quot;Username&quot;</span>, text: <span class=\"hljs-variable\">$username</span>)<br>                .textFieldStyle(<span class=\"hljs-type\">RoundedBorderTextFieldStyle</span>())<br>                .autocapitalization(.none)<br>                .disableAutocorrection(<span class=\"hljs-literal\">true</span>)<br>                .padding()<br><br>            <span class=\"hljs-type\">SecureField</span>(<span class=\"hljs-string\">&quot;Password&quot;</span>, text: <span class=\"hljs-variable\">$password</span>)<br>                .textFieldStyle(<span class=\"hljs-type\">RoundedBorderTextFieldStyle</span>())<br>                .padding()<br><br>            <span class=\"hljs-type\">Button</span>(<span class=\"hljs-string\">&quot;Login&quot;</span>) &#123;<br>                <span class=\"hljs-comment\">// Perform login action</span><br>            &#125;<br>            .disabled(username.isEmpty <span class=\"hljs-operator\">||</span> password.isEmpty)<br>        &#125;<br>        .padding()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在上面的代码中，登录按钮会在用户名或密码字段为空时被禁用。</p>\n<h3 id=\"自定义外观\"><a href=\"#自定义外观\" class=\"headerlink\" title=\"自定义外观\"></a>自定义外观</h3><p>和 <code>TextField</code> 一样，你可以使用修饰符来自定义 <code>SecureField</code> 的外观：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">SecureField</span>(<span class=\"hljs-string\">&quot;Password&quot;</span>, text: <span class=\"hljs-variable\">$password</span>)<br>    .padding()<br>    .background(<span class=\"hljs-type\">Color</span>.gray.opacity(<span class=\"hljs-number\">0.2</span>))<br>    .cornerRadius(<span class=\"hljs-number\">5</span>)<br>    .padding(.horizontal)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"响应提交事件\"><a href=\"#响应提交事件\" class=\"headerlink\" title=\"响应提交事件\"></a>响应提交事件</h3><p>如果你想要在用户提交密码时做出响应（例如，按下键盘的 return 键），你可以使用 <code>onCommit</code> 闭包：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">SecureField</span>(<span class=\"hljs-string\">&quot;Password&quot;</span>, text: <span class=\"hljs-variable\">$password</span>, onCommit: &#123;<br>    <span class=\"hljs-comment\">// Perform an action when the user submits the password</span><br>    loginUser()<br>&#125;)<br>.textFieldStyle(<span class=\"hljs-type\">RoundedBorderTextFieldStyle</span>())<br>.padding()<br></code></pre></td></tr></table></figure>\n\n<p>在这个示例中，<code>loginUser()</code> 函数会在用户按下 return 键后被调用。</p>\n<p><code>SecureField</code> 是构建安全文本输入场景的基础组件，它可以与你的验证逻辑、用户认证服务以及其他 UI 组件结合使用，以创建安全的用户体验。</p>\n"},{"title":"SwiftUI中Sheet控件的用法","date":"2023-11-07T13:02:27.000Z","_content":"在 SwiftUI 中，sheet 是一种展示模态视图的方式。它通常用于显示一个临时的内容屏幕，例如表单、详情页或者是一个步骤的一部分。`sheet` 修饰符可以让你在当前视图上方展示一个新的视图，并提供内容和行为的自定义。\n\n### 使用 `sheet` 修饰符展示模态视图\n\n基本的 `sheet` 用法涉及一个绑定的布尔值，当这个布尔值为真时，sheet 会显示出来。这个布尔值通常用 `@State` 属性来管理。\n\n```swift\nstruct ContentView: View {\n    @State private var showingSheet = false\n\n    var body: some View {\n        Button(\"Show Sheet\") {\n            showingSheet = true\n        }\n        .sheet(isPresented: $showingSheet) {\n            // Sheet 的内容\n            DetailView()\n        }\n    }\n}\n```\n\n在这个例子中，点击按钮会设置 `showingSheet` 为 true，从而触发 sheet 的显示。`DetailView()` 就是你想要作为 sheet 显示的视图。\n\n### 使用 `sheet` 与 `item` 参数\n\n当你要为每个不同的数据对象显示一个 sheet 时，你可以使用 `sheet(item:onDismiss:content:)` 修饰符。这个修饰符需要一个绑定到可选项的 `@State` 属性。当这个属性不是 `nil` 时，将会显示一个 sheet。\n\n```swift\nstruct ContentView: View {\n    @State private var selectedUser: User?\n\n    var body: some View {\n        // 假设你有一个用户列表\n        ForEach(users) { user in\n            Button(user.name) {\n                selectedUser = user\n            }\n        }\n        .sheet(item: $selectedUser) { user in\n            // 当 selectedUser 不是 nil 时，显示的视图\n            UserDetailView(user: user)\n        }\n    }\n}\n\nstruct User: Identifiable {\n    let id = UUID()\n    let name: String\n}\n```\n\n在这个例子中，当你点击一个用户的按钮时，`selectedUser` 被设置为那个用户的实例，触发对应用户详情的 sheet。\n\n### 使用 `sheet` 的 `onDismiss` 参数\n\n当你的 sheet 被关闭时，你可能想要执行一些代码。`onDismiss` 参数允许你添加一个闭包，当 sheet 消失时会被调用。\n\n```swift\n.sheet(isPresented: $showingSheet, onDismiss: {\n    print(\"Sheet was dismissed.\")\n}) {\n    DetailView()\n}\n```\n\n### 动态内容的 sheet\n\n你还可以在 sheet 的闭包中直接构造视图，而不是传递一个预先定义的视图。这样，你可以基于当前状态动态地改变 sheet 的内容。\n\n```swift\n.sheet(isPresented: $showingSheet) {\n    if someCondition {\n        SomeView()\n    } else {\n        AnotherView()\n    }\n}\n```\n\n### FullScreenCover\n\n除了标准的 `sheet`，SwiftUI 还提供了 `fullScreenCover`，它以全屏模式显示内容，对于那些需要更多空间或需要从视觉上区分出来的情况非常有用。\n\n```swift\n.fullScreenCover(isPresented: $showingCover) {\n    FullScreenModalView()\n}\n```\n\n### 结论\n\nSheet 控件在 SwiftUI 中为模态内容的展示提供了一种简洁而强大的方式。通过简单的状态绑定和自定义视图传递，你可以创建丰富的用户体验，并管理视图的呈现和隐藏。记得，模态视图是一个打断用户当前流程的操作，所以应该在需要的时候谨慎使用。","source":"_posts/SwiftUI中Sheet控件的用法.md","raw":"---\ntitle: SwiftUI中Sheet控件的用法\ndate: 2023-11-07 21:02:27\ncategories:\n- SwiftUI\ntags:\n---\n在 SwiftUI 中，sheet 是一种展示模态视图的方式。它通常用于显示一个临时的内容屏幕，例如表单、详情页或者是一个步骤的一部分。`sheet` 修饰符可以让你在当前视图上方展示一个新的视图，并提供内容和行为的自定义。\n\n### 使用 `sheet` 修饰符展示模态视图\n\n基本的 `sheet` 用法涉及一个绑定的布尔值，当这个布尔值为真时，sheet 会显示出来。这个布尔值通常用 `@State` 属性来管理。\n\n```swift\nstruct ContentView: View {\n    @State private var showingSheet = false\n\n    var body: some View {\n        Button(\"Show Sheet\") {\n            showingSheet = true\n        }\n        .sheet(isPresented: $showingSheet) {\n            // Sheet 的内容\n            DetailView()\n        }\n    }\n}\n```\n\n在这个例子中，点击按钮会设置 `showingSheet` 为 true，从而触发 sheet 的显示。`DetailView()` 就是你想要作为 sheet 显示的视图。\n\n### 使用 `sheet` 与 `item` 参数\n\n当你要为每个不同的数据对象显示一个 sheet 时，你可以使用 `sheet(item:onDismiss:content:)` 修饰符。这个修饰符需要一个绑定到可选项的 `@State` 属性。当这个属性不是 `nil` 时，将会显示一个 sheet。\n\n```swift\nstruct ContentView: View {\n    @State private var selectedUser: User?\n\n    var body: some View {\n        // 假设你有一个用户列表\n        ForEach(users) { user in\n            Button(user.name) {\n                selectedUser = user\n            }\n        }\n        .sheet(item: $selectedUser) { user in\n            // 当 selectedUser 不是 nil 时，显示的视图\n            UserDetailView(user: user)\n        }\n    }\n}\n\nstruct User: Identifiable {\n    let id = UUID()\n    let name: String\n}\n```\n\n在这个例子中，当你点击一个用户的按钮时，`selectedUser` 被设置为那个用户的实例，触发对应用户详情的 sheet。\n\n### 使用 `sheet` 的 `onDismiss` 参数\n\n当你的 sheet 被关闭时，你可能想要执行一些代码。`onDismiss` 参数允许你添加一个闭包，当 sheet 消失时会被调用。\n\n```swift\n.sheet(isPresented: $showingSheet, onDismiss: {\n    print(\"Sheet was dismissed.\")\n}) {\n    DetailView()\n}\n```\n\n### 动态内容的 sheet\n\n你还可以在 sheet 的闭包中直接构造视图，而不是传递一个预先定义的视图。这样，你可以基于当前状态动态地改变 sheet 的内容。\n\n```swift\n.sheet(isPresented: $showingSheet) {\n    if someCondition {\n        SomeView()\n    } else {\n        AnotherView()\n    }\n}\n```\n\n### FullScreenCover\n\n除了标准的 `sheet`，SwiftUI 还提供了 `fullScreenCover`，它以全屏模式显示内容，对于那些需要更多空间或需要从视觉上区分出来的情况非常有用。\n\n```swift\n.fullScreenCover(isPresented: $showingCover) {\n    FullScreenModalView()\n}\n```\n\n### 结论\n\nSheet 控件在 SwiftUI 中为模态内容的展示提供了一种简洁而强大的方式。通过简单的状态绑定和自定义视图传递，你可以创建丰富的用户体验，并管理视图的呈现和隐藏。记得，模态视图是一个打断用户当前流程的操作，所以应该在需要的时候谨慎使用。","slug":"SwiftUI中Sheet控件的用法","published":1,"updated":"2024-03-17T06:13:14.464Z","comments":1,"layout":"post","photos":[],"_id":"clu6up53d000vz674e6wmag81","content":"<p>在 SwiftUI 中，sheet 是一种展示模态视图的方式。它通常用于显示一个临时的内容屏幕，例如表单、详情页或者是一个步骤的一部分。<code>sheet</code> 修饰符可以让你在当前视图上方展示一个新的视图，并提供内容和行为的自定义。</p>\n<h3 id=\"使用-sheet-修饰符展示模态视图\"><a href=\"#使用-sheet-修饰符展示模态视图\" class=\"headerlink\" title=\"使用 sheet 修饰符展示模态视图\"></a>使用 <code>sheet</code> 修饰符展示模态视图</h3><p>基本的 <code>sheet</code> 用法涉及一个绑定的布尔值，当这个布尔值为真时，sheet 会显示出来。这个布尔值通常用 <code>@State</code> 属性来管理。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ContentView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> showingSheet <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">false</span><br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">Button</span>(<span class=\"hljs-string\">&quot;Show Sheet&quot;</span>) &#123;<br>            showingSheet <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">true</span><br>        &#125;<br>        .sheet(isPresented: <span class=\"hljs-variable\">$showingSheet</span>) &#123;<br>            <span class=\"hljs-comment\">// Sheet 的内容</span><br>            <span class=\"hljs-type\">DetailView</span>()<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在这个例子中，点击按钮会设置 <code>showingSheet</code> 为 true，从而触发 sheet 的显示。<code>DetailView()</code> 就是你想要作为 sheet 显示的视图。</p>\n<h3 id=\"使用-sheet-与-item-参数\"><a href=\"#使用-sheet-与-item-参数\" class=\"headerlink\" title=\"使用 sheet 与 item 参数\"></a>使用 <code>sheet</code> 与 <code>item</code> 参数</h3><p>当你要为每个不同的数据对象显示一个 sheet 时，你可以使用 <code>sheet(item:onDismiss:content:)</code> 修饰符。这个修饰符需要一个绑定到可选项的 <code>@State</code> 属性。当这个属性不是 <code>nil</code> 时，将会显示一个 sheet。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ContentView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> selectedUser: <span class=\"hljs-type\">User</span>?<br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-comment\">// 假设你有一个用户列表</span><br>        <span class=\"hljs-type\">ForEach</span>(users) &#123; user <span class=\"hljs-keyword\">in</span><br>            <span class=\"hljs-type\">Button</span>(user.name) &#123;<br>                selectedUser <span class=\"hljs-operator\">=</span> user<br>            &#125;<br>        &#125;<br>        .sheet(item: <span class=\"hljs-variable\">$selectedUser</span>) &#123; user <span class=\"hljs-keyword\">in</span><br>            <span class=\"hljs-comment\">// 当 selectedUser 不是 nil 时，显示的视图</span><br>            <span class=\"hljs-type\">UserDetailView</span>(user: user)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">User</span>: <span class=\"hljs-title class_\">Identifiable</span> &#123;<br>    <span class=\"hljs-keyword\">let</span> id <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">UUID</span>()<br>    <span class=\"hljs-keyword\">let</span> name: <span class=\"hljs-type\">String</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在这个例子中，当你点击一个用户的按钮时，<code>selectedUser</code> 被设置为那个用户的实例，触发对应用户详情的 sheet。</p>\n<h3 id=\"使用-sheet-的-onDismiss-参数\"><a href=\"#使用-sheet-的-onDismiss-参数\" class=\"headerlink\" title=\"使用 sheet 的 onDismiss 参数\"></a>使用 <code>sheet</code> 的 <code>onDismiss</code> 参数</h3><p>当你的 sheet 被关闭时，你可能想要执行一些代码。<code>onDismiss</code> 参数允许你添加一个闭包，当 sheet 消失时会被调用。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\">.sheet(isPresented: <span class=\"hljs-variable\">$showingSheet</span>, onDismiss: &#123;<br>    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;Sheet was dismissed.&quot;</span>)<br>&#125;) &#123;<br>    <span class=\"hljs-type\">DetailView</span>()<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"动态内容的-sheet\"><a href=\"#动态内容的-sheet\" class=\"headerlink\" title=\"动态内容的 sheet\"></a>动态内容的 sheet</h3><p>你还可以在 sheet 的闭包中直接构造视图，而不是传递一个预先定义的视图。这样，你可以基于当前状态动态地改变 sheet 的内容。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\">.sheet(isPresented: <span class=\"hljs-variable\">$showingSheet</span>) &#123;<br>    <span class=\"hljs-keyword\">if</span> someCondition &#123;<br>        <span class=\"hljs-type\">SomeView</span>()<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>        <span class=\"hljs-type\">AnotherView</span>()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"FullScreenCover\"><a href=\"#FullScreenCover\" class=\"headerlink\" title=\"FullScreenCover\"></a>FullScreenCover</h3><p>除了标准的 <code>sheet</code>，SwiftUI 还提供了 <code>fullScreenCover</code>，它以全屏模式显示内容，对于那些需要更多空间或需要从视觉上区分出来的情况非常有用。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\">.fullScreenCover(isPresented: <span class=\"hljs-variable\">$showingCover</span>) &#123;<br>    <span class=\"hljs-type\">FullScreenModalView</span>()<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h3><p>Sheet 控件在 SwiftUI 中为模态内容的展示提供了一种简洁而强大的方式。通过简单的状态绑定和自定义视图传递，你可以创建丰富的用户体验，并管理视图的呈现和隐藏。记得，模态视图是一个打断用户当前流程的操作，所以应该在需要的时候谨慎使用。</p>\n","excerpt":"","more":"<p>在 SwiftUI 中，sheet 是一种展示模态视图的方式。它通常用于显示一个临时的内容屏幕，例如表单、详情页或者是一个步骤的一部分。<code>sheet</code> 修饰符可以让你在当前视图上方展示一个新的视图，并提供内容和行为的自定义。</p>\n<h3 id=\"使用-sheet-修饰符展示模态视图\"><a href=\"#使用-sheet-修饰符展示模态视图\" class=\"headerlink\" title=\"使用 sheet 修饰符展示模态视图\"></a>使用 <code>sheet</code> 修饰符展示模态视图</h3><p>基本的 <code>sheet</code> 用法涉及一个绑定的布尔值，当这个布尔值为真时，sheet 会显示出来。这个布尔值通常用 <code>@State</code> 属性来管理。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ContentView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> showingSheet <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">false</span><br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">Button</span>(<span class=\"hljs-string\">&quot;Show Sheet&quot;</span>) &#123;<br>            showingSheet <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">true</span><br>        &#125;<br>        .sheet(isPresented: <span class=\"hljs-variable\">$showingSheet</span>) &#123;<br>            <span class=\"hljs-comment\">// Sheet 的内容</span><br>            <span class=\"hljs-type\">DetailView</span>()<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在这个例子中，点击按钮会设置 <code>showingSheet</code> 为 true，从而触发 sheet 的显示。<code>DetailView()</code> 就是你想要作为 sheet 显示的视图。</p>\n<h3 id=\"使用-sheet-与-item-参数\"><a href=\"#使用-sheet-与-item-参数\" class=\"headerlink\" title=\"使用 sheet 与 item 参数\"></a>使用 <code>sheet</code> 与 <code>item</code> 参数</h3><p>当你要为每个不同的数据对象显示一个 sheet 时，你可以使用 <code>sheet(item:onDismiss:content:)</code> 修饰符。这个修饰符需要一个绑定到可选项的 <code>@State</code> 属性。当这个属性不是 <code>nil</code> 时，将会显示一个 sheet。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ContentView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> selectedUser: <span class=\"hljs-type\">User</span>?<br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-comment\">// 假设你有一个用户列表</span><br>        <span class=\"hljs-type\">ForEach</span>(users) &#123; user <span class=\"hljs-keyword\">in</span><br>            <span class=\"hljs-type\">Button</span>(user.name) &#123;<br>                selectedUser <span class=\"hljs-operator\">=</span> user<br>            &#125;<br>        &#125;<br>        .sheet(item: <span class=\"hljs-variable\">$selectedUser</span>) &#123; user <span class=\"hljs-keyword\">in</span><br>            <span class=\"hljs-comment\">// 当 selectedUser 不是 nil 时，显示的视图</span><br>            <span class=\"hljs-type\">UserDetailView</span>(user: user)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">User</span>: <span class=\"hljs-title class_\">Identifiable</span> &#123;<br>    <span class=\"hljs-keyword\">let</span> id <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">UUID</span>()<br>    <span class=\"hljs-keyword\">let</span> name: <span class=\"hljs-type\">String</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在这个例子中，当你点击一个用户的按钮时，<code>selectedUser</code> 被设置为那个用户的实例，触发对应用户详情的 sheet。</p>\n<h3 id=\"使用-sheet-的-onDismiss-参数\"><a href=\"#使用-sheet-的-onDismiss-参数\" class=\"headerlink\" title=\"使用 sheet 的 onDismiss 参数\"></a>使用 <code>sheet</code> 的 <code>onDismiss</code> 参数</h3><p>当你的 sheet 被关闭时，你可能想要执行一些代码。<code>onDismiss</code> 参数允许你添加一个闭包，当 sheet 消失时会被调用。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\">.sheet(isPresented: <span class=\"hljs-variable\">$showingSheet</span>, onDismiss: &#123;<br>    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;Sheet was dismissed.&quot;</span>)<br>&#125;) &#123;<br>    <span class=\"hljs-type\">DetailView</span>()<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"动态内容的-sheet\"><a href=\"#动态内容的-sheet\" class=\"headerlink\" title=\"动态内容的 sheet\"></a>动态内容的 sheet</h3><p>你还可以在 sheet 的闭包中直接构造视图，而不是传递一个预先定义的视图。这样，你可以基于当前状态动态地改变 sheet 的内容。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\">.sheet(isPresented: <span class=\"hljs-variable\">$showingSheet</span>) &#123;<br>    <span class=\"hljs-keyword\">if</span> someCondition &#123;<br>        <span class=\"hljs-type\">SomeView</span>()<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>        <span class=\"hljs-type\">AnotherView</span>()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"FullScreenCover\"><a href=\"#FullScreenCover\" class=\"headerlink\" title=\"FullScreenCover\"></a>FullScreenCover</h3><p>除了标准的 <code>sheet</code>，SwiftUI 还提供了 <code>fullScreenCover</code>，它以全屏模式显示内容，对于那些需要更多空间或需要从视觉上区分出来的情况非常有用。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\">.fullScreenCover(isPresented: <span class=\"hljs-variable\">$showingCover</span>) &#123;<br>    <span class=\"hljs-type\">FullScreenModalView</span>()<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h3><p>Sheet 控件在 SwiftUI 中为模态内容的展示提供了一种简洁而强大的方式。通过简单的状态绑定和自定义视图传递，你可以创建丰富的用户体验，并管理视图的呈现和隐藏。记得，模态视图是一个打断用户当前流程的操作，所以应该在需要的时候谨慎使用。</p>\n"},{"title":"SwiftUI中Slider组件的用法","date":"2023-11-07T12:50:43.000Z","_content":"在 SwiftUI 中，`Slider` 是一个控件，允许用户从一个连续或者离散的值范围内选择一个值。它通常用来表示设置项中的数值，比如音量控制或者屏幕亮度调整。\n\n### 基础用法\n\n基础的 `Slider` 需要与 `@State` 绑定，来跟踪滑块的当前值。例如，创建一个调节音量的滑块：\n\n```swift\nstruct ContentView: View {\n    @State private var volume: Double = 50\n\n    var body: some View {\n        Slider(value: $volume, in: 0...100)\n    }\n}\n```\n\n在这个例子中，`volume` 变量将会跟踪滑块的当前位置，并且滑块的取值范围被设置在 0 到 100 之间。\n\n### 步长\n\n你可以指定 `Slider` 的 `step` 参数来更改滑块的步长：\n\n```swift\nSlider(value: $volume, in: 0...100, step: 5)\n```\n\n在这个例子中，滑块的值将以 5 的倍数变化。\n\n### 自定义外观\n\n`Slider` 提供了多个修饰符来自定义外观：\n\n```swift\nSlider(value: $volume, in: 0...100)\n    .accentColor(.green) // 改变滑块的颜色\n    .trackColor(.blue, minimumValueLabel: Text(\"0\"), maximumValueLabel: Text(\"100\")) // 自iOS 16起可用\n```\n\n### 添加标签\n\n为了增加无障碍性，你可以为 `Slider` 添加一个标签，这样辅助技术如 VoiceOver 可以读取这个标签：\n\n```swift\nSlider(value: $volume, in: 0...100) {\n    Text(\"Volume\")\n}\n.accessibilityValue(Text(\"\\(Int(volume))\"))\n```\n\n### 实时预览\n\n如果你想在用户拖动滑块时实时获得更新，可以添加 `onEditingChanged` 回调：\n\n```swift\nSlider(value: $volume, in: 0...100, onEditingChanged: { editing in\n    if !editing {\n        // 用户停止拖动滑块时的操作\n    }\n})\n```\n\n### 范围选择\n\n`SwiftUI` 也支持范围选择器，从 `iOS 14` 开始可以使用 `RangeSlider`：\n\n```swift\n@State private var priceRange: ClosedRange<Double> = 10...50\n\nRangeSlider(values: $priceRange, in: 0...100)\n```\n\n在这个例子中，`priceRange` 会跟踪一个范围值，用户可以选择从最低到最高价之间的任何价格区间。\n\n### 使用 `Slider` 配置\n\n对于更复杂的配置，你可以使用 `Slider` 初始化器的更多参数：\n\n```swift\nSlider(\n    value: $volume,\n    in: 0...100,\n    step: 1,\n    onEditingChanged: { editing in\n        // 用户拖动滑块时的操作\n    },\n    minimumValueLabel: Text(\"0\"),\n    maximumValueLabel: Text(\"100\"),\n    label: {\n        Text(\"Volume\")\n    }\n)\n```\n\n以上是 `Slider` 的一些常用用法和配置选项。通过合理利用，你可以在 SwiftUI 应用中提供丰富的交互式元素。","source":"_posts/SwiftUI中Slider组件的用法.md","raw":"---\ntitle: SwiftUI中Slider组件的用法\ndate: 2023-11-07 20:50:43\ncategories:\n- SwiftUI\ntags:\n---\n在 SwiftUI 中，`Slider` 是一个控件，允许用户从一个连续或者离散的值范围内选择一个值。它通常用来表示设置项中的数值，比如音量控制或者屏幕亮度调整。\n\n### 基础用法\n\n基础的 `Slider` 需要与 `@State` 绑定，来跟踪滑块的当前值。例如，创建一个调节音量的滑块：\n\n```swift\nstruct ContentView: View {\n    @State private var volume: Double = 50\n\n    var body: some View {\n        Slider(value: $volume, in: 0...100)\n    }\n}\n```\n\n在这个例子中，`volume` 变量将会跟踪滑块的当前位置，并且滑块的取值范围被设置在 0 到 100 之间。\n\n### 步长\n\n你可以指定 `Slider` 的 `step` 参数来更改滑块的步长：\n\n```swift\nSlider(value: $volume, in: 0...100, step: 5)\n```\n\n在这个例子中，滑块的值将以 5 的倍数变化。\n\n### 自定义外观\n\n`Slider` 提供了多个修饰符来自定义外观：\n\n```swift\nSlider(value: $volume, in: 0...100)\n    .accentColor(.green) // 改变滑块的颜色\n    .trackColor(.blue, minimumValueLabel: Text(\"0\"), maximumValueLabel: Text(\"100\")) // 自iOS 16起可用\n```\n\n### 添加标签\n\n为了增加无障碍性，你可以为 `Slider` 添加一个标签，这样辅助技术如 VoiceOver 可以读取这个标签：\n\n```swift\nSlider(value: $volume, in: 0...100) {\n    Text(\"Volume\")\n}\n.accessibilityValue(Text(\"\\(Int(volume))\"))\n```\n\n### 实时预览\n\n如果你想在用户拖动滑块时实时获得更新，可以添加 `onEditingChanged` 回调：\n\n```swift\nSlider(value: $volume, in: 0...100, onEditingChanged: { editing in\n    if !editing {\n        // 用户停止拖动滑块时的操作\n    }\n})\n```\n\n### 范围选择\n\n`SwiftUI` 也支持范围选择器，从 `iOS 14` 开始可以使用 `RangeSlider`：\n\n```swift\n@State private var priceRange: ClosedRange<Double> = 10...50\n\nRangeSlider(values: $priceRange, in: 0...100)\n```\n\n在这个例子中，`priceRange` 会跟踪一个范围值，用户可以选择从最低到最高价之间的任何价格区间。\n\n### 使用 `Slider` 配置\n\n对于更复杂的配置，你可以使用 `Slider` 初始化器的更多参数：\n\n```swift\nSlider(\n    value: $volume,\n    in: 0...100,\n    step: 1,\n    onEditingChanged: { editing in\n        // 用户拖动滑块时的操作\n    },\n    minimumValueLabel: Text(\"0\"),\n    maximumValueLabel: Text(\"100\"),\n    label: {\n        Text(\"Volume\")\n    }\n)\n```\n\n以上是 `Slider` 的一些常用用法和配置选项。通过合理利用，你可以在 SwiftUI 应用中提供丰富的交互式元素。","slug":"SwiftUI中Slider组件的用法","published":1,"updated":"2024-03-17T06:13:18.491Z","comments":1,"layout":"post","photos":[],"_id":"clu6up53e000xz6740wph484q","content":"<p>在 SwiftUI 中，<code>Slider</code> 是一个控件，允许用户从一个连续或者离散的值范围内选择一个值。它通常用来表示设置项中的数值，比如音量控制或者屏幕亮度调整。</p>\n<h3 id=\"基础用法\"><a href=\"#基础用法\" class=\"headerlink\" title=\"基础用法\"></a>基础用法</h3><p>基础的 <code>Slider</code> 需要与 <code>@State</code> 绑定，来跟踪滑块的当前值。例如，创建一个调节音量的滑块：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ContentView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> volume: <span class=\"hljs-type\">Double</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">50</span><br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">Slider</span>(value: <span class=\"hljs-variable\">$volume</span>, in: <span class=\"hljs-number\">0</span><span class=\"hljs-operator\">...</span><span class=\"hljs-number\">100</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在这个例子中，<code>volume</code> 变量将会跟踪滑块的当前位置，并且滑块的取值范围被设置在 0 到 100 之间。</p>\n<h3 id=\"步长\"><a href=\"#步长\" class=\"headerlink\" title=\"步长\"></a>步长</h3><p>你可以指定 <code>Slider</code> 的 <code>step</code> 参数来更改滑块的步长：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Slider</span>(value: <span class=\"hljs-variable\">$volume</span>, in: <span class=\"hljs-number\">0</span><span class=\"hljs-operator\">...</span><span class=\"hljs-number\">100</span>, step: <span class=\"hljs-number\">5</span>)<br></code></pre></td></tr></table></figure>\n\n<p>在这个例子中，滑块的值将以 5 的倍数变化。</p>\n<h3 id=\"自定义外观\"><a href=\"#自定义外观\" class=\"headerlink\" title=\"自定义外观\"></a>自定义外观</h3><p><code>Slider</code> 提供了多个修饰符来自定义外观：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Slider</span>(value: <span class=\"hljs-variable\">$volume</span>, in: <span class=\"hljs-number\">0</span><span class=\"hljs-operator\">...</span><span class=\"hljs-number\">100</span>)<br>    .accentColor(.green) <span class=\"hljs-comment\">// 改变滑块的颜色</span><br>    .trackColor(.blue, minimumValueLabel: <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;0&quot;</span>), maximumValueLabel: <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;100&quot;</span>)) <span class=\"hljs-comment\">// 自iOS 16起可用</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"添加标签\"><a href=\"#添加标签\" class=\"headerlink\" title=\"添加标签\"></a>添加标签</h3><p>为了增加无障碍性，你可以为 <code>Slider</code> 添加一个标签，这样辅助技术如 VoiceOver 可以读取这个标签：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Slider</span>(value: <span class=\"hljs-variable\">$volume</span>, in: <span class=\"hljs-number\">0</span><span class=\"hljs-operator\">...</span><span class=\"hljs-number\">100</span>) &#123;<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Volume&quot;</span>)<br>&#125;<br>.accessibilityValue(<span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;<span class=\"hljs-subst\">\\(Int(volume))</span>&quot;</span>))<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"实时预览\"><a href=\"#实时预览\" class=\"headerlink\" title=\"实时预览\"></a>实时预览</h3><p>如果你想在用户拖动滑块时实时获得更新，可以添加 <code>onEditingChanged</code> 回调：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Slider</span>(value: <span class=\"hljs-variable\">$volume</span>, in: <span class=\"hljs-number\">0</span><span class=\"hljs-operator\">...</span><span class=\"hljs-number\">100</span>, onEditingChanged: &#123; editing <span class=\"hljs-keyword\">in</span><br>    <span class=\"hljs-keyword\">if</span> <span class=\"hljs-operator\">!</span>editing &#123;<br>        <span class=\"hljs-comment\">// 用户停止拖动滑块时的操作</span><br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"范围选择\"><a href=\"#范围选择\" class=\"headerlink\" title=\"范围选择\"></a>范围选择</h3><p><code>SwiftUI</code> 也支持范围选择器，从 <code>iOS 14</code> 开始可以使用 <code>RangeSlider</code>：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> priceRange: <span class=\"hljs-type\">ClosedRange</span>&lt;<span class=\"hljs-type\">Double</span>&gt; <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">10</span><span class=\"hljs-operator\">...</span><span class=\"hljs-number\">50</span><br><br><span class=\"hljs-type\">RangeSlider</span>(values: <span class=\"hljs-variable\">$priceRange</span>, in: <span class=\"hljs-number\">0</span><span class=\"hljs-operator\">...</span><span class=\"hljs-number\">100</span>)<br></code></pre></td></tr></table></figure>\n\n<p>在这个例子中，<code>priceRange</code> 会跟踪一个范围值，用户可以选择从最低到最高价之间的任何价格区间。</p>\n<h3 id=\"使用-Slider-配置\"><a href=\"#使用-Slider-配置\" class=\"headerlink\" title=\"使用 Slider 配置\"></a>使用 <code>Slider</code> 配置</h3><p>对于更复杂的配置，你可以使用 <code>Slider</code> 初始化器的更多参数：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Slider</span>(<br>    value: <span class=\"hljs-variable\">$volume</span>,<br>    in: <span class=\"hljs-number\">0</span><span class=\"hljs-operator\">...</span><span class=\"hljs-number\">100</span>,<br>    step: <span class=\"hljs-number\">1</span>,<br>    onEditingChanged: &#123; editing <span class=\"hljs-keyword\">in</span><br>        <span class=\"hljs-comment\">// 用户拖动滑块时的操作</span><br>    &#125;,<br>    minimumValueLabel: <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;0&quot;</span>),<br>    maximumValueLabel: <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;100&quot;</span>),<br>    label: &#123;<br>        <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Volume&quot;</span>)<br>    &#125;<br>)<br></code></pre></td></tr></table></figure>\n\n<p>以上是 <code>Slider</code> 的一些常用用法和配置选项。通过合理利用，你可以在 SwiftUI 应用中提供丰富的交互式元素。</p>\n","excerpt":"","more":"<p>在 SwiftUI 中，<code>Slider</code> 是一个控件，允许用户从一个连续或者离散的值范围内选择一个值。它通常用来表示设置项中的数值，比如音量控制或者屏幕亮度调整。</p>\n<h3 id=\"基础用法\"><a href=\"#基础用法\" class=\"headerlink\" title=\"基础用法\"></a>基础用法</h3><p>基础的 <code>Slider</code> 需要与 <code>@State</code> 绑定，来跟踪滑块的当前值。例如，创建一个调节音量的滑块：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ContentView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> volume: <span class=\"hljs-type\">Double</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">50</span><br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">Slider</span>(value: <span class=\"hljs-variable\">$volume</span>, in: <span class=\"hljs-number\">0</span><span class=\"hljs-operator\">...</span><span class=\"hljs-number\">100</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在这个例子中，<code>volume</code> 变量将会跟踪滑块的当前位置，并且滑块的取值范围被设置在 0 到 100 之间。</p>\n<h3 id=\"步长\"><a href=\"#步长\" class=\"headerlink\" title=\"步长\"></a>步长</h3><p>你可以指定 <code>Slider</code> 的 <code>step</code> 参数来更改滑块的步长：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Slider</span>(value: <span class=\"hljs-variable\">$volume</span>, in: <span class=\"hljs-number\">0</span><span class=\"hljs-operator\">...</span><span class=\"hljs-number\">100</span>, step: <span class=\"hljs-number\">5</span>)<br></code></pre></td></tr></table></figure>\n\n<p>在这个例子中，滑块的值将以 5 的倍数变化。</p>\n<h3 id=\"自定义外观\"><a href=\"#自定义外观\" class=\"headerlink\" title=\"自定义外观\"></a>自定义外观</h3><p><code>Slider</code> 提供了多个修饰符来自定义外观：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Slider</span>(value: <span class=\"hljs-variable\">$volume</span>, in: <span class=\"hljs-number\">0</span><span class=\"hljs-operator\">...</span><span class=\"hljs-number\">100</span>)<br>    .accentColor(.green) <span class=\"hljs-comment\">// 改变滑块的颜色</span><br>    .trackColor(.blue, minimumValueLabel: <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;0&quot;</span>), maximumValueLabel: <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;100&quot;</span>)) <span class=\"hljs-comment\">// 自iOS 16起可用</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"添加标签\"><a href=\"#添加标签\" class=\"headerlink\" title=\"添加标签\"></a>添加标签</h3><p>为了增加无障碍性，你可以为 <code>Slider</code> 添加一个标签，这样辅助技术如 VoiceOver 可以读取这个标签：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Slider</span>(value: <span class=\"hljs-variable\">$volume</span>, in: <span class=\"hljs-number\">0</span><span class=\"hljs-operator\">...</span><span class=\"hljs-number\">100</span>) &#123;<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Volume&quot;</span>)<br>&#125;<br>.accessibilityValue(<span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;<span class=\"hljs-subst\">\\(Int(volume))</span>&quot;</span>))<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"实时预览\"><a href=\"#实时预览\" class=\"headerlink\" title=\"实时预览\"></a>实时预览</h3><p>如果你想在用户拖动滑块时实时获得更新，可以添加 <code>onEditingChanged</code> 回调：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Slider</span>(value: <span class=\"hljs-variable\">$volume</span>, in: <span class=\"hljs-number\">0</span><span class=\"hljs-operator\">...</span><span class=\"hljs-number\">100</span>, onEditingChanged: &#123; editing <span class=\"hljs-keyword\">in</span><br>    <span class=\"hljs-keyword\">if</span> <span class=\"hljs-operator\">!</span>editing &#123;<br>        <span class=\"hljs-comment\">// 用户停止拖动滑块时的操作</span><br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"范围选择\"><a href=\"#范围选择\" class=\"headerlink\" title=\"范围选择\"></a>范围选择</h3><p><code>SwiftUI</code> 也支持范围选择器，从 <code>iOS 14</code> 开始可以使用 <code>RangeSlider</code>：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> priceRange: <span class=\"hljs-type\">ClosedRange</span>&lt;<span class=\"hljs-type\">Double</span>&gt; <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">10</span><span class=\"hljs-operator\">...</span><span class=\"hljs-number\">50</span><br><br><span class=\"hljs-type\">RangeSlider</span>(values: <span class=\"hljs-variable\">$priceRange</span>, in: <span class=\"hljs-number\">0</span><span class=\"hljs-operator\">...</span><span class=\"hljs-number\">100</span>)<br></code></pre></td></tr></table></figure>\n\n<p>在这个例子中，<code>priceRange</code> 会跟踪一个范围值，用户可以选择从最低到最高价之间的任何价格区间。</p>\n<h3 id=\"使用-Slider-配置\"><a href=\"#使用-Slider-配置\" class=\"headerlink\" title=\"使用 Slider 配置\"></a>使用 <code>Slider</code> 配置</h3><p>对于更复杂的配置，你可以使用 <code>Slider</code> 初始化器的更多参数：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Slider</span>(<br>    value: <span class=\"hljs-variable\">$volume</span>,<br>    in: <span class=\"hljs-number\">0</span><span class=\"hljs-operator\">...</span><span class=\"hljs-number\">100</span>,<br>    step: <span class=\"hljs-number\">1</span>,<br>    onEditingChanged: &#123; editing <span class=\"hljs-keyword\">in</span><br>        <span class=\"hljs-comment\">// 用户拖动滑块时的操作</span><br>    &#125;,<br>    minimumValueLabel: <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;0&quot;</span>),<br>    maximumValueLabel: <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;100&quot;</span>),<br>    label: &#123;<br>        <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Volume&quot;</span>)<br>    &#125;<br>)<br></code></pre></td></tr></table></figure>\n\n<p>以上是 <code>Slider</code> 的一些常用用法和配置选项。通过合理利用，你可以在 SwiftUI 应用中提供丰富的交互式元素。</p>\n"},{"title":"SwiftUI中Stepper的用法","date":"2023-11-07T12:55:21.000Z","_content":"在 SwiftUI 中，`Stepper` 控件允许用户通过点击增加或减少按钮来增加或减少一个值。它通常用于输入数量或调整设置，例如设置闹钟的时间或者调整购物车内商品的数量。\n\n### 基础用法\n\n下面是一个基础的 `Stepper` 控件用法示例：\n\n```swift\nstruct ContentView: View {\n    @State private var quantity = 0\n\n    var body: some View {\n        Stepper(\"Quantity: \\(quantity)\", value: $quantity)\n    }\n}\n```\n\n在这个例子中，`quantity` 是一个 `@State` 属性，它与 `Stepper` 绑定，用户点击 `Stepper` 来增加或减少 `quantity` 的值。\n\n### 设置范围\n\n你可以为 `Stepper` 设置一个具体的数值范围：\n\n```swift\nStepper(\"Quantity: \\(quantity)\", value: $quantity, in: 0...10)\n```\n\n这样，`quantity` 的值将被限制在 0 到 10 之间。\n\n### 指定步长\n\n通过指定 `step` 参数，你可以控制每次增加或减少的量：\n\n```swift\nStepper(\"Quantity: \\(quantity)\", value: $quantity, in: 0...10, step: 2)\n```\n\n这里每次点击会增加或减少 2 的单位。\n\n### 响应更改\n\n如果你需要在值改变时执行某些操作，可以使用 `onIncrement` 和 `onDecrement` 闭包：\n\n```swift\nStepper(onIncrement: {\n    self.quantity += 1\n    self.performSomeAction()\n}, onDecrement: {\n    self.quantity -= 1\n    self.performSomeAction()\n}, label: {\n    Text(\"Quantity: \\(quantity)\")\n})\n```\n\n`performSomeAction()` 函数会在数量增加或减少时被调用。\n\n### 样式自定义\n\n`Stepper` 可以通过修饰符自定义样式，例如加入 `.labelsHidden()` 来隐藏标签：\n\n```swift\nStepper(\"Quantity: \\(quantity)\", value: $quantity)\n    .labelsHidden()\n```\n\n### 集成到其他 UI 中\n\n`Stepper` 可以很容易地集成到列表或者表单中：\n\n```swift\nForm {\n    Section(header: Text(\"Settings\")) {\n        Stepper(\"Quantity: \\(quantity)\", value: $quantity)\n    }\n}\n```\n\n### 使用场景\n\n- 调整设置，如定时器的分钟数。\n- 购物车中商品的数量。\n- 任何需要简单加减数字输入的地方。\n\n`Stepper` 因其简单直观的用户体验，在需要数字输入但又不适合打开键盘的场合尤其有用。在 SwiftUI 中，它的使用非常简洁，只需几行代码即可集成。","source":"_posts/SwiftUI中Stepper的用法.md","raw":"---\ntitle: SwiftUI中Stepper的用法\ndate: 2023-11-07 20:55:21\ncategories:\n- SwiftUI\ntags:\n---\n在 SwiftUI 中，`Stepper` 控件允许用户通过点击增加或减少按钮来增加或减少一个值。它通常用于输入数量或调整设置，例如设置闹钟的时间或者调整购物车内商品的数量。\n\n### 基础用法\n\n下面是一个基础的 `Stepper` 控件用法示例：\n\n```swift\nstruct ContentView: View {\n    @State private var quantity = 0\n\n    var body: some View {\n        Stepper(\"Quantity: \\(quantity)\", value: $quantity)\n    }\n}\n```\n\n在这个例子中，`quantity` 是一个 `@State` 属性，它与 `Stepper` 绑定，用户点击 `Stepper` 来增加或减少 `quantity` 的值。\n\n### 设置范围\n\n你可以为 `Stepper` 设置一个具体的数值范围：\n\n```swift\nStepper(\"Quantity: \\(quantity)\", value: $quantity, in: 0...10)\n```\n\n这样，`quantity` 的值将被限制在 0 到 10 之间。\n\n### 指定步长\n\n通过指定 `step` 参数，你可以控制每次增加或减少的量：\n\n```swift\nStepper(\"Quantity: \\(quantity)\", value: $quantity, in: 0...10, step: 2)\n```\n\n这里每次点击会增加或减少 2 的单位。\n\n### 响应更改\n\n如果你需要在值改变时执行某些操作，可以使用 `onIncrement` 和 `onDecrement` 闭包：\n\n```swift\nStepper(onIncrement: {\n    self.quantity += 1\n    self.performSomeAction()\n}, onDecrement: {\n    self.quantity -= 1\n    self.performSomeAction()\n}, label: {\n    Text(\"Quantity: \\(quantity)\")\n})\n```\n\n`performSomeAction()` 函数会在数量增加或减少时被调用。\n\n### 样式自定义\n\n`Stepper` 可以通过修饰符自定义样式，例如加入 `.labelsHidden()` 来隐藏标签：\n\n```swift\nStepper(\"Quantity: \\(quantity)\", value: $quantity)\n    .labelsHidden()\n```\n\n### 集成到其他 UI 中\n\n`Stepper` 可以很容易地集成到列表或者表单中：\n\n```swift\nForm {\n    Section(header: Text(\"Settings\")) {\n        Stepper(\"Quantity: \\(quantity)\", value: $quantity)\n    }\n}\n```\n\n### 使用场景\n\n- 调整设置，如定时器的分钟数。\n- 购物车中商品的数量。\n- 任何需要简单加减数字输入的地方。\n\n`Stepper` 因其简单直观的用户体验，在需要数字输入但又不适合打开键盘的场合尤其有用。在 SwiftUI 中，它的使用非常简洁，只需几行代码即可集成。","slug":"SwiftUI中Stepper的用法","published":1,"updated":"2024-03-17T06:13:21.729Z","comments":1,"layout":"post","photos":[],"_id":"clu6up53e0011z674h3v8fp7f","content":"<p>在 SwiftUI 中，<code>Stepper</code> 控件允许用户通过点击增加或减少按钮来增加或减少一个值。它通常用于输入数量或调整设置，例如设置闹钟的时间或者调整购物车内商品的数量。</p>\n<h3 id=\"基础用法\"><a href=\"#基础用法\" class=\"headerlink\" title=\"基础用法\"></a>基础用法</h3><p>下面是一个基础的 <code>Stepper</code> 控件用法示例：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ContentView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> quantity <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span><br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">Stepper</span>(<span class=\"hljs-string\">&quot;Quantity: <span class=\"hljs-subst\">\\(quantity)</span>&quot;</span>, value: <span class=\"hljs-variable\">$quantity</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在这个例子中，<code>quantity</code> 是一个 <code>@State</code> 属性，它与 <code>Stepper</code> 绑定，用户点击 <code>Stepper</code> 来增加或减少 <code>quantity</code> 的值。</p>\n<h3 id=\"设置范围\"><a href=\"#设置范围\" class=\"headerlink\" title=\"设置范围\"></a>设置范围</h3><p>你可以为 <code>Stepper</code> 设置一个具体的数值范围：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Stepper</span>(<span class=\"hljs-string\">&quot;Quantity: <span class=\"hljs-subst\">\\(quantity)</span>&quot;</span>, value: <span class=\"hljs-variable\">$quantity</span>, in: <span class=\"hljs-number\">0</span><span class=\"hljs-operator\">...</span><span class=\"hljs-number\">10</span>)<br></code></pre></td></tr></table></figure>\n\n<p>这样，<code>quantity</code> 的值将被限制在 0 到 10 之间。</p>\n<h3 id=\"指定步长\"><a href=\"#指定步长\" class=\"headerlink\" title=\"指定步长\"></a>指定步长</h3><p>通过指定 <code>step</code> 参数，你可以控制每次增加或减少的量：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Stepper</span>(<span class=\"hljs-string\">&quot;Quantity: <span class=\"hljs-subst\">\\(quantity)</span>&quot;</span>, value: <span class=\"hljs-variable\">$quantity</span>, in: <span class=\"hljs-number\">0</span><span class=\"hljs-operator\">...</span><span class=\"hljs-number\">10</span>, step: <span class=\"hljs-number\">2</span>)<br></code></pre></td></tr></table></figure>\n\n<p>这里每次点击会增加或减少 2 的单位。</p>\n<h3 id=\"响应更改\"><a href=\"#响应更改\" class=\"headerlink\" title=\"响应更改\"></a>响应更改</h3><p>如果你需要在值改变时执行某些操作，可以使用 <code>onIncrement</code> 和 <code>onDecrement</code> 闭包：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Stepper</span>(onIncrement: &#123;<br>    <span class=\"hljs-keyword\">self</span>.quantity <span class=\"hljs-operator\">+=</span> <span class=\"hljs-number\">1</span><br>    <span class=\"hljs-keyword\">self</span>.performSomeAction()<br>&#125;, onDecrement: &#123;<br>    <span class=\"hljs-keyword\">self</span>.quantity <span class=\"hljs-operator\">-=</span> <span class=\"hljs-number\">1</span><br>    <span class=\"hljs-keyword\">self</span>.performSomeAction()<br>&#125;, label: &#123;<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Quantity: <span class=\"hljs-subst\">\\(quantity)</span>&quot;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<p><code>performSomeAction()</code> 函数会在数量增加或减少时被调用。</p>\n<h3 id=\"样式自定义\"><a href=\"#样式自定义\" class=\"headerlink\" title=\"样式自定义\"></a>样式自定义</h3><p><code>Stepper</code> 可以通过修饰符自定义样式，例如加入 <code>.labelsHidden()</code> 来隐藏标签：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Stepper</span>(<span class=\"hljs-string\">&quot;Quantity: <span class=\"hljs-subst\">\\(quantity)</span>&quot;</span>, value: <span class=\"hljs-variable\">$quantity</span>)<br>    .labelsHidden()<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"集成到其他-UI-中\"><a href=\"#集成到其他-UI-中\" class=\"headerlink\" title=\"集成到其他 UI 中\"></a>集成到其他 UI 中</h3><p><code>Stepper</code> 可以很容易地集成到列表或者表单中：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Form</span> &#123;<br>    <span class=\"hljs-type\">Section</span>(header: <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Settings&quot;</span>)) &#123;<br>        <span class=\"hljs-type\">Stepper</span>(<span class=\"hljs-string\">&quot;Quantity: <span class=\"hljs-subst\">\\(quantity)</span>&quot;</span>, value: <span class=\"hljs-variable\">$quantity</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h3><ul>\n<li>调整设置，如定时器的分钟数。</li>\n<li>购物车中商品的数量。</li>\n<li>任何需要简单加减数字输入的地方。</li>\n</ul>\n<p><code>Stepper</code> 因其简单直观的用户体验，在需要数字输入但又不适合打开键盘的场合尤其有用。在 SwiftUI 中，它的使用非常简洁，只需几行代码即可集成。</p>\n","excerpt":"","more":"<p>在 SwiftUI 中，<code>Stepper</code> 控件允许用户通过点击增加或减少按钮来增加或减少一个值。它通常用于输入数量或调整设置，例如设置闹钟的时间或者调整购物车内商品的数量。</p>\n<h3 id=\"基础用法\"><a href=\"#基础用法\" class=\"headerlink\" title=\"基础用法\"></a>基础用法</h3><p>下面是一个基础的 <code>Stepper</code> 控件用法示例：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ContentView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> quantity <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span><br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">Stepper</span>(<span class=\"hljs-string\">&quot;Quantity: <span class=\"hljs-subst\">\\(quantity)</span>&quot;</span>, value: <span class=\"hljs-variable\">$quantity</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在这个例子中，<code>quantity</code> 是一个 <code>@State</code> 属性，它与 <code>Stepper</code> 绑定，用户点击 <code>Stepper</code> 来增加或减少 <code>quantity</code> 的值。</p>\n<h3 id=\"设置范围\"><a href=\"#设置范围\" class=\"headerlink\" title=\"设置范围\"></a>设置范围</h3><p>你可以为 <code>Stepper</code> 设置一个具体的数值范围：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Stepper</span>(<span class=\"hljs-string\">&quot;Quantity: <span class=\"hljs-subst\">\\(quantity)</span>&quot;</span>, value: <span class=\"hljs-variable\">$quantity</span>, in: <span class=\"hljs-number\">0</span><span class=\"hljs-operator\">...</span><span class=\"hljs-number\">10</span>)<br></code></pre></td></tr></table></figure>\n\n<p>这样，<code>quantity</code> 的值将被限制在 0 到 10 之间。</p>\n<h3 id=\"指定步长\"><a href=\"#指定步长\" class=\"headerlink\" title=\"指定步长\"></a>指定步长</h3><p>通过指定 <code>step</code> 参数，你可以控制每次增加或减少的量：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Stepper</span>(<span class=\"hljs-string\">&quot;Quantity: <span class=\"hljs-subst\">\\(quantity)</span>&quot;</span>, value: <span class=\"hljs-variable\">$quantity</span>, in: <span class=\"hljs-number\">0</span><span class=\"hljs-operator\">...</span><span class=\"hljs-number\">10</span>, step: <span class=\"hljs-number\">2</span>)<br></code></pre></td></tr></table></figure>\n\n<p>这里每次点击会增加或减少 2 的单位。</p>\n<h3 id=\"响应更改\"><a href=\"#响应更改\" class=\"headerlink\" title=\"响应更改\"></a>响应更改</h3><p>如果你需要在值改变时执行某些操作，可以使用 <code>onIncrement</code> 和 <code>onDecrement</code> 闭包：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Stepper</span>(onIncrement: &#123;<br>    <span class=\"hljs-keyword\">self</span>.quantity <span class=\"hljs-operator\">+=</span> <span class=\"hljs-number\">1</span><br>    <span class=\"hljs-keyword\">self</span>.performSomeAction()<br>&#125;, onDecrement: &#123;<br>    <span class=\"hljs-keyword\">self</span>.quantity <span class=\"hljs-operator\">-=</span> <span class=\"hljs-number\">1</span><br>    <span class=\"hljs-keyword\">self</span>.performSomeAction()<br>&#125;, label: &#123;<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Quantity: <span class=\"hljs-subst\">\\(quantity)</span>&quot;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<p><code>performSomeAction()</code> 函数会在数量增加或减少时被调用。</p>\n<h3 id=\"样式自定义\"><a href=\"#样式自定义\" class=\"headerlink\" title=\"样式自定义\"></a>样式自定义</h3><p><code>Stepper</code> 可以通过修饰符自定义样式，例如加入 <code>.labelsHidden()</code> 来隐藏标签：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Stepper</span>(<span class=\"hljs-string\">&quot;Quantity: <span class=\"hljs-subst\">\\(quantity)</span>&quot;</span>, value: <span class=\"hljs-variable\">$quantity</span>)<br>    .labelsHidden()<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"集成到其他-UI-中\"><a href=\"#集成到其他-UI-中\" class=\"headerlink\" title=\"集成到其他 UI 中\"></a>集成到其他 UI 中</h3><p><code>Stepper</code> 可以很容易地集成到列表或者表单中：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Form</span> &#123;<br>    <span class=\"hljs-type\">Section</span>(header: <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Settings&quot;</span>)) &#123;<br>        <span class=\"hljs-type\">Stepper</span>(<span class=\"hljs-string\">&quot;Quantity: <span class=\"hljs-subst\">\\(quantity)</span>&quot;</span>, value: <span class=\"hljs-variable\">$quantity</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h3><ul>\n<li>调整设置，如定时器的分钟数。</li>\n<li>购物车中商品的数量。</li>\n<li>任何需要简单加减数字输入的地方。</li>\n</ul>\n<p><code>Stepper</code> 因其简单直观的用户体验，在需要数字输入但又不适合打开键盘的场合尤其有用。在 SwiftUI 中，它的使用非常简洁，只需几行代码即可集成。</p>\n"},{"title":"SwiftUI中Popover控件的用法","date":"2023-11-07T13:06:54.000Z","_content":"在 SwiftUI 中，Popover 是一种用于临时显示浮动内容的组件。它通常被用来提供额外的信息或选项，而不必将用户带离他们当前的上下文。Popover 在 iPad 上特别有用，因为它可以利用更大的屏幕尺寸来展示额外内容而不覆盖整个屏幕。\n\n### Popover 的基本用法\n\n要在 SwiftUI 中创建一个 popover，你可以使用 `.popover` 修饰符。这需要一个绑定的布尔值，当该值为真时，会显示 popover。\n\n```swift\nstruct ContentView: View {\n    @State private var showingPopover = false\n\n    var body: some View {\n        Button(\"Show Popover\") {\n            showingPopover = true\n        }\n        .popover(isPresented: $showingPopover) {\n            Text(\"Here's the content of the Popover.\")\n                .font(.headline)\n                .padding()\n        }\n    }\n}\n```\n\n在这个例子中，当用户点击按钮时，`showingPopover` 变为 `true`，这会触发 popover 的展示。\n\n### Popover 的附加配置\n\nPopover 支持使用 `attachmentAnchor` 和 `arrowEdge` 参数来进一步配置其位置和箭头的朝向。\n\n```swift\n.popover(isPresented: $showingPopover, attachmentAnchor: .point(.bottom), arrowEdge: .top) {\n    // Popover 的内容\n}\n```\n\n### Popover 用于显示动态内容\n\nPopover 也可以用来显示动态内容，这意味着你可以根据某些状态或者条件来决定展示什么内容。\n\n```swift\n.popover(isPresented: $showingPopover) {\n    if someCondition {\n        SomeView()\n    } else {\n        AnotherView()\n    }\n}\n```\n\n### Popover 与 `item` 绑定\n\n除了使用布尔值，popover 还可以通过绑定到一个可选项上来展示，这可以使你基于选择的特定对象显示不同的 popover。\n\n```swift\nstruct ContentView: View {\n    @State private var selectedPerson: Person?\n\n    var body: some View {\n        List(people) { person in\n            Text(person.name)\n                .onTapGesture {\n                    self.selectedPerson = person\n                }\n        }\n        .popover(item: $selectedPerson) { person in\n            PersonDetailView(person: person)\n        }\n    }\n}\n\nstruct Person: Identifiable {\n    let id: UUID\n    let name: String\n}\n```\n\n在上面的例子中，每个人的名字是一个列表项。当点击名字时，`selectedPerson` 被设置为该 `Person` 实例，并且展示了一个 popover 来显示更多关于这个人的详情。\n\n### 在不同设备上的表现\n\nPopover 在 iPadOS 上以浮动视图的形式展现，在 iPhone 上则会占据整个屏幕，类似于 modal presentation。因此，设计你的 popover 内容时，要考虑它在不同设备上的表现。\n\nPopover 通常用于临时任务或补充内容的场景，它的优点在于能够保持用户在当前的上下文中，同时提供额外的交互或信息。与其它模态视图一样，它们应该被谨慎使用，以免打断用户的工作流程。","source":"_posts/SwiftUI中Popover控件的用法.md","raw":"---\ntitle: SwiftUI中Popover控件的用法\ndate: 2023-11-07 21:06:54\ncategories:\n- SwiftUI\ntags:\n---\n在 SwiftUI 中，Popover 是一种用于临时显示浮动内容的组件。它通常被用来提供额外的信息或选项，而不必将用户带离他们当前的上下文。Popover 在 iPad 上特别有用，因为它可以利用更大的屏幕尺寸来展示额外内容而不覆盖整个屏幕。\n\n### Popover 的基本用法\n\n要在 SwiftUI 中创建一个 popover，你可以使用 `.popover` 修饰符。这需要一个绑定的布尔值，当该值为真时，会显示 popover。\n\n```swift\nstruct ContentView: View {\n    @State private var showingPopover = false\n\n    var body: some View {\n        Button(\"Show Popover\") {\n            showingPopover = true\n        }\n        .popover(isPresented: $showingPopover) {\n            Text(\"Here's the content of the Popover.\")\n                .font(.headline)\n                .padding()\n        }\n    }\n}\n```\n\n在这个例子中，当用户点击按钮时，`showingPopover` 变为 `true`，这会触发 popover 的展示。\n\n### Popover 的附加配置\n\nPopover 支持使用 `attachmentAnchor` 和 `arrowEdge` 参数来进一步配置其位置和箭头的朝向。\n\n```swift\n.popover(isPresented: $showingPopover, attachmentAnchor: .point(.bottom), arrowEdge: .top) {\n    // Popover 的内容\n}\n```\n\n### Popover 用于显示动态内容\n\nPopover 也可以用来显示动态内容，这意味着你可以根据某些状态或者条件来决定展示什么内容。\n\n```swift\n.popover(isPresented: $showingPopover) {\n    if someCondition {\n        SomeView()\n    } else {\n        AnotherView()\n    }\n}\n```\n\n### Popover 与 `item` 绑定\n\n除了使用布尔值，popover 还可以通过绑定到一个可选项上来展示，这可以使你基于选择的特定对象显示不同的 popover。\n\n```swift\nstruct ContentView: View {\n    @State private var selectedPerson: Person?\n\n    var body: some View {\n        List(people) { person in\n            Text(person.name)\n                .onTapGesture {\n                    self.selectedPerson = person\n                }\n        }\n        .popover(item: $selectedPerson) { person in\n            PersonDetailView(person: person)\n        }\n    }\n}\n\nstruct Person: Identifiable {\n    let id: UUID\n    let name: String\n}\n```\n\n在上面的例子中，每个人的名字是一个列表项。当点击名字时，`selectedPerson` 被设置为该 `Person` 实例，并且展示了一个 popover 来显示更多关于这个人的详情。\n\n### 在不同设备上的表现\n\nPopover 在 iPadOS 上以浮动视图的形式展现，在 iPhone 上则会占据整个屏幕，类似于 modal presentation。因此，设计你的 popover 内容时，要考虑它在不同设备上的表现。\n\nPopover 通常用于临时任务或补充内容的场景，它的优点在于能够保持用户在当前的上下文中，同时提供额外的交互或信息。与其它模态视图一样，它们应该被谨慎使用，以免打断用户的工作流程。","slug":"SwiftUI中Popover控件的用法","published":1,"updated":"2024-03-17T06:13:01.788Z","comments":1,"layout":"post","photos":[],"_id":"clu6up53e0013z6748n7o179h","content":"<p>在 SwiftUI 中，Popover 是一种用于临时显示浮动内容的组件。它通常被用来提供额外的信息或选项，而不必将用户带离他们当前的上下文。Popover 在 iPad 上特别有用，因为它可以利用更大的屏幕尺寸来展示额外内容而不覆盖整个屏幕。</p>\n<h3 id=\"Popover-的基本用法\"><a href=\"#Popover-的基本用法\" class=\"headerlink\" title=\"Popover 的基本用法\"></a>Popover 的基本用法</h3><p>要在 SwiftUI 中创建一个 popover，你可以使用 <code>.popover</code> 修饰符。这需要一个绑定的布尔值，当该值为真时，会显示 popover。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ContentView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> showingPopover <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">false</span><br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">Button</span>(<span class=\"hljs-string\">&quot;Show Popover&quot;</span>) &#123;<br>            showingPopover <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">true</span><br>        &#125;<br>        .popover(isPresented: <span class=\"hljs-variable\">$showingPopover</span>) &#123;<br>            <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Here&#x27;s the content of the Popover.&quot;</span>)<br>                .font(.headline)<br>                .padding()<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在这个例子中，当用户点击按钮时，<code>showingPopover</code> 变为 <code>true</code>，这会触发 popover 的展示。</p>\n<h3 id=\"Popover-的附加配置\"><a href=\"#Popover-的附加配置\" class=\"headerlink\" title=\"Popover 的附加配置\"></a>Popover 的附加配置</h3><p>Popover 支持使用 <code>attachmentAnchor</code> 和 <code>arrowEdge</code> 参数来进一步配置其位置和箭头的朝向。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\">.popover(isPresented: <span class=\"hljs-variable\">$showingPopover</span>, attachmentAnchor: .point(.bottom), arrowEdge: .top) &#123;<br>    <span class=\"hljs-comment\">// Popover 的内容</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"Popover-用于显示动态内容\"><a href=\"#Popover-用于显示动态内容\" class=\"headerlink\" title=\"Popover 用于显示动态内容\"></a>Popover 用于显示动态内容</h3><p>Popover 也可以用来显示动态内容，这意味着你可以根据某些状态或者条件来决定展示什么内容。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\">.popover(isPresented: <span class=\"hljs-variable\">$showingPopover</span>) &#123;<br>    <span class=\"hljs-keyword\">if</span> someCondition &#123;<br>        <span class=\"hljs-type\">SomeView</span>()<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>        <span class=\"hljs-type\">AnotherView</span>()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"Popover-与-item-绑定\"><a href=\"#Popover-与-item-绑定\" class=\"headerlink\" title=\"Popover 与 item 绑定\"></a>Popover 与 <code>item</code> 绑定</h3><p>除了使用布尔值，popover 还可以通过绑定到一个可选项上来展示，这可以使你基于选择的特定对象显示不同的 popover。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ContentView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> selectedPerson: <span class=\"hljs-type\">Person</span>?<br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">List</span>(people) &#123; person <span class=\"hljs-keyword\">in</span><br>            <span class=\"hljs-type\">Text</span>(person.name)<br>                .onTapGesture &#123;<br>                    <span class=\"hljs-keyword\">self</span>.selectedPerson <span class=\"hljs-operator\">=</span> person<br>                &#125;<br>        &#125;<br>        .popover(item: <span class=\"hljs-variable\">$selectedPerson</span>) &#123; person <span class=\"hljs-keyword\">in</span><br>            <span class=\"hljs-type\">PersonDetailView</span>(person: person)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Person</span>: <span class=\"hljs-title class_\">Identifiable</span> &#123;<br>    <span class=\"hljs-keyword\">let</span> id: <span class=\"hljs-type\">UUID</span><br>    <span class=\"hljs-keyword\">let</span> name: <span class=\"hljs-type\">String</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在上面的例子中，每个人的名字是一个列表项。当点击名字时，<code>selectedPerson</code> 被设置为该 <code>Person</code> 实例，并且展示了一个 popover 来显示更多关于这个人的详情。</p>\n<h3 id=\"在不同设备上的表现\"><a href=\"#在不同设备上的表现\" class=\"headerlink\" title=\"在不同设备上的表现\"></a>在不同设备上的表现</h3><p>Popover 在 iPadOS 上以浮动视图的形式展现，在 iPhone 上则会占据整个屏幕，类似于 modal presentation。因此，设计你的 popover 内容时，要考虑它在不同设备上的表现。</p>\n<p>Popover 通常用于临时任务或补充内容的场景，它的优点在于能够保持用户在当前的上下文中，同时提供额外的交互或信息。与其它模态视图一样，它们应该被谨慎使用，以免打断用户的工作流程。</p>\n","excerpt":"","more":"<p>在 SwiftUI 中，Popover 是一种用于临时显示浮动内容的组件。它通常被用来提供额外的信息或选项，而不必将用户带离他们当前的上下文。Popover 在 iPad 上特别有用，因为它可以利用更大的屏幕尺寸来展示额外内容而不覆盖整个屏幕。</p>\n<h3 id=\"Popover-的基本用法\"><a href=\"#Popover-的基本用法\" class=\"headerlink\" title=\"Popover 的基本用法\"></a>Popover 的基本用法</h3><p>要在 SwiftUI 中创建一个 popover，你可以使用 <code>.popover</code> 修饰符。这需要一个绑定的布尔值，当该值为真时，会显示 popover。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ContentView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> showingPopover <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">false</span><br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">Button</span>(<span class=\"hljs-string\">&quot;Show Popover&quot;</span>) &#123;<br>            showingPopover <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">true</span><br>        &#125;<br>        .popover(isPresented: <span class=\"hljs-variable\">$showingPopover</span>) &#123;<br>            <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Here&#x27;s the content of the Popover.&quot;</span>)<br>                .font(.headline)<br>                .padding()<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在这个例子中，当用户点击按钮时，<code>showingPopover</code> 变为 <code>true</code>，这会触发 popover 的展示。</p>\n<h3 id=\"Popover-的附加配置\"><a href=\"#Popover-的附加配置\" class=\"headerlink\" title=\"Popover 的附加配置\"></a>Popover 的附加配置</h3><p>Popover 支持使用 <code>attachmentAnchor</code> 和 <code>arrowEdge</code> 参数来进一步配置其位置和箭头的朝向。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\">.popover(isPresented: <span class=\"hljs-variable\">$showingPopover</span>, attachmentAnchor: .point(.bottom), arrowEdge: .top) &#123;<br>    <span class=\"hljs-comment\">// Popover 的内容</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"Popover-用于显示动态内容\"><a href=\"#Popover-用于显示动态内容\" class=\"headerlink\" title=\"Popover 用于显示动态内容\"></a>Popover 用于显示动态内容</h3><p>Popover 也可以用来显示动态内容，这意味着你可以根据某些状态或者条件来决定展示什么内容。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\">.popover(isPresented: <span class=\"hljs-variable\">$showingPopover</span>) &#123;<br>    <span class=\"hljs-keyword\">if</span> someCondition &#123;<br>        <span class=\"hljs-type\">SomeView</span>()<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>        <span class=\"hljs-type\">AnotherView</span>()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"Popover-与-item-绑定\"><a href=\"#Popover-与-item-绑定\" class=\"headerlink\" title=\"Popover 与 item 绑定\"></a>Popover 与 <code>item</code> 绑定</h3><p>除了使用布尔值，popover 还可以通过绑定到一个可选项上来展示，这可以使你基于选择的特定对象显示不同的 popover。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ContentView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> selectedPerson: <span class=\"hljs-type\">Person</span>?<br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">List</span>(people) &#123; person <span class=\"hljs-keyword\">in</span><br>            <span class=\"hljs-type\">Text</span>(person.name)<br>                .onTapGesture &#123;<br>                    <span class=\"hljs-keyword\">self</span>.selectedPerson <span class=\"hljs-operator\">=</span> person<br>                &#125;<br>        &#125;<br>        .popover(item: <span class=\"hljs-variable\">$selectedPerson</span>) &#123; person <span class=\"hljs-keyword\">in</span><br>            <span class=\"hljs-type\">PersonDetailView</span>(person: person)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Person</span>: <span class=\"hljs-title class_\">Identifiable</span> &#123;<br>    <span class=\"hljs-keyword\">let</span> id: <span class=\"hljs-type\">UUID</span><br>    <span class=\"hljs-keyword\">let</span> name: <span class=\"hljs-type\">String</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在上面的例子中，每个人的名字是一个列表项。当点击名字时，<code>selectedPerson</code> 被设置为该 <code>Person</code> 实例，并且展示了一个 popover 来显示更多关于这个人的详情。</p>\n<h3 id=\"在不同设备上的表现\"><a href=\"#在不同设备上的表现\" class=\"headerlink\" title=\"在不同设备上的表现\"></a>在不同设备上的表现</h3><p>Popover 在 iPadOS 上以浮动视图的形式展现，在 iPhone 上则会占据整个屏幕，类似于 modal presentation。因此，设计你的 popover 内容时，要考虑它在不同设备上的表现。</p>\n<p>Popover 通常用于临时任务或补充内容的场景，它的优点在于能够保持用户在当前的上下文中，同时提供额外的交互或信息。与其它模态视图一样，它们应该被谨慎使用，以免打断用户的工作流程。</p>\n"},{"title":"SwiftUI中VStack的用法","date":"2023-11-07T13:54:54.000Z","_content":"在 SwiftUI 中，`VStack` 是一个容器视图，它在垂直方向上排列其子视图。这是组织多个子视图，使其在单列中自上而下排列的一种简单有效的方式。\n\n以下是 `VStack` 的基本和高级用法：\n\n### 基本用法\n\n```swift\nVStack {\n    Text(\"First Line\")\n    Text(\"Second Line\")\n    Text(\"Third Line\")\n}\n```\n\n这将会把三行文本垂直排列。\n\n### 调整间距\n\n通过间距参数可以调整子视图之间的距离。\n\n```swift\nVStack(spacing: 10) {\n    Text(\"First Line\")\n    Text(\"Second Line\")\n    Text(\"Third Line\")\n}\n```\n\n这样设置会在每行文本之间添加10点的空间。\n\n### 对齐\n\n`VStack` 默认在水平方向上是居中对齐的，但可以改变这个对齐方式：\n\n```swift\nVStack(alignment: .leading) {\n    Text(\"Aligned to\")\n    Text(\"the leading edge\")\n}\n```\n\n这样会将文本对齐到 VStack 的前缘（左边）。\n\n### 使用 Spacer\n\n`Spacer` 可以用来推动子视图，让它们靠近容器的边缘或者分散对齐。\n\n```swift\nVStack {\n    Text(\"Top\")\n    Spacer() // 推动所有内容到顶部和底部\n    Text(\"Bottom\")\n}\n```\n\n这里的 `Spacer` 会尝试占据所有可用的垂直空间，推动“Top”到顶部，将“Bottom”推到底部。\n\n### 嵌套使用\n\n可以在 `VStack` 中嵌套其他 `HStack` 或 `VStack` 来创建复杂的布局结构。\n\n```swift\nVStack {\n    HStack {\n        Text(\"Top Left\")\n        Text(\"Top Right\")\n    }\n    HStack {\n        Text(\"Bottom Left\")\n        Text(\"Bottom Right\")\n    }\n}\n```\n\n这将创建一个两行的布局，每行都有左右两个文本视图。\n\n### 结合 Frame 和 Alignment 使用\n\n你可以为 `VStack` 或其子视图指定大小和对齐方式：\n\n```swift\nVStack(alignment: .trailing) {\n    Text(\"Line 1\")\n        .frame(width: 200)\n    Text(\"Line 2 is longer\")\n        .frame(width: 150, alignment: .trailing)\n}\n```\n\n这样会使 `VStack` 的文本对齐到右边，尽管子视图的宽度不同。\n\n### 在实际应用中\n\n`VStack` 经常被用来组织表单、列表的单个项、或者任何需要垂直排列的内容。\n\n```swift\nVStack {\n    Image(systemName: \"photo\")\n    Text(\"Welcome to SwiftUI\")\n        .font(.title)\n    Text(\"Let's build some UIs!\")\n        .font(.subheadline)\n}\n.padding()\n```\n\n在这个例子中，图像位于顶部，紧接着是标题和副标题，所有内容都在 `VStack` 中垂直排列，并且使用 `.padding` 修饰符在周围添加空间。\n\n`VStack` 是实现 SwiftUI 应用程序中垂直布局的基石，与 `HStack`、`ZStack` 和其他容器视图一起，可以构建出几乎任何布局结构。","source":"_posts/SwiftUI中VStack的用法.md","raw":"---\ntitle: SwiftUI中VStack的用法\ndate: 2023-11-07 21:54:54\ncategories:\n- SwiftUI\ntags:\n---\n在 SwiftUI 中，`VStack` 是一个容器视图，它在垂直方向上排列其子视图。这是组织多个子视图，使其在单列中自上而下排列的一种简单有效的方式。\n\n以下是 `VStack` 的基本和高级用法：\n\n### 基本用法\n\n```swift\nVStack {\n    Text(\"First Line\")\n    Text(\"Second Line\")\n    Text(\"Third Line\")\n}\n```\n\n这将会把三行文本垂直排列。\n\n### 调整间距\n\n通过间距参数可以调整子视图之间的距离。\n\n```swift\nVStack(spacing: 10) {\n    Text(\"First Line\")\n    Text(\"Second Line\")\n    Text(\"Third Line\")\n}\n```\n\n这样设置会在每行文本之间添加10点的空间。\n\n### 对齐\n\n`VStack` 默认在水平方向上是居中对齐的，但可以改变这个对齐方式：\n\n```swift\nVStack(alignment: .leading) {\n    Text(\"Aligned to\")\n    Text(\"the leading edge\")\n}\n```\n\n这样会将文本对齐到 VStack 的前缘（左边）。\n\n### 使用 Spacer\n\n`Spacer` 可以用来推动子视图，让它们靠近容器的边缘或者分散对齐。\n\n```swift\nVStack {\n    Text(\"Top\")\n    Spacer() // 推动所有内容到顶部和底部\n    Text(\"Bottom\")\n}\n```\n\n这里的 `Spacer` 会尝试占据所有可用的垂直空间，推动“Top”到顶部，将“Bottom”推到底部。\n\n### 嵌套使用\n\n可以在 `VStack` 中嵌套其他 `HStack` 或 `VStack` 来创建复杂的布局结构。\n\n```swift\nVStack {\n    HStack {\n        Text(\"Top Left\")\n        Text(\"Top Right\")\n    }\n    HStack {\n        Text(\"Bottom Left\")\n        Text(\"Bottom Right\")\n    }\n}\n```\n\n这将创建一个两行的布局，每行都有左右两个文本视图。\n\n### 结合 Frame 和 Alignment 使用\n\n你可以为 `VStack` 或其子视图指定大小和对齐方式：\n\n```swift\nVStack(alignment: .trailing) {\n    Text(\"Line 1\")\n        .frame(width: 200)\n    Text(\"Line 2 is longer\")\n        .frame(width: 150, alignment: .trailing)\n}\n```\n\n这样会使 `VStack` 的文本对齐到右边，尽管子视图的宽度不同。\n\n### 在实际应用中\n\n`VStack` 经常被用来组织表单、列表的单个项、或者任何需要垂直排列的内容。\n\n```swift\nVStack {\n    Image(systemName: \"photo\")\n    Text(\"Welcome to SwiftUI\")\n        .font(.title)\n    Text(\"Let's build some UIs!\")\n        .font(.subheadline)\n}\n.padding()\n```\n\n在这个例子中，图像位于顶部，紧接着是标题和副标题，所有内容都在 `VStack` 中垂直排列，并且使用 `.padding` 修饰符在周围添加空间。\n\n`VStack` 是实现 SwiftUI 应用程序中垂直布局的基石，与 `HStack`、`ZStack` 和其他容器视图一起，可以构建出几乎任何布局结构。","slug":"SwiftUI中VStack的用法","published":1,"updated":"2024-03-17T06:13:24.364Z","comments":1,"layout":"post","photos":[],"_id":"clu6up53f0017z67482h83ipg","content":"<p>在 SwiftUI 中，<code>VStack</code> 是一个容器视图，它在垂直方向上排列其子视图。这是组织多个子视图，使其在单列中自上而下排列的一种简单有效的方式。</p>\n<p>以下是 <code>VStack</code> 的基本和高级用法：</p>\n<h3 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">VStack</span> &#123;<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;First Line&quot;</span>)<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Second Line&quot;</span>)<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Third Line&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这将会把三行文本垂直排列。</p>\n<h3 id=\"调整间距\"><a href=\"#调整间距\" class=\"headerlink\" title=\"调整间距\"></a>调整间距</h3><p>通过间距参数可以调整子视图之间的距离。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">VStack</span>(spacing: <span class=\"hljs-number\">10</span>) &#123;<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;First Line&quot;</span>)<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Second Line&quot;</span>)<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Third Line&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这样设置会在每行文本之间添加10点的空间。</p>\n<h3 id=\"对齐\"><a href=\"#对齐\" class=\"headerlink\" title=\"对齐\"></a>对齐</h3><p><code>VStack</code> 默认在水平方向上是居中对齐的，但可以改变这个对齐方式：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">VStack</span>(alignment: .leading) &#123;<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Aligned to&quot;</span>)<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;the leading edge&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这样会将文本对齐到 VStack 的前缘（左边）。</p>\n<h3 id=\"使用-Spacer\"><a href=\"#使用-Spacer\" class=\"headerlink\" title=\"使用 Spacer\"></a>使用 Spacer</h3><p><code>Spacer</code> 可以用来推动子视图，让它们靠近容器的边缘或者分散对齐。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">VStack</span> &#123;<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Top&quot;</span>)<br>    <span class=\"hljs-type\">Spacer</span>() <span class=\"hljs-comment\">// 推动所有内容到顶部和底部</span><br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Bottom&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这里的 <code>Spacer</code> 会尝试占据所有可用的垂直空间，推动“Top”到顶部，将“Bottom”推到底部。</p>\n<h3 id=\"嵌套使用\"><a href=\"#嵌套使用\" class=\"headerlink\" title=\"嵌套使用\"></a>嵌套使用</h3><p>可以在 <code>VStack</code> 中嵌套其他 <code>HStack</code> 或 <code>VStack</code> 来创建复杂的布局结构。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">VStack</span> &#123;<br>    <span class=\"hljs-type\">HStack</span> &#123;<br>        <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Top Left&quot;</span>)<br>        <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Top Right&quot;</span>)<br>    &#125;<br>    <span class=\"hljs-type\">HStack</span> &#123;<br>        <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Bottom Left&quot;</span>)<br>        <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Bottom Right&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这将创建一个两行的布局，每行都有左右两个文本视图。</p>\n<h3 id=\"结合-Frame-和-Alignment-使用\"><a href=\"#结合-Frame-和-Alignment-使用\" class=\"headerlink\" title=\"结合 Frame 和 Alignment 使用\"></a>结合 Frame 和 Alignment 使用</h3><p>你可以为 <code>VStack</code> 或其子视图指定大小和对齐方式：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">VStack</span>(alignment: .trailing) &#123;<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Line 1&quot;</span>)<br>        .frame(width: <span class=\"hljs-number\">200</span>)<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Line 2 is longer&quot;</span>)<br>        .frame(width: <span class=\"hljs-number\">150</span>, alignment: .trailing)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这样会使 <code>VStack</code> 的文本对齐到右边，尽管子视图的宽度不同。</p>\n<h3 id=\"在实际应用中\"><a href=\"#在实际应用中\" class=\"headerlink\" title=\"在实际应用中\"></a>在实际应用中</h3><p><code>VStack</code> 经常被用来组织表单、列表的单个项、或者任何需要垂直排列的内容。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">VStack</span> &#123;<br>    <span class=\"hljs-type\">Image</span>(systemName: <span class=\"hljs-string\">&quot;photo&quot;</span>)<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Welcome to SwiftUI&quot;</span>)<br>        .font(.title)<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Let&#x27;s build some UIs!&quot;</span>)<br>        .font(.subheadline)<br>&#125;<br>.padding()<br></code></pre></td></tr></table></figure>\n\n<p>在这个例子中，图像位于顶部，紧接着是标题和副标题，所有内容都在 <code>VStack</code> 中垂直排列，并且使用 <code>.padding</code> 修饰符在周围添加空间。</p>\n<p><code>VStack</code> 是实现 SwiftUI 应用程序中垂直布局的基石，与 <code>HStack</code>、<code>ZStack</code> 和其他容器视图一起，可以构建出几乎任何布局结构。</p>\n","excerpt":"","more":"<p>在 SwiftUI 中，<code>VStack</code> 是一个容器视图，它在垂直方向上排列其子视图。这是组织多个子视图，使其在单列中自上而下排列的一种简单有效的方式。</p>\n<p>以下是 <code>VStack</code> 的基本和高级用法：</p>\n<h3 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">VStack</span> &#123;<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;First Line&quot;</span>)<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Second Line&quot;</span>)<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Third Line&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这将会把三行文本垂直排列。</p>\n<h3 id=\"调整间距\"><a href=\"#调整间距\" class=\"headerlink\" title=\"调整间距\"></a>调整间距</h3><p>通过间距参数可以调整子视图之间的距离。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">VStack</span>(spacing: <span class=\"hljs-number\">10</span>) &#123;<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;First Line&quot;</span>)<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Second Line&quot;</span>)<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Third Line&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这样设置会在每行文本之间添加10点的空间。</p>\n<h3 id=\"对齐\"><a href=\"#对齐\" class=\"headerlink\" title=\"对齐\"></a>对齐</h3><p><code>VStack</code> 默认在水平方向上是居中对齐的，但可以改变这个对齐方式：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">VStack</span>(alignment: .leading) &#123;<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Aligned to&quot;</span>)<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;the leading edge&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这样会将文本对齐到 VStack 的前缘（左边）。</p>\n<h3 id=\"使用-Spacer\"><a href=\"#使用-Spacer\" class=\"headerlink\" title=\"使用 Spacer\"></a>使用 Spacer</h3><p><code>Spacer</code> 可以用来推动子视图，让它们靠近容器的边缘或者分散对齐。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">VStack</span> &#123;<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Top&quot;</span>)<br>    <span class=\"hljs-type\">Spacer</span>() <span class=\"hljs-comment\">// 推动所有内容到顶部和底部</span><br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Bottom&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这里的 <code>Spacer</code> 会尝试占据所有可用的垂直空间，推动“Top”到顶部，将“Bottom”推到底部。</p>\n<h3 id=\"嵌套使用\"><a href=\"#嵌套使用\" class=\"headerlink\" title=\"嵌套使用\"></a>嵌套使用</h3><p>可以在 <code>VStack</code> 中嵌套其他 <code>HStack</code> 或 <code>VStack</code> 来创建复杂的布局结构。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">VStack</span> &#123;<br>    <span class=\"hljs-type\">HStack</span> &#123;<br>        <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Top Left&quot;</span>)<br>        <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Top Right&quot;</span>)<br>    &#125;<br>    <span class=\"hljs-type\">HStack</span> &#123;<br>        <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Bottom Left&quot;</span>)<br>        <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Bottom Right&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这将创建一个两行的布局，每行都有左右两个文本视图。</p>\n<h3 id=\"结合-Frame-和-Alignment-使用\"><a href=\"#结合-Frame-和-Alignment-使用\" class=\"headerlink\" title=\"结合 Frame 和 Alignment 使用\"></a>结合 Frame 和 Alignment 使用</h3><p>你可以为 <code>VStack</code> 或其子视图指定大小和对齐方式：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">VStack</span>(alignment: .trailing) &#123;<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Line 1&quot;</span>)<br>        .frame(width: <span class=\"hljs-number\">200</span>)<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Line 2 is longer&quot;</span>)<br>        .frame(width: <span class=\"hljs-number\">150</span>, alignment: .trailing)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这样会使 <code>VStack</code> 的文本对齐到右边，尽管子视图的宽度不同。</p>\n<h3 id=\"在实际应用中\"><a href=\"#在实际应用中\" class=\"headerlink\" title=\"在实际应用中\"></a>在实际应用中</h3><p><code>VStack</code> 经常被用来组织表单、列表的单个项、或者任何需要垂直排列的内容。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">VStack</span> &#123;<br>    <span class=\"hljs-type\">Image</span>(systemName: <span class=\"hljs-string\">&quot;photo&quot;</span>)<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Welcome to SwiftUI&quot;</span>)<br>        .font(.title)<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Let&#x27;s build some UIs!&quot;</span>)<br>        .font(.subheadline)<br>&#125;<br>.padding()<br></code></pre></td></tr></table></figure>\n\n<p>在这个例子中，图像位于顶部，紧接着是标题和副标题，所有内容都在 <code>VStack</code> 中垂直排列，并且使用 <code>.padding</code> 修饰符在周围添加空间。</p>\n<p><code>VStack</code> 是实现 SwiftUI 应用程序中垂直布局的基石，与 <code>HStack</code>、<code>ZStack</code> 和其他容器视图一起，可以构建出几乎任何布局结构。</p>\n"},{"title":"SwiftUI中ZStack的用法","date":"2023-11-07T13:57:02.000Z","_content":"`ZStack` 在 SwiftUI 中是用来重叠视图的，它按照代码中的顺序堆叠视图，最先声明的视图会出现在底部，随后声明的视图则依次叠加在上面。这对于创建覆盖效果或者需要视图叠加的界面非常有用。\n\n以下是 `ZStack` 的一些基本用法：\n\n### 基本用法\n\n```swift\nZStack {\n    Text(\"Underneath\")\n    Text(\"On top\")\n}\n```\n\n第二个 `Text` 视图将会覆盖在第一个 `Text` 视图上面。\n\n### 对齐\n\n`ZStack` 默认会将所有子视图居中对齐，但可以指定一个不同的对齐方式。\n\n```swift\nZStack(alignment: .topLeading) {\n    Text(\"Aligned to the top leading corner\")\n    Text(\"Second view\")\n}\n```\n\n上面的代码会使所有子视图在 ZStack 的顶部左侧对齐。\n\n### 使用背景和覆盖\n\n`ZStack` 常用来给视图添加背景或者覆盖。\n\n```swift\nZStack {\n    Image(\"photo\")\n        .resizable()\n        .aspectRatio(contentMode: .fit)\n    Text(\"Over the Image\")\n        .font(.caption)\n        .foregroundColor(.white)\n        .padding(5)\n        .background(Color.black.opacity(0.7))\n        .cornerRadius(10)\n        .padding(10)\n}\n```\n\n文本会作为覆盖层显示在图片上，并且带有半透明的黑色背景以确保文字的可读性。\n\n### 结合 Frame 和 Alignment 使用\n\n可以通过 `frame` 和 `alignment` 属性来控制子视图的大小和位置。\n\n```swift\nZStack {\n    Color.blue\n    VStack {\n        Text(\"Hello\")\n        Text(\"World\")\n    }\n    .alignmentGuide(.top) { d in d[.top] }\n    .frame(width: 200, height: 200, alignment: .top)\n}\n```\n\n在这个例子中，`VStack` 被设定在蓝色背景的上方，并且它的大小被限制为 200x200。\n\n### 在实际应用中\n\n`ZStack` 可以创建自定义的复杂视图，如下面的代码片段中，一个定制按钮的视觉效果就是通过 `ZStack` 实现的：\n\n```swift\nZStack {\n    Circle()\n        .fill(Color.blue)\n        .frame(width: 100, height: 100)\n    Text(\"Click Me\")\n        .font(.title)\n        .foregroundColor(.white)\n}\n```\n\n这会创建一个带有文本的圆形按钮视图。\n\n`ZStack` 是一个非常强大的工具，允许开发者在 SwiftUI 中以创造性的方式构建复杂且富有层次感的用户界面。通过合理地堆叠和对齐视图，可以实现各种自定义设计。","source":"_posts/SwiftUI中ZStack的用法.md","raw":"---\ntitle: SwiftUI中ZStack的用法\ndate: 2023-11-07 21:57:02\ncategories:\n- SwiftUI\ntags:\n---\n`ZStack` 在 SwiftUI 中是用来重叠视图的，它按照代码中的顺序堆叠视图，最先声明的视图会出现在底部，随后声明的视图则依次叠加在上面。这对于创建覆盖效果或者需要视图叠加的界面非常有用。\n\n以下是 `ZStack` 的一些基本用法：\n\n### 基本用法\n\n```swift\nZStack {\n    Text(\"Underneath\")\n    Text(\"On top\")\n}\n```\n\n第二个 `Text` 视图将会覆盖在第一个 `Text` 视图上面。\n\n### 对齐\n\n`ZStack` 默认会将所有子视图居中对齐，但可以指定一个不同的对齐方式。\n\n```swift\nZStack(alignment: .topLeading) {\n    Text(\"Aligned to the top leading corner\")\n    Text(\"Second view\")\n}\n```\n\n上面的代码会使所有子视图在 ZStack 的顶部左侧对齐。\n\n### 使用背景和覆盖\n\n`ZStack` 常用来给视图添加背景或者覆盖。\n\n```swift\nZStack {\n    Image(\"photo\")\n        .resizable()\n        .aspectRatio(contentMode: .fit)\n    Text(\"Over the Image\")\n        .font(.caption)\n        .foregroundColor(.white)\n        .padding(5)\n        .background(Color.black.opacity(0.7))\n        .cornerRadius(10)\n        .padding(10)\n}\n```\n\n文本会作为覆盖层显示在图片上，并且带有半透明的黑色背景以确保文字的可读性。\n\n### 结合 Frame 和 Alignment 使用\n\n可以通过 `frame` 和 `alignment` 属性来控制子视图的大小和位置。\n\n```swift\nZStack {\n    Color.blue\n    VStack {\n        Text(\"Hello\")\n        Text(\"World\")\n    }\n    .alignmentGuide(.top) { d in d[.top] }\n    .frame(width: 200, height: 200, alignment: .top)\n}\n```\n\n在这个例子中，`VStack` 被设定在蓝色背景的上方，并且它的大小被限制为 200x200。\n\n### 在实际应用中\n\n`ZStack` 可以创建自定义的复杂视图，如下面的代码片段中，一个定制按钮的视觉效果就是通过 `ZStack` 实现的：\n\n```swift\nZStack {\n    Circle()\n        .fill(Color.blue)\n        .frame(width: 100, height: 100)\n    Text(\"Click Me\")\n        .font(.title)\n        .foregroundColor(.white)\n}\n```\n\n这会创建一个带有文本的圆形按钮视图。\n\n`ZStack` 是一个非常强大的工具，允许开发者在 SwiftUI 中以创造性的方式构建复杂且富有层次感的用户界面。通过合理地堆叠和对齐视图，可以实现各种自定义设计。","slug":"SwiftUI中ZStack的用法","published":1,"updated":"2024-03-17T06:13:27.124Z","comments":1,"layout":"post","photos":[],"_id":"clu6up53f0019z67416hje63d","content":"<p><code>ZStack</code> 在 SwiftUI 中是用来重叠视图的，它按照代码中的顺序堆叠视图，最先声明的视图会出现在底部，随后声明的视图则依次叠加在上面。这对于创建覆盖效果或者需要视图叠加的界面非常有用。</p>\n<p>以下是 <code>ZStack</code> 的一些基本用法：</p>\n<h3 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">ZStack</span> &#123;<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Underneath&quot;</span>)<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;On top&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>第二个 <code>Text</code> 视图将会覆盖在第一个 <code>Text</code> 视图上面。</p>\n<h3 id=\"对齐\"><a href=\"#对齐\" class=\"headerlink\" title=\"对齐\"></a>对齐</h3><p><code>ZStack</code> 默认会将所有子视图居中对齐，但可以指定一个不同的对齐方式。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">ZStack</span>(alignment: .topLeading) &#123;<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Aligned to the top leading corner&quot;</span>)<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Second view&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>上面的代码会使所有子视图在 ZStack 的顶部左侧对齐。</p>\n<h3 id=\"使用背景和覆盖\"><a href=\"#使用背景和覆盖\" class=\"headerlink\" title=\"使用背景和覆盖\"></a>使用背景和覆盖</h3><p><code>ZStack</code> 常用来给视图添加背景或者覆盖。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">ZStack</span> &#123;<br>    <span class=\"hljs-type\">Image</span>(<span class=\"hljs-string\">&quot;photo&quot;</span>)<br>        .resizable()<br>        .aspectRatio(contentMode: .fit)<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Over the Image&quot;</span>)<br>        .font(.caption)<br>        .foregroundColor(.white)<br>        .padding(<span class=\"hljs-number\">5</span>)<br>        .background(<span class=\"hljs-type\">Color</span>.black.opacity(<span class=\"hljs-number\">0.7</span>))<br>        .cornerRadius(<span class=\"hljs-number\">10</span>)<br>        .padding(<span class=\"hljs-number\">10</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>文本会作为覆盖层显示在图片上，并且带有半透明的黑色背景以确保文字的可读性。</p>\n<h3 id=\"结合-Frame-和-Alignment-使用\"><a href=\"#结合-Frame-和-Alignment-使用\" class=\"headerlink\" title=\"结合 Frame 和 Alignment 使用\"></a>结合 Frame 和 Alignment 使用</h3><p>可以通过 <code>frame</code> 和 <code>alignment</code> 属性来控制子视图的大小和位置。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">ZStack</span> &#123;<br>    <span class=\"hljs-type\">Color</span>.blue<br>    <span class=\"hljs-type\">VStack</span> &#123;<br>        <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Hello&quot;</span>)<br>        <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;World&quot;</span>)<br>    &#125;<br>    .alignmentGuide(.top) &#123; d <span class=\"hljs-keyword\">in</span> d[.top] &#125;<br>    .frame(width: <span class=\"hljs-number\">200</span>, height: <span class=\"hljs-number\">200</span>, alignment: .top)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在这个例子中，<code>VStack</code> 被设定在蓝色背景的上方，并且它的大小被限制为 200x200。</p>\n<h3 id=\"在实际应用中\"><a href=\"#在实际应用中\" class=\"headerlink\" title=\"在实际应用中\"></a>在实际应用中</h3><p><code>ZStack</code> 可以创建自定义的复杂视图，如下面的代码片段中，一个定制按钮的视觉效果就是通过 <code>ZStack</code> 实现的：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">ZStack</span> &#123;<br>    <span class=\"hljs-type\">Circle</span>()<br>        .fill(<span class=\"hljs-type\">Color</span>.blue)<br>        .frame(width: <span class=\"hljs-number\">100</span>, height: <span class=\"hljs-number\">100</span>)<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Click Me&quot;</span>)<br>        .font(.title)<br>        .foregroundColor(.white)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这会创建一个带有文本的圆形按钮视图。</p>\n<p><code>ZStack</code> 是一个非常强大的工具，允许开发者在 SwiftUI 中以创造性的方式构建复杂且富有层次感的用户界面。通过合理地堆叠和对齐视图，可以实现各种自定义设计。</p>\n","excerpt":"","more":"<p><code>ZStack</code> 在 SwiftUI 中是用来重叠视图的，它按照代码中的顺序堆叠视图，最先声明的视图会出现在底部，随后声明的视图则依次叠加在上面。这对于创建覆盖效果或者需要视图叠加的界面非常有用。</p>\n<p>以下是 <code>ZStack</code> 的一些基本用法：</p>\n<h3 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">ZStack</span> &#123;<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Underneath&quot;</span>)<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;On top&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>第二个 <code>Text</code> 视图将会覆盖在第一个 <code>Text</code> 视图上面。</p>\n<h3 id=\"对齐\"><a href=\"#对齐\" class=\"headerlink\" title=\"对齐\"></a>对齐</h3><p><code>ZStack</code> 默认会将所有子视图居中对齐，但可以指定一个不同的对齐方式。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">ZStack</span>(alignment: .topLeading) &#123;<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Aligned to the top leading corner&quot;</span>)<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Second view&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>上面的代码会使所有子视图在 ZStack 的顶部左侧对齐。</p>\n<h3 id=\"使用背景和覆盖\"><a href=\"#使用背景和覆盖\" class=\"headerlink\" title=\"使用背景和覆盖\"></a>使用背景和覆盖</h3><p><code>ZStack</code> 常用来给视图添加背景或者覆盖。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">ZStack</span> &#123;<br>    <span class=\"hljs-type\">Image</span>(<span class=\"hljs-string\">&quot;photo&quot;</span>)<br>        .resizable()<br>        .aspectRatio(contentMode: .fit)<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Over the Image&quot;</span>)<br>        .font(.caption)<br>        .foregroundColor(.white)<br>        .padding(<span class=\"hljs-number\">5</span>)<br>        .background(<span class=\"hljs-type\">Color</span>.black.opacity(<span class=\"hljs-number\">0.7</span>))<br>        .cornerRadius(<span class=\"hljs-number\">10</span>)<br>        .padding(<span class=\"hljs-number\">10</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>文本会作为覆盖层显示在图片上，并且带有半透明的黑色背景以确保文字的可读性。</p>\n<h3 id=\"结合-Frame-和-Alignment-使用\"><a href=\"#结合-Frame-和-Alignment-使用\" class=\"headerlink\" title=\"结合 Frame 和 Alignment 使用\"></a>结合 Frame 和 Alignment 使用</h3><p>可以通过 <code>frame</code> 和 <code>alignment</code> 属性来控制子视图的大小和位置。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">ZStack</span> &#123;<br>    <span class=\"hljs-type\">Color</span>.blue<br>    <span class=\"hljs-type\">VStack</span> &#123;<br>        <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Hello&quot;</span>)<br>        <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;World&quot;</span>)<br>    &#125;<br>    .alignmentGuide(.top) &#123; d <span class=\"hljs-keyword\">in</span> d[.top] &#125;<br>    .frame(width: <span class=\"hljs-number\">200</span>, height: <span class=\"hljs-number\">200</span>, alignment: .top)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在这个例子中，<code>VStack</code> 被设定在蓝色背景的上方，并且它的大小被限制为 200x200。</p>\n<h3 id=\"在实际应用中\"><a href=\"#在实际应用中\" class=\"headerlink\" title=\"在实际应用中\"></a>在实际应用中</h3><p><code>ZStack</code> 可以创建自定义的复杂视图，如下面的代码片段中，一个定制按钮的视觉效果就是通过 <code>ZStack</code> 实现的：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">ZStack</span> &#123;<br>    <span class=\"hljs-type\">Circle</span>()<br>        .fill(<span class=\"hljs-type\">Color</span>.blue)<br>        .frame(width: <span class=\"hljs-number\">100</span>, height: <span class=\"hljs-number\">100</span>)<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Click Me&quot;</span>)<br>        .font(.title)<br>        .foregroundColor(.white)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这会创建一个带有文本的圆形按钮视图。</p>\n<p><code>ZStack</code> 是一个非常强大的工具，允许开发者在 SwiftUI 中以创造性的方式构建复杂且富有层次感的用户界面。通过合理地堆叠和对齐视图，可以实现各种自定义设计。</p>\n"},{"title":"SwiftUI中的Image组件的用法","date":"2023-11-07T12:19:55.000Z","_content":"在 SwiftUI 中，`Image` 视图用于显示图片。你可以使用多种来源的图片，包括应用的资源包、系统图标库以及从网络获取的图片。下面是一些 `Image` 组件的基本和进阶用法。\n\n### 基础用法\n\n#### 从 Assets.xcassets 加载图片：\n\n```swift\nImage(\"myImage\") // \"myImage\" 是你的图片在 Assets.xcassets 中的名称\n```\n\n#### 使用系统图标：\n\n```swift\nImage(systemName: \"star.fill\") // 使用 SF Symbols 的图标\n```\n\n### 常用修饰符\n\n#### 重新着色（tinting）：\n\n```swift\nImage(\"myImage\")\n    .resizable() // 允许图片被拉伸\n    .renderingMode(.template) // 将图片设置为模板模式\n    .foregroundColor(.blue) // 改变图片颜色\n```\n\n#### 缩放以适应容器大小：\n\n```swift\nImage(\"myImage\")\n    .resizable() // 允许图片被拉伸\n    .aspectRatio(contentMode: .fit) // 保持图片的宽高比\n```\n\n#### 填充整个容器：\n\n```swift\nImage(\"myImage\")\n    .resizable()\n    .aspectRatio(contentMode: .fill) // 图片可能会超出容器大小\n    .clipped() // 超出部分将被裁剪\n```\n\n#### 调整图片大小：\n\n```swift\nImage(\"myImage\")\n    .resizable()\n    .frame(width: 100, height: 100) // 指定图片的宽和高\n```\n\n#### 圆形剪裁：\n\n```swift\nImage(\"myImage\")\n    .resizable()\n    .scaledToFill()\n    .frame(width: 100, height: 100)\n    .clipShape(Circle()) // 将图片剪裁成圆形\n    .overlay(Circle().stroke(Color.white, lineWidth: 4)) // 圆形边框\n    .shadow(radius: 10) // 阴影效果\n```\n\n### 高级用法\n\n#### 图片叠加（Overlay）：\n\n```swift\nImage(\"myImage\")\n    .resizable()\n    .scaledToFit()\n    .overlay(\n        Text(\"Overlay\") // 在图片上添加文本覆盖层\n            .font(.caption)\n            .padding(5)\n            .background(Color.black.opacity(0.5))\n            .cornerRadius(5)\n            .foregroundColor(.white)\n            .padding(10), // 文本内边距\n        alignment: .bottomTrailing // 对齐到图片的右下角\n    )\n```\n\n#### 图片遮罩（Masking）：\n\n```swift\nImage(\"myImage\")\n    .resizable()\n    .scaledToFit()\n    .mask(\n        Text(\"SwiftUI\") // 使用文本作为遮罩\n            .font(.system(size: 72))\n            .bold()\n    )\n```\n\n#### 图片动画：\n\n```swift\n@State private var isRotated = false\n\nvar body: some View {\n    Image(\"myImage\")\n        .resizable()\n        .rotationEffect(.degrees(isRotated ? 360 : 0)) // 旋转动画\n        .animation(.linear(duration: 2), value: isRotated)\n        .onAppear {\n            isRotated.toggle()\n        }\n}\n```\n\n### 使用网络图片\n\n在 SwiftUI 中，没有内置从网络直接加载图片的方法。通常，你需要使用 `URLSession` 获取图片数据，然后将数据转换为 `UIImage`（在 iOS 上）或 `NSImage`（在 macOS 上），最后将其转换为 SwiftUI 可以使用的 `Image`。或者你可以使用第三方库，如 `SDWebImageSwiftUI` 来简化网络图片的加载过程。\n\n在 SwiftUI 2.0 之后的版本，`AsyncImage` 视图提供了一个原生的异步加载网络图片的方法：\n\n```swift\nAsyncImage(url: URL(string: \"https://example.com/myImage.png\")) { image in\n    image.resizable() // 如果成功加载，显示图片\n}\nplaceholder: {\n    ProgressView() // 在加载期间显示加载指示器\n}\n.frame(width: 100, height: 100)\n```\n\n`Image` 视图在 SwiftUI 中是核心组件之一，它配\n\n合修饰符和其他视图，能够实现丰富多彩的用户界面元素。","source":"_posts/SwiftUI中的Image组件的用法.md","raw":"---\ntitle: SwiftUI中的Image组件的用法\ndate: 2023-11-07 20:19:55\ncategories:\n- SwiftUI\ntags:\n---\n在 SwiftUI 中，`Image` 视图用于显示图片。你可以使用多种来源的图片，包括应用的资源包、系统图标库以及从网络获取的图片。下面是一些 `Image` 组件的基本和进阶用法。\n\n### 基础用法\n\n#### 从 Assets.xcassets 加载图片：\n\n```swift\nImage(\"myImage\") // \"myImage\" 是你的图片在 Assets.xcassets 中的名称\n```\n\n#### 使用系统图标：\n\n```swift\nImage(systemName: \"star.fill\") // 使用 SF Symbols 的图标\n```\n\n### 常用修饰符\n\n#### 重新着色（tinting）：\n\n```swift\nImage(\"myImage\")\n    .resizable() // 允许图片被拉伸\n    .renderingMode(.template) // 将图片设置为模板模式\n    .foregroundColor(.blue) // 改变图片颜色\n```\n\n#### 缩放以适应容器大小：\n\n```swift\nImage(\"myImage\")\n    .resizable() // 允许图片被拉伸\n    .aspectRatio(contentMode: .fit) // 保持图片的宽高比\n```\n\n#### 填充整个容器：\n\n```swift\nImage(\"myImage\")\n    .resizable()\n    .aspectRatio(contentMode: .fill) // 图片可能会超出容器大小\n    .clipped() // 超出部分将被裁剪\n```\n\n#### 调整图片大小：\n\n```swift\nImage(\"myImage\")\n    .resizable()\n    .frame(width: 100, height: 100) // 指定图片的宽和高\n```\n\n#### 圆形剪裁：\n\n```swift\nImage(\"myImage\")\n    .resizable()\n    .scaledToFill()\n    .frame(width: 100, height: 100)\n    .clipShape(Circle()) // 将图片剪裁成圆形\n    .overlay(Circle().stroke(Color.white, lineWidth: 4)) // 圆形边框\n    .shadow(radius: 10) // 阴影效果\n```\n\n### 高级用法\n\n#### 图片叠加（Overlay）：\n\n```swift\nImage(\"myImage\")\n    .resizable()\n    .scaledToFit()\n    .overlay(\n        Text(\"Overlay\") // 在图片上添加文本覆盖层\n            .font(.caption)\n            .padding(5)\n            .background(Color.black.opacity(0.5))\n            .cornerRadius(5)\n            .foregroundColor(.white)\n            .padding(10), // 文本内边距\n        alignment: .bottomTrailing // 对齐到图片的右下角\n    )\n```\n\n#### 图片遮罩（Masking）：\n\n```swift\nImage(\"myImage\")\n    .resizable()\n    .scaledToFit()\n    .mask(\n        Text(\"SwiftUI\") // 使用文本作为遮罩\n            .font(.system(size: 72))\n            .bold()\n    )\n```\n\n#### 图片动画：\n\n```swift\n@State private var isRotated = false\n\nvar body: some View {\n    Image(\"myImage\")\n        .resizable()\n        .rotationEffect(.degrees(isRotated ? 360 : 0)) // 旋转动画\n        .animation(.linear(duration: 2), value: isRotated)\n        .onAppear {\n            isRotated.toggle()\n        }\n}\n```\n\n### 使用网络图片\n\n在 SwiftUI 中，没有内置从网络直接加载图片的方法。通常，你需要使用 `URLSession` 获取图片数据，然后将数据转换为 `UIImage`（在 iOS 上）或 `NSImage`（在 macOS 上），最后将其转换为 SwiftUI 可以使用的 `Image`。或者你可以使用第三方库，如 `SDWebImageSwiftUI` 来简化网络图片的加载过程。\n\n在 SwiftUI 2.0 之后的版本，`AsyncImage` 视图提供了一个原生的异步加载网络图片的方法：\n\n```swift\nAsyncImage(url: URL(string: \"https://example.com/myImage.png\")) { image in\n    image.resizable() // 如果成功加载，显示图片\n}\nplaceholder: {\n    ProgressView() // 在加载期间显示加载指示器\n}\n.frame(width: 100, height: 100)\n```\n\n`Image` 视图在 SwiftUI 中是核心组件之一，它配\n\n合修饰符和其他视图，能够实现丰富多彩的用户界面元素。","slug":"SwiftUI中的Image组件的用法","published":1,"updated":"2024-03-17T06:12:34.479Z","comments":1,"layout":"post","photos":[],"_id":"clu6up53f001bz6747s4zb3nf","content":"<p>在 SwiftUI 中，<code>Image</code> 视图用于显示图片。你可以使用多种来源的图片，包括应用的资源包、系统图标库以及从网络获取的图片。下面是一些 <code>Image</code> 组件的基本和进阶用法。</p>\n<h3 id=\"基础用法\"><a href=\"#基础用法\" class=\"headerlink\" title=\"基础用法\"></a>基础用法</h3><h4 id=\"从-Assets-xcassets-加载图片：\"><a href=\"#从-Assets-xcassets-加载图片：\" class=\"headerlink\" title=\"从 Assets.xcassets 加载图片：\"></a>从 Assets.xcassets 加载图片：</h4><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Image</span>(<span class=\"hljs-string\">&quot;myImage&quot;</span>) <span class=\"hljs-comment\">// &quot;myImage&quot; 是你的图片在 Assets.xcassets 中的名称</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"使用系统图标：\"><a href=\"#使用系统图标：\" class=\"headerlink\" title=\"使用系统图标：\"></a>使用系统图标：</h4><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Image</span>(systemName: <span class=\"hljs-string\">&quot;star.fill&quot;</span>) <span class=\"hljs-comment\">// 使用 SF Symbols 的图标</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"常用修饰符\"><a href=\"#常用修饰符\" class=\"headerlink\" title=\"常用修饰符\"></a>常用修饰符</h3><h4 id=\"重新着色（tinting）：\"><a href=\"#重新着色（tinting）：\" class=\"headerlink\" title=\"重新着色（tinting）：\"></a>重新着色（tinting）：</h4><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Image</span>(<span class=\"hljs-string\">&quot;myImage&quot;</span>)<br>    .resizable() <span class=\"hljs-comment\">// 允许图片被拉伸</span><br>    .renderingMode(.template) <span class=\"hljs-comment\">// 将图片设置为模板模式</span><br>    .foregroundColor(.blue) <span class=\"hljs-comment\">// 改变图片颜色</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"缩放以适应容器大小：\"><a href=\"#缩放以适应容器大小：\" class=\"headerlink\" title=\"缩放以适应容器大小：\"></a>缩放以适应容器大小：</h4><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Image</span>(<span class=\"hljs-string\">&quot;myImage&quot;</span>)<br>    .resizable() <span class=\"hljs-comment\">// 允许图片被拉伸</span><br>    .aspectRatio(contentMode: .fit) <span class=\"hljs-comment\">// 保持图片的宽高比</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"填充整个容器：\"><a href=\"#填充整个容器：\" class=\"headerlink\" title=\"填充整个容器：\"></a>填充整个容器：</h4><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Image</span>(<span class=\"hljs-string\">&quot;myImage&quot;</span>)<br>    .resizable()<br>    .aspectRatio(contentMode: .fill) <span class=\"hljs-comment\">// 图片可能会超出容器大小</span><br>    .clipped() <span class=\"hljs-comment\">// 超出部分将被裁剪</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"调整图片大小：\"><a href=\"#调整图片大小：\" class=\"headerlink\" title=\"调整图片大小：\"></a>调整图片大小：</h4><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Image</span>(<span class=\"hljs-string\">&quot;myImage&quot;</span>)<br>    .resizable()<br>    .frame(width: <span class=\"hljs-number\">100</span>, height: <span class=\"hljs-number\">100</span>) <span class=\"hljs-comment\">// 指定图片的宽和高</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"圆形剪裁：\"><a href=\"#圆形剪裁：\" class=\"headerlink\" title=\"圆形剪裁：\"></a>圆形剪裁：</h4><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Image</span>(<span class=\"hljs-string\">&quot;myImage&quot;</span>)<br>    .resizable()<br>    .scaledToFill()<br>    .frame(width: <span class=\"hljs-number\">100</span>, height: <span class=\"hljs-number\">100</span>)<br>    .clipShape(<span class=\"hljs-type\">Circle</span>()) <span class=\"hljs-comment\">// 将图片剪裁成圆形</span><br>    .overlay(<span class=\"hljs-type\">Circle</span>().stroke(<span class=\"hljs-type\">Color</span>.white, lineWidth: <span class=\"hljs-number\">4</span>)) <span class=\"hljs-comment\">// 圆形边框</span><br>    .shadow(radius: <span class=\"hljs-number\">10</span>) <span class=\"hljs-comment\">// 阴影效果</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"高级用法\"><a href=\"#高级用法\" class=\"headerlink\" title=\"高级用法\"></a>高级用法</h3><h4 id=\"图片叠加（Overlay）：\"><a href=\"#图片叠加（Overlay）：\" class=\"headerlink\" title=\"图片叠加（Overlay）：\"></a>图片叠加（Overlay）：</h4><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Image</span>(<span class=\"hljs-string\">&quot;myImage&quot;</span>)<br>    .resizable()<br>    .scaledToFit()<br>    .overlay(<br>        <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Overlay&quot;</span>) <span class=\"hljs-comment\">// 在图片上添加文本覆盖层</span><br>            .font(.caption)<br>            .padding(<span class=\"hljs-number\">5</span>)<br>            .background(<span class=\"hljs-type\">Color</span>.black.opacity(<span class=\"hljs-number\">0.5</span>))<br>            .cornerRadius(<span class=\"hljs-number\">5</span>)<br>            .foregroundColor(.white)<br>            .padding(<span class=\"hljs-number\">10</span>), <span class=\"hljs-comment\">// 文本内边距</span><br>        alignment: .bottomTrailing <span class=\"hljs-comment\">// 对齐到图片的右下角</span><br>    )<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"图片遮罩（Masking）：\"><a href=\"#图片遮罩（Masking）：\" class=\"headerlink\" title=\"图片遮罩（Masking）：\"></a>图片遮罩（Masking）：</h4><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Image</span>(<span class=\"hljs-string\">&quot;myImage&quot;</span>)<br>    .resizable()<br>    .scaledToFit()<br>    .mask(<br>        <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;SwiftUI&quot;</span>) <span class=\"hljs-comment\">// 使用文本作为遮罩</span><br>            .font(.system(size: <span class=\"hljs-number\">72</span>))<br>            .bold()<br>    )<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"图片动画：\"><a href=\"#图片动画：\" class=\"headerlink\" title=\"图片动画：\"></a>图片动画：</h4><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> isRotated <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">false</span><br><br><span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>    <span class=\"hljs-type\">Image</span>(<span class=\"hljs-string\">&quot;myImage&quot;</span>)<br>        .resizable()<br>        .rotationEffect(.degrees(isRotated <span class=\"hljs-operator\">?</span> <span class=\"hljs-number\">360</span> : <span class=\"hljs-number\">0</span>)) <span class=\"hljs-comment\">// 旋转动画</span><br>        .animation(.linear(duration: <span class=\"hljs-number\">2</span>), value: isRotated)<br>        .onAppear &#123;<br>            isRotated.toggle()<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"使用网络图片\"><a href=\"#使用网络图片\" class=\"headerlink\" title=\"使用网络图片\"></a>使用网络图片</h3><p>在 SwiftUI 中，没有内置从网络直接加载图片的方法。通常，你需要使用 <code>URLSession</code> 获取图片数据，然后将数据转换为 <code>UIImage</code>（在 iOS 上）或 <code>NSImage</code>（在 macOS 上），最后将其转换为 SwiftUI 可以使用的 <code>Image</code>。或者你可以使用第三方库，如 <code>SDWebImageSwiftUI</code> 来简化网络图片的加载过程。</p>\n<p>在 SwiftUI 2.0 之后的版本，<code>AsyncImage</code> 视图提供了一个原生的异步加载网络图片的方法：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">AsyncImage</span>(url: <span class=\"hljs-type\">URL</span>(string: <span class=\"hljs-string\">&quot;https://example.com/myImage.png&quot;</span>)) &#123; image <span class=\"hljs-keyword\">in</span><br>    image.resizable() <span class=\"hljs-comment\">// 如果成功加载，显示图片</span><br>&#125;<br>placeholder: &#123;<br>    <span class=\"hljs-type\">ProgressView</span>() <span class=\"hljs-comment\">// 在加载期间显示加载指示器</span><br>&#125;<br>.frame(width: <span class=\"hljs-number\">100</span>, height: <span class=\"hljs-number\">100</span>)<br></code></pre></td></tr></table></figure>\n\n<p><code>Image</code> 视图在 SwiftUI 中是核心组件之一，它配</p>\n<p>合修饰符和其他视图，能够实现丰富多彩的用户界面元素。</p>\n","excerpt":"","more":"<p>在 SwiftUI 中，<code>Image</code> 视图用于显示图片。你可以使用多种来源的图片，包括应用的资源包、系统图标库以及从网络获取的图片。下面是一些 <code>Image</code> 组件的基本和进阶用法。</p>\n<h3 id=\"基础用法\"><a href=\"#基础用法\" class=\"headerlink\" title=\"基础用法\"></a>基础用法</h3><h4 id=\"从-Assets-xcassets-加载图片：\"><a href=\"#从-Assets-xcassets-加载图片：\" class=\"headerlink\" title=\"从 Assets.xcassets 加载图片：\"></a>从 Assets.xcassets 加载图片：</h4><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Image</span>(<span class=\"hljs-string\">&quot;myImage&quot;</span>) <span class=\"hljs-comment\">// &quot;myImage&quot; 是你的图片在 Assets.xcassets 中的名称</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"使用系统图标：\"><a href=\"#使用系统图标：\" class=\"headerlink\" title=\"使用系统图标：\"></a>使用系统图标：</h4><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Image</span>(systemName: <span class=\"hljs-string\">&quot;star.fill&quot;</span>) <span class=\"hljs-comment\">// 使用 SF Symbols 的图标</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"常用修饰符\"><a href=\"#常用修饰符\" class=\"headerlink\" title=\"常用修饰符\"></a>常用修饰符</h3><h4 id=\"重新着色（tinting）：\"><a href=\"#重新着色（tinting）：\" class=\"headerlink\" title=\"重新着色（tinting）：\"></a>重新着色（tinting）：</h4><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Image</span>(<span class=\"hljs-string\">&quot;myImage&quot;</span>)<br>    .resizable() <span class=\"hljs-comment\">// 允许图片被拉伸</span><br>    .renderingMode(.template) <span class=\"hljs-comment\">// 将图片设置为模板模式</span><br>    .foregroundColor(.blue) <span class=\"hljs-comment\">// 改变图片颜色</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"缩放以适应容器大小：\"><a href=\"#缩放以适应容器大小：\" class=\"headerlink\" title=\"缩放以适应容器大小：\"></a>缩放以适应容器大小：</h4><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Image</span>(<span class=\"hljs-string\">&quot;myImage&quot;</span>)<br>    .resizable() <span class=\"hljs-comment\">// 允许图片被拉伸</span><br>    .aspectRatio(contentMode: .fit) <span class=\"hljs-comment\">// 保持图片的宽高比</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"填充整个容器：\"><a href=\"#填充整个容器：\" class=\"headerlink\" title=\"填充整个容器：\"></a>填充整个容器：</h4><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Image</span>(<span class=\"hljs-string\">&quot;myImage&quot;</span>)<br>    .resizable()<br>    .aspectRatio(contentMode: .fill) <span class=\"hljs-comment\">// 图片可能会超出容器大小</span><br>    .clipped() <span class=\"hljs-comment\">// 超出部分将被裁剪</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"调整图片大小：\"><a href=\"#调整图片大小：\" class=\"headerlink\" title=\"调整图片大小：\"></a>调整图片大小：</h4><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Image</span>(<span class=\"hljs-string\">&quot;myImage&quot;</span>)<br>    .resizable()<br>    .frame(width: <span class=\"hljs-number\">100</span>, height: <span class=\"hljs-number\">100</span>) <span class=\"hljs-comment\">// 指定图片的宽和高</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"圆形剪裁：\"><a href=\"#圆形剪裁：\" class=\"headerlink\" title=\"圆形剪裁：\"></a>圆形剪裁：</h4><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Image</span>(<span class=\"hljs-string\">&quot;myImage&quot;</span>)<br>    .resizable()<br>    .scaledToFill()<br>    .frame(width: <span class=\"hljs-number\">100</span>, height: <span class=\"hljs-number\">100</span>)<br>    .clipShape(<span class=\"hljs-type\">Circle</span>()) <span class=\"hljs-comment\">// 将图片剪裁成圆形</span><br>    .overlay(<span class=\"hljs-type\">Circle</span>().stroke(<span class=\"hljs-type\">Color</span>.white, lineWidth: <span class=\"hljs-number\">4</span>)) <span class=\"hljs-comment\">// 圆形边框</span><br>    .shadow(radius: <span class=\"hljs-number\">10</span>) <span class=\"hljs-comment\">// 阴影效果</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"高级用法\"><a href=\"#高级用法\" class=\"headerlink\" title=\"高级用法\"></a>高级用法</h3><h4 id=\"图片叠加（Overlay）：\"><a href=\"#图片叠加（Overlay）：\" class=\"headerlink\" title=\"图片叠加（Overlay）：\"></a>图片叠加（Overlay）：</h4><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Image</span>(<span class=\"hljs-string\">&quot;myImage&quot;</span>)<br>    .resizable()<br>    .scaledToFit()<br>    .overlay(<br>        <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Overlay&quot;</span>) <span class=\"hljs-comment\">// 在图片上添加文本覆盖层</span><br>            .font(.caption)<br>            .padding(<span class=\"hljs-number\">5</span>)<br>            .background(<span class=\"hljs-type\">Color</span>.black.opacity(<span class=\"hljs-number\">0.5</span>))<br>            .cornerRadius(<span class=\"hljs-number\">5</span>)<br>            .foregroundColor(.white)<br>            .padding(<span class=\"hljs-number\">10</span>), <span class=\"hljs-comment\">// 文本内边距</span><br>        alignment: .bottomTrailing <span class=\"hljs-comment\">// 对齐到图片的右下角</span><br>    )<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"图片遮罩（Masking）：\"><a href=\"#图片遮罩（Masking）：\" class=\"headerlink\" title=\"图片遮罩（Masking）：\"></a>图片遮罩（Masking）：</h4><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Image</span>(<span class=\"hljs-string\">&quot;myImage&quot;</span>)<br>    .resizable()<br>    .scaledToFit()<br>    .mask(<br>        <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;SwiftUI&quot;</span>) <span class=\"hljs-comment\">// 使用文本作为遮罩</span><br>            .font(.system(size: <span class=\"hljs-number\">72</span>))<br>            .bold()<br>    )<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"图片动画：\"><a href=\"#图片动画：\" class=\"headerlink\" title=\"图片动画：\"></a>图片动画：</h4><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> isRotated <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">false</span><br><br><span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>    <span class=\"hljs-type\">Image</span>(<span class=\"hljs-string\">&quot;myImage&quot;</span>)<br>        .resizable()<br>        .rotationEffect(.degrees(isRotated <span class=\"hljs-operator\">?</span> <span class=\"hljs-number\">360</span> : <span class=\"hljs-number\">0</span>)) <span class=\"hljs-comment\">// 旋转动画</span><br>        .animation(.linear(duration: <span class=\"hljs-number\">2</span>), value: isRotated)<br>        .onAppear &#123;<br>            isRotated.toggle()<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"使用网络图片\"><a href=\"#使用网络图片\" class=\"headerlink\" title=\"使用网络图片\"></a>使用网络图片</h3><p>在 SwiftUI 中，没有内置从网络直接加载图片的方法。通常，你需要使用 <code>URLSession</code> 获取图片数据，然后将数据转换为 <code>UIImage</code>（在 iOS 上）或 <code>NSImage</code>（在 macOS 上），最后将其转换为 SwiftUI 可以使用的 <code>Image</code>。或者你可以使用第三方库，如 <code>SDWebImageSwiftUI</code> 来简化网络图片的加载过程。</p>\n<p>在 SwiftUI 2.0 之后的版本，<code>AsyncImage</code> 视图提供了一个原生的异步加载网络图片的方法：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">AsyncImage</span>(url: <span class=\"hljs-type\">URL</span>(string: <span class=\"hljs-string\">&quot;https://example.com/myImage.png&quot;</span>)) &#123; image <span class=\"hljs-keyword\">in</span><br>    image.resizable() <span class=\"hljs-comment\">// 如果成功加载，显示图片</span><br>&#125;<br>placeholder: &#123;<br>    <span class=\"hljs-type\">ProgressView</span>() <span class=\"hljs-comment\">// 在加载期间显示加载指示器</span><br>&#125;<br>.frame(width: <span class=\"hljs-number\">100</span>, height: <span class=\"hljs-number\">100</span>)<br></code></pre></td></tr></table></figure>\n\n<p><code>Image</code> 视图在 SwiftUI 中是核心组件之一，它配</p>\n<p>合修饰符和其他视图，能够实现丰富多彩的用户界面元素。</p>\n"},{"title":"SwiftUI中的TextField组件的用法","date":"2023-11-07T12:27:08.000Z","_content":"在 SwiftUI 中，`TextField` 组件用于收集用户输入的文本信息。它类似于 UIKit 中的 `UITextField` 或者 Web 开发中的 `<input type=\"text\">`。\n\n### 基础用法\n\n要创建一个 `TextField`，你至少需要提供两个参数：一个标签和一个绑定到文本值的变量。\n\n```swift\nstruct ContentView: View {\n    @State private var name: String = \"\"\n\n    var body: some View {\n        TextField(\"Enter your name\", text: $name)\n            .textFieldStyle(RoundedBorderTextFieldStyle()) // 为文本框添加边框样式\n            .padding() // 增加一些内边距\n    }\n}\n```\n\n### 定制样式\n\nSwiftUI 允许通过修饰符来定制 `TextField` 的外观和行为。\n\n```swift\nTextField(\"Enter your name\", text: $name)\n    .padding()\n    .background(Color.gray.opacity(0.2)) // 设置背景色\n    .cornerRadius(5) // 设置圆角\n    .font(.title) // 设置字体样式\n    .padding(.horizontal) // 水平方向的内边距\n```\n\n### 键盘类型、自动纠错和安全输入\n\n你可以为 `TextField` 设置键盘类型、是否自动纠错以及是否安全输入。\n\n```swift\nTextField(\"Email\", text: $email)\n    .keyboardType(.emailAddress) // 设置键盘类型为邮箱地址\n    .autocapitalization(.none) // 关闭自动大写\n    .disableAutocorrection(true) // 关闭自动纠错\n\nSecureField(\"Password\", text: $password) // 用于密码输入，会隐藏输入内容\n```\n\n### 占位符的定制\n\n在 SwiftUI 中，占位符是通过直接在 `TextField` 的初始化器中设置的。你也可以使用 `NSAttributedString` 来自定义占位符的外观，但这需要与 `UIKit` 桥接。\n\n```swift\nTextField(\"Enter your name\", text: $name)\n```\n\n### 响应用户操作\n\n为了响应用户的输入操作，你可以使用 `onCommit` 参数来定义当用户按下 Return 键时的行为。\n\n```swift\nTextField(\"Enter your name\", text: $name, onCommit: {\n    // 用户按下 Return 键时的操作\n    print(\"User entered: \\(name)\")\n})\n```\n\n### 聚焦和失焦\n\nSwiftUI 2.0 引入了 `@FocusState`，使你能够控制 `TextField` 的聚焦状态。\n\n```swift\n@State private var name: String = \"\"\n@FocusState private var isInputActive: Bool\n\nvar body: some View {\n    TextField(\"Enter your name\", text: $name)\n        .focused($isInputActive) // 将 TextField 的焦点状态绑定到 isInputActive\n        .onAppear {\n            DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {\n                self.isInputActive = true // 自动聚焦到 TextField\n            }\n        }\n}\n```\n\n### 使用 `TextField` 修饰符\n\nSwiftUI 为 `TextField` 提供了许多修饰符来自定义外观和行为，例如 `.textFieldStyle()`、`.keyboardType()`、`.textContentType()` 等。\n\n使用 `TextField` 的过程中，可能需要对其行为和外观进行调整以适应特定的 UI 设计。通过结合多种修饰符，你可以创建出符合需求的文本输入界面。","source":"_posts/SwiftUI中的TextField组件的用法.md","raw":"---\ntitle: SwiftUI中的TextField组件的用法\ndate: 2023-11-07 20:27:08\ncategories:\n- SwiftUI\ntags:\n---\n在 SwiftUI 中，`TextField` 组件用于收集用户输入的文本信息。它类似于 UIKit 中的 `UITextField` 或者 Web 开发中的 `<input type=\"text\">`。\n\n### 基础用法\n\n要创建一个 `TextField`，你至少需要提供两个参数：一个标签和一个绑定到文本值的变量。\n\n```swift\nstruct ContentView: View {\n    @State private var name: String = \"\"\n\n    var body: some View {\n        TextField(\"Enter your name\", text: $name)\n            .textFieldStyle(RoundedBorderTextFieldStyle()) // 为文本框添加边框样式\n            .padding() // 增加一些内边距\n    }\n}\n```\n\n### 定制样式\n\nSwiftUI 允许通过修饰符来定制 `TextField` 的外观和行为。\n\n```swift\nTextField(\"Enter your name\", text: $name)\n    .padding()\n    .background(Color.gray.opacity(0.2)) // 设置背景色\n    .cornerRadius(5) // 设置圆角\n    .font(.title) // 设置字体样式\n    .padding(.horizontal) // 水平方向的内边距\n```\n\n### 键盘类型、自动纠错和安全输入\n\n你可以为 `TextField` 设置键盘类型、是否自动纠错以及是否安全输入。\n\n```swift\nTextField(\"Email\", text: $email)\n    .keyboardType(.emailAddress) // 设置键盘类型为邮箱地址\n    .autocapitalization(.none) // 关闭自动大写\n    .disableAutocorrection(true) // 关闭自动纠错\n\nSecureField(\"Password\", text: $password) // 用于密码输入，会隐藏输入内容\n```\n\n### 占位符的定制\n\n在 SwiftUI 中，占位符是通过直接在 `TextField` 的初始化器中设置的。你也可以使用 `NSAttributedString` 来自定义占位符的外观，但这需要与 `UIKit` 桥接。\n\n```swift\nTextField(\"Enter your name\", text: $name)\n```\n\n### 响应用户操作\n\n为了响应用户的输入操作，你可以使用 `onCommit` 参数来定义当用户按下 Return 键时的行为。\n\n```swift\nTextField(\"Enter your name\", text: $name, onCommit: {\n    // 用户按下 Return 键时的操作\n    print(\"User entered: \\(name)\")\n})\n```\n\n### 聚焦和失焦\n\nSwiftUI 2.0 引入了 `@FocusState`，使你能够控制 `TextField` 的聚焦状态。\n\n```swift\n@State private var name: String = \"\"\n@FocusState private var isInputActive: Bool\n\nvar body: some View {\n    TextField(\"Enter your name\", text: $name)\n        .focused($isInputActive) // 将 TextField 的焦点状态绑定到 isInputActive\n        .onAppear {\n            DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {\n                self.isInputActive = true // 自动聚焦到 TextField\n            }\n        }\n}\n```\n\n### 使用 `TextField` 修饰符\n\nSwiftUI 为 `TextField` 提供了许多修饰符来自定义外观和行为，例如 `.textFieldStyle()`、`.keyboardType()`、`.textContentType()` 等。\n\n使用 `TextField` 的过程中，可能需要对其行为和外观进行调整以适应特定的 UI 设计。通过结合多种修饰符，你可以创建出符合需求的文本输入界面。","slug":"SwiftUI中的TextField组件的用法","published":1,"updated":"2024-03-17T06:12:39.198Z","comments":1,"layout":"post","photos":[],"_id":"clu6up53f001ez6743uacde68","content":"<p>在 SwiftUI 中，<code>TextField</code> 组件用于收集用户输入的文本信息。它类似于 UIKit 中的 <code>UITextField</code> 或者 Web 开发中的 <code>&lt;input type=&quot;text&quot;&gt;</code>。</p>\n<h3 id=\"基础用法\"><a href=\"#基础用法\" class=\"headerlink\" title=\"基础用法\"></a>基础用法</h3><p>要创建一个 <code>TextField</code>，你至少需要提供两个参数：一个标签和一个绑定到文本值的变量。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ContentView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> name: <span class=\"hljs-type\">String</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;&quot;</span><br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">TextField</span>(<span class=\"hljs-string\">&quot;Enter your name&quot;</span>, text: <span class=\"hljs-variable\">$name</span>)<br>            .textFieldStyle(<span class=\"hljs-type\">RoundedBorderTextFieldStyle</span>()) <span class=\"hljs-comment\">// 为文本框添加边框样式</span><br>            .padding() <span class=\"hljs-comment\">// 增加一些内边距</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"定制样式\"><a href=\"#定制样式\" class=\"headerlink\" title=\"定制样式\"></a>定制样式</h3><p>SwiftUI 允许通过修饰符来定制 <code>TextField</code> 的外观和行为。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">TextField</span>(<span class=\"hljs-string\">&quot;Enter your name&quot;</span>, text: <span class=\"hljs-variable\">$name</span>)<br>    .padding()<br>    .background(<span class=\"hljs-type\">Color</span>.gray.opacity(<span class=\"hljs-number\">0.2</span>)) <span class=\"hljs-comment\">// 设置背景色</span><br>    .cornerRadius(<span class=\"hljs-number\">5</span>) <span class=\"hljs-comment\">// 设置圆角</span><br>    .font(.title) <span class=\"hljs-comment\">// 设置字体样式</span><br>    .padding(.horizontal) <span class=\"hljs-comment\">// 水平方向的内边距</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"键盘类型、自动纠错和安全输入\"><a href=\"#键盘类型、自动纠错和安全输入\" class=\"headerlink\" title=\"键盘类型、自动纠错和安全输入\"></a>键盘类型、自动纠错和安全输入</h3><p>你可以为 <code>TextField</code> 设置键盘类型、是否自动纠错以及是否安全输入。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">TextField</span>(<span class=\"hljs-string\">&quot;Email&quot;</span>, text: <span class=\"hljs-variable\">$email</span>)<br>    .keyboardType(.emailAddress) <span class=\"hljs-comment\">// 设置键盘类型为邮箱地址</span><br>    .autocapitalization(.none) <span class=\"hljs-comment\">// 关闭自动大写</span><br>    .disableAutocorrection(<span class=\"hljs-literal\">true</span>) <span class=\"hljs-comment\">// 关闭自动纠错</span><br><br><span class=\"hljs-type\">SecureField</span>(<span class=\"hljs-string\">&quot;Password&quot;</span>, text: <span class=\"hljs-variable\">$password</span>) <span class=\"hljs-comment\">// 用于密码输入，会隐藏输入内容</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"占位符的定制\"><a href=\"#占位符的定制\" class=\"headerlink\" title=\"占位符的定制\"></a>占位符的定制</h3><p>在 SwiftUI 中，占位符是通过直接在 <code>TextField</code> 的初始化器中设置的。你也可以使用 <code>NSAttributedString</code> 来自定义占位符的外观，但这需要与 <code>UIKit</code> 桥接。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">TextField</span>(<span class=\"hljs-string\">&quot;Enter your name&quot;</span>, text: <span class=\"hljs-variable\">$name</span>)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"响应用户操作\"><a href=\"#响应用户操作\" class=\"headerlink\" title=\"响应用户操作\"></a>响应用户操作</h3><p>为了响应用户的输入操作，你可以使用 <code>onCommit</code> 参数来定义当用户按下 Return 键时的行为。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">TextField</span>(<span class=\"hljs-string\">&quot;Enter your name&quot;</span>, text: <span class=\"hljs-variable\">$name</span>, onCommit: &#123;<br>    <span class=\"hljs-comment\">// 用户按下 Return 键时的操作</span><br>    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;User entered: <span class=\"hljs-subst\">\\(name)</span>&quot;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"聚焦和失焦\"><a href=\"#聚焦和失焦\" class=\"headerlink\" title=\"聚焦和失焦\"></a>聚焦和失焦</h3><p>SwiftUI 2.0 引入了 <code>@FocusState</code>，使你能够控制 <code>TextField</code> 的聚焦状态。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> name: <span class=\"hljs-type\">String</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;&quot;</span><br><span class=\"hljs-meta\">@FocusState</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> isInputActive: <span class=\"hljs-type\">Bool</span><br><br><span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>    <span class=\"hljs-type\">TextField</span>(<span class=\"hljs-string\">&quot;Enter your name&quot;</span>, text: <span class=\"hljs-variable\">$name</span>)<br>        .focused(<span class=\"hljs-variable\">$isInputActive</span>) <span class=\"hljs-comment\">// 将 TextField 的焦点状态绑定到 isInputActive</span><br>        .onAppear &#123;<br>            <span class=\"hljs-type\">DispatchQueue</span>.main.asyncAfter(deadline: .now() <span class=\"hljs-operator\">+</span> <span class=\"hljs-number\">0.5</span>) &#123;<br>                <span class=\"hljs-keyword\">self</span>.isInputActive <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">true</span> <span class=\"hljs-comment\">// 自动聚焦到 TextField</span><br>            &#125;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"使用-TextField-修饰符\"><a href=\"#使用-TextField-修饰符\" class=\"headerlink\" title=\"使用 TextField 修饰符\"></a>使用 <code>TextField</code> 修饰符</h3><p>SwiftUI 为 <code>TextField</code> 提供了许多修饰符来自定义外观和行为，例如 <code>.textFieldStyle()</code>、<code>.keyboardType()</code>、<code>.textContentType()</code> 等。</p>\n<p>使用 <code>TextField</code> 的过程中，可能需要对其行为和外观进行调整以适应特定的 UI 设计。通过结合多种修饰符，你可以创建出符合需求的文本输入界面。</p>\n","excerpt":"","more":"<p>在 SwiftUI 中，<code>TextField</code> 组件用于收集用户输入的文本信息。它类似于 UIKit 中的 <code>UITextField</code> 或者 Web 开发中的 <code>&lt;input type=&quot;text&quot;&gt;</code>。</p>\n<h3 id=\"基础用法\"><a href=\"#基础用法\" class=\"headerlink\" title=\"基础用法\"></a>基础用法</h3><p>要创建一个 <code>TextField</code>，你至少需要提供两个参数：一个标签和一个绑定到文本值的变量。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ContentView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> name: <span class=\"hljs-type\">String</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;&quot;</span><br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">TextField</span>(<span class=\"hljs-string\">&quot;Enter your name&quot;</span>, text: <span class=\"hljs-variable\">$name</span>)<br>            .textFieldStyle(<span class=\"hljs-type\">RoundedBorderTextFieldStyle</span>()) <span class=\"hljs-comment\">// 为文本框添加边框样式</span><br>            .padding() <span class=\"hljs-comment\">// 增加一些内边距</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"定制样式\"><a href=\"#定制样式\" class=\"headerlink\" title=\"定制样式\"></a>定制样式</h3><p>SwiftUI 允许通过修饰符来定制 <code>TextField</code> 的外观和行为。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">TextField</span>(<span class=\"hljs-string\">&quot;Enter your name&quot;</span>, text: <span class=\"hljs-variable\">$name</span>)<br>    .padding()<br>    .background(<span class=\"hljs-type\">Color</span>.gray.opacity(<span class=\"hljs-number\">0.2</span>)) <span class=\"hljs-comment\">// 设置背景色</span><br>    .cornerRadius(<span class=\"hljs-number\">5</span>) <span class=\"hljs-comment\">// 设置圆角</span><br>    .font(.title) <span class=\"hljs-comment\">// 设置字体样式</span><br>    .padding(.horizontal) <span class=\"hljs-comment\">// 水平方向的内边距</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"键盘类型、自动纠错和安全输入\"><a href=\"#键盘类型、自动纠错和安全输入\" class=\"headerlink\" title=\"键盘类型、自动纠错和安全输入\"></a>键盘类型、自动纠错和安全输入</h3><p>你可以为 <code>TextField</code> 设置键盘类型、是否自动纠错以及是否安全输入。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">TextField</span>(<span class=\"hljs-string\">&quot;Email&quot;</span>, text: <span class=\"hljs-variable\">$email</span>)<br>    .keyboardType(.emailAddress) <span class=\"hljs-comment\">// 设置键盘类型为邮箱地址</span><br>    .autocapitalization(.none) <span class=\"hljs-comment\">// 关闭自动大写</span><br>    .disableAutocorrection(<span class=\"hljs-literal\">true</span>) <span class=\"hljs-comment\">// 关闭自动纠错</span><br><br><span class=\"hljs-type\">SecureField</span>(<span class=\"hljs-string\">&quot;Password&quot;</span>, text: <span class=\"hljs-variable\">$password</span>) <span class=\"hljs-comment\">// 用于密码输入，会隐藏输入内容</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"占位符的定制\"><a href=\"#占位符的定制\" class=\"headerlink\" title=\"占位符的定制\"></a>占位符的定制</h3><p>在 SwiftUI 中，占位符是通过直接在 <code>TextField</code> 的初始化器中设置的。你也可以使用 <code>NSAttributedString</code> 来自定义占位符的外观，但这需要与 <code>UIKit</code> 桥接。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">TextField</span>(<span class=\"hljs-string\">&quot;Enter your name&quot;</span>, text: <span class=\"hljs-variable\">$name</span>)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"响应用户操作\"><a href=\"#响应用户操作\" class=\"headerlink\" title=\"响应用户操作\"></a>响应用户操作</h3><p>为了响应用户的输入操作，你可以使用 <code>onCommit</code> 参数来定义当用户按下 Return 键时的行为。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">TextField</span>(<span class=\"hljs-string\">&quot;Enter your name&quot;</span>, text: <span class=\"hljs-variable\">$name</span>, onCommit: &#123;<br>    <span class=\"hljs-comment\">// 用户按下 Return 键时的操作</span><br>    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;User entered: <span class=\"hljs-subst\">\\(name)</span>&quot;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"聚焦和失焦\"><a href=\"#聚焦和失焦\" class=\"headerlink\" title=\"聚焦和失焦\"></a>聚焦和失焦</h3><p>SwiftUI 2.0 引入了 <code>@FocusState</code>，使你能够控制 <code>TextField</code> 的聚焦状态。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> name: <span class=\"hljs-type\">String</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;&quot;</span><br><span class=\"hljs-meta\">@FocusState</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> isInputActive: <span class=\"hljs-type\">Bool</span><br><br><span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>    <span class=\"hljs-type\">TextField</span>(<span class=\"hljs-string\">&quot;Enter your name&quot;</span>, text: <span class=\"hljs-variable\">$name</span>)<br>        .focused(<span class=\"hljs-variable\">$isInputActive</span>) <span class=\"hljs-comment\">// 将 TextField 的焦点状态绑定到 isInputActive</span><br>        .onAppear &#123;<br>            <span class=\"hljs-type\">DispatchQueue</span>.main.asyncAfter(deadline: .now() <span class=\"hljs-operator\">+</span> <span class=\"hljs-number\">0.5</span>) &#123;<br>                <span class=\"hljs-keyword\">self</span>.isInputActive <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">true</span> <span class=\"hljs-comment\">// 自动聚焦到 TextField</span><br>            &#125;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"使用-TextField-修饰符\"><a href=\"#使用-TextField-修饰符\" class=\"headerlink\" title=\"使用 TextField 修饰符\"></a>使用 <code>TextField</code> 修饰符</h3><p>SwiftUI 为 <code>TextField</code> 提供了许多修饰符来自定义外观和行为，例如 <code>.textFieldStyle()</code>、<code>.keyboardType()</code>、<code>.textContentType()</code> 等。</p>\n<p>使用 <code>TextField</code> 的过程中，可能需要对其行为和外观进行调整以适应特定的 UI 设计。通过结合多种修饰符，你可以创建出符合需求的文本输入界面。</p>\n"},{"title":"SwiftUI中的布局","date":"2023-11-07T13:47:45.000Z","_content":"在 SwiftUI 中，布局是通过一系列的容器视图来实现的，这些容器视图可以控制它们子视图的位置和大小。常用的布局容器有 `HStack`、`VStack`、`ZStack`、`Grid`、`List` 和 `ScrollView` 等。\n\n### 基本的布局结构\n\n- **HStack**：水平堆叠子视图。\n- **VStack**：垂直堆叠子视图。\n- **ZStack**：重叠子视图，即在 Z 轴上（深度方向）堆叠。\n\n```swift\nstruct ContentView: View {\n    var body: some View {\n        VStack { // 垂直堆叠\n            HStack { // 水平堆叠\n                Text(\"Left\")\n                Spacer() // 使用 Spacer 来推动两边的文本\n                Text(\"Right\")\n            }\n            ZStack { // Z轴堆叠\n                Circle().fill(Color.blue)\n                Text(\"Foreground\")\n            }\n        }\n    }\n}\n```\n\n### 对齐和间距\n\n可以对堆叠容器使用 `alignment` 和 `spacing` 参数来定义子视图的对齐方式和间距。\n\n```swift\nHStack(alignment: .top, spacing: 20) {\n    Text(\"Left\")\n    Text(\"Right\")\n}\n```\n\n### 帧（Frame）\n\n通过 `.frame` 修饰符可以为视图设定宽度、高度和对齐方式。\n\n```swift\nText(\"Hello, World!\")\n    .frame(width: 200, height: 200, alignment: .center)\n```\n\n### 弹性空间和填充\n\n- **Spacer**：在视图之间创建一个可扩展的空间，常用于推动视图到屏幕的边缘。\n- **Padding**：通过 `.padding` 修饰符来为视图添加内边距。\n\n```swift\nVStack {\n    Text(\"First\")\n    Spacer() // 将占据可用的所有空间\n    Text(\"Last\")\n}\n.padding() // 在 VStack 的所有边缘添加内边距\n```\n\n### Divider 和 Separator\n\n可以使用 `Divider` 来在视图中添加一条分割线。\n\n```swift\nVStack {\n    Text(\"Above Divider\")\n    Divider()\n    Text(\"Below Divider\")\n}\n```\n\n### ScrollView\n\n`ScrollView` 允许内容超出屏幕大小时滚动查看。\n\n```swift\nScrollView {\n    VStack(spacing: 20) {\n        ForEach(0..<100) { index in\n            Text(\"Row \\(index)\")\n        }\n    }\n}\n```\n\n### List\n\n`List` 用于创建一个滚动的列表视图。\n\n```swift\nList(0..<100) { index in\n    Text(\"Item \\(index)\")\n}\n```\n\n### Grids\n\n在 SwiftUI 中，可以使用 `LazyVGrid` 和 `LazyHGrid` 来创建网格布局。\n\n```swift\nLazyVGrid(columns: [GridItem(.adaptive(minimum: 100))]) {\n    ForEach(0..<100) { index in\n        Text(\"Item \\(index)\")\n    }\n}\n```\n\n### Frame Layout\n\n对于复杂的布局，可能需要手动计算视图的尺寸和位置，使用 `.frame` 修饰符来设置大小，并使用 `.offset`、`.position` 等修饰符来调整位置。\n\n### 自定义布局\n\n可以通过创建自定义的 `ViewModifier` 或者自定义的布局容器来创建复杂的布局模式。\n\nSwiftUI 的布局系统是高度可组合的，你可以将多个布局容器和修饰符组合在一起，来创建复杂和响应式的用户界面。重要的是要理解 SwiftUI 的布局原则——尤其是容器如何影响内部子视图的布局，以及修饰符的顺序如何影响结果。","source":"_posts/SwiftUI中的布局.md","raw":"---\ntitle: SwiftUI中的布局\ndate: 2023-11-07 21:47:45\ncategories:\n- SwiftUI\ntags:\n---\n在 SwiftUI 中，布局是通过一系列的容器视图来实现的，这些容器视图可以控制它们子视图的位置和大小。常用的布局容器有 `HStack`、`VStack`、`ZStack`、`Grid`、`List` 和 `ScrollView` 等。\n\n### 基本的布局结构\n\n- **HStack**：水平堆叠子视图。\n- **VStack**：垂直堆叠子视图。\n- **ZStack**：重叠子视图，即在 Z 轴上（深度方向）堆叠。\n\n```swift\nstruct ContentView: View {\n    var body: some View {\n        VStack { // 垂直堆叠\n            HStack { // 水平堆叠\n                Text(\"Left\")\n                Spacer() // 使用 Spacer 来推动两边的文本\n                Text(\"Right\")\n            }\n            ZStack { // Z轴堆叠\n                Circle().fill(Color.blue)\n                Text(\"Foreground\")\n            }\n        }\n    }\n}\n```\n\n### 对齐和间距\n\n可以对堆叠容器使用 `alignment` 和 `spacing` 参数来定义子视图的对齐方式和间距。\n\n```swift\nHStack(alignment: .top, spacing: 20) {\n    Text(\"Left\")\n    Text(\"Right\")\n}\n```\n\n### 帧（Frame）\n\n通过 `.frame` 修饰符可以为视图设定宽度、高度和对齐方式。\n\n```swift\nText(\"Hello, World!\")\n    .frame(width: 200, height: 200, alignment: .center)\n```\n\n### 弹性空间和填充\n\n- **Spacer**：在视图之间创建一个可扩展的空间，常用于推动视图到屏幕的边缘。\n- **Padding**：通过 `.padding` 修饰符来为视图添加内边距。\n\n```swift\nVStack {\n    Text(\"First\")\n    Spacer() // 将占据可用的所有空间\n    Text(\"Last\")\n}\n.padding() // 在 VStack 的所有边缘添加内边距\n```\n\n### Divider 和 Separator\n\n可以使用 `Divider` 来在视图中添加一条分割线。\n\n```swift\nVStack {\n    Text(\"Above Divider\")\n    Divider()\n    Text(\"Below Divider\")\n}\n```\n\n### ScrollView\n\n`ScrollView` 允许内容超出屏幕大小时滚动查看。\n\n```swift\nScrollView {\n    VStack(spacing: 20) {\n        ForEach(0..<100) { index in\n            Text(\"Row \\(index)\")\n        }\n    }\n}\n```\n\n### List\n\n`List` 用于创建一个滚动的列表视图。\n\n```swift\nList(0..<100) { index in\n    Text(\"Item \\(index)\")\n}\n```\n\n### Grids\n\n在 SwiftUI 中，可以使用 `LazyVGrid` 和 `LazyHGrid` 来创建网格布局。\n\n```swift\nLazyVGrid(columns: [GridItem(.adaptive(minimum: 100))]) {\n    ForEach(0..<100) { index in\n        Text(\"Item \\(index)\")\n    }\n}\n```\n\n### Frame Layout\n\n对于复杂的布局，可能需要手动计算视图的尺寸和位置，使用 `.frame` 修饰符来设置大小，并使用 `.offset`、`.position` 等修饰符来调整位置。\n\n### 自定义布局\n\n可以通过创建自定义的 `ViewModifier` 或者自定义的布局容器来创建复杂的布局模式。\n\nSwiftUI 的布局系统是高度可组合的，你可以将多个布局容器和修饰符组合在一起，来创建复杂和响应式的用户界面。重要的是要理解 SwiftUI 的布局原则——尤其是容器如何影响内部子视图的布局，以及修饰符的顺序如何影响结果。","slug":"SwiftUI中的布局","published":1,"updated":"2024-03-17T06:12:21.929Z","comments":1,"layout":"post","photos":[],"_id":"clu6up53f001hz67464yedp6j","content":"<p>在 SwiftUI 中，布局是通过一系列的容器视图来实现的，这些容器视图可以控制它们子视图的位置和大小。常用的布局容器有 <code>HStack</code>、<code>VStack</code>、<code>ZStack</code>、<code>Grid</code>、<code>List</code> 和 <code>ScrollView</code> 等。</p>\n<h3 id=\"基本的布局结构\"><a href=\"#基本的布局结构\" class=\"headerlink\" title=\"基本的布局结构\"></a>基本的布局结构</h3><ul>\n<li><strong>HStack</strong>：水平堆叠子视图。</li>\n<li><strong>VStack</strong>：垂直堆叠子视图。</li>\n<li><strong>ZStack</strong>：重叠子视图，即在 Z 轴上（深度方向）堆叠。</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ContentView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">VStack</span> &#123; <span class=\"hljs-comment\">// 垂直堆叠</span><br>            <span class=\"hljs-type\">HStack</span> &#123; <span class=\"hljs-comment\">// 水平堆叠</span><br>                <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Left&quot;</span>)<br>                <span class=\"hljs-type\">Spacer</span>() <span class=\"hljs-comment\">// 使用 Spacer 来推动两边的文本</span><br>                <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Right&quot;</span>)<br>            &#125;<br>            <span class=\"hljs-type\">ZStack</span> &#123; <span class=\"hljs-comment\">// Z轴堆叠</span><br>                <span class=\"hljs-type\">Circle</span>().fill(<span class=\"hljs-type\">Color</span>.blue)<br>                <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Foreground&quot;</span>)<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"对齐和间距\"><a href=\"#对齐和间距\" class=\"headerlink\" title=\"对齐和间距\"></a>对齐和间距</h3><p>可以对堆叠容器使用 <code>alignment</code> 和 <code>spacing</code> 参数来定义子视图的对齐方式和间距。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">HStack</span>(alignment: .top, spacing: <span class=\"hljs-number\">20</span>) &#123;<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Left&quot;</span>)<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Right&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"帧（Frame）\"><a href=\"#帧（Frame）\" class=\"headerlink\" title=\"帧（Frame）\"></a>帧（Frame）</h3><p>通过 <code>.frame</code> 修饰符可以为视图设定宽度、高度和对齐方式。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Hello, World!&quot;</span>)<br>    .frame(width: <span class=\"hljs-number\">200</span>, height: <span class=\"hljs-number\">200</span>, alignment: .center)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"弹性空间和填充\"><a href=\"#弹性空间和填充\" class=\"headerlink\" title=\"弹性空间和填充\"></a>弹性空间和填充</h3><ul>\n<li><strong>Spacer</strong>：在视图之间创建一个可扩展的空间，常用于推动视图到屏幕的边缘。</li>\n<li><strong>Padding</strong>：通过 <code>.padding</code> 修饰符来为视图添加内边距。</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">VStack</span> &#123;<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;First&quot;</span>)<br>    <span class=\"hljs-type\">Spacer</span>() <span class=\"hljs-comment\">// 将占据可用的所有空间</span><br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Last&quot;</span>)<br>&#125;<br>.padding() <span class=\"hljs-comment\">// 在 VStack 的所有边缘添加内边距</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"Divider-和-Separator\"><a href=\"#Divider-和-Separator\" class=\"headerlink\" title=\"Divider 和 Separator\"></a>Divider 和 Separator</h3><p>可以使用 <code>Divider</code> 来在视图中添加一条分割线。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">VStack</span> &#123;<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Above Divider&quot;</span>)<br>    <span class=\"hljs-type\">Divider</span>()<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Below Divider&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"ScrollView\"><a href=\"#ScrollView\" class=\"headerlink\" title=\"ScrollView\"></a>ScrollView</h3><p><code>ScrollView</code> 允许内容超出屏幕大小时滚动查看。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">ScrollView</span> &#123;<br>    <span class=\"hljs-type\">VStack</span>(spacing: <span class=\"hljs-number\">20</span>) &#123;<br>        <span class=\"hljs-type\">ForEach</span>(<span class=\"hljs-number\">0</span><span class=\"hljs-operator\">..&lt;</span><span class=\"hljs-number\">100</span>) &#123; index <span class=\"hljs-keyword\">in</span><br>            <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Row <span class=\"hljs-subst\">\\(index)</span>&quot;</span>)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"List\"><a href=\"#List\" class=\"headerlink\" title=\"List\"></a>List</h3><p><code>List</code> 用于创建一个滚动的列表视图。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">List</span>(<span class=\"hljs-number\">0</span><span class=\"hljs-operator\">..&lt;</span><span class=\"hljs-number\">100</span>) &#123; index <span class=\"hljs-keyword\">in</span><br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Item <span class=\"hljs-subst\">\\(index)</span>&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"Grids\"><a href=\"#Grids\" class=\"headerlink\" title=\"Grids\"></a>Grids</h3><p>在 SwiftUI 中，可以使用 <code>LazyVGrid</code> 和 <code>LazyHGrid</code> 来创建网格布局。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">LazyVGrid</span>(columns: [<span class=\"hljs-type\">GridItem</span>(.adaptive(minimum: <span class=\"hljs-number\">100</span>))]) &#123;<br>    <span class=\"hljs-type\">ForEach</span>(<span class=\"hljs-number\">0</span><span class=\"hljs-operator\">..&lt;</span><span class=\"hljs-number\">100</span>) &#123; index <span class=\"hljs-keyword\">in</span><br>        <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Item <span class=\"hljs-subst\">\\(index)</span>&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"Frame-Layout\"><a href=\"#Frame-Layout\" class=\"headerlink\" title=\"Frame Layout\"></a>Frame Layout</h3><p>对于复杂的布局，可能需要手动计算视图的尺寸和位置，使用 <code>.frame</code> 修饰符来设置大小，并使用 <code>.offset</code>、<code>.position</code> 等修饰符来调整位置。</p>\n<h3 id=\"自定义布局\"><a href=\"#自定义布局\" class=\"headerlink\" title=\"自定义布局\"></a>自定义布局</h3><p>可以通过创建自定义的 <code>ViewModifier</code> 或者自定义的布局容器来创建复杂的布局模式。</p>\n<p>SwiftUI 的布局系统是高度可组合的，你可以将多个布局容器和修饰符组合在一起，来创建复杂和响应式的用户界面。重要的是要理解 SwiftUI 的布局原则——尤其是容器如何影响内部子视图的布局，以及修饰符的顺序如何影响结果。</p>\n","excerpt":"","more":"<p>在 SwiftUI 中，布局是通过一系列的容器视图来实现的，这些容器视图可以控制它们子视图的位置和大小。常用的布局容器有 <code>HStack</code>、<code>VStack</code>、<code>ZStack</code>、<code>Grid</code>、<code>List</code> 和 <code>ScrollView</code> 等。</p>\n<h3 id=\"基本的布局结构\"><a href=\"#基本的布局结构\" class=\"headerlink\" title=\"基本的布局结构\"></a>基本的布局结构</h3><ul>\n<li><strong>HStack</strong>：水平堆叠子视图。</li>\n<li><strong>VStack</strong>：垂直堆叠子视图。</li>\n<li><strong>ZStack</strong>：重叠子视图，即在 Z 轴上（深度方向）堆叠。</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ContentView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">VStack</span> &#123; <span class=\"hljs-comment\">// 垂直堆叠</span><br>            <span class=\"hljs-type\">HStack</span> &#123; <span class=\"hljs-comment\">// 水平堆叠</span><br>                <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Left&quot;</span>)<br>                <span class=\"hljs-type\">Spacer</span>() <span class=\"hljs-comment\">// 使用 Spacer 来推动两边的文本</span><br>                <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Right&quot;</span>)<br>            &#125;<br>            <span class=\"hljs-type\">ZStack</span> &#123; <span class=\"hljs-comment\">// Z轴堆叠</span><br>                <span class=\"hljs-type\">Circle</span>().fill(<span class=\"hljs-type\">Color</span>.blue)<br>                <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Foreground&quot;</span>)<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"对齐和间距\"><a href=\"#对齐和间距\" class=\"headerlink\" title=\"对齐和间距\"></a>对齐和间距</h3><p>可以对堆叠容器使用 <code>alignment</code> 和 <code>spacing</code> 参数来定义子视图的对齐方式和间距。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">HStack</span>(alignment: .top, spacing: <span class=\"hljs-number\">20</span>) &#123;<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Left&quot;</span>)<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Right&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"帧（Frame）\"><a href=\"#帧（Frame）\" class=\"headerlink\" title=\"帧（Frame）\"></a>帧（Frame）</h3><p>通过 <code>.frame</code> 修饰符可以为视图设定宽度、高度和对齐方式。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Hello, World!&quot;</span>)<br>    .frame(width: <span class=\"hljs-number\">200</span>, height: <span class=\"hljs-number\">200</span>, alignment: .center)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"弹性空间和填充\"><a href=\"#弹性空间和填充\" class=\"headerlink\" title=\"弹性空间和填充\"></a>弹性空间和填充</h3><ul>\n<li><strong>Spacer</strong>：在视图之间创建一个可扩展的空间，常用于推动视图到屏幕的边缘。</li>\n<li><strong>Padding</strong>：通过 <code>.padding</code> 修饰符来为视图添加内边距。</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">VStack</span> &#123;<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;First&quot;</span>)<br>    <span class=\"hljs-type\">Spacer</span>() <span class=\"hljs-comment\">// 将占据可用的所有空间</span><br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Last&quot;</span>)<br>&#125;<br>.padding() <span class=\"hljs-comment\">// 在 VStack 的所有边缘添加内边距</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"Divider-和-Separator\"><a href=\"#Divider-和-Separator\" class=\"headerlink\" title=\"Divider 和 Separator\"></a>Divider 和 Separator</h3><p>可以使用 <code>Divider</code> 来在视图中添加一条分割线。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">VStack</span> &#123;<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Above Divider&quot;</span>)<br>    <span class=\"hljs-type\">Divider</span>()<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Below Divider&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"ScrollView\"><a href=\"#ScrollView\" class=\"headerlink\" title=\"ScrollView\"></a>ScrollView</h3><p><code>ScrollView</code> 允许内容超出屏幕大小时滚动查看。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">ScrollView</span> &#123;<br>    <span class=\"hljs-type\">VStack</span>(spacing: <span class=\"hljs-number\">20</span>) &#123;<br>        <span class=\"hljs-type\">ForEach</span>(<span class=\"hljs-number\">0</span><span class=\"hljs-operator\">..&lt;</span><span class=\"hljs-number\">100</span>) &#123; index <span class=\"hljs-keyword\">in</span><br>            <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Row <span class=\"hljs-subst\">\\(index)</span>&quot;</span>)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"List\"><a href=\"#List\" class=\"headerlink\" title=\"List\"></a>List</h3><p><code>List</code> 用于创建一个滚动的列表视图。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">List</span>(<span class=\"hljs-number\">0</span><span class=\"hljs-operator\">..&lt;</span><span class=\"hljs-number\">100</span>) &#123; index <span class=\"hljs-keyword\">in</span><br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Item <span class=\"hljs-subst\">\\(index)</span>&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"Grids\"><a href=\"#Grids\" class=\"headerlink\" title=\"Grids\"></a>Grids</h3><p>在 SwiftUI 中，可以使用 <code>LazyVGrid</code> 和 <code>LazyHGrid</code> 来创建网格布局。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">LazyVGrid</span>(columns: [<span class=\"hljs-type\">GridItem</span>(.adaptive(minimum: <span class=\"hljs-number\">100</span>))]) &#123;<br>    <span class=\"hljs-type\">ForEach</span>(<span class=\"hljs-number\">0</span><span class=\"hljs-operator\">..&lt;</span><span class=\"hljs-number\">100</span>) &#123; index <span class=\"hljs-keyword\">in</span><br>        <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Item <span class=\"hljs-subst\">\\(index)</span>&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"Frame-Layout\"><a href=\"#Frame-Layout\" class=\"headerlink\" title=\"Frame Layout\"></a>Frame Layout</h3><p>对于复杂的布局，可能需要手动计算视图的尺寸和位置，使用 <code>.frame</code> 修饰符来设置大小，并使用 <code>.offset</code>、<code>.position</code> 等修饰符来调整位置。</p>\n<h3 id=\"自定义布局\"><a href=\"#自定义布局\" class=\"headerlink\" title=\"自定义布局\"></a>自定义布局</h3><p>可以通过创建自定义的 <code>ViewModifier</code> 或者自定义的布局容器来创建复杂的布局模式。</p>\n<p>SwiftUI 的布局系统是高度可组合的，你可以将多个布局容器和修饰符组合在一起，来创建复杂和响应式的用户界面。重要的是要理解 SwiftUI 的布局原则——尤其是容器如何影响内部子视图的布局，以及修饰符的顺序如何影响结果。</p>\n"},{"title":"SwiftUI中的开关组件的用法","date":"2023-11-07T12:24:24.000Z","_content":"在 SwiftUI 中，`Toggle` 是一个用于切换布尔值的 UI 控件。这通常与应用的一些设置或状态开关对应。\n\n### 基础用法\n\n你可以这样创建一个基础的 `Toggle`：\n\n```swift\n@State private var isOn = false\n\nvar body: some View {\n    Toggle(\"Switch Label\", isOn: $isOn)\n}\n```\n\n这里的 `$isOn` 是对 `isOn` 变量的一个绑定，它会在用户操作 `Toggle` 时自动更新。\n\n### 自定义外观\n\nSwiftUI 允许使用各种修饰符自定义 `Toggle` 的外观：\n\n```swift\nToggle(isOn: $isOn) {\n    Text(\"Switch Label\")\n}\n.toggleStyle(SwitchToggleStyle(tint: .green)) // 自定义开关颜色\n```\n\n### 使用自定义图标\n\n你也可以为 `Toggle` 的标签使用自定义图标：\n\n```swift\nToggle(isOn: $isOn) {\n    HStack {\n        Image(systemName: \"moon.stars.fill\")\n        Text(\"Dark Mode\")\n    }\n}\n```\n\n### 与列表集成\n\n`Toggle` 经常和 `List` 结合使用，尤其是在设置界面：\n\n```swift\nList {\n    Toggle(\"Wi-Fi\", isOn: $isWifiEnabled)\n    Toggle(\"Bluetooth\", isOn: $isBluetoothEnabled)\n    // ... 其他设置项\n}\n```\n\n### 无文本标签\n\n如果你不需要显示文本标签，可以使用空 `Text` 或直接省略标签参数：\n\n```swift\nToggle(\"\", isOn: $isOn)\n// 或者\nToggle(isOn: $isOn) {\n    // 省略标签\n}\n```\n\n### 可访问性\n\n为了确保你的 `Toggle` 对于辅助功能用户来说是可访问的，你可以提供额外的信息：\n\n```swift\nToggle(\"Enable Notifications\", isOn: $areNotificationsEnabled)\n    .accessibilityLabel(Text(\"Enable Notifications\"))\n    .accessibilityHint(Text(\"Toggles whether or not to receive notifications.\"))\n```\n\n### 响应状态变化\n\n如果你想要在 `Toggle` 状态改变时执行一些操作，你可以使用 `.onChange(of:)` 修饰符：\n\n```swift\nToggle(\"Enable Notifications\", isOn: $areNotificationsEnabled)\n    .onChange(of: areNotificationsEnabled) { newValue in\n        // 当 Toggle 状态变化时执行\n        print(\"Notifications are now \\(newValue ? \"enabled\" : \"disabled\")\")\n    }\n```\n\n使用 `Toggle` 组件可以很容易地为用户提供控制应用设置的方式，它是可声明式 UI 的一个例子，将状态的可视化与状态管理结合起来。通过在 SwiftUI 视图中声明状态和状态之间的绑定，`Toggle` 的状态改变可以传播到你的应用的其他部分，或者触发一些逻辑。","source":"_posts/SwiftUI中的开关组件的用法.md","raw":"---\ntitle: SwiftUI中的开关组件的用法\ndate: 2023-11-07 20:24:24\ncategories:\n- SwiftUI\ntags:\n---\n在 SwiftUI 中，`Toggle` 是一个用于切换布尔值的 UI 控件。这通常与应用的一些设置或状态开关对应。\n\n### 基础用法\n\n你可以这样创建一个基础的 `Toggle`：\n\n```swift\n@State private var isOn = false\n\nvar body: some View {\n    Toggle(\"Switch Label\", isOn: $isOn)\n}\n```\n\n这里的 `$isOn` 是对 `isOn` 变量的一个绑定，它会在用户操作 `Toggle` 时自动更新。\n\n### 自定义外观\n\nSwiftUI 允许使用各种修饰符自定义 `Toggle` 的外观：\n\n```swift\nToggle(isOn: $isOn) {\n    Text(\"Switch Label\")\n}\n.toggleStyle(SwitchToggleStyle(tint: .green)) // 自定义开关颜色\n```\n\n### 使用自定义图标\n\n你也可以为 `Toggle` 的标签使用自定义图标：\n\n```swift\nToggle(isOn: $isOn) {\n    HStack {\n        Image(systemName: \"moon.stars.fill\")\n        Text(\"Dark Mode\")\n    }\n}\n```\n\n### 与列表集成\n\n`Toggle` 经常和 `List` 结合使用，尤其是在设置界面：\n\n```swift\nList {\n    Toggle(\"Wi-Fi\", isOn: $isWifiEnabled)\n    Toggle(\"Bluetooth\", isOn: $isBluetoothEnabled)\n    // ... 其他设置项\n}\n```\n\n### 无文本标签\n\n如果你不需要显示文本标签，可以使用空 `Text` 或直接省略标签参数：\n\n```swift\nToggle(\"\", isOn: $isOn)\n// 或者\nToggle(isOn: $isOn) {\n    // 省略标签\n}\n```\n\n### 可访问性\n\n为了确保你的 `Toggle` 对于辅助功能用户来说是可访问的，你可以提供额外的信息：\n\n```swift\nToggle(\"Enable Notifications\", isOn: $areNotificationsEnabled)\n    .accessibilityLabel(Text(\"Enable Notifications\"))\n    .accessibilityHint(Text(\"Toggles whether or not to receive notifications.\"))\n```\n\n### 响应状态变化\n\n如果你想要在 `Toggle` 状态改变时执行一些操作，你可以使用 `.onChange(of:)` 修饰符：\n\n```swift\nToggle(\"Enable Notifications\", isOn: $areNotificationsEnabled)\n    .onChange(of: areNotificationsEnabled) { newValue in\n        // 当 Toggle 状态变化时执行\n        print(\"Notifications are now \\(newValue ? \"enabled\" : \"disabled\")\")\n    }\n```\n\n使用 `Toggle` 组件可以很容易地为用户提供控制应用设置的方式，它是可声明式 UI 的一个例子，将状态的可视化与状态管理结合起来。通过在 SwiftUI 视图中声明状态和状态之间的绑定，`Toggle` 的状态改变可以传播到你的应用的其他部分，或者触发一些逻辑。","slug":"SwiftUI中的开关组件的用法","published":1,"updated":"2024-03-17T06:12:25.015Z","comments":1,"layout":"post","photos":[],"_id":"clu6up53g001kz6742ibren5e","content":"<p>在 SwiftUI 中，<code>Toggle</code> 是一个用于切换布尔值的 UI 控件。这通常与应用的一些设置或状态开关对应。</p>\n<h3 id=\"基础用法\"><a href=\"#基础用法\" class=\"headerlink\" title=\"基础用法\"></a>基础用法</h3><p>你可以这样创建一个基础的 <code>Toggle</code>：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> isOn <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">false</span><br><br><span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>    <span class=\"hljs-type\">Toggle</span>(<span class=\"hljs-string\">&quot;Switch Label&quot;</span>, isOn: <span class=\"hljs-variable\">$isOn</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这里的 <code>$isOn</code> 是对 <code>isOn</code> 变量的一个绑定，它会在用户操作 <code>Toggle</code> 时自动更新。</p>\n<h3 id=\"自定义外观\"><a href=\"#自定义外观\" class=\"headerlink\" title=\"自定义外观\"></a>自定义外观</h3><p>SwiftUI 允许使用各种修饰符自定义 <code>Toggle</code> 的外观：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Toggle</span>(isOn: <span class=\"hljs-variable\">$isOn</span>) &#123;<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Switch Label&quot;</span>)<br>&#125;<br>.toggleStyle(<span class=\"hljs-type\">SwitchToggleStyle</span>(tint: .green)) <span class=\"hljs-comment\">// 自定义开关颜色</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"使用自定义图标\"><a href=\"#使用自定义图标\" class=\"headerlink\" title=\"使用自定义图标\"></a>使用自定义图标</h3><p>你也可以为 <code>Toggle</code> 的标签使用自定义图标：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Toggle</span>(isOn: <span class=\"hljs-variable\">$isOn</span>) &#123;<br>    <span class=\"hljs-type\">HStack</span> &#123;<br>        <span class=\"hljs-type\">Image</span>(systemName: <span class=\"hljs-string\">&quot;moon.stars.fill&quot;</span>)<br>        <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Dark Mode&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"与列表集成\"><a href=\"#与列表集成\" class=\"headerlink\" title=\"与列表集成\"></a>与列表集成</h3><p><code>Toggle</code> 经常和 <code>List</code> 结合使用，尤其是在设置界面：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">List</span> &#123;<br>    <span class=\"hljs-type\">Toggle</span>(<span class=\"hljs-string\">&quot;Wi-Fi&quot;</span>, isOn: <span class=\"hljs-variable\">$isWifiEnabled</span>)<br>    <span class=\"hljs-type\">Toggle</span>(<span class=\"hljs-string\">&quot;Bluetooth&quot;</span>, isOn: <span class=\"hljs-variable\">$isBluetoothEnabled</span>)<br>    <span class=\"hljs-comment\">// ... 其他设置项</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"无文本标签\"><a href=\"#无文本标签\" class=\"headerlink\" title=\"无文本标签\"></a>无文本标签</h3><p>如果你不需要显示文本标签，可以使用空 <code>Text</code> 或直接省略标签参数：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Toggle</span>(<span class=\"hljs-string\">&quot;&quot;</span>, isOn: <span class=\"hljs-variable\">$isOn</span>)<br><span class=\"hljs-comment\">// 或者</span><br><span class=\"hljs-type\">Toggle</span>(isOn: <span class=\"hljs-variable\">$isOn</span>) &#123;<br>    <span class=\"hljs-comment\">// 省略标签</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"可访问性\"><a href=\"#可访问性\" class=\"headerlink\" title=\"可访问性\"></a>可访问性</h3><p>为了确保你的 <code>Toggle</code> 对于辅助功能用户来说是可访问的，你可以提供额外的信息：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Toggle</span>(<span class=\"hljs-string\">&quot;Enable Notifications&quot;</span>, isOn: <span class=\"hljs-variable\">$areNotificationsEnabled</span>)<br>    .accessibilityLabel(<span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Enable Notifications&quot;</span>))<br>    .accessibilityHint(<span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Toggles whether or not to receive notifications.&quot;</span>))<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"响应状态变化\"><a href=\"#响应状态变化\" class=\"headerlink\" title=\"响应状态变化\"></a>响应状态变化</h3><p>如果你想要在 <code>Toggle</code> 状态改变时执行一些操作，你可以使用 <code>.onChange(of:)</code> 修饰符：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Toggle</span>(<span class=\"hljs-string\">&quot;Enable Notifications&quot;</span>, isOn: <span class=\"hljs-variable\">$areNotificationsEnabled</span>)<br>    .onChange(of: areNotificationsEnabled) &#123; newValue <span class=\"hljs-keyword\">in</span><br>        <span class=\"hljs-comment\">// 当 Toggle 状态变化时执行</span><br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;Notifications are now <span class=\"hljs-subst\">\\(newValue <span class=\"hljs-operator\">?</span> <span class=\"hljs-string\">&quot;enabled&quot;</span> : <span class=\"hljs-string\">&quot;disabled&quot;</span>)</span>&quot;</span>)<br>    &#125;<br></code></pre></td></tr></table></figure>\n\n<p>使用 <code>Toggle</code> 组件可以很容易地为用户提供控制应用设置的方式，它是可声明式 UI 的一个例子，将状态的可视化与状态管理结合起来。通过在 SwiftUI 视图中声明状态和状态之间的绑定，<code>Toggle</code> 的状态改变可以传播到你的应用的其他部分，或者触发一些逻辑。</p>\n","excerpt":"","more":"<p>在 SwiftUI 中，<code>Toggle</code> 是一个用于切换布尔值的 UI 控件。这通常与应用的一些设置或状态开关对应。</p>\n<h3 id=\"基础用法\"><a href=\"#基础用法\" class=\"headerlink\" title=\"基础用法\"></a>基础用法</h3><p>你可以这样创建一个基础的 <code>Toggle</code>：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> isOn <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">false</span><br><br><span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>    <span class=\"hljs-type\">Toggle</span>(<span class=\"hljs-string\">&quot;Switch Label&quot;</span>, isOn: <span class=\"hljs-variable\">$isOn</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这里的 <code>$isOn</code> 是对 <code>isOn</code> 变量的一个绑定，它会在用户操作 <code>Toggle</code> 时自动更新。</p>\n<h3 id=\"自定义外观\"><a href=\"#自定义外观\" class=\"headerlink\" title=\"自定义外观\"></a>自定义外观</h3><p>SwiftUI 允许使用各种修饰符自定义 <code>Toggle</code> 的外观：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Toggle</span>(isOn: <span class=\"hljs-variable\">$isOn</span>) &#123;<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Switch Label&quot;</span>)<br>&#125;<br>.toggleStyle(<span class=\"hljs-type\">SwitchToggleStyle</span>(tint: .green)) <span class=\"hljs-comment\">// 自定义开关颜色</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"使用自定义图标\"><a href=\"#使用自定义图标\" class=\"headerlink\" title=\"使用自定义图标\"></a>使用自定义图标</h3><p>你也可以为 <code>Toggle</code> 的标签使用自定义图标：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Toggle</span>(isOn: <span class=\"hljs-variable\">$isOn</span>) &#123;<br>    <span class=\"hljs-type\">HStack</span> &#123;<br>        <span class=\"hljs-type\">Image</span>(systemName: <span class=\"hljs-string\">&quot;moon.stars.fill&quot;</span>)<br>        <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Dark Mode&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"与列表集成\"><a href=\"#与列表集成\" class=\"headerlink\" title=\"与列表集成\"></a>与列表集成</h3><p><code>Toggle</code> 经常和 <code>List</code> 结合使用，尤其是在设置界面：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">List</span> &#123;<br>    <span class=\"hljs-type\">Toggle</span>(<span class=\"hljs-string\">&quot;Wi-Fi&quot;</span>, isOn: <span class=\"hljs-variable\">$isWifiEnabled</span>)<br>    <span class=\"hljs-type\">Toggle</span>(<span class=\"hljs-string\">&quot;Bluetooth&quot;</span>, isOn: <span class=\"hljs-variable\">$isBluetoothEnabled</span>)<br>    <span class=\"hljs-comment\">// ... 其他设置项</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"无文本标签\"><a href=\"#无文本标签\" class=\"headerlink\" title=\"无文本标签\"></a>无文本标签</h3><p>如果你不需要显示文本标签，可以使用空 <code>Text</code> 或直接省略标签参数：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Toggle</span>(<span class=\"hljs-string\">&quot;&quot;</span>, isOn: <span class=\"hljs-variable\">$isOn</span>)<br><span class=\"hljs-comment\">// 或者</span><br><span class=\"hljs-type\">Toggle</span>(isOn: <span class=\"hljs-variable\">$isOn</span>) &#123;<br>    <span class=\"hljs-comment\">// 省略标签</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"可访问性\"><a href=\"#可访问性\" class=\"headerlink\" title=\"可访问性\"></a>可访问性</h3><p>为了确保你的 <code>Toggle</code> 对于辅助功能用户来说是可访问的，你可以提供额外的信息：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Toggle</span>(<span class=\"hljs-string\">&quot;Enable Notifications&quot;</span>, isOn: <span class=\"hljs-variable\">$areNotificationsEnabled</span>)<br>    .accessibilityLabel(<span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Enable Notifications&quot;</span>))<br>    .accessibilityHint(<span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Toggles whether or not to receive notifications.&quot;</span>))<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"响应状态变化\"><a href=\"#响应状态变化\" class=\"headerlink\" title=\"响应状态变化\"></a>响应状态变化</h3><p>如果你想要在 <code>Toggle</code> 状态改变时执行一些操作，你可以使用 <code>.onChange(of:)</code> 修饰符：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Toggle</span>(<span class=\"hljs-string\">&quot;Enable Notifications&quot;</span>, isOn: <span class=\"hljs-variable\">$areNotificationsEnabled</span>)<br>    .onChange(of: areNotificationsEnabled) &#123; newValue <span class=\"hljs-keyword\">in</span><br>        <span class=\"hljs-comment\">// 当 Toggle 状态变化时执行</span><br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;Notifications are now <span class=\"hljs-subst\">\\(newValue <span class=\"hljs-operator\">?</span> <span class=\"hljs-string\">&quot;enabled&quot;</span> : <span class=\"hljs-string\">&quot;disabled&quot;</span>)</span>&quot;</span>)<br>    &#125;<br></code></pre></td></tr></table></figure>\n\n<p>使用 <code>Toggle</code> 组件可以很容易地为用户提供控制应用设置的方式，它是可声明式 UI 的一个例子，将状态的可视化与状态管理结合起来。通过在 SwiftUI 视图中声明状态和状态之间的绑定，<code>Toggle</code> 的状态改变可以传播到你的应用的其他部分，或者触发一些逻辑。</p>\n"},{"title":"SwiftUI中的按钮组件的用法","date":"2023-11-07T12:12:22.000Z","_content":"SwiftUI 中的 `Button` 组件用于执行用户点击时的操作。它可以容纳文本、图像或其他自定义视图，并且可以通过修饰符来自定义其外观和行为。\n\n下面是 `Button` 的一些基础用法：\n\n### 基础用法\n\n创建一个简单的按钮，并定义点击时执行的动作：\n\n```swift\nButton(\"Click Me\") {\n    // 在这里放置点击按钮后要执行的代码\n    print(\"Button was tapped\")\n}\n```\n\n### 自定义外观\n\n可以通过链式调用修饰符来自定义按钮的外观：\n\n```swift\nButton(\"Click Me\") {\n    // 执行动作\n    print(\"Button was tapped\")\n}\n.foregroundColor(.white)\n.background(Color.blue)\n.cornerRadius(10)\n.padding()\n```\n\n### 使用图像\n\n你还可以使用 `Image` 视图创建一个图像按钮：\n\n```swift\nButton(action: {\n    // 执行动作\n    print(\"Image Button was tapped\")\n}) {\n    Image(systemName: \"heart.fill\")\n        .foregroundColor(.red)\n}\n```\n\n### 组合文本和图像\n\n`Button` 可以容纳多个视图，例如文本和图像：\n\n```swift\nButton(action: {\n    // 执行动作\n}) {\n    HStack {\n        Image(systemName: \"heart.fill\")\n        Text(\"Like\")\n    }\n}\n```\n\n### 自定义按钮样式\n\nSwiftUI 允许你通过 `.buttonStyle()` 修饰符来应用自定义的按钮样式：\n\n```swift\nButton(\"Click Me\") {\n    // 执行动作\n}\n.buttonStyle(MyCustomButtonStyle()) // 应用自定义的按钮样式\n```\n\n### 使用 `Button` 初始化器创建按钮\n\n除了使用闭包，`Button` 还提供了使用 `label` 参数的初始化器，可以让你为按钮的内容提供一个视图构建器：\n\n```swift\nButton(action: {\n    // 执行动作\n}) {\n    // 创建按钮内容\n    Text(\"Click Me\")\n        .fontWeight(.bold)\n}\n```\n\n### 按钮的禁用状态\n\n你可以通过 `.disabled()` 修饰符来控制按钮的可点击状态：\n\n```swift\nButton(\"Click Me\") {\n    // 执行动作\n}\n.disabled(isButtonDisabled) // 根据某个条件禁用按钮\n```\n\n在 SwiftUI 中，`Button` 组件是可组合的，这意味着你可以通过修饰符、自定义样式和视图构建器，创建各种外观和行为的按钮，满足不同的设计需求。\n\n在SwiftUI中，`Button` 的高级用法可以包括自定义触摸行为、动画、无障碍功能和集成到复杂的用户界面模式中。以下是一些高级用法：\n\n### 1. 自定义点击动画\n\n你可以在按钮上应用动画，以便在用户点击时提供视觉反馈：\n\n```swift\nButton(action: {\n    withAnimation {\n        // 执行动作\n    }\n}) {\n    Text(\"Click Me\")\n}\n.scaleEffect(isPressed ? 1.2 : 1.0)\n.animation(.easeInOut(duration: 0.2), value: isPressed)\n.simultaneousGesture(DragGesture(minimumDistance: 0).onChanged({ _ in\n    self.isPressed = true\n}).onEnded({ _ in\n    self.isPressed = false\n}))\n```\n\n### 2. 创建自定义按钮样式\n\n在SwiftUI中，你可以通过实现`ButtonStyle`协议来创建复杂的按钮样式：\n\n```swift\nstruct MyButtonStyle: ButtonStyle {\n    func makeBody(configuration: Self.Configuration) -> some View {\n        configuration.label\n            .background(configuration.isPressed ? Color.gray : Color.blue)\n            .foregroundColor(.white)\n            .cornerRadius(10)\n            .padding()\n            .scaleEffect(configuration.isPressed ? 0.95 : 1)\n            .animation(.spring(), value: configuration.isPressed)\n    }\n}\n\n// 使用自定义样式\nButton(\"Custom Style\") {\n    // 执行动作\n}.buttonStyle(MyButtonStyle())\n```\n\n### 3. 触摸手势集成\n\n通过添加手势，可以对按钮的触摸事件进行更精细的控制：\n\n```swift\nButton(action: {\n    // 执行动作\n}) {\n    Text(\"Gesture Button\")\n}\n.gesture(LongPressGesture(minimumDuration: 2).onEnded { _ in\n    print(\"Long press!\")\n})\n```\n\n### 4. 无障碍功能的集成\n\n确保按钮对于辅助技术是可访问的，例如屏幕阅读器：\n\n```swift\nButton(action: {\n    // 执行动作\n}) {\n    Image(systemName: \"star\")\n}\n.accessibilityLabel(Text(\"Favorite\"))\n.accessibilityHint(Text(\"Double-tap to mark as favorite.\"))\n```\n\n### 5. 按钮与列表集成\n\n将按钮集成到列表或者表单中，并通过按钮改变列表内容：\n\n```swift\nList {\n    Button(\"Add Item\") {\n        // 向列表添加项\n        items.append(\"New Item\")\n    }\n    ForEach(items, id: \\.self) { item in\n        Text(item)\n    }\n}\n```\n\n### 6. 条件禁用按钮\n\n基于特定逻辑禁用按钮：\n\n```swift\nButton(\"Submit\") {\n    // 提交表单\n}\n.disabled(!formIsValid)\n```\n\n### 7. 按钮的多样化布局\n\n结合`HStack`, `VStack`, `ZStack`以及`Spacer`等创建复杂布局：\n\n```swift\nButton(action: {\n    // 执行动作\n}) {\n    VStack {\n        Image(systemName: \"star\")\n        Text(\"Favorites\")\n    }\n}\n```\n\n### 8. 利用视图修改器创建按钮样式\n\n创建一个可以重用的视图修改器，并在按钮上应用：\n\n```swift\nstruct OutlineStyle: ViewModifier {\n    func body(content: Content) -> some View {\n        content\n            .padding()\n            .background(Color.white)\n            .overlay(\n                RoundedRectangle(cornerRadius: 5)\n                    .stroke(Color.blue, lineWidth: 1)\n            )\n    }\n}\n\nButton(\"Outlined Button\") {\n    // 执行动作\n}\n.modifier(OutlineStyle())\n```\n\nSwiftUI中的`Button`使用起来非常灵活，你可以利用多种方式来自定义行为和样式，以满足特定的用户界面和用户体验需求。","source":"_posts/SwiftUI中的按钮组件的用法.md","raw":"---\ntitle: SwiftUI中的按钮组件的用法\ndate: 2023-11-07 20:12:22\ncategories:\n- SwiftUI\ntags:\n---\nSwiftUI 中的 `Button` 组件用于执行用户点击时的操作。它可以容纳文本、图像或其他自定义视图，并且可以通过修饰符来自定义其外观和行为。\n\n下面是 `Button` 的一些基础用法：\n\n### 基础用法\n\n创建一个简单的按钮，并定义点击时执行的动作：\n\n```swift\nButton(\"Click Me\") {\n    // 在这里放置点击按钮后要执行的代码\n    print(\"Button was tapped\")\n}\n```\n\n### 自定义外观\n\n可以通过链式调用修饰符来自定义按钮的外观：\n\n```swift\nButton(\"Click Me\") {\n    // 执行动作\n    print(\"Button was tapped\")\n}\n.foregroundColor(.white)\n.background(Color.blue)\n.cornerRadius(10)\n.padding()\n```\n\n### 使用图像\n\n你还可以使用 `Image` 视图创建一个图像按钮：\n\n```swift\nButton(action: {\n    // 执行动作\n    print(\"Image Button was tapped\")\n}) {\n    Image(systemName: \"heart.fill\")\n        .foregroundColor(.red)\n}\n```\n\n### 组合文本和图像\n\n`Button` 可以容纳多个视图，例如文本和图像：\n\n```swift\nButton(action: {\n    // 执行动作\n}) {\n    HStack {\n        Image(systemName: \"heart.fill\")\n        Text(\"Like\")\n    }\n}\n```\n\n### 自定义按钮样式\n\nSwiftUI 允许你通过 `.buttonStyle()` 修饰符来应用自定义的按钮样式：\n\n```swift\nButton(\"Click Me\") {\n    // 执行动作\n}\n.buttonStyle(MyCustomButtonStyle()) // 应用自定义的按钮样式\n```\n\n### 使用 `Button` 初始化器创建按钮\n\n除了使用闭包，`Button` 还提供了使用 `label` 参数的初始化器，可以让你为按钮的内容提供一个视图构建器：\n\n```swift\nButton(action: {\n    // 执行动作\n}) {\n    // 创建按钮内容\n    Text(\"Click Me\")\n        .fontWeight(.bold)\n}\n```\n\n### 按钮的禁用状态\n\n你可以通过 `.disabled()` 修饰符来控制按钮的可点击状态：\n\n```swift\nButton(\"Click Me\") {\n    // 执行动作\n}\n.disabled(isButtonDisabled) // 根据某个条件禁用按钮\n```\n\n在 SwiftUI 中，`Button` 组件是可组合的，这意味着你可以通过修饰符、自定义样式和视图构建器，创建各种外观和行为的按钮，满足不同的设计需求。\n\n在SwiftUI中，`Button` 的高级用法可以包括自定义触摸行为、动画、无障碍功能和集成到复杂的用户界面模式中。以下是一些高级用法：\n\n### 1. 自定义点击动画\n\n你可以在按钮上应用动画，以便在用户点击时提供视觉反馈：\n\n```swift\nButton(action: {\n    withAnimation {\n        // 执行动作\n    }\n}) {\n    Text(\"Click Me\")\n}\n.scaleEffect(isPressed ? 1.2 : 1.0)\n.animation(.easeInOut(duration: 0.2), value: isPressed)\n.simultaneousGesture(DragGesture(minimumDistance: 0).onChanged({ _ in\n    self.isPressed = true\n}).onEnded({ _ in\n    self.isPressed = false\n}))\n```\n\n### 2. 创建自定义按钮样式\n\n在SwiftUI中，你可以通过实现`ButtonStyle`协议来创建复杂的按钮样式：\n\n```swift\nstruct MyButtonStyle: ButtonStyle {\n    func makeBody(configuration: Self.Configuration) -> some View {\n        configuration.label\n            .background(configuration.isPressed ? Color.gray : Color.blue)\n            .foregroundColor(.white)\n            .cornerRadius(10)\n            .padding()\n            .scaleEffect(configuration.isPressed ? 0.95 : 1)\n            .animation(.spring(), value: configuration.isPressed)\n    }\n}\n\n// 使用自定义样式\nButton(\"Custom Style\") {\n    // 执行动作\n}.buttonStyle(MyButtonStyle())\n```\n\n### 3. 触摸手势集成\n\n通过添加手势，可以对按钮的触摸事件进行更精细的控制：\n\n```swift\nButton(action: {\n    // 执行动作\n}) {\n    Text(\"Gesture Button\")\n}\n.gesture(LongPressGesture(minimumDuration: 2).onEnded { _ in\n    print(\"Long press!\")\n})\n```\n\n### 4. 无障碍功能的集成\n\n确保按钮对于辅助技术是可访问的，例如屏幕阅读器：\n\n```swift\nButton(action: {\n    // 执行动作\n}) {\n    Image(systemName: \"star\")\n}\n.accessibilityLabel(Text(\"Favorite\"))\n.accessibilityHint(Text(\"Double-tap to mark as favorite.\"))\n```\n\n### 5. 按钮与列表集成\n\n将按钮集成到列表或者表单中，并通过按钮改变列表内容：\n\n```swift\nList {\n    Button(\"Add Item\") {\n        // 向列表添加项\n        items.append(\"New Item\")\n    }\n    ForEach(items, id: \\.self) { item in\n        Text(item)\n    }\n}\n```\n\n### 6. 条件禁用按钮\n\n基于特定逻辑禁用按钮：\n\n```swift\nButton(\"Submit\") {\n    // 提交表单\n}\n.disabled(!formIsValid)\n```\n\n### 7. 按钮的多样化布局\n\n结合`HStack`, `VStack`, `ZStack`以及`Spacer`等创建复杂布局：\n\n```swift\nButton(action: {\n    // 执行动作\n}) {\n    VStack {\n        Image(systemName: \"star\")\n        Text(\"Favorites\")\n    }\n}\n```\n\n### 8. 利用视图修改器创建按钮样式\n\n创建一个可以重用的视图修改器，并在按钮上应用：\n\n```swift\nstruct OutlineStyle: ViewModifier {\n    func body(content: Content) -> some View {\n        content\n            .padding()\n            .background(Color.white)\n            .overlay(\n                RoundedRectangle(cornerRadius: 5)\n                    .stroke(Color.blue, lineWidth: 1)\n            )\n    }\n}\n\nButton(\"Outlined Button\") {\n    // 执行动作\n}\n.modifier(OutlineStyle())\n```\n\nSwiftUI中的`Button`使用起来非常灵活，你可以利用多种方式来自定义行为和样式，以满足特定的用户界面和用户体验需求。","slug":"SwiftUI中的按钮组件的用法","published":1,"updated":"2024-03-17T06:12:18.419Z","comments":1,"layout":"post","photos":[],"_id":"clu6up53g001nz674gslwc1va","content":"<p>SwiftUI 中的 <code>Button</code> 组件用于执行用户点击时的操作。它可以容纳文本、图像或其他自定义视图，并且可以通过修饰符来自定义其外观和行为。</p>\n<p>下面是 <code>Button</code> 的一些基础用法：</p>\n<h3 id=\"基础用法\"><a href=\"#基础用法\" class=\"headerlink\" title=\"基础用法\"></a>基础用法</h3><p>创建一个简单的按钮，并定义点击时执行的动作：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Button</span>(<span class=\"hljs-string\">&quot;Click Me&quot;</span>) &#123;<br>    <span class=\"hljs-comment\">// 在这里放置点击按钮后要执行的代码</span><br>    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;Button was tapped&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"自定义外观\"><a href=\"#自定义外观\" class=\"headerlink\" title=\"自定义外观\"></a>自定义外观</h3><p>可以通过链式调用修饰符来自定义按钮的外观：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Button</span>(<span class=\"hljs-string\">&quot;Click Me&quot;</span>) &#123;<br>    <span class=\"hljs-comment\">// 执行动作</span><br>    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;Button was tapped&quot;</span>)<br>&#125;<br>.foregroundColor(.white)<br>.background(<span class=\"hljs-type\">Color</span>.blue)<br>.cornerRadius(<span class=\"hljs-number\">10</span>)<br>.padding()<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"使用图像\"><a href=\"#使用图像\" class=\"headerlink\" title=\"使用图像\"></a>使用图像</h3><p>你还可以使用 <code>Image</code> 视图创建一个图像按钮：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Button</span>(action: &#123;<br>    <span class=\"hljs-comment\">// 执行动作</span><br>    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;Image Button was tapped&quot;</span>)<br>&#125;) &#123;<br>    <span class=\"hljs-type\">Image</span>(systemName: <span class=\"hljs-string\">&quot;heart.fill&quot;</span>)<br>        .foregroundColor(.red)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"组合文本和图像\"><a href=\"#组合文本和图像\" class=\"headerlink\" title=\"组合文本和图像\"></a>组合文本和图像</h3><p><code>Button</code> 可以容纳多个视图，例如文本和图像：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Button</span>(action: &#123;<br>    <span class=\"hljs-comment\">// 执行动作</span><br>&#125;) &#123;<br>    <span class=\"hljs-type\">HStack</span> &#123;<br>        <span class=\"hljs-type\">Image</span>(systemName: <span class=\"hljs-string\">&quot;heart.fill&quot;</span>)<br>        <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Like&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"自定义按钮样式\"><a href=\"#自定义按钮样式\" class=\"headerlink\" title=\"自定义按钮样式\"></a>自定义按钮样式</h3><p>SwiftUI 允许你通过 <code>.buttonStyle()</code> 修饰符来应用自定义的按钮样式：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Button</span>(<span class=\"hljs-string\">&quot;Click Me&quot;</span>) &#123;<br>    <span class=\"hljs-comment\">// 执行动作</span><br>&#125;<br>.buttonStyle(<span class=\"hljs-type\">MyCustomButtonStyle</span>()) <span class=\"hljs-comment\">// 应用自定义的按钮样式</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"使用-Button-初始化器创建按钮\"><a href=\"#使用-Button-初始化器创建按钮\" class=\"headerlink\" title=\"使用 Button 初始化器创建按钮\"></a>使用 <code>Button</code> 初始化器创建按钮</h3><p>除了使用闭包，<code>Button</code> 还提供了使用 <code>label</code> 参数的初始化器，可以让你为按钮的内容提供一个视图构建器：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Button</span>(action: &#123;<br>    <span class=\"hljs-comment\">// 执行动作</span><br>&#125;) &#123;<br>    <span class=\"hljs-comment\">// 创建按钮内容</span><br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Click Me&quot;</span>)<br>        .fontWeight(.bold)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"按钮的禁用状态\"><a href=\"#按钮的禁用状态\" class=\"headerlink\" title=\"按钮的禁用状态\"></a>按钮的禁用状态</h3><p>你可以通过 <code>.disabled()</code> 修饰符来控制按钮的可点击状态：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Button</span>(<span class=\"hljs-string\">&quot;Click Me&quot;</span>) &#123;<br>    <span class=\"hljs-comment\">// 执行动作</span><br>&#125;<br>.disabled(isButtonDisabled) <span class=\"hljs-comment\">// 根据某个条件禁用按钮</span><br></code></pre></td></tr></table></figure>\n\n<p>在 SwiftUI 中，<code>Button</code> 组件是可组合的，这意味着你可以通过修饰符、自定义样式和视图构建器，创建各种外观和行为的按钮，满足不同的设计需求。</p>\n<p>在SwiftUI中，<code>Button</code> 的高级用法可以包括自定义触摸行为、动画、无障碍功能和集成到复杂的用户界面模式中。以下是一些高级用法：</p>\n<h3 id=\"1-自定义点击动画\"><a href=\"#1-自定义点击动画\" class=\"headerlink\" title=\"1. 自定义点击动画\"></a>1. 自定义点击动画</h3><p>你可以在按钮上应用动画，以便在用户点击时提供视觉反馈：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Button</span>(action: &#123;<br>    withAnimation &#123;<br>        <span class=\"hljs-comment\">// 执行动作</span><br>    &#125;<br>&#125;) &#123;<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Click Me&quot;</span>)<br>&#125;<br>.scaleEffect(isPressed <span class=\"hljs-operator\">?</span> <span class=\"hljs-number\">1.2</span> : <span class=\"hljs-number\">1.0</span>)<br>.animation(.easeInOut(duration: <span class=\"hljs-number\">0.2</span>), value: isPressed)<br>.simultaneousGesture(<span class=\"hljs-type\">DragGesture</span>(minimumDistance: <span class=\"hljs-number\">0</span>).onChanged(&#123; <span class=\"hljs-keyword\">_</span> <span class=\"hljs-keyword\">in</span><br>    <span class=\"hljs-keyword\">self</span>.isPressed <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">true</span><br>&#125;).onEnded(&#123; <span class=\"hljs-keyword\">_</span> <span class=\"hljs-keyword\">in</span><br>    <span class=\"hljs-keyword\">self</span>.isPressed <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">false</span><br>&#125;))<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"2-创建自定义按钮样式\"><a href=\"#2-创建自定义按钮样式\" class=\"headerlink\" title=\"2. 创建自定义按钮样式\"></a>2. 创建自定义按钮样式</h3><p>在SwiftUI中，你可以通过实现<code>ButtonStyle</code>协议来创建复杂的按钮样式：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">MyButtonStyle</span>: <span class=\"hljs-title class_\">ButtonStyle</span> &#123;<br>    <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">makeBody</span>(<span class=\"hljs-params\">configuration</span>: <span class=\"hljs-keyword\">Self</span>.<span class=\"hljs-type\">Configuration</span>) -&gt; <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        configuration.label<br>            .background(configuration.isPressed <span class=\"hljs-operator\">?</span> <span class=\"hljs-type\">Color</span>.gray : <span class=\"hljs-type\">Color</span>.blue)<br>            .foregroundColor(.white)<br>            .cornerRadius(<span class=\"hljs-number\">10</span>)<br>            .padding()<br>            .scaleEffect(configuration.isPressed <span class=\"hljs-operator\">?</span> <span class=\"hljs-number\">0.95</span> : <span class=\"hljs-number\">1</span>)<br>            .animation(.spring(), value: configuration.isPressed)<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\">// 使用自定义样式</span><br><span class=\"hljs-type\">Button</span>(<span class=\"hljs-string\">&quot;Custom Style&quot;</span>) &#123;<br>    <span class=\"hljs-comment\">// 执行动作</span><br>&#125;.buttonStyle(<span class=\"hljs-type\">MyButtonStyle</span>())<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"3-触摸手势集成\"><a href=\"#3-触摸手势集成\" class=\"headerlink\" title=\"3. 触摸手势集成\"></a>3. 触摸手势集成</h3><p>通过添加手势，可以对按钮的触摸事件进行更精细的控制：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Button</span>(action: &#123;<br>    <span class=\"hljs-comment\">// 执行动作</span><br>&#125;) &#123;<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Gesture Button&quot;</span>)<br>&#125;<br>.gesture(<span class=\"hljs-type\">LongPressGesture</span>(minimumDuration: <span class=\"hljs-number\">2</span>).onEnded &#123; <span class=\"hljs-keyword\">_</span> <span class=\"hljs-keyword\">in</span><br>    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;Long press!&quot;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"4-无障碍功能的集成\"><a href=\"#4-无障碍功能的集成\" class=\"headerlink\" title=\"4. 无障碍功能的集成\"></a>4. 无障碍功能的集成</h3><p>确保按钮对于辅助技术是可访问的，例如屏幕阅读器：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Button</span>(action: &#123;<br>    <span class=\"hljs-comment\">// 执行动作</span><br>&#125;) &#123;<br>    <span class=\"hljs-type\">Image</span>(systemName: <span class=\"hljs-string\">&quot;star&quot;</span>)<br>&#125;<br>.accessibilityLabel(<span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Favorite&quot;</span>))<br>.accessibilityHint(<span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Double-tap to mark as favorite.&quot;</span>))<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"5-按钮与列表集成\"><a href=\"#5-按钮与列表集成\" class=\"headerlink\" title=\"5. 按钮与列表集成\"></a>5. 按钮与列表集成</h3><p>将按钮集成到列表或者表单中，并通过按钮改变列表内容：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">List</span> &#123;<br>    <span class=\"hljs-type\">Button</span>(<span class=\"hljs-string\">&quot;Add Item&quot;</span>) &#123;<br>        <span class=\"hljs-comment\">// 向列表添加项</span><br>        items.append(<span class=\"hljs-string\">&quot;New Item&quot;</span>)<br>    &#125;<br>    <span class=\"hljs-type\">ForEach</span>(items, id: \\.<span class=\"hljs-keyword\">self</span>) &#123; item <span class=\"hljs-keyword\">in</span><br>        <span class=\"hljs-type\">Text</span>(item)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"6-条件禁用按钮\"><a href=\"#6-条件禁用按钮\" class=\"headerlink\" title=\"6. 条件禁用按钮\"></a>6. 条件禁用按钮</h3><p>基于特定逻辑禁用按钮：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Button</span>(<span class=\"hljs-string\">&quot;Submit&quot;</span>) &#123;<br>    <span class=\"hljs-comment\">// 提交表单</span><br>&#125;<br>.disabled(<span class=\"hljs-operator\">!</span>formIsValid)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"7-按钮的多样化布局\"><a href=\"#7-按钮的多样化布局\" class=\"headerlink\" title=\"7. 按钮的多样化布局\"></a>7. 按钮的多样化布局</h3><p>结合<code>HStack</code>, <code>VStack</code>, <code>ZStack</code>以及<code>Spacer</code>等创建复杂布局：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Button</span>(action: &#123;<br>    <span class=\"hljs-comment\">// 执行动作</span><br>&#125;) &#123;<br>    <span class=\"hljs-type\">VStack</span> &#123;<br>        <span class=\"hljs-type\">Image</span>(systemName: <span class=\"hljs-string\">&quot;star&quot;</span>)<br>        <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Favorites&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"8-利用视图修改器创建按钮样式\"><a href=\"#8-利用视图修改器创建按钮样式\" class=\"headerlink\" title=\"8. 利用视图修改器创建按钮样式\"></a>8. 利用视图修改器创建按钮样式</h3><p>创建一个可以重用的视图修改器，并在按钮上应用：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">OutlineStyle</span>: <span class=\"hljs-title class_\">ViewModifier</span> &#123;<br>    <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">body</span>(<span class=\"hljs-params\">content</span>: <span class=\"hljs-type\">Content</span>) -&gt; <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        content<br>            .padding()<br>            .background(<span class=\"hljs-type\">Color</span>.white)<br>            .overlay(<br>                <span class=\"hljs-type\">RoundedRectangle</span>(cornerRadius: <span class=\"hljs-number\">5</span>)<br>                    .stroke(<span class=\"hljs-type\">Color</span>.blue, lineWidth: <span class=\"hljs-number\">1</span>)<br>            )<br>    &#125;<br>&#125;<br><br><span class=\"hljs-type\">Button</span>(<span class=\"hljs-string\">&quot;Outlined Button&quot;</span>) &#123;<br>    <span class=\"hljs-comment\">// 执行动作</span><br>&#125;<br>.modifier(<span class=\"hljs-type\">OutlineStyle</span>())<br></code></pre></td></tr></table></figure>\n\n<p>SwiftUI中的<code>Button</code>使用起来非常灵活，你可以利用多种方式来自定义行为和样式，以满足特定的用户界面和用户体验需求。</p>\n","excerpt":"","more":"<p>SwiftUI 中的 <code>Button</code> 组件用于执行用户点击时的操作。它可以容纳文本、图像或其他自定义视图，并且可以通过修饰符来自定义其外观和行为。</p>\n<p>下面是 <code>Button</code> 的一些基础用法：</p>\n<h3 id=\"基础用法\"><a href=\"#基础用法\" class=\"headerlink\" title=\"基础用法\"></a>基础用法</h3><p>创建一个简单的按钮，并定义点击时执行的动作：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Button</span>(<span class=\"hljs-string\">&quot;Click Me&quot;</span>) &#123;<br>    <span class=\"hljs-comment\">// 在这里放置点击按钮后要执行的代码</span><br>    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;Button was tapped&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"自定义外观\"><a href=\"#自定义外观\" class=\"headerlink\" title=\"自定义外观\"></a>自定义外观</h3><p>可以通过链式调用修饰符来自定义按钮的外观：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Button</span>(<span class=\"hljs-string\">&quot;Click Me&quot;</span>) &#123;<br>    <span class=\"hljs-comment\">// 执行动作</span><br>    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;Button was tapped&quot;</span>)<br>&#125;<br>.foregroundColor(.white)<br>.background(<span class=\"hljs-type\">Color</span>.blue)<br>.cornerRadius(<span class=\"hljs-number\">10</span>)<br>.padding()<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"使用图像\"><a href=\"#使用图像\" class=\"headerlink\" title=\"使用图像\"></a>使用图像</h3><p>你还可以使用 <code>Image</code> 视图创建一个图像按钮：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Button</span>(action: &#123;<br>    <span class=\"hljs-comment\">// 执行动作</span><br>    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;Image Button was tapped&quot;</span>)<br>&#125;) &#123;<br>    <span class=\"hljs-type\">Image</span>(systemName: <span class=\"hljs-string\">&quot;heart.fill&quot;</span>)<br>        .foregroundColor(.red)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"组合文本和图像\"><a href=\"#组合文本和图像\" class=\"headerlink\" title=\"组合文本和图像\"></a>组合文本和图像</h3><p><code>Button</code> 可以容纳多个视图，例如文本和图像：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Button</span>(action: &#123;<br>    <span class=\"hljs-comment\">// 执行动作</span><br>&#125;) &#123;<br>    <span class=\"hljs-type\">HStack</span> &#123;<br>        <span class=\"hljs-type\">Image</span>(systemName: <span class=\"hljs-string\">&quot;heart.fill&quot;</span>)<br>        <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Like&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"自定义按钮样式\"><a href=\"#自定义按钮样式\" class=\"headerlink\" title=\"自定义按钮样式\"></a>自定义按钮样式</h3><p>SwiftUI 允许你通过 <code>.buttonStyle()</code> 修饰符来应用自定义的按钮样式：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Button</span>(<span class=\"hljs-string\">&quot;Click Me&quot;</span>) &#123;<br>    <span class=\"hljs-comment\">// 执行动作</span><br>&#125;<br>.buttonStyle(<span class=\"hljs-type\">MyCustomButtonStyle</span>()) <span class=\"hljs-comment\">// 应用自定义的按钮样式</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"使用-Button-初始化器创建按钮\"><a href=\"#使用-Button-初始化器创建按钮\" class=\"headerlink\" title=\"使用 Button 初始化器创建按钮\"></a>使用 <code>Button</code> 初始化器创建按钮</h3><p>除了使用闭包，<code>Button</code> 还提供了使用 <code>label</code> 参数的初始化器，可以让你为按钮的内容提供一个视图构建器：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Button</span>(action: &#123;<br>    <span class=\"hljs-comment\">// 执行动作</span><br>&#125;) &#123;<br>    <span class=\"hljs-comment\">// 创建按钮内容</span><br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Click Me&quot;</span>)<br>        .fontWeight(.bold)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"按钮的禁用状态\"><a href=\"#按钮的禁用状态\" class=\"headerlink\" title=\"按钮的禁用状态\"></a>按钮的禁用状态</h3><p>你可以通过 <code>.disabled()</code> 修饰符来控制按钮的可点击状态：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Button</span>(<span class=\"hljs-string\">&quot;Click Me&quot;</span>) &#123;<br>    <span class=\"hljs-comment\">// 执行动作</span><br>&#125;<br>.disabled(isButtonDisabled) <span class=\"hljs-comment\">// 根据某个条件禁用按钮</span><br></code></pre></td></tr></table></figure>\n\n<p>在 SwiftUI 中，<code>Button</code> 组件是可组合的，这意味着你可以通过修饰符、自定义样式和视图构建器，创建各种外观和行为的按钮，满足不同的设计需求。</p>\n<p>在SwiftUI中，<code>Button</code> 的高级用法可以包括自定义触摸行为、动画、无障碍功能和集成到复杂的用户界面模式中。以下是一些高级用法：</p>\n<h3 id=\"1-自定义点击动画\"><a href=\"#1-自定义点击动画\" class=\"headerlink\" title=\"1. 自定义点击动画\"></a>1. 自定义点击动画</h3><p>你可以在按钮上应用动画，以便在用户点击时提供视觉反馈：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Button</span>(action: &#123;<br>    withAnimation &#123;<br>        <span class=\"hljs-comment\">// 执行动作</span><br>    &#125;<br>&#125;) &#123;<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Click Me&quot;</span>)<br>&#125;<br>.scaleEffect(isPressed <span class=\"hljs-operator\">?</span> <span class=\"hljs-number\">1.2</span> : <span class=\"hljs-number\">1.0</span>)<br>.animation(.easeInOut(duration: <span class=\"hljs-number\">0.2</span>), value: isPressed)<br>.simultaneousGesture(<span class=\"hljs-type\">DragGesture</span>(minimumDistance: <span class=\"hljs-number\">0</span>).onChanged(&#123; <span class=\"hljs-keyword\">_</span> <span class=\"hljs-keyword\">in</span><br>    <span class=\"hljs-keyword\">self</span>.isPressed <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">true</span><br>&#125;).onEnded(&#123; <span class=\"hljs-keyword\">_</span> <span class=\"hljs-keyword\">in</span><br>    <span class=\"hljs-keyword\">self</span>.isPressed <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">false</span><br>&#125;))<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"2-创建自定义按钮样式\"><a href=\"#2-创建自定义按钮样式\" class=\"headerlink\" title=\"2. 创建自定义按钮样式\"></a>2. 创建自定义按钮样式</h3><p>在SwiftUI中，你可以通过实现<code>ButtonStyle</code>协议来创建复杂的按钮样式：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">MyButtonStyle</span>: <span class=\"hljs-title class_\">ButtonStyle</span> &#123;<br>    <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">makeBody</span>(<span class=\"hljs-params\">configuration</span>: <span class=\"hljs-keyword\">Self</span>.<span class=\"hljs-type\">Configuration</span>) -&gt; <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        configuration.label<br>            .background(configuration.isPressed <span class=\"hljs-operator\">?</span> <span class=\"hljs-type\">Color</span>.gray : <span class=\"hljs-type\">Color</span>.blue)<br>            .foregroundColor(.white)<br>            .cornerRadius(<span class=\"hljs-number\">10</span>)<br>            .padding()<br>            .scaleEffect(configuration.isPressed <span class=\"hljs-operator\">?</span> <span class=\"hljs-number\">0.95</span> : <span class=\"hljs-number\">1</span>)<br>            .animation(.spring(), value: configuration.isPressed)<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\">// 使用自定义样式</span><br><span class=\"hljs-type\">Button</span>(<span class=\"hljs-string\">&quot;Custom Style&quot;</span>) &#123;<br>    <span class=\"hljs-comment\">// 执行动作</span><br>&#125;.buttonStyle(<span class=\"hljs-type\">MyButtonStyle</span>())<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"3-触摸手势集成\"><a href=\"#3-触摸手势集成\" class=\"headerlink\" title=\"3. 触摸手势集成\"></a>3. 触摸手势集成</h3><p>通过添加手势，可以对按钮的触摸事件进行更精细的控制：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Button</span>(action: &#123;<br>    <span class=\"hljs-comment\">// 执行动作</span><br>&#125;) &#123;<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Gesture Button&quot;</span>)<br>&#125;<br>.gesture(<span class=\"hljs-type\">LongPressGesture</span>(minimumDuration: <span class=\"hljs-number\">2</span>).onEnded &#123; <span class=\"hljs-keyword\">_</span> <span class=\"hljs-keyword\">in</span><br>    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;Long press!&quot;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"4-无障碍功能的集成\"><a href=\"#4-无障碍功能的集成\" class=\"headerlink\" title=\"4. 无障碍功能的集成\"></a>4. 无障碍功能的集成</h3><p>确保按钮对于辅助技术是可访问的，例如屏幕阅读器：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Button</span>(action: &#123;<br>    <span class=\"hljs-comment\">// 执行动作</span><br>&#125;) &#123;<br>    <span class=\"hljs-type\">Image</span>(systemName: <span class=\"hljs-string\">&quot;star&quot;</span>)<br>&#125;<br>.accessibilityLabel(<span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Favorite&quot;</span>))<br>.accessibilityHint(<span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Double-tap to mark as favorite.&quot;</span>))<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"5-按钮与列表集成\"><a href=\"#5-按钮与列表集成\" class=\"headerlink\" title=\"5. 按钮与列表集成\"></a>5. 按钮与列表集成</h3><p>将按钮集成到列表或者表单中，并通过按钮改变列表内容：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">List</span> &#123;<br>    <span class=\"hljs-type\">Button</span>(<span class=\"hljs-string\">&quot;Add Item&quot;</span>) &#123;<br>        <span class=\"hljs-comment\">// 向列表添加项</span><br>        items.append(<span class=\"hljs-string\">&quot;New Item&quot;</span>)<br>    &#125;<br>    <span class=\"hljs-type\">ForEach</span>(items, id: \\.<span class=\"hljs-keyword\">self</span>) &#123; item <span class=\"hljs-keyword\">in</span><br>        <span class=\"hljs-type\">Text</span>(item)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"6-条件禁用按钮\"><a href=\"#6-条件禁用按钮\" class=\"headerlink\" title=\"6. 条件禁用按钮\"></a>6. 条件禁用按钮</h3><p>基于特定逻辑禁用按钮：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Button</span>(<span class=\"hljs-string\">&quot;Submit&quot;</span>) &#123;<br>    <span class=\"hljs-comment\">// 提交表单</span><br>&#125;<br>.disabled(<span class=\"hljs-operator\">!</span>formIsValid)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"7-按钮的多样化布局\"><a href=\"#7-按钮的多样化布局\" class=\"headerlink\" title=\"7. 按钮的多样化布局\"></a>7. 按钮的多样化布局</h3><p>结合<code>HStack</code>, <code>VStack</code>, <code>ZStack</code>以及<code>Spacer</code>等创建复杂布局：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Button</span>(action: &#123;<br>    <span class=\"hljs-comment\">// 执行动作</span><br>&#125;) &#123;<br>    <span class=\"hljs-type\">VStack</span> &#123;<br>        <span class=\"hljs-type\">Image</span>(systemName: <span class=\"hljs-string\">&quot;star&quot;</span>)<br>        <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Favorites&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"8-利用视图修改器创建按钮样式\"><a href=\"#8-利用视图修改器创建按钮样式\" class=\"headerlink\" title=\"8. 利用视图修改器创建按钮样式\"></a>8. 利用视图修改器创建按钮样式</h3><p>创建一个可以重用的视图修改器，并在按钮上应用：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">OutlineStyle</span>: <span class=\"hljs-title class_\">ViewModifier</span> &#123;<br>    <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">body</span>(<span class=\"hljs-params\">content</span>: <span class=\"hljs-type\">Content</span>) -&gt; <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        content<br>            .padding()<br>            .background(<span class=\"hljs-type\">Color</span>.white)<br>            .overlay(<br>                <span class=\"hljs-type\">RoundedRectangle</span>(cornerRadius: <span class=\"hljs-number\">5</span>)<br>                    .stroke(<span class=\"hljs-type\">Color</span>.blue, lineWidth: <span class=\"hljs-number\">1</span>)<br>            )<br>    &#125;<br>&#125;<br><br><span class=\"hljs-type\">Button</span>(<span class=\"hljs-string\">&quot;Outlined Button&quot;</span>) &#123;<br>    <span class=\"hljs-comment\">// 执行动作</span><br>&#125;<br>.modifier(<span class=\"hljs-type\">OutlineStyle</span>())<br></code></pre></td></tr></table></figure>\n\n<p>SwiftUI中的<code>Button</code>使用起来非常灵活，你可以利用多种方式来自定义行为和样式，以满足特定的用户界面和用户体验需求。</p>\n"},{"title":"SwiftUI中的文本控件的用法","date":"2023-11-07T12:04:52.000Z","_content":"SwiftUI 中的 `Text` 视图用于显示一行或多行只读文本。它是 SwiftUI 中显示文本内容的基础组件，支持字符串文字和动态字符串。\n\n这里有一些基本和常见的用法：\n\n### 基本用法\n\n创建一个简单的 `Text` 视图：\n\n```swift\nText(\"Hello, World!\")\n```\n\n### 文本样式\n\n你可以为 `Text` 视图添加修饰符来改变文本的样式：\n\n```swift\nText(\"Hello, World!\")\n    .font(.title) // 设置字体样式\n    .fontWeight(.bold) // 设置字体权重\n    .foregroundColor(.blue) // 设置文本颜色\n```\n\n### 多行文本和截断\n\nSwiftUI 会根据需要自动换行文本，也可以控制截断的位置：\n\n```swift\nText(\"This is a very long string that will wrap or truncate based on the available space.\")\n    .frame(width: 100) // 限制视图的宽度\n    .lineLimit(2) // 最多显示两行\n    .truncationMode(.tail) // 末尾截断\n```\n\n### 对齐文本\n\n可以调整文本的对齐方式：\n\n```swift\nText(\"Aligned Text\")\n    .frame(width: 200, height: 200) // 设置视图的大小\n    .multilineTextAlignment(.center) // 多行文本居中对齐\n```\n\n### 文本和图像的组合\n\n`Text` 视图可以和其他视图比如 `Image` 组合在一起：\n\n```swift\nHStack {\n    Image(systemName: \"star.fill\") // 系统图标\n        .foregroundColor(.yellow) // 设置图标颜色\n    Text(\"Favorite\")\n        .font(.headline) // 设置文本字体\n}\n```\n\n### 本地化和动态文本\n\nSwiftUI 支持本地化和动态文本内容：\n\n```swift\nText(LocalizedStringKey(\"WelcomeMessage\"))\nText(\"Hello, \\(userName)!\")\n```\n\n### 文本样式的继承\n\n如果你将 `Text` 视图放入另一个视图中，它将继承父视图的样式：\n\n```swift\nVStack {\n    Text(\"First Line\")\n    Text(\"Second Line\")\n}.font(.title) // 所有文本都应用标题字体样式\n```\n\n### 交互式文本（例如链接）\n\n可以在 `Text` 视图中添加可交互的链接：\n\n```swift\nText(\"Visit Apple's website for more information.\")\n    .underline()\n    .foregroundColor(.blue)\n    .onTapGesture {\n        if let url = URL(string: \"https://www.apple.com\") {\n            UIApplication.shared.open(url)\n        }\n    }\n```\n\n`Text` 视图是 SwiftUI 中非常强大的组件，其修饰符可以链式组合，用于创建丰富且响应式的文本界面。记住在实际的 iOS 开发环境中，某些功能（如打开 URL）可能需要其他的考虑（例如使用 `Link` 视图而不是 `onTapGesture`）。\n\nSwiftUI 的 `Text` 视图虽然简单，但它也支持一些高级用法，允许创建复杂和富有表现力的文本布局。以下是一些高级用法的示例：\n\n### 富文本（Attributed Strings）\n\n在 SwiftUI 中，你可以使用属性字符串来创建富文本，这可以通过直接在 `Text` 初始化器中使用带有属性的字符串来实现：\n\n```swift\nlet attributedString = NSAttributedString( ... ) // 创建一个属性字符串\nText(attributedString)\n```\n\n在 SwiftUI 3.0 中，可以更方便地创建富文本，使用多个 `Text` 视图的组合，并对它们应用不同的修饰符：\n\n```swift\nText(\"This \") +\nText(\"word \").fontWeight(.bold) +\nText(\"is bold.\")\n```\n\n### 文本插值和格式化\n\nSwiftUI 允许对插入到 `Text` 中的数据进行格式化：\n\n```swift\nText(\"The temperature is \\(temperature, specifier: \"%.1f\") degrees.\")\n```\n\n或者使用更现代的方法，配合 `FormatStyle`：\n\n```swift\nText(temperature, format: .number.precision(.fractionLength(1)))\n```\n\n### 组合和叠加视图\n\n在 SwiftUI 中，可以将 `Text` 视图与其他视图组合，并应用不同的布局和效果：\n\n```swift\nText(\"Hello\")\n    .background(\n        Image(\"backgroundImage\")\n            .resizable()\n            .aspectRatio(contentMode: .fill)\n    )\n```\n\n### 文本阴影和其他效果\n\n可以为文本添加阴影或其他视觉效果：\n\n```swift\nText(\"Elevated Text\")\n    .shadow(color: .gray, radius: 2, x: 0, y: 2)\n```\n\n### 条件修饰符\n\n可以基于条件应用不同的修饰符：\n\n```swift\nText(\"This might be bold\")\n    .fontWeight(isBold ? .bold : nil)\n```\n\n### 选择性地隐藏视图\n\n有时候你可能想要基于某些条件隐藏 `Text` 视图。这可以通过条件修饰符实现：\n\n```swift\nText(\"Hidden text\")\n    .opacity(isHidden ? 0 : 1)\n```\n\n### 访问视图大小\n\n可以通过 `background` 修饰符和 `GeometryReader` 来获取 `Text` 视图的大小：\n\n```swift\nText(\"Dynamic Size\")\n    .background(GeometryReader { geometry in\n        Color.clear.onAppear {\n            print(\"Text size: \\(geometry.size)\")\n        }\n    })\n```\n\n### 复杂的文本处理\n\n如果你需要对文本进行更复杂的处理，比如解析和渲染 HTML 或者 Markdown，你可能需要使用 `NSAttributedString` 或查找第三方库，或在 SwiftUI 中嵌入 `UIKit` 或 `AppKit` 组件来完成。\n\n### 响应式文本\n\n可以通过环境变量，如 `@EnvironmentObject` 或 `@ObservedObject` 来创建响应式文本，使其内容基于应用程序的状态而改变。\n\nSwiftUI `Text` 视图的高级用法，结合了修饰符和 SwiftUI 的其他视图和功能，可以创建高度定制化的文本展示效果。这些高级技巧可以帮助你更好地控制文本的布局、样式和行为。","source":"_posts/SwiftUI中的文本控件的用法.md","raw":"---\ntitle: SwiftUI中的文本控件的用法\ndate: 2023-11-07 20:04:52\ncategories:\n- SwiftUI\ntags:\n---\nSwiftUI 中的 `Text` 视图用于显示一行或多行只读文本。它是 SwiftUI 中显示文本内容的基础组件，支持字符串文字和动态字符串。\n\n这里有一些基本和常见的用法：\n\n### 基本用法\n\n创建一个简单的 `Text` 视图：\n\n```swift\nText(\"Hello, World!\")\n```\n\n### 文本样式\n\n你可以为 `Text` 视图添加修饰符来改变文本的样式：\n\n```swift\nText(\"Hello, World!\")\n    .font(.title) // 设置字体样式\n    .fontWeight(.bold) // 设置字体权重\n    .foregroundColor(.blue) // 设置文本颜色\n```\n\n### 多行文本和截断\n\nSwiftUI 会根据需要自动换行文本，也可以控制截断的位置：\n\n```swift\nText(\"This is a very long string that will wrap or truncate based on the available space.\")\n    .frame(width: 100) // 限制视图的宽度\n    .lineLimit(2) // 最多显示两行\n    .truncationMode(.tail) // 末尾截断\n```\n\n### 对齐文本\n\n可以调整文本的对齐方式：\n\n```swift\nText(\"Aligned Text\")\n    .frame(width: 200, height: 200) // 设置视图的大小\n    .multilineTextAlignment(.center) // 多行文本居中对齐\n```\n\n### 文本和图像的组合\n\n`Text` 视图可以和其他视图比如 `Image` 组合在一起：\n\n```swift\nHStack {\n    Image(systemName: \"star.fill\") // 系统图标\n        .foregroundColor(.yellow) // 设置图标颜色\n    Text(\"Favorite\")\n        .font(.headline) // 设置文本字体\n}\n```\n\n### 本地化和动态文本\n\nSwiftUI 支持本地化和动态文本内容：\n\n```swift\nText(LocalizedStringKey(\"WelcomeMessage\"))\nText(\"Hello, \\(userName)!\")\n```\n\n### 文本样式的继承\n\n如果你将 `Text` 视图放入另一个视图中，它将继承父视图的样式：\n\n```swift\nVStack {\n    Text(\"First Line\")\n    Text(\"Second Line\")\n}.font(.title) // 所有文本都应用标题字体样式\n```\n\n### 交互式文本（例如链接）\n\n可以在 `Text` 视图中添加可交互的链接：\n\n```swift\nText(\"Visit Apple's website for more information.\")\n    .underline()\n    .foregroundColor(.blue)\n    .onTapGesture {\n        if let url = URL(string: \"https://www.apple.com\") {\n            UIApplication.shared.open(url)\n        }\n    }\n```\n\n`Text` 视图是 SwiftUI 中非常强大的组件，其修饰符可以链式组合，用于创建丰富且响应式的文本界面。记住在实际的 iOS 开发环境中，某些功能（如打开 URL）可能需要其他的考虑（例如使用 `Link` 视图而不是 `onTapGesture`）。\n\nSwiftUI 的 `Text` 视图虽然简单，但它也支持一些高级用法，允许创建复杂和富有表现力的文本布局。以下是一些高级用法的示例：\n\n### 富文本（Attributed Strings）\n\n在 SwiftUI 中，你可以使用属性字符串来创建富文本，这可以通过直接在 `Text` 初始化器中使用带有属性的字符串来实现：\n\n```swift\nlet attributedString = NSAttributedString( ... ) // 创建一个属性字符串\nText(attributedString)\n```\n\n在 SwiftUI 3.0 中，可以更方便地创建富文本，使用多个 `Text` 视图的组合，并对它们应用不同的修饰符：\n\n```swift\nText(\"This \") +\nText(\"word \").fontWeight(.bold) +\nText(\"is bold.\")\n```\n\n### 文本插值和格式化\n\nSwiftUI 允许对插入到 `Text` 中的数据进行格式化：\n\n```swift\nText(\"The temperature is \\(temperature, specifier: \"%.1f\") degrees.\")\n```\n\n或者使用更现代的方法，配合 `FormatStyle`：\n\n```swift\nText(temperature, format: .number.precision(.fractionLength(1)))\n```\n\n### 组合和叠加视图\n\n在 SwiftUI 中，可以将 `Text` 视图与其他视图组合，并应用不同的布局和效果：\n\n```swift\nText(\"Hello\")\n    .background(\n        Image(\"backgroundImage\")\n            .resizable()\n            .aspectRatio(contentMode: .fill)\n    )\n```\n\n### 文本阴影和其他效果\n\n可以为文本添加阴影或其他视觉效果：\n\n```swift\nText(\"Elevated Text\")\n    .shadow(color: .gray, radius: 2, x: 0, y: 2)\n```\n\n### 条件修饰符\n\n可以基于条件应用不同的修饰符：\n\n```swift\nText(\"This might be bold\")\n    .fontWeight(isBold ? .bold : nil)\n```\n\n### 选择性地隐藏视图\n\n有时候你可能想要基于某些条件隐藏 `Text` 视图。这可以通过条件修饰符实现：\n\n```swift\nText(\"Hidden text\")\n    .opacity(isHidden ? 0 : 1)\n```\n\n### 访问视图大小\n\n可以通过 `background` 修饰符和 `GeometryReader` 来获取 `Text` 视图的大小：\n\n```swift\nText(\"Dynamic Size\")\n    .background(GeometryReader { geometry in\n        Color.clear.onAppear {\n            print(\"Text size: \\(geometry.size)\")\n        }\n    })\n```\n\n### 复杂的文本处理\n\n如果你需要对文本进行更复杂的处理，比如解析和渲染 HTML 或者 Markdown，你可能需要使用 `NSAttributedString` 或查找第三方库，或在 SwiftUI 中嵌入 `UIKit` 或 `AppKit` 组件来完成。\n\n### 响应式文本\n\n可以通过环境变量，如 `@EnvironmentObject` 或 `@ObservedObject` 来创建响应式文本，使其内容基于应用程序的状态而改变。\n\nSwiftUI `Text` 视图的高级用法，结合了修饰符和 SwiftUI 的其他视图和功能，可以创建高度定制化的文本展示效果。这些高级技巧可以帮助你更好地控制文本的布局、样式和行为。","slug":"SwiftUI中的文本控件的用法","published":1,"updated":"2024-03-17T06:12:31.171Z","comments":1,"layout":"post","photos":[],"_id":"clu6up53g001qz674eaj62zgp","content":"<p>SwiftUI 中的 <code>Text</code> 视图用于显示一行或多行只读文本。它是 SwiftUI 中显示文本内容的基础组件，支持字符串文字和动态字符串。</p>\n<p>这里有一些基本和常见的用法：</p>\n<h3 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><p>创建一个简单的 <code>Text</code> 视图：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Hello, World!&quot;</span>)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"文本样式\"><a href=\"#文本样式\" class=\"headerlink\" title=\"文本样式\"></a>文本样式</h3><p>你可以为 <code>Text</code> 视图添加修饰符来改变文本的样式：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Hello, World!&quot;</span>)<br>    .font(.title) <span class=\"hljs-comment\">// 设置字体样式</span><br>    .fontWeight(.bold) <span class=\"hljs-comment\">// 设置字体权重</span><br>    .foregroundColor(.blue) <span class=\"hljs-comment\">// 设置文本颜色</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"多行文本和截断\"><a href=\"#多行文本和截断\" class=\"headerlink\" title=\"多行文本和截断\"></a>多行文本和截断</h3><p>SwiftUI 会根据需要自动换行文本，也可以控制截断的位置：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;This is a very long string that will wrap or truncate based on the available space.&quot;</span>)<br>    .frame(width: <span class=\"hljs-number\">100</span>) <span class=\"hljs-comment\">// 限制视图的宽度</span><br>    .lineLimit(<span class=\"hljs-number\">2</span>) <span class=\"hljs-comment\">// 最多显示两行</span><br>    .truncationMode(.tail) <span class=\"hljs-comment\">// 末尾截断</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"对齐文本\"><a href=\"#对齐文本\" class=\"headerlink\" title=\"对齐文本\"></a>对齐文本</h3><p>可以调整文本的对齐方式：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Aligned Text&quot;</span>)<br>    .frame(width: <span class=\"hljs-number\">200</span>, height: <span class=\"hljs-number\">200</span>) <span class=\"hljs-comment\">// 设置视图的大小</span><br>    .multilineTextAlignment(.center) <span class=\"hljs-comment\">// 多行文本居中对齐</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"文本和图像的组合\"><a href=\"#文本和图像的组合\" class=\"headerlink\" title=\"文本和图像的组合\"></a>文本和图像的组合</h3><p><code>Text</code> 视图可以和其他视图比如 <code>Image</code> 组合在一起：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">HStack</span> &#123;<br>    <span class=\"hljs-type\">Image</span>(systemName: <span class=\"hljs-string\">&quot;star.fill&quot;</span>) <span class=\"hljs-comment\">// 系统图标</span><br>        .foregroundColor(.yellow) <span class=\"hljs-comment\">// 设置图标颜色</span><br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Favorite&quot;</span>)<br>        .font(.headline) <span class=\"hljs-comment\">// 设置文本字体</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"本地化和动态文本\"><a href=\"#本地化和动态文本\" class=\"headerlink\" title=\"本地化和动态文本\"></a>本地化和动态文本</h3><p>SwiftUI 支持本地化和动态文本内容：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Text</span>(<span class=\"hljs-type\">LocalizedStringKey</span>(<span class=\"hljs-string\">&quot;WelcomeMessage&quot;</span>))<br><span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Hello, <span class=\"hljs-subst\">\\(userName)</span>!&quot;</span>)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"文本样式的继承\"><a href=\"#文本样式的继承\" class=\"headerlink\" title=\"文本样式的继承\"></a>文本样式的继承</h3><p>如果你将 <code>Text</code> 视图放入另一个视图中，它将继承父视图的样式：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">VStack</span> &#123;<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;First Line&quot;</span>)<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Second Line&quot;</span>)<br>&#125;.font(.title) <span class=\"hljs-comment\">// 所有文本都应用标题字体样式</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"交互式文本（例如链接）\"><a href=\"#交互式文本（例如链接）\" class=\"headerlink\" title=\"交互式文本（例如链接）\"></a>交互式文本（例如链接）</h3><p>可以在 <code>Text</code> 视图中添加可交互的链接：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Visit Apple&#x27;s website for more information.&quot;</span>)<br>    .underline()<br>    .foregroundColor(.blue)<br>    .onTapGesture &#123;<br>        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">let</span> url <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">URL</span>(string: <span class=\"hljs-string\">&quot;https://www.apple.com&quot;</span>) &#123;<br>            <span class=\"hljs-type\">UIApplication</span>.shared.open(url)<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>\n\n<p><code>Text</code> 视图是 SwiftUI 中非常强大的组件，其修饰符可以链式组合，用于创建丰富且响应式的文本界面。记住在实际的 iOS 开发环境中，某些功能（如打开 URL）可能需要其他的考虑（例如使用 <code>Link</code> 视图而不是 <code>onTapGesture</code>）。</p>\n<p>SwiftUI 的 <code>Text</code> 视图虽然简单，但它也支持一些高级用法，允许创建复杂和富有表现力的文本布局。以下是一些高级用法的示例：</p>\n<h3 id=\"富文本（Attributed-Strings）\"><a href=\"#富文本（Attributed-Strings）\" class=\"headerlink\" title=\"富文本（Attributed Strings）\"></a>富文本（Attributed Strings）</h3><p>在 SwiftUI 中，你可以使用属性字符串来创建富文本，这可以通过直接在 <code>Text</code> 初始化器中使用带有属性的字符串来实现：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">let</span> attributedString <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">NSAttributedString</span>( <span class=\"hljs-operator\">...</span> ) <span class=\"hljs-comment\">// 创建一个属性字符串</span><br><span class=\"hljs-type\">Text</span>(attributedString)<br></code></pre></td></tr></table></figure>\n\n<p>在 SwiftUI 3.0 中，可以更方便地创建富文本，使用多个 <code>Text</code> 视图的组合，并对它们应用不同的修饰符：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;This &quot;</span>) <span class=\"hljs-operator\">+</span><br><span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;word &quot;</span>).fontWeight(.bold) <span class=\"hljs-operator\">+</span><br><span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;is bold.&quot;</span>)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"文本插值和格式化\"><a href=\"#文本插值和格式化\" class=\"headerlink\" title=\"文本插值和格式化\"></a>文本插值和格式化</h3><p>SwiftUI 允许对插入到 <code>Text</code> 中的数据进行格式化：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;The temperature is <span class=\"hljs-subst\">\\(temperature, specifier: <span class=\"hljs-string\">&quot;%.1f&quot;</span>)</span> degrees.&quot;</span>)<br></code></pre></td></tr></table></figure>\n\n<p>或者使用更现代的方法，配合 <code>FormatStyle</code>：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Text</span>(temperature, format: .number.precision(.fractionLength(<span class=\"hljs-number\">1</span>)))<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"组合和叠加视图\"><a href=\"#组合和叠加视图\" class=\"headerlink\" title=\"组合和叠加视图\"></a>组合和叠加视图</h3><p>在 SwiftUI 中，可以将 <code>Text</code> 视图与其他视图组合，并应用不同的布局和效果：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Hello&quot;</span>)<br>    .background(<br>        <span class=\"hljs-type\">Image</span>(<span class=\"hljs-string\">&quot;backgroundImage&quot;</span>)<br>            .resizable()<br>            .aspectRatio(contentMode: .fill)<br>    )<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"文本阴影和其他效果\"><a href=\"#文本阴影和其他效果\" class=\"headerlink\" title=\"文本阴影和其他效果\"></a>文本阴影和其他效果</h3><p>可以为文本添加阴影或其他视觉效果：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Elevated Text&quot;</span>)<br>    .shadow(color: .gray, radius: <span class=\"hljs-number\">2</span>, x: <span class=\"hljs-number\">0</span>, y: <span class=\"hljs-number\">2</span>)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"条件修饰符\"><a href=\"#条件修饰符\" class=\"headerlink\" title=\"条件修饰符\"></a>条件修饰符</h3><p>可以基于条件应用不同的修饰符：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;This might be bold&quot;</span>)<br>    .fontWeight(isBold <span class=\"hljs-operator\">?</span> .bold : <span class=\"hljs-literal\">nil</span>)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"选择性地隐藏视图\"><a href=\"#选择性地隐藏视图\" class=\"headerlink\" title=\"选择性地隐藏视图\"></a>选择性地隐藏视图</h3><p>有时候你可能想要基于某些条件隐藏 <code>Text</code> 视图。这可以通过条件修饰符实现：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Hidden text&quot;</span>)<br>    .opacity(isHidden <span class=\"hljs-operator\">?</span> <span class=\"hljs-number\">0</span> : <span class=\"hljs-number\">1</span>)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"访问视图大小\"><a href=\"#访问视图大小\" class=\"headerlink\" title=\"访问视图大小\"></a>访问视图大小</h3><p>可以通过 <code>background</code> 修饰符和 <code>GeometryReader</code> 来获取 <code>Text</code> 视图的大小：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Dynamic Size&quot;</span>)<br>    .background(<span class=\"hljs-type\">GeometryReader</span> &#123; geometry <span class=\"hljs-keyword\">in</span><br>        <span class=\"hljs-type\">Color</span>.clear.onAppear &#123;<br>            <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;Text size: <span class=\"hljs-subst\">\\(geometry.size)</span>&quot;</span>)<br>        &#125;<br>    &#125;)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"复杂的文本处理\"><a href=\"#复杂的文本处理\" class=\"headerlink\" title=\"复杂的文本处理\"></a>复杂的文本处理</h3><p>如果你需要对文本进行更复杂的处理，比如解析和渲染 HTML 或者 Markdown，你可能需要使用 <code>NSAttributedString</code> 或查找第三方库，或在 SwiftUI 中嵌入 <code>UIKit</code> 或 <code>AppKit</code> 组件来完成。</p>\n<h3 id=\"响应式文本\"><a href=\"#响应式文本\" class=\"headerlink\" title=\"响应式文本\"></a>响应式文本</h3><p>可以通过环境变量，如 <code>@EnvironmentObject</code> 或 <code>@ObservedObject</code> 来创建响应式文本，使其内容基于应用程序的状态而改变。</p>\n<p>SwiftUI <code>Text</code> 视图的高级用法，结合了修饰符和 SwiftUI 的其他视图和功能，可以创建高度定制化的文本展示效果。这些高级技巧可以帮助你更好地控制文本的布局、样式和行为。</p>\n","excerpt":"","more":"<p>SwiftUI 中的 <code>Text</code> 视图用于显示一行或多行只读文本。它是 SwiftUI 中显示文本内容的基础组件，支持字符串文字和动态字符串。</p>\n<p>这里有一些基本和常见的用法：</p>\n<h3 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><p>创建一个简单的 <code>Text</code> 视图：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Hello, World!&quot;</span>)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"文本样式\"><a href=\"#文本样式\" class=\"headerlink\" title=\"文本样式\"></a>文本样式</h3><p>你可以为 <code>Text</code> 视图添加修饰符来改变文本的样式：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Hello, World!&quot;</span>)<br>    .font(.title) <span class=\"hljs-comment\">// 设置字体样式</span><br>    .fontWeight(.bold) <span class=\"hljs-comment\">// 设置字体权重</span><br>    .foregroundColor(.blue) <span class=\"hljs-comment\">// 设置文本颜色</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"多行文本和截断\"><a href=\"#多行文本和截断\" class=\"headerlink\" title=\"多行文本和截断\"></a>多行文本和截断</h3><p>SwiftUI 会根据需要自动换行文本，也可以控制截断的位置：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;This is a very long string that will wrap or truncate based on the available space.&quot;</span>)<br>    .frame(width: <span class=\"hljs-number\">100</span>) <span class=\"hljs-comment\">// 限制视图的宽度</span><br>    .lineLimit(<span class=\"hljs-number\">2</span>) <span class=\"hljs-comment\">// 最多显示两行</span><br>    .truncationMode(.tail) <span class=\"hljs-comment\">// 末尾截断</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"对齐文本\"><a href=\"#对齐文本\" class=\"headerlink\" title=\"对齐文本\"></a>对齐文本</h3><p>可以调整文本的对齐方式：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Aligned Text&quot;</span>)<br>    .frame(width: <span class=\"hljs-number\">200</span>, height: <span class=\"hljs-number\">200</span>) <span class=\"hljs-comment\">// 设置视图的大小</span><br>    .multilineTextAlignment(.center) <span class=\"hljs-comment\">// 多行文本居中对齐</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"文本和图像的组合\"><a href=\"#文本和图像的组合\" class=\"headerlink\" title=\"文本和图像的组合\"></a>文本和图像的组合</h3><p><code>Text</code> 视图可以和其他视图比如 <code>Image</code> 组合在一起：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">HStack</span> &#123;<br>    <span class=\"hljs-type\">Image</span>(systemName: <span class=\"hljs-string\">&quot;star.fill&quot;</span>) <span class=\"hljs-comment\">// 系统图标</span><br>        .foregroundColor(.yellow) <span class=\"hljs-comment\">// 设置图标颜色</span><br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Favorite&quot;</span>)<br>        .font(.headline) <span class=\"hljs-comment\">// 设置文本字体</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"本地化和动态文本\"><a href=\"#本地化和动态文本\" class=\"headerlink\" title=\"本地化和动态文本\"></a>本地化和动态文本</h3><p>SwiftUI 支持本地化和动态文本内容：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Text</span>(<span class=\"hljs-type\">LocalizedStringKey</span>(<span class=\"hljs-string\">&quot;WelcomeMessage&quot;</span>))<br><span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Hello, <span class=\"hljs-subst\">\\(userName)</span>!&quot;</span>)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"文本样式的继承\"><a href=\"#文本样式的继承\" class=\"headerlink\" title=\"文本样式的继承\"></a>文本样式的继承</h3><p>如果你将 <code>Text</code> 视图放入另一个视图中，它将继承父视图的样式：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">VStack</span> &#123;<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;First Line&quot;</span>)<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Second Line&quot;</span>)<br>&#125;.font(.title) <span class=\"hljs-comment\">// 所有文本都应用标题字体样式</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"交互式文本（例如链接）\"><a href=\"#交互式文本（例如链接）\" class=\"headerlink\" title=\"交互式文本（例如链接）\"></a>交互式文本（例如链接）</h3><p>可以在 <code>Text</code> 视图中添加可交互的链接：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Visit Apple&#x27;s website for more information.&quot;</span>)<br>    .underline()<br>    .foregroundColor(.blue)<br>    .onTapGesture &#123;<br>        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">let</span> url <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">URL</span>(string: <span class=\"hljs-string\">&quot;https://www.apple.com&quot;</span>) &#123;<br>            <span class=\"hljs-type\">UIApplication</span>.shared.open(url)<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>\n\n<p><code>Text</code> 视图是 SwiftUI 中非常强大的组件，其修饰符可以链式组合，用于创建丰富且响应式的文本界面。记住在实际的 iOS 开发环境中，某些功能（如打开 URL）可能需要其他的考虑（例如使用 <code>Link</code> 视图而不是 <code>onTapGesture</code>）。</p>\n<p>SwiftUI 的 <code>Text</code> 视图虽然简单，但它也支持一些高级用法，允许创建复杂和富有表现力的文本布局。以下是一些高级用法的示例：</p>\n<h3 id=\"富文本（Attributed-Strings）\"><a href=\"#富文本（Attributed-Strings）\" class=\"headerlink\" title=\"富文本（Attributed Strings）\"></a>富文本（Attributed Strings）</h3><p>在 SwiftUI 中，你可以使用属性字符串来创建富文本，这可以通过直接在 <code>Text</code> 初始化器中使用带有属性的字符串来实现：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">let</span> attributedString <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">NSAttributedString</span>( <span class=\"hljs-operator\">...</span> ) <span class=\"hljs-comment\">// 创建一个属性字符串</span><br><span class=\"hljs-type\">Text</span>(attributedString)<br></code></pre></td></tr></table></figure>\n\n<p>在 SwiftUI 3.0 中，可以更方便地创建富文本，使用多个 <code>Text</code> 视图的组合，并对它们应用不同的修饰符：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;This &quot;</span>) <span class=\"hljs-operator\">+</span><br><span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;word &quot;</span>).fontWeight(.bold) <span class=\"hljs-operator\">+</span><br><span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;is bold.&quot;</span>)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"文本插值和格式化\"><a href=\"#文本插值和格式化\" class=\"headerlink\" title=\"文本插值和格式化\"></a>文本插值和格式化</h3><p>SwiftUI 允许对插入到 <code>Text</code> 中的数据进行格式化：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;The temperature is <span class=\"hljs-subst\">\\(temperature, specifier: <span class=\"hljs-string\">&quot;%.1f&quot;</span>)</span> degrees.&quot;</span>)<br></code></pre></td></tr></table></figure>\n\n<p>或者使用更现代的方法，配合 <code>FormatStyle</code>：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Text</span>(temperature, format: .number.precision(.fractionLength(<span class=\"hljs-number\">1</span>)))<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"组合和叠加视图\"><a href=\"#组合和叠加视图\" class=\"headerlink\" title=\"组合和叠加视图\"></a>组合和叠加视图</h3><p>在 SwiftUI 中，可以将 <code>Text</code> 视图与其他视图组合，并应用不同的布局和效果：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Hello&quot;</span>)<br>    .background(<br>        <span class=\"hljs-type\">Image</span>(<span class=\"hljs-string\">&quot;backgroundImage&quot;</span>)<br>            .resizable()<br>            .aspectRatio(contentMode: .fill)<br>    )<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"文本阴影和其他效果\"><a href=\"#文本阴影和其他效果\" class=\"headerlink\" title=\"文本阴影和其他效果\"></a>文本阴影和其他效果</h3><p>可以为文本添加阴影或其他视觉效果：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Elevated Text&quot;</span>)<br>    .shadow(color: .gray, radius: <span class=\"hljs-number\">2</span>, x: <span class=\"hljs-number\">0</span>, y: <span class=\"hljs-number\">2</span>)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"条件修饰符\"><a href=\"#条件修饰符\" class=\"headerlink\" title=\"条件修饰符\"></a>条件修饰符</h3><p>可以基于条件应用不同的修饰符：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;This might be bold&quot;</span>)<br>    .fontWeight(isBold <span class=\"hljs-operator\">?</span> .bold : <span class=\"hljs-literal\">nil</span>)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"选择性地隐藏视图\"><a href=\"#选择性地隐藏视图\" class=\"headerlink\" title=\"选择性地隐藏视图\"></a>选择性地隐藏视图</h3><p>有时候你可能想要基于某些条件隐藏 <code>Text</code> 视图。这可以通过条件修饰符实现：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Hidden text&quot;</span>)<br>    .opacity(isHidden <span class=\"hljs-operator\">?</span> <span class=\"hljs-number\">0</span> : <span class=\"hljs-number\">1</span>)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"访问视图大小\"><a href=\"#访问视图大小\" class=\"headerlink\" title=\"访问视图大小\"></a>访问视图大小</h3><p>可以通过 <code>background</code> 修饰符和 <code>GeometryReader</code> 来获取 <code>Text</code> 视图的大小：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Dynamic Size&quot;</span>)<br>    .background(<span class=\"hljs-type\">GeometryReader</span> &#123; geometry <span class=\"hljs-keyword\">in</span><br>        <span class=\"hljs-type\">Color</span>.clear.onAppear &#123;<br>            <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;Text size: <span class=\"hljs-subst\">\\(geometry.size)</span>&quot;</span>)<br>        &#125;<br>    &#125;)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"复杂的文本处理\"><a href=\"#复杂的文本处理\" class=\"headerlink\" title=\"复杂的文本处理\"></a>复杂的文本处理</h3><p>如果你需要对文本进行更复杂的处理，比如解析和渲染 HTML 或者 Markdown，你可能需要使用 <code>NSAttributedString</code> 或查找第三方库，或在 SwiftUI 中嵌入 <code>UIKit</code> 或 <code>AppKit</code> 组件来完成。</p>\n<h3 id=\"响应式文本\"><a href=\"#响应式文本\" class=\"headerlink\" title=\"响应式文本\"></a>响应式文本</h3><p>可以通过环境变量，如 <code>@EnvironmentObject</code> 或 <code>@ObservedObject</code> 来创建响应式文本，使其内容基于应用程序的状态而改变。</p>\n<p>SwiftUI <code>Text</code> 视图的高级用法，结合了修饰符和 SwiftUI 的其他视图和功能，可以创建高度定制化的文本展示效果。这些高级技巧可以帮助你更好地控制文本的布局、样式和行为。</p>\n"},{"title":"SwiftUI和UIKit对比","date":"2023-11-07T07:20:04.000Z","_content":"SwiftUI 和 UIKit 是 iOS 开发中用于构建用户界面的两个不同的框架，它们各自有着不同的特点和用途。下面是一些比较重要的对比点：\n\n### 界面构建方式\n- **SwiftUI** 是声明式的，你定义了 UI 应该如何根据状态变化进行显示。\n- **UIKit** 是命令式的，你需要详细地指出如何在每个状态和交互下更新 UI。\n\n### 语言和环境\n- **SwiftUI** 只能在 Swift 中使用，并且需要 iOS 13 或更高的操作系统。\n- **UIKit** 可以用 Swift 或 Objective-C 编写，并支持从 iOS 2 开始的所有版本。\n\n### 设计理念\n- **SwiftUI** 旨在简化 UI 设计流程，使用更少的代码来完成更多的工作，同时强调数据驱动的 UI。\n- **UIKit** 更注重细节和控制，开发者可以对界面的每一个部分进行精细调整。\n\n### 学习曲线\n- **SwiftUI** 提供了更简单的语法和更少的样板代码，使得新手更容易入门。\n- **UIKit** 由于其历史悠久，资源丰富，但对于新手来说，学习曲线可能相对陡峭。\n\n### 功能和成熟度\n- **SwiftUI** 是比较新的，每年都在迅速增加新功能，但是某些高级或特定的功能可能不如 UIKit 那样成熟。\n- **UIKit** 非常成熟，功能全面，经过了多年的测试和使用。\n\n### 社区和资源\n- **SwiftUI** 正在迅速发展，社区和资源也在增加，但是相比于 UIKit 还是较少。\n- **UIKit** 拥有广泛的社区支持，大量的教程、书籍和第三方库。\n\n### 可维护性和扩展性\n- **SwiftUI** 由于其新颖的设计，可能会让既有的项目在集成时遇到挑战，但是对于新项目，其可维护性和扩展性被设计得很好。\n- **UIKit** 对于既有的项目非常友好，但在维护大型项目时可能需要更多的努力。\n\n### 性能\n- **SwiftUI** 的性能通常很好，但由于是新技术，可能在某些复杂场景下会有性能瓶颈。\n- **UIKit** 的性能非常成熟和优化，对于性能敏感的应用来说，它提供了更细粒度的控制。\n\n### 跨平台\n- **SwiftUI** 设计之初就考虑了跨平台，在 macOS、iOS、watchOS 和 tvOS 上有统一的开发体验。\n- **UIKit** 主要用于 iOS 和 tvOS，对于 macOS，需要使用 AppKit。\n\n总结来说，SwiftUI 是现代、声明式和跨平台的 UI 框架，适用于新项目和喜欢最新技术的开发者，而 UIKit 是更成熟、更具控制力的 UI 框架，适用于需要广泛支持和细粒度控制的大型应用或项目。对于现有项目，特别是需要支持旧版本 iOS 的项目，UIKit 依然是必须的。很多开发者在现有的 UIKit 应用中逐步引入 SwiftUI，以此来享受两个框架各自的优势。","source":"_posts/SwiftUI和UIKit对比.md","raw":"---\ntitle: SwiftUI和UIKit对比\ndate: 2023-11-07 15:20:04\ncategories:\n- SwiftUI\ntags:\n---\nSwiftUI 和 UIKit 是 iOS 开发中用于构建用户界面的两个不同的框架，它们各自有着不同的特点和用途。下面是一些比较重要的对比点：\n\n### 界面构建方式\n- **SwiftUI** 是声明式的，你定义了 UI 应该如何根据状态变化进行显示。\n- **UIKit** 是命令式的，你需要详细地指出如何在每个状态和交互下更新 UI。\n\n### 语言和环境\n- **SwiftUI** 只能在 Swift 中使用，并且需要 iOS 13 或更高的操作系统。\n- **UIKit** 可以用 Swift 或 Objective-C 编写，并支持从 iOS 2 开始的所有版本。\n\n### 设计理念\n- **SwiftUI** 旨在简化 UI 设计流程，使用更少的代码来完成更多的工作，同时强调数据驱动的 UI。\n- **UIKit** 更注重细节和控制，开发者可以对界面的每一个部分进行精细调整。\n\n### 学习曲线\n- **SwiftUI** 提供了更简单的语法和更少的样板代码，使得新手更容易入门。\n- **UIKit** 由于其历史悠久，资源丰富，但对于新手来说，学习曲线可能相对陡峭。\n\n### 功能和成熟度\n- **SwiftUI** 是比较新的，每年都在迅速增加新功能，但是某些高级或特定的功能可能不如 UIKit 那样成熟。\n- **UIKit** 非常成熟，功能全面，经过了多年的测试和使用。\n\n### 社区和资源\n- **SwiftUI** 正在迅速发展，社区和资源也在增加，但是相比于 UIKit 还是较少。\n- **UIKit** 拥有广泛的社区支持，大量的教程、书籍和第三方库。\n\n### 可维护性和扩展性\n- **SwiftUI** 由于其新颖的设计，可能会让既有的项目在集成时遇到挑战，但是对于新项目，其可维护性和扩展性被设计得很好。\n- **UIKit** 对于既有的项目非常友好，但在维护大型项目时可能需要更多的努力。\n\n### 性能\n- **SwiftUI** 的性能通常很好，但由于是新技术，可能在某些复杂场景下会有性能瓶颈。\n- **UIKit** 的性能非常成熟和优化，对于性能敏感的应用来说，它提供了更细粒度的控制。\n\n### 跨平台\n- **SwiftUI** 设计之初就考虑了跨平台，在 macOS、iOS、watchOS 和 tvOS 上有统一的开发体验。\n- **UIKit** 主要用于 iOS 和 tvOS，对于 macOS，需要使用 AppKit。\n\n总结来说，SwiftUI 是现代、声明式和跨平台的 UI 框架，适用于新项目和喜欢最新技术的开发者，而 UIKit 是更成熟、更具控制力的 UI 框架，适用于需要广泛支持和细粒度控制的大型应用或项目。对于现有项目，特别是需要支持旧版本 iOS 的项目，UIKit 依然是必须的。很多开发者在现有的 UIKit 应用中逐步引入 SwiftUI，以此来享受两个框架各自的优势。","slug":"SwiftUI和UIKit对比","published":1,"updated":"2024-03-17T06:10:56.967Z","comments":1,"layout":"post","photos":[],"_id":"clu6up53g001sz6741f053q1k","content":"<p>SwiftUI 和 UIKit 是 iOS 开发中用于构建用户界面的两个不同的框架，它们各自有着不同的特点和用途。下面是一些比较重要的对比点：</p>\n<h3 id=\"界面构建方式\"><a href=\"#界面构建方式\" class=\"headerlink\" title=\"界面构建方式\"></a>界面构建方式</h3><ul>\n<li><strong>SwiftUI</strong> 是声明式的，你定义了 UI 应该如何根据状态变化进行显示。</li>\n<li><strong>UIKit</strong> 是命令式的，你需要详细地指出如何在每个状态和交互下更新 UI。</li>\n</ul>\n<h3 id=\"语言和环境\"><a href=\"#语言和环境\" class=\"headerlink\" title=\"语言和环境\"></a>语言和环境</h3><ul>\n<li><strong>SwiftUI</strong> 只能在 Swift 中使用，并且需要 iOS 13 或更高的操作系统。</li>\n<li><strong>UIKit</strong> 可以用 Swift 或 Objective-C 编写，并支持从 iOS 2 开始的所有版本。</li>\n</ul>\n<h3 id=\"设计理念\"><a href=\"#设计理念\" class=\"headerlink\" title=\"设计理念\"></a>设计理念</h3><ul>\n<li><strong>SwiftUI</strong> 旨在简化 UI 设计流程，使用更少的代码来完成更多的工作，同时强调数据驱动的 UI。</li>\n<li><strong>UIKit</strong> 更注重细节和控制，开发者可以对界面的每一个部分进行精细调整。</li>\n</ul>\n<h3 id=\"学习曲线\"><a href=\"#学习曲线\" class=\"headerlink\" title=\"学习曲线\"></a>学习曲线</h3><ul>\n<li><strong>SwiftUI</strong> 提供了更简单的语法和更少的样板代码，使得新手更容易入门。</li>\n<li><strong>UIKit</strong> 由于其历史悠久，资源丰富，但对于新手来说，学习曲线可能相对陡峭。</li>\n</ul>\n<h3 id=\"功能和成熟度\"><a href=\"#功能和成熟度\" class=\"headerlink\" title=\"功能和成熟度\"></a>功能和成熟度</h3><ul>\n<li><strong>SwiftUI</strong> 是比较新的，每年都在迅速增加新功能，但是某些高级或特定的功能可能不如 UIKit 那样成熟。</li>\n<li><strong>UIKit</strong> 非常成熟，功能全面，经过了多年的测试和使用。</li>\n</ul>\n<h3 id=\"社区和资源\"><a href=\"#社区和资源\" class=\"headerlink\" title=\"社区和资源\"></a>社区和资源</h3><ul>\n<li><strong>SwiftUI</strong> 正在迅速发展，社区和资源也在增加，但是相比于 UIKit 还是较少。</li>\n<li><strong>UIKit</strong> 拥有广泛的社区支持，大量的教程、书籍和第三方库。</li>\n</ul>\n<h3 id=\"可维护性和扩展性\"><a href=\"#可维护性和扩展性\" class=\"headerlink\" title=\"可维护性和扩展性\"></a>可维护性和扩展性</h3><ul>\n<li><strong>SwiftUI</strong> 由于其新颖的设计，可能会让既有的项目在集成时遇到挑战，但是对于新项目，其可维护性和扩展性被设计得很好。</li>\n<li><strong>UIKit</strong> 对于既有的项目非常友好，但在维护大型项目时可能需要更多的努力。</li>\n</ul>\n<h3 id=\"性能\"><a href=\"#性能\" class=\"headerlink\" title=\"性能\"></a>性能</h3><ul>\n<li><strong>SwiftUI</strong> 的性能通常很好，但由于是新技术，可能在某些复杂场景下会有性能瓶颈。</li>\n<li><strong>UIKit</strong> 的性能非常成熟和优化，对于性能敏感的应用来说，它提供了更细粒度的控制。</li>\n</ul>\n<h3 id=\"跨平台\"><a href=\"#跨平台\" class=\"headerlink\" title=\"跨平台\"></a>跨平台</h3><ul>\n<li><strong>SwiftUI</strong> 设计之初就考虑了跨平台，在 macOS、iOS、watchOS 和 tvOS 上有统一的开发体验。</li>\n<li><strong>UIKit</strong> 主要用于 iOS 和 tvOS，对于 macOS，需要使用 AppKit。</li>\n</ul>\n<p>总结来说，SwiftUI 是现代、声明式和跨平台的 UI 框架，适用于新项目和喜欢最新技术的开发者，而 UIKit 是更成熟、更具控制力的 UI 框架，适用于需要广泛支持和细粒度控制的大型应用或项目。对于现有项目，特别是需要支持旧版本 iOS 的项目，UIKit 依然是必须的。很多开发者在现有的 UIKit 应用中逐步引入 SwiftUI，以此来享受两个框架各自的优势。</p>\n","excerpt":"","more":"<p>SwiftUI 和 UIKit 是 iOS 开发中用于构建用户界面的两个不同的框架，它们各自有着不同的特点和用途。下面是一些比较重要的对比点：</p>\n<h3 id=\"界面构建方式\"><a href=\"#界面构建方式\" class=\"headerlink\" title=\"界面构建方式\"></a>界面构建方式</h3><ul>\n<li><strong>SwiftUI</strong> 是声明式的，你定义了 UI 应该如何根据状态变化进行显示。</li>\n<li><strong>UIKit</strong> 是命令式的，你需要详细地指出如何在每个状态和交互下更新 UI。</li>\n</ul>\n<h3 id=\"语言和环境\"><a href=\"#语言和环境\" class=\"headerlink\" title=\"语言和环境\"></a>语言和环境</h3><ul>\n<li><strong>SwiftUI</strong> 只能在 Swift 中使用，并且需要 iOS 13 或更高的操作系统。</li>\n<li><strong>UIKit</strong> 可以用 Swift 或 Objective-C 编写，并支持从 iOS 2 开始的所有版本。</li>\n</ul>\n<h3 id=\"设计理念\"><a href=\"#设计理念\" class=\"headerlink\" title=\"设计理念\"></a>设计理念</h3><ul>\n<li><strong>SwiftUI</strong> 旨在简化 UI 设计流程，使用更少的代码来完成更多的工作，同时强调数据驱动的 UI。</li>\n<li><strong>UIKit</strong> 更注重细节和控制，开发者可以对界面的每一个部分进行精细调整。</li>\n</ul>\n<h3 id=\"学习曲线\"><a href=\"#学习曲线\" class=\"headerlink\" title=\"学习曲线\"></a>学习曲线</h3><ul>\n<li><strong>SwiftUI</strong> 提供了更简单的语法和更少的样板代码，使得新手更容易入门。</li>\n<li><strong>UIKit</strong> 由于其历史悠久，资源丰富，但对于新手来说，学习曲线可能相对陡峭。</li>\n</ul>\n<h3 id=\"功能和成熟度\"><a href=\"#功能和成熟度\" class=\"headerlink\" title=\"功能和成熟度\"></a>功能和成熟度</h3><ul>\n<li><strong>SwiftUI</strong> 是比较新的，每年都在迅速增加新功能，但是某些高级或特定的功能可能不如 UIKit 那样成熟。</li>\n<li><strong>UIKit</strong> 非常成熟，功能全面，经过了多年的测试和使用。</li>\n</ul>\n<h3 id=\"社区和资源\"><a href=\"#社区和资源\" class=\"headerlink\" title=\"社区和资源\"></a>社区和资源</h3><ul>\n<li><strong>SwiftUI</strong> 正在迅速发展，社区和资源也在增加，但是相比于 UIKit 还是较少。</li>\n<li><strong>UIKit</strong> 拥有广泛的社区支持，大量的教程、书籍和第三方库。</li>\n</ul>\n<h3 id=\"可维护性和扩展性\"><a href=\"#可维护性和扩展性\" class=\"headerlink\" title=\"可维护性和扩展性\"></a>可维护性和扩展性</h3><ul>\n<li><strong>SwiftUI</strong> 由于其新颖的设计，可能会让既有的项目在集成时遇到挑战，但是对于新项目，其可维护性和扩展性被设计得很好。</li>\n<li><strong>UIKit</strong> 对于既有的项目非常友好，但在维护大型项目时可能需要更多的努力。</li>\n</ul>\n<h3 id=\"性能\"><a href=\"#性能\" class=\"headerlink\" title=\"性能\"></a>性能</h3><ul>\n<li><strong>SwiftUI</strong> 的性能通常很好，但由于是新技术，可能在某些复杂场景下会有性能瓶颈。</li>\n<li><strong>UIKit</strong> 的性能非常成熟和优化，对于性能敏感的应用来说，它提供了更细粒度的控制。</li>\n</ul>\n<h3 id=\"跨平台\"><a href=\"#跨平台\" class=\"headerlink\" title=\"跨平台\"></a>跨平台</h3><ul>\n<li><strong>SwiftUI</strong> 设计之初就考虑了跨平台，在 macOS、iOS、watchOS 和 tvOS 上有统一的开发体验。</li>\n<li><strong>UIKit</strong> 主要用于 iOS 和 tvOS，对于 macOS，需要使用 AppKit。</li>\n</ul>\n<p>总结来说，SwiftUI 是现代、声明式和跨平台的 UI 框架，适用于新项目和喜欢最新技术的开发者，而 UIKit 是更成熟、更具控制力的 UI 框架，适用于需要广泛支持和细粒度控制的大型应用或项目。对于现有项目，特别是需要支持旧版本 iOS 的项目，UIKit 依然是必须的。很多开发者在现有的 UIKit 应用中逐步引入 SwiftUI，以此来享受两个框架各自的优势。</p>\n"},{"title":"SwiftUI提供了哪些UI组件?","date":"2023-11-07T07:44:38.000Z","_content":"SwiftUI 提供了一系列的 UI 组件，它们在 SwiftUI 中被称为 Views。以下是一些基础的组件及其用途：\n\n### Textual Components\n- **Text**: 显示一行或多行只读文本。\n- **TextField**: 允许用户输入文本。\n- **SecureField**: 用于密码输入，输入内容会被遮蔽。\n- **Label**: 显示文本和图标旁边的文本，适用于快速创建简单的标签。\n\n### Image and Graphics\n- **Image**: 显示图片。\n- **Icon**: 利用 SF Symbols 或自定义图像显示图标。\n- **Shape**: 绘制基本图形，如 Rectangle、Circle、Ellipse、Capsule 等。\n\n### Buttons and Toggles\n- **Button**: 可触发动作的标准按钮。\n- **Toggle**: 开关按钮，可用于切换状态。\n- **Picker**: 选择器，允许从多个选项中选择一个。\n- **Slider**: 滑块，用于从范围中选择一个值。\n- **Stepper**: 步进器，用于增加或减少一个值。\n\n### Containers and Layout\n- **HStack**: 水平堆叠的容器，用于横向排列子视图。\n- **VStack**: 垂直堆叠的容器，用于纵向排列子视图。\n- **ZStack**: 重叠容器，用于层叠视图。\n- **List**: 用于显示一系列数据的滚动列表。\n- **ScrollView**: 提供可滚动视图的容器。\n- **Grids (LazyHGrid/LazyVGrid)**: 创建水平或垂直的网格布局。\n- **Form**: 用于创建表单布局，常用于设置页面。\n- **NavigationView**: 创建带有导航能力的视图结构。\n\n### Presentation\n- **Alert**: 显示警告消息。\n- **Sheet**: 从底部滑出的覆盖层，用于显示次级视图。\n- **Popover**: 弹出视图，用于 iPad 上的视图展示。\n- **Modal**: 用于展示临时内容，例如详情页或选择器。\n\n### Controls and Indicators\n- **ProgressView**: 显示进度指示器。\n- **ActivityIndicator**: 显示一个旋转的加载提示符（iOS 14 以前称为 ActivityIndicator）。\n- **Link**: 提供一个可导航至外部链接或其他视图的按钮。\n\n### Specialized Views\n- **Map**: 集成地图显示。\n- **WebView**: 显示一个网页的视图（通过 `WKWebView`）。\n\n### Animation and Transition\n- **Animation**: 将动画应用于视图状态的改变。\n- **Transition**: 定义视图添加或移除时的动画效果。\n\n### Environment and Preferences\n- **Environment**: 用于从父视图传递数据到子视图的对象。\n\n这些组件可以结合起来，形成复杂的 UI 布局，并且可以通过各种修饰符（Modifiers）进行扩展和自定义，以实现具体的设计要求和动态效果。修饰符可以更改视图的显示方式，例如字体、颜色、对齐、填充、边框等属性，也可以添加如阴影、圆角等视觉效果。此外，SwiftUI 还提供了强大的数据绑定和状态管理机制，使得用户界面的开发更为动态和交互式。","source":"_posts/SwiftUI提供了哪些UI组件.md","raw":"---\ntitle: SwiftUI提供了哪些UI组件?\ndate: 2023-11-07 15:44:38\ncategories:\n- SwiftUI\ntags:\n---\nSwiftUI 提供了一系列的 UI 组件，它们在 SwiftUI 中被称为 Views。以下是一些基础的组件及其用途：\n\n### Textual Components\n- **Text**: 显示一行或多行只读文本。\n- **TextField**: 允许用户输入文本。\n- **SecureField**: 用于密码输入，输入内容会被遮蔽。\n- **Label**: 显示文本和图标旁边的文本，适用于快速创建简单的标签。\n\n### Image and Graphics\n- **Image**: 显示图片。\n- **Icon**: 利用 SF Symbols 或自定义图像显示图标。\n- **Shape**: 绘制基本图形，如 Rectangle、Circle、Ellipse、Capsule 等。\n\n### Buttons and Toggles\n- **Button**: 可触发动作的标准按钮。\n- **Toggle**: 开关按钮，可用于切换状态。\n- **Picker**: 选择器，允许从多个选项中选择一个。\n- **Slider**: 滑块，用于从范围中选择一个值。\n- **Stepper**: 步进器，用于增加或减少一个值。\n\n### Containers and Layout\n- **HStack**: 水平堆叠的容器，用于横向排列子视图。\n- **VStack**: 垂直堆叠的容器，用于纵向排列子视图。\n- **ZStack**: 重叠容器，用于层叠视图。\n- **List**: 用于显示一系列数据的滚动列表。\n- **ScrollView**: 提供可滚动视图的容器。\n- **Grids (LazyHGrid/LazyVGrid)**: 创建水平或垂直的网格布局。\n- **Form**: 用于创建表单布局，常用于设置页面。\n- **NavigationView**: 创建带有导航能力的视图结构。\n\n### Presentation\n- **Alert**: 显示警告消息。\n- **Sheet**: 从底部滑出的覆盖层，用于显示次级视图。\n- **Popover**: 弹出视图，用于 iPad 上的视图展示。\n- **Modal**: 用于展示临时内容，例如详情页或选择器。\n\n### Controls and Indicators\n- **ProgressView**: 显示进度指示器。\n- **ActivityIndicator**: 显示一个旋转的加载提示符（iOS 14 以前称为 ActivityIndicator）。\n- **Link**: 提供一个可导航至外部链接或其他视图的按钮。\n\n### Specialized Views\n- **Map**: 集成地图显示。\n- **WebView**: 显示一个网页的视图（通过 `WKWebView`）。\n\n### Animation and Transition\n- **Animation**: 将动画应用于视图状态的改变。\n- **Transition**: 定义视图添加或移除时的动画效果。\n\n### Environment and Preferences\n- **Environment**: 用于从父视图传递数据到子视图的对象。\n\n这些组件可以结合起来，形成复杂的 UI 布局，并且可以通过各种修饰符（Modifiers）进行扩展和自定义，以实现具体的设计要求和动态效果。修饰符可以更改视图的显示方式，例如字体、颜色、对齐、填充、边框等属性，也可以添加如阴影、圆角等视觉效果。此外，SwiftUI 还提供了强大的数据绑定和状态管理机制，使得用户界面的开发更为动态和交互式。","slug":"SwiftUI提供了哪些UI组件","published":1,"updated":"2024-03-17T06:12:14.981Z","comments":1,"layout":"post","photos":[],"_id":"clu6up53g001uz674c20q8k2t","content":"<p>SwiftUI 提供了一系列的 UI 组件，它们在 SwiftUI 中被称为 Views。以下是一些基础的组件及其用途：</p>\n<h3 id=\"Textual-Components\"><a href=\"#Textual-Components\" class=\"headerlink\" title=\"Textual Components\"></a>Textual Components</h3><ul>\n<li><strong>Text</strong>: 显示一行或多行只读文本。</li>\n<li><strong>TextField</strong>: 允许用户输入文本。</li>\n<li><strong>SecureField</strong>: 用于密码输入，输入内容会被遮蔽。</li>\n<li><strong>Label</strong>: 显示文本和图标旁边的文本，适用于快速创建简单的标签。</li>\n</ul>\n<h3 id=\"Image-and-Graphics\"><a href=\"#Image-and-Graphics\" class=\"headerlink\" title=\"Image and Graphics\"></a>Image and Graphics</h3><ul>\n<li><strong>Image</strong>: 显示图片。</li>\n<li><strong>Icon</strong>: 利用 SF Symbols 或自定义图像显示图标。</li>\n<li><strong>Shape</strong>: 绘制基本图形，如 Rectangle、Circle、Ellipse、Capsule 等。</li>\n</ul>\n<h3 id=\"Buttons-and-Toggles\"><a href=\"#Buttons-and-Toggles\" class=\"headerlink\" title=\"Buttons and Toggles\"></a>Buttons and Toggles</h3><ul>\n<li><strong>Button</strong>: 可触发动作的标准按钮。</li>\n<li><strong>Toggle</strong>: 开关按钮，可用于切换状态。</li>\n<li><strong>Picker</strong>: 选择器，允许从多个选项中选择一个。</li>\n<li><strong>Slider</strong>: 滑块，用于从范围中选择一个值。</li>\n<li><strong>Stepper</strong>: 步进器，用于增加或减少一个值。</li>\n</ul>\n<h3 id=\"Containers-and-Layout\"><a href=\"#Containers-and-Layout\" class=\"headerlink\" title=\"Containers and Layout\"></a>Containers and Layout</h3><ul>\n<li><strong>HStack</strong>: 水平堆叠的容器，用于横向排列子视图。</li>\n<li><strong>VStack</strong>: 垂直堆叠的容器，用于纵向排列子视图。</li>\n<li><strong>ZStack</strong>: 重叠容器，用于层叠视图。</li>\n<li><strong>List</strong>: 用于显示一系列数据的滚动列表。</li>\n<li><strong>ScrollView</strong>: 提供可滚动视图的容器。</li>\n<li><strong>Grids (LazyHGrid&#x2F;LazyVGrid)</strong>: 创建水平或垂直的网格布局。</li>\n<li><strong>Form</strong>: 用于创建表单布局，常用于设置页面。</li>\n<li><strong>NavigationView</strong>: 创建带有导航能力的视图结构。</li>\n</ul>\n<h3 id=\"Presentation\"><a href=\"#Presentation\" class=\"headerlink\" title=\"Presentation\"></a>Presentation</h3><ul>\n<li><strong>Alert</strong>: 显示警告消息。</li>\n<li><strong>Sheet</strong>: 从底部滑出的覆盖层，用于显示次级视图。</li>\n<li><strong>Popover</strong>: 弹出视图，用于 iPad 上的视图展示。</li>\n<li><strong>Modal</strong>: 用于展示临时内容，例如详情页或选择器。</li>\n</ul>\n<h3 id=\"Controls-and-Indicators\"><a href=\"#Controls-and-Indicators\" class=\"headerlink\" title=\"Controls and Indicators\"></a>Controls and Indicators</h3><ul>\n<li><strong>ProgressView</strong>: 显示进度指示器。</li>\n<li><strong>ActivityIndicator</strong>: 显示一个旋转的加载提示符（iOS 14 以前称为 ActivityIndicator）。</li>\n<li><strong>Link</strong>: 提供一个可导航至外部链接或其他视图的按钮。</li>\n</ul>\n<h3 id=\"Specialized-Views\"><a href=\"#Specialized-Views\" class=\"headerlink\" title=\"Specialized Views\"></a>Specialized Views</h3><ul>\n<li><strong>Map</strong>: 集成地图显示。</li>\n<li><strong>WebView</strong>: 显示一个网页的视图（通过 <code>WKWebView</code>）。</li>\n</ul>\n<h3 id=\"Animation-and-Transition\"><a href=\"#Animation-and-Transition\" class=\"headerlink\" title=\"Animation and Transition\"></a>Animation and Transition</h3><ul>\n<li><strong>Animation</strong>: 将动画应用于视图状态的改变。</li>\n<li><strong>Transition</strong>: 定义视图添加或移除时的动画效果。</li>\n</ul>\n<h3 id=\"Environment-and-Preferences\"><a href=\"#Environment-and-Preferences\" class=\"headerlink\" title=\"Environment and Preferences\"></a>Environment and Preferences</h3><ul>\n<li><strong>Environment</strong>: 用于从父视图传递数据到子视图的对象。</li>\n</ul>\n<p>这些组件可以结合起来，形成复杂的 UI 布局，并且可以通过各种修饰符（Modifiers）进行扩展和自定义，以实现具体的设计要求和动态效果。修饰符可以更改视图的显示方式，例如字体、颜色、对齐、填充、边框等属性，也可以添加如阴影、圆角等视觉效果。此外，SwiftUI 还提供了强大的数据绑定和状态管理机制，使得用户界面的开发更为动态和交互式。</p>\n","excerpt":"","more":"<p>SwiftUI 提供了一系列的 UI 组件，它们在 SwiftUI 中被称为 Views。以下是一些基础的组件及其用途：</p>\n<h3 id=\"Textual-Components\"><a href=\"#Textual-Components\" class=\"headerlink\" title=\"Textual Components\"></a>Textual Components</h3><ul>\n<li><strong>Text</strong>: 显示一行或多行只读文本。</li>\n<li><strong>TextField</strong>: 允许用户输入文本。</li>\n<li><strong>SecureField</strong>: 用于密码输入，输入内容会被遮蔽。</li>\n<li><strong>Label</strong>: 显示文本和图标旁边的文本，适用于快速创建简单的标签。</li>\n</ul>\n<h3 id=\"Image-and-Graphics\"><a href=\"#Image-and-Graphics\" class=\"headerlink\" title=\"Image and Graphics\"></a>Image and Graphics</h3><ul>\n<li><strong>Image</strong>: 显示图片。</li>\n<li><strong>Icon</strong>: 利用 SF Symbols 或自定义图像显示图标。</li>\n<li><strong>Shape</strong>: 绘制基本图形，如 Rectangle、Circle、Ellipse、Capsule 等。</li>\n</ul>\n<h3 id=\"Buttons-and-Toggles\"><a href=\"#Buttons-and-Toggles\" class=\"headerlink\" title=\"Buttons and Toggles\"></a>Buttons and Toggles</h3><ul>\n<li><strong>Button</strong>: 可触发动作的标准按钮。</li>\n<li><strong>Toggle</strong>: 开关按钮，可用于切换状态。</li>\n<li><strong>Picker</strong>: 选择器，允许从多个选项中选择一个。</li>\n<li><strong>Slider</strong>: 滑块，用于从范围中选择一个值。</li>\n<li><strong>Stepper</strong>: 步进器，用于增加或减少一个值。</li>\n</ul>\n<h3 id=\"Containers-and-Layout\"><a href=\"#Containers-and-Layout\" class=\"headerlink\" title=\"Containers and Layout\"></a>Containers and Layout</h3><ul>\n<li><strong>HStack</strong>: 水平堆叠的容器，用于横向排列子视图。</li>\n<li><strong>VStack</strong>: 垂直堆叠的容器，用于纵向排列子视图。</li>\n<li><strong>ZStack</strong>: 重叠容器，用于层叠视图。</li>\n<li><strong>List</strong>: 用于显示一系列数据的滚动列表。</li>\n<li><strong>ScrollView</strong>: 提供可滚动视图的容器。</li>\n<li><strong>Grids (LazyHGrid&#x2F;LazyVGrid)</strong>: 创建水平或垂直的网格布局。</li>\n<li><strong>Form</strong>: 用于创建表单布局，常用于设置页面。</li>\n<li><strong>NavigationView</strong>: 创建带有导航能力的视图结构。</li>\n</ul>\n<h3 id=\"Presentation\"><a href=\"#Presentation\" class=\"headerlink\" title=\"Presentation\"></a>Presentation</h3><ul>\n<li><strong>Alert</strong>: 显示警告消息。</li>\n<li><strong>Sheet</strong>: 从底部滑出的覆盖层，用于显示次级视图。</li>\n<li><strong>Popover</strong>: 弹出视图，用于 iPad 上的视图展示。</li>\n<li><strong>Modal</strong>: 用于展示临时内容，例如详情页或选择器。</li>\n</ul>\n<h3 id=\"Controls-and-Indicators\"><a href=\"#Controls-and-Indicators\" class=\"headerlink\" title=\"Controls and Indicators\"></a>Controls and Indicators</h3><ul>\n<li><strong>ProgressView</strong>: 显示进度指示器。</li>\n<li><strong>ActivityIndicator</strong>: 显示一个旋转的加载提示符（iOS 14 以前称为 ActivityIndicator）。</li>\n<li><strong>Link</strong>: 提供一个可导航至外部链接或其他视图的按钮。</li>\n</ul>\n<h3 id=\"Specialized-Views\"><a href=\"#Specialized-Views\" class=\"headerlink\" title=\"Specialized Views\"></a>Specialized Views</h3><ul>\n<li><strong>Map</strong>: 集成地图显示。</li>\n<li><strong>WebView</strong>: 显示一个网页的视图（通过 <code>WKWebView</code>）。</li>\n</ul>\n<h3 id=\"Animation-and-Transition\"><a href=\"#Animation-and-Transition\" class=\"headerlink\" title=\"Animation and Transition\"></a>Animation and Transition</h3><ul>\n<li><strong>Animation</strong>: 将动画应用于视图状态的改变。</li>\n<li><strong>Transition</strong>: 定义视图添加或移除时的动画效果。</li>\n</ul>\n<h3 id=\"Environment-and-Preferences\"><a href=\"#Environment-and-Preferences\" class=\"headerlink\" title=\"Environment and Preferences\"></a>Environment and Preferences</h3><ul>\n<li><strong>Environment</strong>: 用于从父视图传递数据到子视图的对象。</li>\n</ul>\n<p>这些组件可以结合起来，形成复杂的 UI 布局，并且可以通过各种修饰符（Modifiers）进行扩展和自定义，以实现具体的设计要求和动态效果。修饰符可以更改视图的显示方式，例如字体、颜色、对齐、填充、边框等属性，也可以添加如阴影、圆角等视觉效果。此外，SwiftUI 还提供了强大的数据绑定和状态管理机制，使得用户界面的开发更为动态和交互式。</p>\n"},{"title":"SwiftUI核心技术","date":"2023-11-07T16:07:31.000Z","_content":"**前言**\n- SwiftUI的介绍\n- SwiftUI与UIKit的比较\n- 本书适用读者\n- 如何使用本书\n\n**第一部分：SwiftUI基础**\n- 第1章：SwiftUI概述\n  - SwiftUI的设计哲学\n  - SwiftUI的架构\n  - MVVM设计模式在SwiftUI中的应用\n- 第2章：Swift语言回顾\n  - Swift基础\n  - 面向协议编程\n  - Swift中的函数式编程特性\n- 第3章：环境搭建\n  - Xcode和SwiftUI\n  - Swift Package Manager\n  - 创建第一个SwiftUI应用\n\n**第二部分：构建用户界面**\n- 第4章：视图与控件\n  - Text和Image\n  - Buttons和Toggle\n  - TextField和Slider\n  - 自定义视图和控件\n- 第5章：布局管理\n  - 堆（Stacks）\n  - 对齐与帧（Alignment and Frames）\n  - Spacer和Divider\n  - 布局优先级\n- 第6章：数据流与绑定\n  - State和Binding\n  - ObservedObject和EnvironmentObject\n  - @Published和Combine\n  - 数据流的最佳实践\n- 第7章：导航与呈现\n  - NavigationView和NavigationViewLink\n  - TabView\n  - Sheets和Alerts\n  - Navigation的高级用法\n\n**第三部分：进阶SwiftUI**\n- 第8章：动画与转场\n  - 基础动画\n  - 自定义动画\n  - 交互式和响应式动画\n  - 转场动画\n- 第9章：复合视图与可复用性\n  - 组合现有视图\n  - 创建可复用的视图库\n  - 自定义Modifier\n- 第10章：集成Core Data和CloudKit\n  - Core Data概念和配置\n  - SwiftUIT中的Core Data集成\n  - 使用CloudKit进行数据同步\n\n**第四部分：平台特定的设计**\n- 第11章：适配多平台\n  - Catalyst: 从iOS到macOS\n  - watchOS特有的UI组件\n  - tvOS和大屏体验\n- 第12章：Dark Mode和Accessibility\n  - 支持暗黑模式\n  - 辅助功能的最佳实践\n  - 动态字体与国际化\n\n**第五部分：性能优化与测试**\n- 第13章：性能优化\n  - 诊断和解决性能问题\n  - 延迟加载和内存管理\n  - 视图更新效率优化\n- 第14章：测试与调试\n  - 单元测试和UI测试\n  - 使用Xcode调试\n  - 预览与条件编译\n\n**第六部分：实战案例**\n- 第15章：构建一个完整的应用（Part 1）\n  - 应用结构规划\n  - 用户界面设计\n  - 应用逻辑实现\n- 第16章：构建一个完整的应用（Part 2）\n  - 数据持久化\n  - 网络请求和数据处理\n  - 应用测试和发布准备\n\n**附录**\n- A：SwiftUI视图和控件清单\n- B：SwiftUI常见问题解答\n- C：资源和进一步阅读\n\n**结束语**\n- 对SwiftUI的展望\n- 社区和支持\n\n**索引**\n\n---\n\n这个大纲为读者提供了从基础到进阶，再到实际应用开发的完整路径。可以\n\n根据读者的反馈和最新的SwiftUI更新不断调整和增补内容。\n\n当然，以下是一段示例前言的草稿，可以用作你书籍的前言部分。\n\n---\n\n**前言**\n\n欢迎来到《SwiftUI核心技术》，一本旨在探索和解锁Apple最新UI框架——SwiftUI的无限潜力的指南。在这个移动第一的时代，出色的用户界面和顺畅的用户体验是成功应用的关键。随着SwiftUI的出现，Apple开创了一种新的构建UI的方式，它比以往更加直观，更具表现力，且在所有Apple设备上都提供一致的体验。\n\n**SwiftUI的介绍**\n\nSwiftUI是Apple在2019年引入的一个创新的UI工具包，用于在所有Apple平台上构建用户界面。它利用Swift语言的强大功能，通过声明性语法简化了UI开发。SwiftUI不仅提供了一种更简洁、更易于理解的方式来构建UI，而且还具有数据驱动的特点，这意味着UI的每个部分都是根据应用状态的变化来更新的。\n\n**SwiftUI与UIKit的比较**\n\n尽管UIKit已经是iOS应用开发的主导UI框架多年，但SwiftUI带来了许多优势，特别是在创建跨平台UI时。UIKit依赖于命令式编程和手动管理的UIView，而SwiftUI使用声明式代码和自动管理的视图体系结构。这就意味着用SwiftUI可以用更少的代码做更多的工作，同时减少了出错的可能性。不过，对于已经存在的项目，UIKit仍然是必不可少的，因此理解两者的差异对于现代iOS开发者来说至关重要。\n\n**本书适用读者**\n\n无论您是新手程序员还是有经验的开发者，只要您对掌握SwiftUI感兴趣，这本书就是为您准备的。我们假设您已经对Swift语言有了基本的了解，并希望扩展您的知识库来包括UI设计。如果您是从UIKit转型来的开发者，这本书将帮助您理解SwiftUI的独特之处，并指导您如何迁移现有的知识和技能。\n\n**如何使用本书**\n\n《SwiftUI核心技术》是按模块组织的，从基础知识到高级应用，最后是综合案例研究。您可以按顺序阅读以构建坚实的基础，也可以直接跳到对您当前项目最相关的章节。每个概念都伴随着代码示例和最佳实践，以便您可以实践所学，并在实际中应用这些技能。书中还包含了挑战和练习，让您能够测试自己的理解并巩固学习成果。\n\n当您准备开始您的SwiftUI之旅时，希望这本书成为您的指南，带您更深入地了解如何使用这一令人兴奋的新框架来创造美妙、响应迅速且富有表现力的用户界面。\n\n---\n\n希望这段前言能够为您的书籍奠定一个温馨而专业的开场。您可以根据实际需要调整这段文本，以更好地符合您对书籍的愿景。\n\n**第1章：SwiftUI概述**\n\n**1. SwiftUI的设计哲学**\n\n苹果公司在2019年WWDC上推出SwiftUI时，开启了iOS、macOS、watchOS和tvOS开发的新篇章。该框架的设计哲学突破了以往UI开发的界限，以优雅且革命性的方式提高了开发速度、改善了代码的质量，并统一了跨平台的用户体验。本节将详细介绍构成SwiftUI设计哲学的核心元素。\n\n**简洁的声明性语法**\n\nSwiftUI的核心是其声明性语法。在传统的命令式编程模型中，开发者需要详细指定如何绘制和更新用户界面的每一个变化。这种方式虽然直接，但随着应用界面变得越来越复杂，代码就会变得难以理解和维护。相比之下，SwiftUI采用声明性方法，允许开发者表达他们想要的界面应该是什么样子，而非如何绘制界面。\n\n例如，一个按钮的创建和配置，在UIKit中可能需要数行代码来设定它的状态和外观，还要添加响应点击的动作。而在SwiftUI中，同样的按钮只需要几行声明性代码即可完成：\n\n```swift\nButton(\"点击我\") {\n    print(\"按钮被点击\")\n}\n```\n\n这样的语法不仅使代码更易读，也使得UI的各个组件能够更容易地重用和组合。\n\n**组件化和可组合性**\n\nSwiftUI强调组件化—创建可重用的UI组件—以及可组合性—将这些组件拼接成复杂的UI。每个SwiftUI视图都是一种结构体，这是一种轻量级的数据类型，非常适合用来描述UI组件。这与UIKit的类和对象相比，可以显著提高性能，特别是在用户界面需要快速重建时。\n\n此外，SwiftUI的视图可以包含其他视图，这就为开发者提供了极大的灵活性来构建复杂的用户界面。例如，可以创建一个自定义的按钮样式，然后在不同的地方多次使用，而无需重写样式代码。\n\n**一致性和跨平台设计**\n\nSwiftUI的一个显著特点是其跨平台能力。相同的SwiftUI代码可以运行在iOS、macOS、watchOS和tvOS上，无需做出太多修改。这种一致性意味着开发者可以为所有Apple平台构建统一的应用体验，同时允许针对特定平台的优化。\n\n跨平台设计的好处是显而易见的。开发者可以集中精力于创建出色的用户体验，而不是花费时间在适配不同平台的布局和控件上。SwiftUI通过提供一致的API和控件集，确保了界面在各个设备上都能保持良好的交互和视觉效果。\n\n**数据驱动的UI更新**\n\nSwiftUI的另一个核心特性是数据驱动的UI更新。这意味着UI的状态可以被绑定到应用程序的数据模型上，当数据变化时，UI会自动更新。这种绑定使用了Swift的属性包装器如`@State`和`@Binding`，它们提供了一种声明性的方式来定义视图的源数据。\n\n以一个简单的文本输入为例，在UIKit中，您可能需要实现委托模式来响应文本变化，然后手动更新UI。而在SwiftUI中，您可以这样做：\n\n```swift\nstruct ContentView: View {\n    @State private var userName: String = \"\"\n\n    var body: some View\n\n {\n        TextField(\"请输入用户名\", text: $userName)\n        Text(\"您好，\\(userName)!\")\n    }\n}\n```\n\n在这个例子中，`TextField`的文本被绑定到`userName`状态上。当用户在文本字段中输入时，`userName`会自动更新，而且相关的`Text`视图也会即时反映这个变化。\n\n**总结**\n\nSwiftUI的设计哲学是为了提高开发效率、改善代码质量，并使应用能够快速适应未来的变化。通过其声明性语法、组件化和可组合性、一致性以及数据驱动的UI更新，SwiftUI为现代应用开发树立了新的标准。接下来，我们将进一步探讨SwiftUI是如何实现这些设计理念的，并通过实例展示这些概念在实际开发中的应用。\n\n**2. SwiftUI的架构**\n\nSwiftUI是构建在一系列高效且现代的编程模式和原则之上的，它不仅简化了用户界面的创建，而且通过其独特的架构提升了应用性能和开发效率。在本节中，我们将深入了解构成SwiftUI架构的各个部分，以及它们如何协同工作以创建流畅且动态的用户界面。\n\n**视图层次结构与组件**\n\n在SwiftUI中，一切都是视图。从文本标签(`Text`)到按钮(`Button`)，再到整个屏幕(`ContentView`)，所有的UI组件都是视图。SwiftUI使用一种结构体(`struct`)来定义视图，这是一个轻量级的数据类型，非常适合描述UI组件。每个视图都知道如何绘制自己，并能定义自己的布局。\n\n一个关键概念是视图的层次结构，它表示视图的嵌套。父视图可以包含多个子视图，创建出丰富的布局。SwiftUI使用声明性的方法来组织视图层次，这意味着您声明界面应该如何组织，而不是编写代码来动态创建和管理视图对象。\n\n**布局系统**\n\nSwiftUI的布局系统是自适应和响应式的，允许视图以一种非常自然的方式响应外部条件的变化，如设备的屏幕大小或者设备方向。布局是由视图本身以及环境(`Environment`)中的信息决定的。每个视图提供了一个`body`属性，描述了其子视图的布局。\n\nSwiftUI的`Stack`、`List`、`Grid`等布局容器帮助您定义强大而灵活的布局。例如，一个`VStack`会垂直堆叠其子视图，而一个`HStack`则会水平堆叠。每个容器都可以包含其他容器，从而创建复杂且响应式的布局结构。\n\n**数据流和绑定**\n\nSwiftUI的架构旨在促进数据流的清晰和一致。它通过使用一系列属性包装器来实现，如`@State`、`@Binding`、`@ObservedObject`和`@EnvironmentObject`。这些属性包装器提供了不同层级的数据流和状态管理，确保视图与数据保持同步。\n\n`@State`是一种私有的、视图内的状态管理，用于存储视图的本地数据。`@Binding`则创建了一个可读写的连接到另一个视图持有的`@State`的连接，从而允许数据在不同视图间共享。\n\n对于更复杂的数据管理，`@ObservedObject`和`@EnvironmentObject`使得视图能够订阅外部的数据模型。当数据模型标记为`ObservableObject`并且其内部的数据通过`@Published`包装器进行更改时，订阅这些模型的视图会自动更新。\n\n**声明性渲染**\n\nSwiftUI的架构在内部使用了一种高效的声明性渲染引擎，它能够智能地重绘改变了的部分而非整个界面。这是通过比较视图的当前状态和新的声明来实现的。当状态发生变化时，SwiftUI计算出最小的差异，并且只更新需要改变的部分。\n\n这种智能重绘是非常重要的，因为它意味着视图的更新可以非常快速，并且能保持性能，即使在复杂的界面和动画中也是如此。\n\n**Swift与SwiftUI的紧密集成**\n\nSwiftUI与Swift编程语言的紧密集成提供了许多编程上的好处。利用Swift的强类型系统、函数式编程特性和高级语言构造，SwiftUI可以确保代码安全、清晰且易于理解。\n\nSwiftUI的一切，从其布局系统到与Combine框架的集成，都是为了简化编程模型，允许开发者以一种更直观和高效的方式来构建用户界面。\n\n**总结**\n\nSwiftUI的架构是其强大功能和易用性的基石。通过视图层次结构、响应式布局系统、清晰的数据流和绑定以及高效的声明性渲染，SwiftUI提供了一个坚实的基础来构建现代的跨平台应用。了解这些概念对于充分利用SwiftUI的潜力是至关重要的。在本书的后续章节中，我们将进一步深入探讨每个概念，并通过具体的代码示例来展示它们在实际开发中的应用。\n\n\n**3. MVVM设计模式在SwiftUI中的应用**\n\n在现代应用开发中，架构模式的选择对于确保代码的可读性、可维护性和可扩展性至关重要。Model-View-ViewModel (MVVM) 是一种被广泛采用的设计模式，尤其是在SwiftUI中，它提供了一种清晰地分离用户界面和业务逻辑的方式。本节将探讨MVVM设计模式，并详细说明它如何在SwiftUI中得到应用。\n\n**MVVM的核心概念**\n\nMVVM设计模式将应用分为三个主要组件：Model、View和ViewModel。\n\n- **Model** - 表示应用的数据和业务逻辑。它是纯粹的Swift类或结构体，不含任何UI代码。\n- **View** - 显示应用的用户界面。在SwiftUI中，所有的UI组件都是视图，从单个按钮到整个屏幕。\n- **ViewModel** - 作为Model和View之间的桥梁。它包含了展示逻辑，但不包含业务逻辑或者状态管理的代码。\n\nMVVM通过这种分离，确保了UI代码的简洁性，并允许业务逻辑独立于UI，使其更易于测试和重用。\n\n**ViewModel在SwiftUI中的角色**\n\n在SwiftUI中，ViewModel通常是一个符合`ObservableObject`协议的Swift类。它会暴露出用于UI显示的数据，并将用户的交互转化为模型更新和视图的状态更改。\n\n例如，如果您有一个任务列表应用，ViewModel可能包含一个任务数组的状态以及添加新任务的方法。当用户通过界面添加任务时，ViewModel会更新Model，并通知View重新渲染以显示新任务。\n\n**数据绑定和状态管理**\n\nSwiftUI的数据绑定特性与MVVM的配合尤其紧密。使用`@Published`属性包装器，ViewModel可以提供可观察的数据属性，当这些属性的值变化时，关联的视图可以自动更新。\n\n此外，SwiftUI的状态管理属性包装器，如`@State`、`@Binding`、`@StateObject`和`@EnvironmentObject`，进一步简化了ViewModel与View之间数据和状态的同步。\n\n**MVVM的实际应用**\n\n在SwiftUI应用中实施MVVM时，ViewModel的职责包括：\n\n- 提供视图所需的数据。\n- 响应用户输入并更新Model。\n- 监控Model的变化并通知View更新。\n- 处理导航和视图间的协调逻辑。\n\n由于SwiftUI的视图是声明性的，ViewModel成为控制视图状态的中心。开发者不再需要写大量的引导代码来手动更新UI，而是可以依靠SwiftUI的绑定机制和ViewModel来自动处理。\n\n**总结**\n\nMVVM设计模式在SwiftUI中的应用为创建结构化和高效的应用程序提供了框架。通过将业务逻辑移至ViewModel，并利用SwiftUI的响应式数据绑定，开发者能够创建更清晰、更易于维护和扩展的代码。在本书接下来的章节中，我们将通过具体示例深入探讨MVVM模式在SwiftUI应用开发中的具体实现和最佳实践。\n\n\n**第2章：Swift语言回顾**\n\n**1. Swift基础**\n\nSwift 是由苹果公司开发的一种强大的编程语言，旨在为开发者提供一种简单、清晰且高效的语言工具。它既适合新手学习编程，也足以满足专业开发者构建复杂应用的需求。在本节中，我们将回顾Swift语言的基础，为深入学习SwiftUI打下坚实的基础。\n\n**变量和常量**\n\nSwift 使用 `var` 关键字来声明变量，`let` 关键字来声明常量。变量是可以被赋予不同值的标识符，而常量一旦设定初始值后则不能更改。\n\n```swift\nvar greeting = \"Hello, world!\"\nlet pi = 3.14159\n```\n\n**数据类型**\n\nSwift 是一种类型安全的语言，这意味着每个变量都有一个明确的类型。Swift 的基本数据类型包括 `Int`、`Float`、`Double`、`Bool`、`String` 等。\n\n```swift\nvar age: Int = 30\nvar price: Double = 29.99\nvar isHidden: Bool = false\nvar name: String = \"John Doe\"\n```\n\n**控制流**\n\nSwift 提供了丰富的控制流结构，包括 `if`、`else` 条件语句，`switch` 语句，以及 `for-in`、`while` 和 `repeat-while` 循环。\n\n```swift\nif age > 18 {\n    print(\"Adult\")\n} else {\n    print(\"Minor\")\n}\n\nfor index in 1...5 {\n    print(index)\n}\n```\n\n**函数**\n\n函数是执行特定任务的自包含代码块。Swift 的函数使用 `func` 关键字声明，可以接受参数和返回值。\n\n```swift\nfunc greet(person: String) -> String {\n    return \"Hello, \\(person)!\"\n}\nprint(greet(person: \"Anna\")) // Prints \"Hello, Anna!\"\n```\n\n**闭包**\n\n闭包是可以在代码中被传递和使用的自包含功能块，类似于其他语言中的匿名函数。闭包捕获并存储它们的上下文中的任何常量和变量的引用。\n\n```swift\nlet names = [\"Chris\", \"Alex\", \"Ewa\", \"Barry\", \"Daniella\"]\nvar reversedNames = names.sorted(by: { $0 > $1 })\n```\n\n**结构体和类**\n\nSwift 中的结构体和类是构建代码的基本构件。结构体是值类型，而类是引用类型。\n\n```swift\nstruct Point {\n    var x: Int\n    var y: Int\n}\n\nclass Vehicle {\n    var numberOfWheels = 0\n    func description() -> String {\n        return \"\\(numberOfWheels) wheel(s)\"\n    }\n}\n```\n\n**属性和方法**\n\n属性用于存储值，方法用于添加特定的行为。计算属性则提供了一种自定义的 getter 和 setter 来间接获取和设置其他属性或变量的值。\n\n```swift\nclass Circle {\n    var radius: Double = 0\n    var circumference: Double {\n        return pi * radius * 2\n    }\n}\n```\n\n**协议和扩展**\n\n协议定义了一组方法和属性的蓝图，类、结构体和枚举可以实现这些协议。扩展则允许你为现有的类型添加新的功能。\n\n```swift\nprotocol Identifiable {\n    var id: String { get set }\n}\n\nextension String {\n    func capitalizedFirst() -> String {\n        return prefix(1).uppercased() + self.lowercased().dropFirst()\n    }\n}\n```\n\n**错误处理**\n\nSwift 中的错误处理允许你表示并处理程序执行中可能遇到的错误条件。\n\n```swift\nenum PrinterError: Error {\n    case outOfPaper\n    case noToner\n    case onFire\n}\n\nfunc send(job: Int, toPrinter printerName: String) throws -> String {\n    if printerName == \"Never Has Toner\" {\n        throw PrinterError.noToner\n    }\n    return \"Job sent\"\n\n\n}\n```\n\n**泛型**\n\n泛型允许你写出灵活、可重用的函数和类型，它们可以工作于任何类型。\n\n```swift\nfunc swapTwoValues<T>(_ a: inout T, _ b: inout T) {\n    let temporaryA = a\n    a = b\n    b = temporaryA\n}\n```\n\n**总结**\n\n这些是Swift语言的一些核心概念，掌握它们对于理解SwiftUI的工作方式至关重要。Swift的这些特性提供了构建SwiftUI应用所需的工具和构建块，接下来的章节中我们将看到这些基础如何在实际的SwiftUI编程中得到应用。\n\n\n**2. 面向协议编程**\n\n面向协议编程（Protocol-Oriented Programming，POP）是Swift语言的一个核心范式。与面向对象编程（Object-Oriented Programming，OOP）关注在类和继承上构建程序的层次结构不同，POP倡导通过定义协议并将它们实现于类、结构体或枚举来构建程序的行为和形态。在本节中，我们将探讨POP的基础，以及如何在Swift中应用这个强大的编程范式。\n\n**协议的定义**\n\n协议定义了一套蓝图，规定了采纳协议的类型必须实现哪些方法和属性。协议可以被类、结构体或枚举类型采纳，以提供所需的实现。\n\n```swift\nprotocol Identifiable {\n    var id: String { get set }\n    func identify()\n}\n\nextension Identifiable {\n    func identify() {\n        print(\"My ID is \\(id).\")\n    }\n}\n```\n\n在上述例子中，任何采纳`Identifiable`协议的类型都必须有一个`id`属性，并且默认提供了一个`identify`方法的实现。\n\n**面向协议的优势**\n\n- **复用性**：通过定义协议，您可以创建可在多种类型间复用的方法和属性。\n- **松耦合**：类型之间的依赖性降低，因为它们依赖于协议，而不是具体的实现。\n- **灵活性**：可以为不同的类型添加协议扩展，为它们提供特定的功能，而无需修改原有类型代码。\n- **适应性**：类型可以同时采纳多个协议，易于适配和扩展。\n\n**使用协议定义行为**\n\n一个典型的POP实践是定义一系列协议来代表应用的不同部分可以共享的行为，而不是创建基类。\n\n```swift\nprotocol Flyable {\n    var airspeedVelocity: Double { get }\n}\n\nprotocol Feasible {\n    var isFeasible: Bool { get }\n}\n\n// 现在，任何类型都可以采纳Flyable和Feasible协议，不仅限于某个类的子类。\nstruct Bird: Flyable, Feasible {\n    var airspeedVelocity: Double\n    var isFeasible: Bool\n}\n```\n\n**在扩展中采纳协议**\n\nSwift允许在类型的扩展中采纳协议。这意味着即使是先前定义好的类型，也可以被增强来采纳新的协议。\n\n```swift\nextension Array: Identifiable where Element: Identifiable {\n    var id: String {\n        return self.map { $0.id }.joined(separator: \", \")\n    }\n}\n```\n\n这里，只要数组的元素采纳了`Identifiable`协议，数组本身就自动采纳了`Identifiable`。\n\n**关联类型**\n\n协议可以具有关联类型，这是一种未被指定的类型占位符，其具体类型将由协议的采纳者提供。\n\n```swift\nprotocol Container {\n    associatedtype Item\n    mutating func append(_ item: Item)\n    var count: Int { get }\n    subscript(i: Int) -> Item { get }\n}\n\nstruct IntStack: Container {\n    // 实现Container协议的要求\n    typealias Item = Int\n    // ...\n}\n```\n\n关联类型增加了协议的灵活性，使其可以被不同的类型以不同的方式采纳。\n\n**总结**\n\n面向协议编程是Swift语言的一个核心原则，它鼓励开发者通过协议来定义接口和行为，而不是传统的继承。这样的方法为代码提供了更高的复用性和灵活性，也更加\n\n安全。在SwiftUI中，您会发现许多UI组件都是基于协议来构建的，这使得自定义和扩展UI变得十分方便和高效。通过本节的学习，您应该对如何使用面向协议编程来构建更强大、更模块化的Swift应用有了更深刻的理解。\n\n\n**3. Swift中的函数式编程特性**\n\n函数式编程是一种编程范式，它将计算视为数学函数的评估，并避免状态以及可变数据。Swift虽然不是一个纯函数式编程语言，但它融合了许多函数式编程的特性。这些特性可以帮助开发者编写更简洁、更易于理解的代码。在本节中，我们将探索Swift中的函数式编程特性及其在实际编程中的应用。\n\n**不可变性**\n\n在函数式编程中，不可变性是一个核心概念。不可变的数据可以避免副作用和状态变化，这使得程序更容易理解和调试。在Swift中，使用`let`关键字声明的常量是不可变的。\n\n```swift\nlet constantArray = [1, 2, 3]\n// constantArray[0] = 4 // 这行代码将导致编译错误，因为数组是不可变的\n```\n\n**一等函数**\n\nSwift将函数作为一等公民，这意味着函数可以作为其他函数的参数传递，也可以作为函数的返回值，还可以赋值给变量。\n\n```swift\nfunc add(_ a: Int, _ b: Int) -> Int {\n    return a + b\n}\n\nvar mathFunction: (Int, Int) -> Int = add\nprint(mathFunction(2, 3)) // 输出 5\n```\n\n**高阶函数**\n\nSwift标准库中提供了多种高阶函数，如`map`、`filter`、`reduce`等，这些函数都可以接受一个函数作为输入。\n\n- `map` 用于将集合中的每个元素通过特定的方法进行转换。\n- `filter` 用于选择集合中符合特定条件的元素。\n- `reduce` 用于将集合中的元素合并成一个单一的值。\n\n```swift\nlet numbers = [1, 2, 3, 4, 5]\nlet squaredNumbers = numbers.map { $0 * $0 } // [1, 4, 9, 16, 25]\nlet evenNumbers = numbers.filter { $0 % 2 == 0 } // [2, 4]\nlet sumOfNumbers = numbers.reduce(0, +) // 15\n```\n\n**闭包**\n\n闭包是自包含的函数代码块，可以在代码中传递和使用。它们尤其适用于函数式编程，因为它们可以捕获和存储任何它们所在上下文中的常量和变量的引用。\n\n```swift\nlet names = [\"Chris\", \"Alex\", \"Ewa\", \"Barry\", \"Daniella\"]\nlet reversedNames = names.sorted(by: { s1, s2 in return s1 > s2 })\n```\n\n**柯里化（Currying）**\n\n柯里化是函数式编程中的一个概念，指的是将一个接受多个参数的函数转换成一系列只接受单一参数的函数。\n\n```swift\nfunc add(_ a: Int) -> (Int) -> Int {\n    return { b in return a + b }\n}\n\nlet addTwo = add(2)\nlet result = addTwo(3) // 5\n```\n\n**惰性求值（Lazy Evaluation）**\n\nSwift中的序列和集合提供了惰性求值的选项，这意味着只有在需要计算值的时候才会进行计算。这可以提高程序的性能，特别是在处理大型数据集时。\n\n```swift\nlet data = 1...1000\nlet result = data.lazy.filter { $0 % 2 == 0 }.map { $0 * 2 }\n// result 的计算将会被延迟，直到实际被需要\n```\n\n**总结**\n\nSwift的函数式编程特性能够帮助开发者写出更加清晰、简洁和可维护的代码。通过利用不可变性、高阶函数、闭\n\n包等特性，Swift开发者可以编写出更加表达力强、逻辑清晰的代码。在SwiftUI开发中，这些特性被广泛应用，以实现数据和UI的高效绑定和操作。掌握这些函数式编程的概念将在接下来的章节中帮助读者更好地理解SwiftUI的设计和实现方式。\n\n\n","source":"_posts/SwiftUI核心技术.md","raw":"---\ntitle: SwiftUI核心技术\ndate: 2023-11-08 00:07:31\ncategories:\n- SwiftUI\ntags:\n---\n**前言**\n- SwiftUI的介绍\n- SwiftUI与UIKit的比较\n- 本书适用读者\n- 如何使用本书\n\n**第一部分：SwiftUI基础**\n- 第1章：SwiftUI概述\n  - SwiftUI的设计哲学\n  - SwiftUI的架构\n  - MVVM设计模式在SwiftUI中的应用\n- 第2章：Swift语言回顾\n  - Swift基础\n  - 面向协议编程\n  - Swift中的函数式编程特性\n- 第3章：环境搭建\n  - Xcode和SwiftUI\n  - Swift Package Manager\n  - 创建第一个SwiftUI应用\n\n**第二部分：构建用户界面**\n- 第4章：视图与控件\n  - Text和Image\n  - Buttons和Toggle\n  - TextField和Slider\n  - 自定义视图和控件\n- 第5章：布局管理\n  - 堆（Stacks）\n  - 对齐与帧（Alignment and Frames）\n  - Spacer和Divider\n  - 布局优先级\n- 第6章：数据流与绑定\n  - State和Binding\n  - ObservedObject和EnvironmentObject\n  - @Published和Combine\n  - 数据流的最佳实践\n- 第7章：导航与呈现\n  - NavigationView和NavigationViewLink\n  - TabView\n  - Sheets和Alerts\n  - Navigation的高级用法\n\n**第三部分：进阶SwiftUI**\n- 第8章：动画与转场\n  - 基础动画\n  - 自定义动画\n  - 交互式和响应式动画\n  - 转场动画\n- 第9章：复合视图与可复用性\n  - 组合现有视图\n  - 创建可复用的视图库\n  - 自定义Modifier\n- 第10章：集成Core Data和CloudKit\n  - Core Data概念和配置\n  - SwiftUIT中的Core Data集成\n  - 使用CloudKit进行数据同步\n\n**第四部分：平台特定的设计**\n- 第11章：适配多平台\n  - Catalyst: 从iOS到macOS\n  - watchOS特有的UI组件\n  - tvOS和大屏体验\n- 第12章：Dark Mode和Accessibility\n  - 支持暗黑模式\n  - 辅助功能的最佳实践\n  - 动态字体与国际化\n\n**第五部分：性能优化与测试**\n- 第13章：性能优化\n  - 诊断和解决性能问题\n  - 延迟加载和内存管理\n  - 视图更新效率优化\n- 第14章：测试与调试\n  - 单元测试和UI测试\n  - 使用Xcode调试\n  - 预览与条件编译\n\n**第六部分：实战案例**\n- 第15章：构建一个完整的应用（Part 1）\n  - 应用结构规划\n  - 用户界面设计\n  - 应用逻辑实现\n- 第16章：构建一个完整的应用（Part 2）\n  - 数据持久化\n  - 网络请求和数据处理\n  - 应用测试和发布准备\n\n**附录**\n- A：SwiftUI视图和控件清单\n- B：SwiftUI常见问题解答\n- C：资源和进一步阅读\n\n**结束语**\n- 对SwiftUI的展望\n- 社区和支持\n\n**索引**\n\n---\n\n这个大纲为读者提供了从基础到进阶，再到实际应用开发的完整路径。可以\n\n根据读者的反馈和最新的SwiftUI更新不断调整和增补内容。\n\n当然，以下是一段示例前言的草稿，可以用作你书籍的前言部分。\n\n---\n\n**前言**\n\n欢迎来到《SwiftUI核心技术》，一本旨在探索和解锁Apple最新UI框架——SwiftUI的无限潜力的指南。在这个移动第一的时代，出色的用户界面和顺畅的用户体验是成功应用的关键。随着SwiftUI的出现，Apple开创了一种新的构建UI的方式，它比以往更加直观，更具表现力，且在所有Apple设备上都提供一致的体验。\n\n**SwiftUI的介绍**\n\nSwiftUI是Apple在2019年引入的一个创新的UI工具包，用于在所有Apple平台上构建用户界面。它利用Swift语言的强大功能，通过声明性语法简化了UI开发。SwiftUI不仅提供了一种更简洁、更易于理解的方式来构建UI，而且还具有数据驱动的特点，这意味着UI的每个部分都是根据应用状态的变化来更新的。\n\n**SwiftUI与UIKit的比较**\n\n尽管UIKit已经是iOS应用开发的主导UI框架多年，但SwiftUI带来了许多优势，特别是在创建跨平台UI时。UIKit依赖于命令式编程和手动管理的UIView，而SwiftUI使用声明式代码和自动管理的视图体系结构。这就意味着用SwiftUI可以用更少的代码做更多的工作，同时减少了出错的可能性。不过，对于已经存在的项目，UIKit仍然是必不可少的，因此理解两者的差异对于现代iOS开发者来说至关重要。\n\n**本书适用读者**\n\n无论您是新手程序员还是有经验的开发者，只要您对掌握SwiftUI感兴趣，这本书就是为您准备的。我们假设您已经对Swift语言有了基本的了解，并希望扩展您的知识库来包括UI设计。如果您是从UIKit转型来的开发者，这本书将帮助您理解SwiftUI的独特之处，并指导您如何迁移现有的知识和技能。\n\n**如何使用本书**\n\n《SwiftUI核心技术》是按模块组织的，从基础知识到高级应用，最后是综合案例研究。您可以按顺序阅读以构建坚实的基础，也可以直接跳到对您当前项目最相关的章节。每个概念都伴随着代码示例和最佳实践，以便您可以实践所学，并在实际中应用这些技能。书中还包含了挑战和练习，让您能够测试自己的理解并巩固学习成果。\n\n当您准备开始您的SwiftUI之旅时，希望这本书成为您的指南，带您更深入地了解如何使用这一令人兴奋的新框架来创造美妙、响应迅速且富有表现力的用户界面。\n\n---\n\n希望这段前言能够为您的书籍奠定一个温馨而专业的开场。您可以根据实际需要调整这段文本，以更好地符合您对书籍的愿景。\n\n**第1章：SwiftUI概述**\n\n**1. SwiftUI的设计哲学**\n\n苹果公司在2019年WWDC上推出SwiftUI时，开启了iOS、macOS、watchOS和tvOS开发的新篇章。该框架的设计哲学突破了以往UI开发的界限，以优雅且革命性的方式提高了开发速度、改善了代码的质量，并统一了跨平台的用户体验。本节将详细介绍构成SwiftUI设计哲学的核心元素。\n\n**简洁的声明性语法**\n\nSwiftUI的核心是其声明性语法。在传统的命令式编程模型中，开发者需要详细指定如何绘制和更新用户界面的每一个变化。这种方式虽然直接，但随着应用界面变得越来越复杂，代码就会变得难以理解和维护。相比之下，SwiftUI采用声明性方法，允许开发者表达他们想要的界面应该是什么样子，而非如何绘制界面。\n\n例如，一个按钮的创建和配置，在UIKit中可能需要数行代码来设定它的状态和外观，还要添加响应点击的动作。而在SwiftUI中，同样的按钮只需要几行声明性代码即可完成：\n\n```swift\nButton(\"点击我\") {\n    print(\"按钮被点击\")\n}\n```\n\n这样的语法不仅使代码更易读，也使得UI的各个组件能够更容易地重用和组合。\n\n**组件化和可组合性**\n\nSwiftUI强调组件化—创建可重用的UI组件—以及可组合性—将这些组件拼接成复杂的UI。每个SwiftUI视图都是一种结构体，这是一种轻量级的数据类型，非常适合用来描述UI组件。这与UIKit的类和对象相比，可以显著提高性能，特别是在用户界面需要快速重建时。\n\n此外，SwiftUI的视图可以包含其他视图，这就为开发者提供了极大的灵活性来构建复杂的用户界面。例如，可以创建一个自定义的按钮样式，然后在不同的地方多次使用，而无需重写样式代码。\n\n**一致性和跨平台设计**\n\nSwiftUI的一个显著特点是其跨平台能力。相同的SwiftUI代码可以运行在iOS、macOS、watchOS和tvOS上，无需做出太多修改。这种一致性意味着开发者可以为所有Apple平台构建统一的应用体验，同时允许针对特定平台的优化。\n\n跨平台设计的好处是显而易见的。开发者可以集中精力于创建出色的用户体验，而不是花费时间在适配不同平台的布局和控件上。SwiftUI通过提供一致的API和控件集，确保了界面在各个设备上都能保持良好的交互和视觉效果。\n\n**数据驱动的UI更新**\n\nSwiftUI的另一个核心特性是数据驱动的UI更新。这意味着UI的状态可以被绑定到应用程序的数据模型上，当数据变化时，UI会自动更新。这种绑定使用了Swift的属性包装器如`@State`和`@Binding`，它们提供了一种声明性的方式来定义视图的源数据。\n\n以一个简单的文本输入为例，在UIKit中，您可能需要实现委托模式来响应文本变化，然后手动更新UI。而在SwiftUI中，您可以这样做：\n\n```swift\nstruct ContentView: View {\n    @State private var userName: String = \"\"\n\n    var body: some View\n\n {\n        TextField(\"请输入用户名\", text: $userName)\n        Text(\"您好，\\(userName)!\")\n    }\n}\n```\n\n在这个例子中，`TextField`的文本被绑定到`userName`状态上。当用户在文本字段中输入时，`userName`会自动更新，而且相关的`Text`视图也会即时反映这个变化。\n\n**总结**\n\nSwiftUI的设计哲学是为了提高开发效率、改善代码质量，并使应用能够快速适应未来的变化。通过其声明性语法、组件化和可组合性、一致性以及数据驱动的UI更新，SwiftUI为现代应用开发树立了新的标准。接下来，我们将进一步探讨SwiftUI是如何实现这些设计理念的，并通过实例展示这些概念在实际开发中的应用。\n\n**2. SwiftUI的架构**\n\nSwiftUI是构建在一系列高效且现代的编程模式和原则之上的，它不仅简化了用户界面的创建，而且通过其独特的架构提升了应用性能和开发效率。在本节中，我们将深入了解构成SwiftUI架构的各个部分，以及它们如何协同工作以创建流畅且动态的用户界面。\n\n**视图层次结构与组件**\n\n在SwiftUI中，一切都是视图。从文本标签(`Text`)到按钮(`Button`)，再到整个屏幕(`ContentView`)，所有的UI组件都是视图。SwiftUI使用一种结构体(`struct`)来定义视图，这是一个轻量级的数据类型，非常适合描述UI组件。每个视图都知道如何绘制自己，并能定义自己的布局。\n\n一个关键概念是视图的层次结构，它表示视图的嵌套。父视图可以包含多个子视图，创建出丰富的布局。SwiftUI使用声明性的方法来组织视图层次，这意味着您声明界面应该如何组织，而不是编写代码来动态创建和管理视图对象。\n\n**布局系统**\n\nSwiftUI的布局系统是自适应和响应式的，允许视图以一种非常自然的方式响应外部条件的变化，如设备的屏幕大小或者设备方向。布局是由视图本身以及环境(`Environment`)中的信息决定的。每个视图提供了一个`body`属性，描述了其子视图的布局。\n\nSwiftUI的`Stack`、`List`、`Grid`等布局容器帮助您定义强大而灵活的布局。例如，一个`VStack`会垂直堆叠其子视图，而一个`HStack`则会水平堆叠。每个容器都可以包含其他容器，从而创建复杂且响应式的布局结构。\n\n**数据流和绑定**\n\nSwiftUI的架构旨在促进数据流的清晰和一致。它通过使用一系列属性包装器来实现，如`@State`、`@Binding`、`@ObservedObject`和`@EnvironmentObject`。这些属性包装器提供了不同层级的数据流和状态管理，确保视图与数据保持同步。\n\n`@State`是一种私有的、视图内的状态管理，用于存储视图的本地数据。`@Binding`则创建了一个可读写的连接到另一个视图持有的`@State`的连接，从而允许数据在不同视图间共享。\n\n对于更复杂的数据管理，`@ObservedObject`和`@EnvironmentObject`使得视图能够订阅外部的数据模型。当数据模型标记为`ObservableObject`并且其内部的数据通过`@Published`包装器进行更改时，订阅这些模型的视图会自动更新。\n\n**声明性渲染**\n\nSwiftUI的架构在内部使用了一种高效的声明性渲染引擎，它能够智能地重绘改变了的部分而非整个界面。这是通过比较视图的当前状态和新的声明来实现的。当状态发生变化时，SwiftUI计算出最小的差异，并且只更新需要改变的部分。\n\n这种智能重绘是非常重要的，因为它意味着视图的更新可以非常快速，并且能保持性能，即使在复杂的界面和动画中也是如此。\n\n**Swift与SwiftUI的紧密集成**\n\nSwiftUI与Swift编程语言的紧密集成提供了许多编程上的好处。利用Swift的强类型系统、函数式编程特性和高级语言构造，SwiftUI可以确保代码安全、清晰且易于理解。\n\nSwiftUI的一切，从其布局系统到与Combine框架的集成，都是为了简化编程模型，允许开发者以一种更直观和高效的方式来构建用户界面。\n\n**总结**\n\nSwiftUI的架构是其强大功能和易用性的基石。通过视图层次结构、响应式布局系统、清晰的数据流和绑定以及高效的声明性渲染，SwiftUI提供了一个坚实的基础来构建现代的跨平台应用。了解这些概念对于充分利用SwiftUI的潜力是至关重要的。在本书的后续章节中，我们将进一步深入探讨每个概念，并通过具体的代码示例来展示它们在实际开发中的应用。\n\n\n**3. MVVM设计模式在SwiftUI中的应用**\n\n在现代应用开发中，架构模式的选择对于确保代码的可读性、可维护性和可扩展性至关重要。Model-View-ViewModel (MVVM) 是一种被广泛采用的设计模式，尤其是在SwiftUI中，它提供了一种清晰地分离用户界面和业务逻辑的方式。本节将探讨MVVM设计模式，并详细说明它如何在SwiftUI中得到应用。\n\n**MVVM的核心概念**\n\nMVVM设计模式将应用分为三个主要组件：Model、View和ViewModel。\n\n- **Model** - 表示应用的数据和业务逻辑。它是纯粹的Swift类或结构体，不含任何UI代码。\n- **View** - 显示应用的用户界面。在SwiftUI中，所有的UI组件都是视图，从单个按钮到整个屏幕。\n- **ViewModel** - 作为Model和View之间的桥梁。它包含了展示逻辑，但不包含业务逻辑或者状态管理的代码。\n\nMVVM通过这种分离，确保了UI代码的简洁性，并允许业务逻辑独立于UI，使其更易于测试和重用。\n\n**ViewModel在SwiftUI中的角色**\n\n在SwiftUI中，ViewModel通常是一个符合`ObservableObject`协议的Swift类。它会暴露出用于UI显示的数据，并将用户的交互转化为模型更新和视图的状态更改。\n\n例如，如果您有一个任务列表应用，ViewModel可能包含一个任务数组的状态以及添加新任务的方法。当用户通过界面添加任务时，ViewModel会更新Model，并通知View重新渲染以显示新任务。\n\n**数据绑定和状态管理**\n\nSwiftUI的数据绑定特性与MVVM的配合尤其紧密。使用`@Published`属性包装器，ViewModel可以提供可观察的数据属性，当这些属性的值变化时，关联的视图可以自动更新。\n\n此外，SwiftUI的状态管理属性包装器，如`@State`、`@Binding`、`@StateObject`和`@EnvironmentObject`，进一步简化了ViewModel与View之间数据和状态的同步。\n\n**MVVM的实际应用**\n\n在SwiftUI应用中实施MVVM时，ViewModel的职责包括：\n\n- 提供视图所需的数据。\n- 响应用户输入并更新Model。\n- 监控Model的变化并通知View更新。\n- 处理导航和视图间的协调逻辑。\n\n由于SwiftUI的视图是声明性的，ViewModel成为控制视图状态的中心。开发者不再需要写大量的引导代码来手动更新UI，而是可以依靠SwiftUI的绑定机制和ViewModel来自动处理。\n\n**总结**\n\nMVVM设计模式在SwiftUI中的应用为创建结构化和高效的应用程序提供了框架。通过将业务逻辑移至ViewModel，并利用SwiftUI的响应式数据绑定，开发者能够创建更清晰、更易于维护和扩展的代码。在本书接下来的章节中，我们将通过具体示例深入探讨MVVM模式在SwiftUI应用开发中的具体实现和最佳实践。\n\n\n**第2章：Swift语言回顾**\n\n**1. Swift基础**\n\nSwift 是由苹果公司开发的一种强大的编程语言，旨在为开发者提供一种简单、清晰且高效的语言工具。它既适合新手学习编程，也足以满足专业开发者构建复杂应用的需求。在本节中，我们将回顾Swift语言的基础，为深入学习SwiftUI打下坚实的基础。\n\n**变量和常量**\n\nSwift 使用 `var` 关键字来声明变量，`let` 关键字来声明常量。变量是可以被赋予不同值的标识符，而常量一旦设定初始值后则不能更改。\n\n```swift\nvar greeting = \"Hello, world!\"\nlet pi = 3.14159\n```\n\n**数据类型**\n\nSwift 是一种类型安全的语言，这意味着每个变量都有一个明确的类型。Swift 的基本数据类型包括 `Int`、`Float`、`Double`、`Bool`、`String` 等。\n\n```swift\nvar age: Int = 30\nvar price: Double = 29.99\nvar isHidden: Bool = false\nvar name: String = \"John Doe\"\n```\n\n**控制流**\n\nSwift 提供了丰富的控制流结构，包括 `if`、`else` 条件语句，`switch` 语句，以及 `for-in`、`while` 和 `repeat-while` 循环。\n\n```swift\nif age > 18 {\n    print(\"Adult\")\n} else {\n    print(\"Minor\")\n}\n\nfor index in 1...5 {\n    print(index)\n}\n```\n\n**函数**\n\n函数是执行特定任务的自包含代码块。Swift 的函数使用 `func` 关键字声明，可以接受参数和返回值。\n\n```swift\nfunc greet(person: String) -> String {\n    return \"Hello, \\(person)!\"\n}\nprint(greet(person: \"Anna\")) // Prints \"Hello, Anna!\"\n```\n\n**闭包**\n\n闭包是可以在代码中被传递和使用的自包含功能块，类似于其他语言中的匿名函数。闭包捕获并存储它们的上下文中的任何常量和变量的引用。\n\n```swift\nlet names = [\"Chris\", \"Alex\", \"Ewa\", \"Barry\", \"Daniella\"]\nvar reversedNames = names.sorted(by: { $0 > $1 })\n```\n\n**结构体和类**\n\nSwift 中的结构体和类是构建代码的基本构件。结构体是值类型，而类是引用类型。\n\n```swift\nstruct Point {\n    var x: Int\n    var y: Int\n}\n\nclass Vehicle {\n    var numberOfWheels = 0\n    func description() -> String {\n        return \"\\(numberOfWheels) wheel(s)\"\n    }\n}\n```\n\n**属性和方法**\n\n属性用于存储值，方法用于添加特定的行为。计算属性则提供了一种自定义的 getter 和 setter 来间接获取和设置其他属性或变量的值。\n\n```swift\nclass Circle {\n    var radius: Double = 0\n    var circumference: Double {\n        return pi * radius * 2\n    }\n}\n```\n\n**协议和扩展**\n\n协议定义了一组方法和属性的蓝图，类、结构体和枚举可以实现这些协议。扩展则允许你为现有的类型添加新的功能。\n\n```swift\nprotocol Identifiable {\n    var id: String { get set }\n}\n\nextension String {\n    func capitalizedFirst() -> String {\n        return prefix(1).uppercased() + self.lowercased().dropFirst()\n    }\n}\n```\n\n**错误处理**\n\nSwift 中的错误处理允许你表示并处理程序执行中可能遇到的错误条件。\n\n```swift\nenum PrinterError: Error {\n    case outOfPaper\n    case noToner\n    case onFire\n}\n\nfunc send(job: Int, toPrinter printerName: String) throws -> String {\n    if printerName == \"Never Has Toner\" {\n        throw PrinterError.noToner\n    }\n    return \"Job sent\"\n\n\n}\n```\n\n**泛型**\n\n泛型允许你写出灵活、可重用的函数和类型，它们可以工作于任何类型。\n\n```swift\nfunc swapTwoValues<T>(_ a: inout T, _ b: inout T) {\n    let temporaryA = a\n    a = b\n    b = temporaryA\n}\n```\n\n**总结**\n\n这些是Swift语言的一些核心概念，掌握它们对于理解SwiftUI的工作方式至关重要。Swift的这些特性提供了构建SwiftUI应用所需的工具和构建块，接下来的章节中我们将看到这些基础如何在实际的SwiftUI编程中得到应用。\n\n\n**2. 面向协议编程**\n\n面向协议编程（Protocol-Oriented Programming，POP）是Swift语言的一个核心范式。与面向对象编程（Object-Oriented Programming，OOP）关注在类和继承上构建程序的层次结构不同，POP倡导通过定义协议并将它们实现于类、结构体或枚举来构建程序的行为和形态。在本节中，我们将探讨POP的基础，以及如何在Swift中应用这个强大的编程范式。\n\n**协议的定义**\n\n协议定义了一套蓝图，规定了采纳协议的类型必须实现哪些方法和属性。协议可以被类、结构体或枚举类型采纳，以提供所需的实现。\n\n```swift\nprotocol Identifiable {\n    var id: String { get set }\n    func identify()\n}\n\nextension Identifiable {\n    func identify() {\n        print(\"My ID is \\(id).\")\n    }\n}\n```\n\n在上述例子中，任何采纳`Identifiable`协议的类型都必须有一个`id`属性，并且默认提供了一个`identify`方法的实现。\n\n**面向协议的优势**\n\n- **复用性**：通过定义协议，您可以创建可在多种类型间复用的方法和属性。\n- **松耦合**：类型之间的依赖性降低，因为它们依赖于协议，而不是具体的实现。\n- **灵活性**：可以为不同的类型添加协议扩展，为它们提供特定的功能，而无需修改原有类型代码。\n- **适应性**：类型可以同时采纳多个协议，易于适配和扩展。\n\n**使用协议定义行为**\n\n一个典型的POP实践是定义一系列协议来代表应用的不同部分可以共享的行为，而不是创建基类。\n\n```swift\nprotocol Flyable {\n    var airspeedVelocity: Double { get }\n}\n\nprotocol Feasible {\n    var isFeasible: Bool { get }\n}\n\n// 现在，任何类型都可以采纳Flyable和Feasible协议，不仅限于某个类的子类。\nstruct Bird: Flyable, Feasible {\n    var airspeedVelocity: Double\n    var isFeasible: Bool\n}\n```\n\n**在扩展中采纳协议**\n\nSwift允许在类型的扩展中采纳协议。这意味着即使是先前定义好的类型，也可以被增强来采纳新的协议。\n\n```swift\nextension Array: Identifiable where Element: Identifiable {\n    var id: String {\n        return self.map { $0.id }.joined(separator: \", \")\n    }\n}\n```\n\n这里，只要数组的元素采纳了`Identifiable`协议，数组本身就自动采纳了`Identifiable`。\n\n**关联类型**\n\n协议可以具有关联类型，这是一种未被指定的类型占位符，其具体类型将由协议的采纳者提供。\n\n```swift\nprotocol Container {\n    associatedtype Item\n    mutating func append(_ item: Item)\n    var count: Int { get }\n    subscript(i: Int) -> Item { get }\n}\n\nstruct IntStack: Container {\n    // 实现Container协议的要求\n    typealias Item = Int\n    // ...\n}\n```\n\n关联类型增加了协议的灵活性，使其可以被不同的类型以不同的方式采纳。\n\n**总结**\n\n面向协议编程是Swift语言的一个核心原则，它鼓励开发者通过协议来定义接口和行为，而不是传统的继承。这样的方法为代码提供了更高的复用性和灵活性，也更加\n\n安全。在SwiftUI中，您会发现许多UI组件都是基于协议来构建的，这使得自定义和扩展UI变得十分方便和高效。通过本节的学习，您应该对如何使用面向协议编程来构建更强大、更模块化的Swift应用有了更深刻的理解。\n\n\n**3. Swift中的函数式编程特性**\n\n函数式编程是一种编程范式，它将计算视为数学函数的评估，并避免状态以及可变数据。Swift虽然不是一个纯函数式编程语言，但它融合了许多函数式编程的特性。这些特性可以帮助开发者编写更简洁、更易于理解的代码。在本节中，我们将探索Swift中的函数式编程特性及其在实际编程中的应用。\n\n**不可变性**\n\n在函数式编程中，不可变性是一个核心概念。不可变的数据可以避免副作用和状态变化，这使得程序更容易理解和调试。在Swift中，使用`let`关键字声明的常量是不可变的。\n\n```swift\nlet constantArray = [1, 2, 3]\n// constantArray[0] = 4 // 这行代码将导致编译错误，因为数组是不可变的\n```\n\n**一等函数**\n\nSwift将函数作为一等公民，这意味着函数可以作为其他函数的参数传递，也可以作为函数的返回值，还可以赋值给变量。\n\n```swift\nfunc add(_ a: Int, _ b: Int) -> Int {\n    return a + b\n}\n\nvar mathFunction: (Int, Int) -> Int = add\nprint(mathFunction(2, 3)) // 输出 5\n```\n\n**高阶函数**\n\nSwift标准库中提供了多种高阶函数，如`map`、`filter`、`reduce`等，这些函数都可以接受一个函数作为输入。\n\n- `map` 用于将集合中的每个元素通过特定的方法进行转换。\n- `filter` 用于选择集合中符合特定条件的元素。\n- `reduce` 用于将集合中的元素合并成一个单一的值。\n\n```swift\nlet numbers = [1, 2, 3, 4, 5]\nlet squaredNumbers = numbers.map { $0 * $0 } // [1, 4, 9, 16, 25]\nlet evenNumbers = numbers.filter { $0 % 2 == 0 } // [2, 4]\nlet sumOfNumbers = numbers.reduce(0, +) // 15\n```\n\n**闭包**\n\n闭包是自包含的函数代码块，可以在代码中传递和使用。它们尤其适用于函数式编程，因为它们可以捕获和存储任何它们所在上下文中的常量和变量的引用。\n\n```swift\nlet names = [\"Chris\", \"Alex\", \"Ewa\", \"Barry\", \"Daniella\"]\nlet reversedNames = names.sorted(by: { s1, s2 in return s1 > s2 })\n```\n\n**柯里化（Currying）**\n\n柯里化是函数式编程中的一个概念，指的是将一个接受多个参数的函数转换成一系列只接受单一参数的函数。\n\n```swift\nfunc add(_ a: Int) -> (Int) -> Int {\n    return { b in return a + b }\n}\n\nlet addTwo = add(2)\nlet result = addTwo(3) // 5\n```\n\n**惰性求值（Lazy Evaluation）**\n\nSwift中的序列和集合提供了惰性求值的选项，这意味着只有在需要计算值的时候才会进行计算。这可以提高程序的性能，特别是在处理大型数据集时。\n\n```swift\nlet data = 1...1000\nlet result = data.lazy.filter { $0 % 2 == 0 }.map { $0 * 2 }\n// result 的计算将会被延迟，直到实际被需要\n```\n\n**总结**\n\nSwift的函数式编程特性能够帮助开发者写出更加清晰、简洁和可维护的代码。通过利用不可变性、高阶函数、闭\n\n包等特性，Swift开发者可以编写出更加表达力强、逻辑清晰的代码。在SwiftUI开发中，这些特性被广泛应用，以实现数据和UI的高效绑定和操作。掌握这些函数式编程的概念将在接下来的章节中帮助读者更好地理解SwiftUI的设计和实现方式。\n\n\n","slug":"SwiftUI核心技术","published":1,"updated":"2024-03-17T06:11:04.809Z","comments":1,"layout":"post","photos":[],"_id":"clu6up53h001wz674eh1m6wbt","content":"<p><strong>前言</strong></p>\n<ul>\n<li>SwiftUI的介绍</li>\n<li>SwiftUI与UIKit的比较</li>\n<li>本书适用读者</li>\n<li>如何使用本书</li>\n</ul>\n<p><strong>第一部分：SwiftUI基础</strong></p>\n<ul>\n<li>第1章：SwiftUI概述<ul>\n<li>SwiftUI的设计哲学</li>\n<li>SwiftUI的架构</li>\n<li>MVVM设计模式在SwiftUI中的应用</li>\n</ul>\n</li>\n<li>第2章：Swift语言回顾<ul>\n<li>Swift基础</li>\n<li>面向协议编程</li>\n<li>Swift中的函数式编程特性</li>\n</ul>\n</li>\n<li>第3章：环境搭建<ul>\n<li>Xcode和SwiftUI</li>\n<li>Swift Package Manager</li>\n<li>创建第一个SwiftUI应用</li>\n</ul>\n</li>\n</ul>\n<p><strong>第二部分：构建用户界面</strong></p>\n<ul>\n<li>第4章：视图与控件<ul>\n<li>Text和Image</li>\n<li>Buttons和Toggle</li>\n<li>TextField和Slider</li>\n<li>自定义视图和控件</li>\n</ul>\n</li>\n<li>第5章：布局管理<ul>\n<li>堆（Stacks）</li>\n<li>对齐与帧（Alignment and Frames）</li>\n<li>Spacer和Divider</li>\n<li>布局优先级</li>\n</ul>\n</li>\n<li>第6章：数据流与绑定<ul>\n<li>State和Binding</li>\n<li>ObservedObject和EnvironmentObject</li>\n<li>@Published和Combine</li>\n<li>数据流的最佳实践</li>\n</ul>\n</li>\n<li>第7章：导航与呈现<ul>\n<li>NavigationView和NavigationViewLink</li>\n<li>TabView</li>\n<li>Sheets和Alerts</li>\n<li>Navigation的高级用法</li>\n</ul>\n</li>\n</ul>\n<p><strong>第三部分：进阶SwiftUI</strong></p>\n<ul>\n<li>第8章：动画与转场<ul>\n<li>基础动画</li>\n<li>自定义动画</li>\n<li>交互式和响应式动画</li>\n<li>转场动画</li>\n</ul>\n</li>\n<li>第9章：复合视图与可复用性<ul>\n<li>组合现有视图</li>\n<li>创建可复用的视图库</li>\n<li>自定义Modifier</li>\n</ul>\n</li>\n<li>第10章：集成Core Data和CloudKit<ul>\n<li>Core Data概念和配置</li>\n<li>SwiftUIT中的Core Data集成</li>\n<li>使用CloudKit进行数据同步</li>\n</ul>\n</li>\n</ul>\n<p><strong>第四部分：平台特定的设计</strong></p>\n<ul>\n<li>第11章：适配多平台<ul>\n<li>Catalyst: 从iOS到macOS</li>\n<li>watchOS特有的UI组件</li>\n<li>tvOS和大屏体验</li>\n</ul>\n</li>\n<li>第12章：Dark Mode和Accessibility<ul>\n<li>支持暗黑模式</li>\n<li>辅助功能的最佳实践</li>\n<li>动态字体与国际化</li>\n</ul>\n</li>\n</ul>\n<p><strong>第五部分：性能优化与测试</strong></p>\n<ul>\n<li>第13章：性能优化<ul>\n<li>诊断和解决性能问题</li>\n<li>延迟加载和内存管理</li>\n<li>视图更新效率优化</li>\n</ul>\n</li>\n<li>第14章：测试与调试<ul>\n<li>单元测试和UI测试</li>\n<li>使用Xcode调试</li>\n<li>预览与条件编译</li>\n</ul>\n</li>\n</ul>\n<p><strong>第六部分：实战案例</strong></p>\n<ul>\n<li>第15章：构建一个完整的应用（Part 1）<ul>\n<li>应用结构规划</li>\n<li>用户界面设计</li>\n<li>应用逻辑实现</li>\n</ul>\n</li>\n<li>第16章：构建一个完整的应用（Part 2）<ul>\n<li>数据持久化</li>\n<li>网络请求和数据处理</li>\n<li>应用测试和发布准备</li>\n</ul>\n</li>\n</ul>\n<p><strong>附录</strong></p>\n<ul>\n<li>A：SwiftUI视图和控件清单</li>\n<li>B：SwiftUI常见问题解答</li>\n<li>C：资源和进一步阅读</li>\n</ul>\n<p><strong>结束语</strong></p>\n<ul>\n<li>对SwiftUI的展望</li>\n<li>社区和支持</li>\n</ul>\n<p><strong>索引</strong></p>\n<hr>\n<p>这个大纲为读者提供了从基础到进阶，再到实际应用开发的完整路径。可以</p>\n<p>根据读者的反馈和最新的SwiftUI更新不断调整和增补内容。</p>\n<p>当然，以下是一段示例前言的草稿，可以用作你书籍的前言部分。</p>\n<hr>\n<p><strong>前言</strong></p>\n<p>欢迎来到《SwiftUI核心技术》，一本旨在探索和解锁Apple最新UI框架——SwiftUI的无限潜力的指南。在这个移动第一的时代，出色的用户界面和顺畅的用户体验是成功应用的关键。随着SwiftUI的出现，Apple开创了一种新的构建UI的方式，它比以往更加直观，更具表现力，且在所有Apple设备上都提供一致的体验。</p>\n<p><strong>SwiftUI的介绍</strong></p>\n<p>SwiftUI是Apple在2019年引入的一个创新的UI工具包，用于在所有Apple平台上构建用户界面。它利用Swift语言的强大功能，通过声明性语法简化了UI开发。SwiftUI不仅提供了一种更简洁、更易于理解的方式来构建UI，而且还具有数据驱动的特点，这意味着UI的每个部分都是根据应用状态的变化来更新的。</p>\n<p><strong>SwiftUI与UIKit的比较</strong></p>\n<p>尽管UIKit已经是iOS应用开发的主导UI框架多年，但SwiftUI带来了许多优势，特别是在创建跨平台UI时。UIKit依赖于命令式编程和手动管理的UIView，而SwiftUI使用声明式代码和自动管理的视图体系结构。这就意味着用SwiftUI可以用更少的代码做更多的工作，同时减少了出错的可能性。不过，对于已经存在的项目，UIKit仍然是必不可少的，因此理解两者的差异对于现代iOS开发者来说至关重要。</p>\n<p><strong>本书适用读者</strong></p>\n<p>无论您是新手程序员还是有经验的开发者，只要您对掌握SwiftUI感兴趣，这本书就是为您准备的。我们假设您已经对Swift语言有了基本的了解，并希望扩展您的知识库来包括UI设计。如果您是从UIKit转型来的开发者，这本书将帮助您理解SwiftUI的独特之处，并指导您如何迁移现有的知识和技能。</p>\n<p><strong>如何使用本书</strong></p>\n<p>《SwiftUI核心技术》是按模块组织的，从基础知识到高级应用，最后是综合案例研究。您可以按顺序阅读以构建坚实的基础，也可以直接跳到对您当前项目最相关的章节。每个概念都伴随着代码示例和最佳实践，以便您可以实践所学，并在实际中应用这些技能。书中还包含了挑战和练习，让您能够测试自己的理解并巩固学习成果。</p>\n<p>当您准备开始您的SwiftUI之旅时，希望这本书成为您的指南，带您更深入地了解如何使用这一令人兴奋的新框架来创造美妙、响应迅速且富有表现力的用户界面。</p>\n<hr>\n<p>希望这段前言能够为您的书籍奠定一个温馨而专业的开场。您可以根据实际需要调整这段文本，以更好地符合您对书籍的愿景。</p>\n<p><strong>第1章：SwiftUI概述</strong></p>\n<p><strong>1. SwiftUI的设计哲学</strong></p>\n<p>苹果公司在2019年WWDC上推出SwiftUI时，开启了iOS、macOS、watchOS和tvOS开发的新篇章。该框架的设计哲学突破了以往UI开发的界限，以优雅且革命性的方式提高了开发速度、改善了代码的质量，并统一了跨平台的用户体验。本节将详细介绍构成SwiftUI设计哲学的核心元素。</p>\n<p><strong>简洁的声明性语法</strong></p>\n<p>SwiftUI的核心是其声明性语法。在传统的命令式编程模型中，开发者需要详细指定如何绘制和更新用户界面的每一个变化。这种方式虽然直接，但随着应用界面变得越来越复杂，代码就会变得难以理解和维护。相比之下，SwiftUI采用声明性方法，允许开发者表达他们想要的界面应该是什么样子，而非如何绘制界面。</p>\n<p>例如，一个按钮的创建和配置，在UIKit中可能需要数行代码来设定它的状态和外观，还要添加响应点击的动作。而在SwiftUI中，同样的按钮只需要几行声明性代码即可完成：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Button</span>(<span class=\"hljs-string\">&quot;点击我&quot;</span>) &#123;<br>    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;按钮被点击&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这样的语法不仅使代码更易读，也使得UI的各个组件能够更容易地重用和组合。</p>\n<p><strong>组件化和可组合性</strong></p>\n<p>SwiftUI强调组件化—创建可重用的UI组件—以及可组合性—将这些组件拼接成复杂的UI。每个SwiftUI视图都是一种结构体，这是一种轻量级的数据类型，非常适合用来描述UI组件。这与UIKit的类和对象相比，可以显著提高性能，特别是在用户界面需要快速重建时。</p>\n<p>此外，SwiftUI的视图可以包含其他视图，这就为开发者提供了极大的灵活性来构建复杂的用户界面。例如，可以创建一个自定义的按钮样式，然后在不同的地方多次使用，而无需重写样式代码。</p>\n<p><strong>一致性和跨平台设计</strong></p>\n<p>SwiftUI的一个显著特点是其跨平台能力。相同的SwiftUI代码可以运行在iOS、macOS、watchOS和tvOS上，无需做出太多修改。这种一致性意味着开发者可以为所有Apple平台构建统一的应用体验，同时允许针对特定平台的优化。</p>\n<p>跨平台设计的好处是显而易见的。开发者可以集中精力于创建出色的用户体验，而不是花费时间在适配不同平台的布局和控件上。SwiftUI通过提供一致的API和控件集，确保了界面在各个设备上都能保持良好的交互和视觉效果。</p>\n<p><strong>数据驱动的UI更新</strong></p>\n<p>SwiftUI的另一个核心特性是数据驱动的UI更新。这意味着UI的状态可以被绑定到应用程序的数据模型上，当数据变化时，UI会自动更新。这种绑定使用了Swift的属性包装器如<code>@State</code>和<code>@Binding</code>，它们提供了一种声明性的方式来定义视图的源数据。</p>\n<p>以一个简单的文本输入为例，在UIKit中，您可能需要实现委托模式来响应文本变化，然后手动更新UI。而在SwiftUI中，您可以这样做：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ContentView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> userName: <span class=\"hljs-type\">String</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;&quot;</span><br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span><br><br> &#123;<br>        <span class=\"hljs-type\">TextField</span>(<span class=\"hljs-string\">&quot;请输入用户名&quot;</span>, text: <span class=\"hljs-variable\">$userName</span>)<br>        <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;您好，<span class=\"hljs-subst\">\\(userName)</span>!&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在这个例子中，<code>TextField</code>的文本被绑定到<code>userName</code>状态上。当用户在文本字段中输入时，<code>userName</code>会自动更新，而且相关的<code>Text</code>视图也会即时反映这个变化。</p>\n<p><strong>总结</strong></p>\n<p>SwiftUI的设计哲学是为了提高开发效率、改善代码质量，并使应用能够快速适应未来的变化。通过其声明性语法、组件化和可组合性、一致性以及数据驱动的UI更新，SwiftUI为现代应用开发树立了新的标准。接下来，我们将进一步探讨SwiftUI是如何实现这些设计理念的，并通过实例展示这些概念在实际开发中的应用。</p>\n<p><strong>2. SwiftUI的架构</strong></p>\n<p>SwiftUI是构建在一系列高效且现代的编程模式和原则之上的，它不仅简化了用户界面的创建，而且通过其独特的架构提升了应用性能和开发效率。在本节中，我们将深入了解构成SwiftUI架构的各个部分，以及它们如何协同工作以创建流畅且动态的用户界面。</p>\n<p><strong>视图层次结构与组件</strong></p>\n<p>在SwiftUI中，一切都是视图。从文本标签(<code>Text</code>)到按钮(<code>Button</code>)，再到整个屏幕(<code>ContentView</code>)，所有的UI组件都是视图。SwiftUI使用一种结构体(<code>struct</code>)来定义视图，这是一个轻量级的数据类型，非常适合描述UI组件。每个视图都知道如何绘制自己，并能定义自己的布局。</p>\n<p>一个关键概念是视图的层次结构，它表示视图的嵌套。父视图可以包含多个子视图，创建出丰富的布局。SwiftUI使用声明性的方法来组织视图层次，这意味着您声明界面应该如何组织，而不是编写代码来动态创建和管理视图对象。</p>\n<p><strong>布局系统</strong></p>\n<p>SwiftUI的布局系统是自适应和响应式的，允许视图以一种非常自然的方式响应外部条件的变化，如设备的屏幕大小或者设备方向。布局是由视图本身以及环境(<code>Environment</code>)中的信息决定的。每个视图提供了一个<code>body</code>属性，描述了其子视图的布局。</p>\n<p>SwiftUI的<code>Stack</code>、<code>List</code>、<code>Grid</code>等布局容器帮助您定义强大而灵活的布局。例如，一个<code>VStack</code>会垂直堆叠其子视图，而一个<code>HStack</code>则会水平堆叠。每个容器都可以包含其他容器，从而创建复杂且响应式的布局结构。</p>\n<p><strong>数据流和绑定</strong></p>\n<p>SwiftUI的架构旨在促进数据流的清晰和一致。它通过使用一系列属性包装器来实现，如<code>@State</code>、<code>@Binding</code>、<code>@ObservedObject</code>和<code>@EnvironmentObject</code>。这些属性包装器提供了不同层级的数据流和状态管理，确保视图与数据保持同步。</p>\n<p><code>@State</code>是一种私有的、视图内的状态管理，用于存储视图的本地数据。<code>@Binding</code>则创建了一个可读写的连接到另一个视图持有的<code>@State</code>的连接，从而允许数据在不同视图间共享。</p>\n<p>对于更复杂的数据管理，<code>@ObservedObject</code>和<code>@EnvironmentObject</code>使得视图能够订阅外部的数据模型。当数据模型标记为<code>ObservableObject</code>并且其内部的数据通过<code>@Published</code>包装器进行更改时，订阅这些模型的视图会自动更新。</p>\n<p><strong>声明性渲染</strong></p>\n<p>SwiftUI的架构在内部使用了一种高效的声明性渲染引擎，它能够智能地重绘改变了的部分而非整个界面。这是通过比较视图的当前状态和新的声明来实现的。当状态发生变化时，SwiftUI计算出最小的差异，并且只更新需要改变的部分。</p>\n<p>这种智能重绘是非常重要的，因为它意味着视图的更新可以非常快速，并且能保持性能，即使在复杂的界面和动画中也是如此。</p>\n<p><strong>Swift与SwiftUI的紧密集成</strong></p>\n<p>SwiftUI与Swift编程语言的紧密集成提供了许多编程上的好处。利用Swift的强类型系统、函数式编程特性和高级语言构造，SwiftUI可以确保代码安全、清晰且易于理解。</p>\n<p>SwiftUI的一切，从其布局系统到与Combine框架的集成，都是为了简化编程模型，允许开发者以一种更直观和高效的方式来构建用户界面。</p>\n<p><strong>总结</strong></p>\n<p>SwiftUI的架构是其强大功能和易用性的基石。通过视图层次结构、响应式布局系统、清晰的数据流和绑定以及高效的声明性渲染，SwiftUI提供了一个坚实的基础来构建现代的跨平台应用。了解这些概念对于充分利用SwiftUI的潜力是至关重要的。在本书的后续章节中，我们将进一步深入探讨每个概念，并通过具体的代码示例来展示它们在实际开发中的应用。</p>\n<p><strong>3. MVVM设计模式在SwiftUI中的应用</strong></p>\n<p>在现代应用开发中，架构模式的选择对于确保代码的可读性、可维护性和可扩展性至关重要。Model-View-ViewModel (MVVM) 是一种被广泛采用的设计模式，尤其是在SwiftUI中，它提供了一种清晰地分离用户界面和业务逻辑的方式。本节将探讨MVVM设计模式，并详细说明它如何在SwiftUI中得到应用。</p>\n<p><strong>MVVM的核心概念</strong></p>\n<p>MVVM设计模式将应用分为三个主要组件：Model、View和ViewModel。</p>\n<ul>\n<li><strong>Model</strong> - 表示应用的数据和业务逻辑。它是纯粹的Swift类或结构体，不含任何UI代码。</li>\n<li><strong>View</strong> - 显示应用的用户界面。在SwiftUI中，所有的UI组件都是视图，从单个按钮到整个屏幕。</li>\n<li><strong>ViewModel</strong> - 作为Model和View之间的桥梁。它包含了展示逻辑，但不包含业务逻辑或者状态管理的代码。</li>\n</ul>\n<p>MVVM通过这种分离，确保了UI代码的简洁性，并允许业务逻辑独立于UI，使其更易于测试和重用。</p>\n<p><strong>ViewModel在SwiftUI中的角色</strong></p>\n<p>在SwiftUI中，ViewModel通常是一个符合<code>ObservableObject</code>协议的Swift类。它会暴露出用于UI显示的数据，并将用户的交互转化为模型更新和视图的状态更改。</p>\n<p>例如，如果您有一个任务列表应用，ViewModel可能包含一个任务数组的状态以及添加新任务的方法。当用户通过界面添加任务时，ViewModel会更新Model，并通知View重新渲染以显示新任务。</p>\n<p><strong>数据绑定和状态管理</strong></p>\n<p>SwiftUI的数据绑定特性与MVVM的配合尤其紧密。使用<code>@Published</code>属性包装器，ViewModel可以提供可观察的数据属性，当这些属性的值变化时，关联的视图可以自动更新。</p>\n<p>此外，SwiftUI的状态管理属性包装器，如<code>@State</code>、<code>@Binding</code>、<code>@StateObject</code>和<code>@EnvironmentObject</code>，进一步简化了ViewModel与View之间数据和状态的同步。</p>\n<p><strong>MVVM的实际应用</strong></p>\n<p>在SwiftUI应用中实施MVVM时，ViewModel的职责包括：</p>\n<ul>\n<li>提供视图所需的数据。</li>\n<li>响应用户输入并更新Model。</li>\n<li>监控Model的变化并通知View更新。</li>\n<li>处理导航和视图间的协调逻辑。</li>\n</ul>\n<p>由于SwiftUI的视图是声明性的，ViewModel成为控制视图状态的中心。开发者不再需要写大量的引导代码来手动更新UI，而是可以依靠SwiftUI的绑定机制和ViewModel来自动处理。</p>\n<p><strong>总结</strong></p>\n<p>MVVM设计模式在SwiftUI中的应用为创建结构化和高效的应用程序提供了框架。通过将业务逻辑移至ViewModel，并利用SwiftUI的响应式数据绑定，开发者能够创建更清晰、更易于维护和扩展的代码。在本书接下来的章节中，我们将通过具体示例深入探讨MVVM模式在SwiftUI应用开发中的具体实现和最佳实践。</p>\n<p><strong>第2章：Swift语言回顾</strong></p>\n<p><strong>1. Swift基础</strong></p>\n<p>Swift 是由苹果公司开发的一种强大的编程语言，旨在为开发者提供一种简单、清晰且高效的语言工具。它既适合新手学习编程，也足以满足专业开发者构建复杂应用的需求。在本节中，我们将回顾Swift语言的基础，为深入学习SwiftUI打下坚实的基础。</p>\n<p><strong>变量和常量</strong></p>\n<p>Swift 使用 <code>var</code> 关键字来声明变量，<code>let</code> 关键字来声明常量。变量是可以被赋予不同值的标识符，而常量一旦设定初始值后则不能更改。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">var</span> greeting <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;Hello, world!&quot;</span><br><span class=\"hljs-keyword\">let</span> pi <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">3.14159</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>数据类型</strong></p>\n<p>Swift 是一种类型安全的语言，这意味着每个变量都有一个明确的类型。Swift 的基本数据类型包括 <code>Int</code>、<code>Float</code>、<code>Double</code>、<code>Bool</code>、<code>String</code> 等。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">var</span> age: <span class=\"hljs-type\">Int</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">30</span><br><span class=\"hljs-keyword\">var</span> price: <span class=\"hljs-type\">Double</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">29.99</span><br><span class=\"hljs-keyword\">var</span> isHidden: <span class=\"hljs-type\">Bool</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">false</span><br><span class=\"hljs-keyword\">var</span> name: <span class=\"hljs-type\">String</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;John Doe&quot;</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>控制流</strong></p>\n<p>Swift 提供了丰富的控制流结构，包括 <code>if</code>、<code>else</code> 条件语句，<code>switch</code> 语句，以及 <code>for-in</code>、<code>while</code> 和 <code>repeat-while</code> 循环。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">if</span> age <span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-number\">18</span> &#123;<br>    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;Adult&quot;</span>)<br>&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;Minor&quot;</span>)<br>&#125;<br><br><span class=\"hljs-keyword\">for</span> index <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">1</span><span class=\"hljs-operator\">...</span><span class=\"hljs-number\">5</span> &#123;<br>    <span class=\"hljs-built_in\">print</span>(index)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>函数</strong></p>\n<p>函数是执行特定任务的自包含代码块。Swift 的函数使用 <code>func</code> 关键字声明，可以接受参数和返回值。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">greet</span>(<span class=\"hljs-params\">person</span>: <span class=\"hljs-type\">String</span>) -&gt; <span class=\"hljs-type\">String</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;Hello, <span class=\"hljs-subst\">\\(person)</span>!&quot;</span><br>&#125;<br><span class=\"hljs-built_in\">print</span>(greet(person: <span class=\"hljs-string\">&quot;Anna&quot;</span>)) <span class=\"hljs-comment\">// Prints &quot;Hello, Anna!&quot;</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>闭包</strong></p>\n<p>闭包是可以在代码中被传递和使用的自包含功能块，类似于其他语言中的匿名函数。闭包捕获并存储它们的上下文中的任何常量和变量的引用。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">let</span> names <span class=\"hljs-operator\">=</span> [<span class=\"hljs-string\">&quot;Chris&quot;</span>, <span class=\"hljs-string\">&quot;Alex&quot;</span>, <span class=\"hljs-string\">&quot;Ewa&quot;</span>, <span class=\"hljs-string\">&quot;Barry&quot;</span>, <span class=\"hljs-string\">&quot;Daniella&quot;</span>]<br><span class=\"hljs-keyword\">var</span> reversedNames <span class=\"hljs-operator\">=</span> names.sorted(by: &#123; <span class=\"hljs-variable\">$0</span> <span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-variable\">$1</span> &#125;)<br></code></pre></td></tr></table></figure>\n\n<p><strong>结构体和类</strong></p>\n<p>Swift 中的结构体和类是构建代码的基本构件。结构体是值类型，而类是引用类型。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Point</span> &#123;<br>    <span class=\"hljs-keyword\">var</span> x: <span class=\"hljs-type\">Int</span><br>    <span class=\"hljs-keyword\">var</span> y: <span class=\"hljs-type\">Int</span><br>&#125;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Vehicle</span> &#123;<br>    <span class=\"hljs-keyword\">var</span> numberOfWheels <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span><br>    <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">description</span>() -&gt; <span class=\"hljs-type\">String</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;<span class=\"hljs-subst\">\\(numberOfWheels)</span> wheel(s)&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>属性和方法</strong></p>\n<p>属性用于存储值，方法用于添加特定的行为。计算属性则提供了一种自定义的 getter 和 setter 来间接获取和设置其他属性或变量的值。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Circle</span> &#123;<br>    <span class=\"hljs-keyword\">var</span> radius: <span class=\"hljs-type\">Double</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span><br>    <span class=\"hljs-keyword\">var</span> circumference: <span class=\"hljs-type\">Double</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> pi <span class=\"hljs-operator\">*</span> radius <span class=\"hljs-operator\">*</span> <span class=\"hljs-number\">2</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>协议和扩展</strong></p>\n<p>协议定义了一组方法和属性的蓝图，类、结构体和枚举可以实现这些协议。扩展则允许你为现有的类型添加新的功能。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">protocol</span> <span class=\"hljs-title class_\">Identifiable</span> &#123;<br>    <span class=\"hljs-keyword\">var</span> id: <span class=\"hljs-type\">String</span> &#123; <span class=\"hljs-keyword\">get</span> <span class=\"hljs-keyword\">set</span> &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">extension</span> <span class=\"hljs-title class_\">String</span> &#123;<br>    <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">capitalizedFirst</span>() -&gt; <span class=\"hljs-type\">String</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">prefix</span>(<span class=\"hljs-number\">1</span>).uppercased() <span class=\"hljs-operator\">+</span> <span class=\"hljs-keyword\">self</span>.lowercased().dropFirst()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>错误处理</strong></p>\n<p>Swift 中的错误处理允许你表示并处理程序执行中可能遇到的错误条件。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title class_\">PrinterError</span>: <span class=\"hljs-title class_\">Error</span> &#123;<br>    <span class=\"hljs-keyword\">case</span> outOfPaper<br>    <span class=\"hljs-keyword\">case</span> noToner<br>    <span class=\"hljs-keyword\">case</span> onFire<br>&#125;<br><br><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">send</span>(<span class=\"hljs-params\">job</span>: <span class=\"hljs-type\">Int</span>, <span class=\"hljs-params\">toPrinter</span> <span class=\"hljs-params\">printerName</span>: <span class=\"hljs-type\">String</span>) <span class=\"hljs-keyword\">throws</span> -&gt; <span class=\"hljs-type\">String</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> printerName <span class=\"hljs-operator\">==</span> <span class=\"hljs-string\">&quot;Never Has Toner&quot;</span> &#123;<br>        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-type\">PrinterError</span>.noToner<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;Job sent&quot;</span><br><br><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>泛型</strong></p>\n<p>泛型允许你写出灵活、可重用的函数和类型，它们可以工作于任何类型。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">swapTwoValues</span>&lt;<span class=\"hljs-type\">T</span>&gt;(<span class=\"hljs-keyword\">_</span> <span class=\"hljs-params\">a</span>: <span class=\"hljs-keyword\">inout</span> <span class=\"hljs-type\">T</span>, <span class=\"hljs-keyword\">_</span> <span class=\"hljs-params\">b</span>: <span class=\"hljs-keyword\">inout</span> <span class=\"hljs-type\">T</span>) &#123;<br>    <span class=\"hljs-keyword\">let</span> temporaryA <span class=\"hljs-operator\">=</span> a<br>    a <span class=\"hljs-operator\">=</span> b<br>    b <span class=\"hljs-operator\">=</span> temporaryA<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>总结</strong></p>\n<p>这些是Swift语言的一些核心概念，掌握它们对于理解SwiftUI的工作方式至关重要。Swift的这些特性提供了构建SwiftUI应用所需的工具和构建块，接下来的章节中我们将看到这些基础如何在实际的SwiftUI编程中得到应用。</p>\n<p><strong>2. 面向协议编程</strong></p>\n<p>面向协议编程（Protocol-Oriented Programming，POP）是Swift语言的一个核心范式。与面向对象编程（Object-Oriented Programming，OOP）关注在类和继承上构建程序的层次结构不同，POP倡导通过定义协议并将它们实现于类、结构体或枚举来构建程序的行为和形态。在本节中，我们将探讨POP的基础，以及如何在Swift中应用这个强大的编程范式。</p>\n<p><strong>协议的定义</strong></p>\n<p>协议定义了一套蓝图，规定了采纳协议的类型必须实现哪些方法和属性。协议可以被类、结构体或枚举类型采纳，以提供所需的实现。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">protocol</span> <span class=\"hljs-title class_\">Identifiable</span> &#123;<br>    <span class=\"hljs-keyword\">var</span> id: <span class=\"hljs-type\">String</span> &#123; <span class=\"hljs-keyword\">get</span> <span class=\"hljs-keyword\">set</span> &#125;<br>    <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">identify</span>()<br>&#125;<br><br><span class=\"hljs-keyword\">extension</span> <span class=\"hljs-title class_\">Identifiable</span> &#123;<br>    <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">identify</span>() &#123;<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;My ID is <span class=\"hljs-subst\">\\(id)</span>.&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在上述例子中，任何采纳<code>Identifiable</code>协议的类型都必须有一个<code>id</code>属性，并且默认提供了一个<code>identify</code>方法的实现。</p>\n<p><strong>面向协议的优势</strong></p>\n<ul>\n<li><strong>复用性</strong>：通过定义协议，您可以创建可在多种类型间复用的方法和属性。</li>\n<li><strong>松耦合</strong>：类型之间的依赖性降低，因为它们依赖于协议，而不是具体的实现。</li>\n<li><strong>灵活性</strong>：可以为不同的类型添加协议扩展，为它们提供特定的功能，而无需修改原有类型代码。</li>\n<li><strong>适应性</strong>：类型可以同时采纳多个协议，易于适配和扩展。</li>\n</ul>\n<p><strong>使用协议定义行为</strong></p>\n<p>一个典型的POP实践是定义一系列协议来代表应用的不同部分可以共享的行为，而不是创建基类。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">protocol</span> <span class=\"hljs-title class_\">Flyable</span> &#123;<br>    <span class=\"hljs-keyword\">var</span> airspeedVelocity: <span class=\"hljs-type\">Double</span> &#123; <span class=\"hljs-keyword\">get</span> &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">protocol</span> <span class=\"hljs-title class_\">Feasible</span> &#123;<br>    <span class=\"hljs-keyword\">var</span> isFeasible: <span class=\"hljs-type\">Bool</span> &#123; <span class=\"hljs-keyword\">get</span> &#125;<br>&#125;<br><br><span class=\"hljs-comment\">// 现在，任何类型都可以采纳Flyable和Feasible协议，不仅限于某个类的子类。</span><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Bird</span>: <span class=\"hljs-title class_\">Flyable</span>, <span class=\"hljs-title class_\">Feasible</span> &#123;<br>    <span class=\"hljs-keyword\">var</span> airspeedVelocity: <span class=\"hljs-type\">Double</span><br>    <span class=\"hljs-keyword\">var</span> isFeasible: <span class=\"hljs-type\">Bool</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>在扩展中采纳协议</strong></p>\n<p>Swift允许在类型的扩展中采纳协议。这意味着即使是先前定义好的类型，也可以被增强来采纳新的协议。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">extension</span> <span class=\"hljs-title class_\">Array</span>: <span class=\"hljs-title class_\">Identifiable</span> <span class=\"hljs-title class_\">where</span> <span class=\"hljs-title class_\">Element</span>: <span class=\"hljs-title class_\">Identifiable</span> &#123;<br>    <span class=\"hljs-keyword\">var</span> id: <span class=\"hljs-type\">String</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">self</span>.map &#123; <span class=\"hljs-variable\">$0</span>.id &#125;.joined(separator: <span class=\"hljs-string\">&quot;, &quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这里，只要数组的元素采纳了<code>Identifiable</code>协议，数组本身就自动采纳了<code>Identifiable</code>。</p>\n<p><strong>关联类型</strong></p>\n<p>协议可以具有关联类型，这是一种未被指定的类型占位符，其具体类型将由协议的采纳者提供。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">protocol</span> <span class=\"hljs-title class_\">Container</span> &#123;<br>    <span class=\"hljs-keyword\">associatedtype</span> <span class=\"hljs-type\">Item</span><br>    <span class=\"hljs-keyword\">mutating</span> <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">append</span>(<span class=\"hljs-keyword\">_</span> <span class=\"hljs-params\">item</span>: <span class=\"hljs-type\">Item</span>)<br>    <span class=\"hljs-keyword\">var</span> count: <span class=\"hljs-type\">Int</span> &#123; <span class=\"hljs-keyword\">get</span> &#125;<br>    <span class=\"hljs-keyword\">subscript</span>(<span class=\"hljs-params\">i</span>: <span class=\"hljs-type\">Int</span>) -&gt; <span class=\"hljs-type\">Item</span> &#123; <span class=\"hljs-keyword\">get</span> &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">IntStack</span>: <span class=\"hljs-title class_\">Container</span> &#123;<br>    <span class=\"hljs-comment\">// 实现Container协议的要求</span><br>    <span class=\"hljs-keyword\">typealias</span> <span class=\"hljs-type\">Item</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">Int</span><br>    <span class=\"hljs-comment\">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>关联类型增加了协议的灵活性，使其可以被不同的类型以不同的方式采纳。</p>\n<p><strong>总结</strong></p>\n<p>面向协议编程是Swift语言的一个核心原则，它鼓励开发者通过协议来定义接口和行为，而不是传统的继承。这样的方法为代码提供了更高的复用性和灵活性，也更加</p>\n<p>安全。在SwiftUI中，您会发现许多UI组件都是基于协议来构建的，这使得自定义和扩展UI变得十分方便和高效。通过本节的学习，您应该对如何使用面向协议编程来构建更强大、更模块化的Swift应用有了更深刻的理解。</p>\n<p><strong>3. Swift中的函数式编程特性</strong></p>\n<p>函数式编程是一种编程范式，它将计算视为数学函数的评估，并避免状态以及可变数据。Swift虽然不是一个纯函数式编程语言，但它融合了许多函数式编程的特性。这些特性可以帮助开发者编写更简洁、更易于理解的代码。在本节中，我们将探索Swift中的函数式编程特性及其在实际编程中的应用。</p>\n<p><strong>不可变性</strong></p>\n<p>在函数式编程中，不可变性是一个核心概念。不可变的数据可以避免副作用和状态变化，这使得程序更容易理解和调试。在Swift中，使用<code>let</code>关键字声明的常量是不可变的。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">let</span> constantArray <span class=\"hljs-operator\">=</span> [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]<br><span class=\"hljs-comment\">// constantArray[0] = 4 // 这行代码将导致编译错误，因为数组是不可变的</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>一等函数</strong></p>\n<p>Swift将函数作为一等公民，这意味着函数可以作为其他函数的参数传递，也可以作为函数的返回值，还可以赋值给变量。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">add</span>(<span class=\"hljs-keyword\">_</span> <span class=\"hljs-params\">a</span>: <span class=\"hljs-type\">Int</span>, <span class=\"hljs-keyword\">_</span> <span class=\"hljs-params\">b</span>: <span class=\"hljs-type\">Int</span>) -&gt; <span class=\"hljs-type\">Int</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> a <span class=\"hljs-operator\">+</span> b<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> mathFunction: (<span class=\"hljs-type\">Int</span>, <span class=\"hljs-type\">Int</span>) -&gt; <span class=\"hljs-type\">Int</span> <span class=\"hljs-operator\">=</span> add<br><span class=\"hljs-built_in\">print</span>(mathFunction(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>)) <span class=\"hljs-comment\">// 输出 5</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>高阶函数</strong></p>\n<p>Swift标准库中提供了多种高阶函数，如<code>map</code>、<code>filter</code>、<code>reduce</code>等，这些函数都可以接受一个函数作为输入。</p>\n<ul>\n<li><code>map</code> 用于将集合中的每个元素通过特定的方法进行转换。</li>\n<li><code>filter</code> 用于选择集合中符合特定条件的元素。</li>\n<li><code>reduce</code> 用于将集合中的元素合并成一个单一的值。</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">let</span> numbers <span class=\"hljs-operator\">=</span> [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>]<br><span class=\"hljs-keyword\">let</span> squaredNumbers <span class=\"hljs-operator\">=</span> numbers.map &#123; <span class=\"hljs-variable\">$0</span> <span class=\"hljs-operator\">*</span> <span class=\"hljs-variable\">$0</span> &#125; <span class=\"hljs-comment\">// [1, 4, 9, 16, 25]</span><br><span class=\"hljs-keyword\">let</span> evenNumbers <span class=\"hljs-operator\">=</span> numbers.filter &#123; <span class=\"hljs-variable\">$0</span> <span class=\"hljs-operator\">%</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-operator\">==</span> <span class=\"hljs-number\">0</span> &#125; <span class=\"hljs-comment\">// [2, 4]</span><br><span class=\"hljs-keyword\">let</span> sumOfNumbers <span class=\"hljs-operator\">=</span> numbers.reduce(<span class=\"hljs-number\">0</span>, <span class=\"hljs-operator\">+</span>) <span class=\"hljs-comment\">// 15</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>闭包</strong></p>\n<p>闭包是自包含的函数代码块，可以在代码中传递和使用。它们尤其适用于函数式编程，因为它们可以捕获和存储任何它们所在上下文中的常量和变量的引用。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">let</span> names <span class=\"hljs-operator\">=</span> [<span class=\"hljs-string\">&quot;Chris&quot;</span>, <span class=\"hljs-string\">&quot;Alex&quot;</span>, <span class=\"hljs-string\">&quot;Ewa&quot;</span>, <span class=\"hljs-string\">&quot;Barry&quot;</span>, <span class=\"hljs-string\">&quot;Daniella&quot;</span>]<br><span class=\"hljs-keyword\">let</span> reversedNames <span class=\"hljs-operator\">=</span> names.sorted(by: &#123; s1, s2 <span class=\"hljs-keyword\">in</span> <span class=\"hljs-keyword\">return</span> s1 <span class=\"hljs-operator\">&gt;</span> s2 &#125;)<br></code></pre></td></tr></table></figure>\n\n<p><strong>柯里化（Currying）</strong></p>\n<p>柯里化是函数式编程中的一个概念，指的是将一个接受多个参数的函数转换成一系列只接受单一参数的函数。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">add</span>(<span class=\"hljs-keyword\">_</span> <span class=\"hljs-params\">a</span>: <span class=\"hljs-type\">Int</span>) -&gt; (<span class=\"hljs-type\">Int</span>) -&gt; <span class=\"hljs-type\">Int</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> &#123; b <span class=\"hljs-keyword\">in</span> <span class=\"hljs-keyword\">return</span> a <span class=\"hljs-operator\">+</span> b &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">let</span> addTwo <span class=\"hljs-operator\">=</span> add(<span class=\"hljs-number\">2</span>)<br><span class=\"hljs-keyword\">let</span> result <span class=\"hljs-operator\">=</span> addTwo(<span class=\"hljs-number\">3</span>) <span class=\"hljs-comment\">// 5</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>惰性求值（Lazy Evaluation）</strong></p>\n<p>Swift中的序列和集合提供了惰性求值的选项，这意味着只有在需要计算值的时候才会进行计算。这可以提高程序的性能，特别是在处理大型数据集时。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">let</span> data <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1</span><span class=\"hljs-operator\">...</span><span class=\"hljs-number\">1000</span><br><span class=\"hljs-keyword\">let</span> result <span class=\"hljs-operator\">=</span> data.lazy.filter &#123; <span class=\"hljs-variable\">$0</span> <span class=\"hljs-operator\">%</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-operator\">==</span> <span class=\"hljs-number\">0</span> &#125;.map &#123; <span class=\"hljs-variable\">$0</span> <span class=\"hljs-operator\">*</span> <span class=\"hljs-number\">2</span> &#125;<br><span class=\"hljs-comment\">// result 的计算将会被延迟，直到实际被需要</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>总结</strong></p>\n<p>Swift的函数式编程特性能够帮助开发者写出更加清晰、简洁和可维护的代码。通过利用不可变性、高阶函数、闭</p>\n<p>包等特性，Swift开发者可以编写出更加表达力强、逻辑清晰的代码。在SwiftUI开发中，这些特性被广泛应用，以实现数据和UI的高效绑定和操作。掌握这些函数式编程的概念将在接下来的章节中帮助读者更好地理解SwiftUI的设计和实现方式。</p>\n","excerpt":"","more":"<p><strong>前言</strong></p>\n<ul>\n<li>SwiftUI的介绍</li>\n<li>SwiftUI与UIKit的比较</li>\n<li>本书适用读者</li>\n<li>如何使用本书</li>\n</ul>\n<p><strong>第一部分：SwiftUI基础</strong></p>\n<ul>\n<li>第1章：SwiftUI概述<ul>\n<li>SwiftUI的设计哲学</li>\n<li>SwiftUI的架构</li>\n<li>MVVM设计模式在SwiftUI中的应用</li>\n</ul>\n</li>\n<li>第2章：Swift语言回顾<ul>\n<li>Swift基础</li>\n<li>面向协议编程</li>\n<li>Swift中的函数式编程特性</li>\n</ul>\n</li>\n<li>第3章：环境搭建<ul>\n<li>Xcode和SwiftUI</li>\n<li>Swift Package Manager</li>\n<li>创建第一个SwiftUI应用</li>\n</ul>\n</li>\n</ul>\n<p><strong>第二部分：构建用户界面</strong></p>\n<ul>\n<li>第4章：视图与控件<ul>\n<li>Text和Image</li>\n<li>Buttons和Toggle</li>\n<li>TextField和Slider</li>\n<li>自定义视图和控件</li>\n</ul>\n</li>\n<li>第5章：布局管理<ul>\n<li>堆（Stacks）</li>\n<li>对齐与帧（Alignment and Frames）</li>\n<li>Spacer和Divider</li>\n<li>布局优先级</li>\n</ul>\n</li>\n<li>第6章：数据流与绑定<ul>\n<li>State和Binding</li>\n<li>ObservedObject和EnvironmentObject</li>\n<li>@Published和Combine</li>\n<li>数据流的最佳实践</li>\n</ul>\n</li>\n<li>第7章：导航与呈现<ul>\n<li>NavigationView和NavigationViewLink</li>\n<li>TabView</li>\n<li>Sheets和Alerts</li>\n<li>Navigation的高级用法</li>\n</ul>\n</li>\n</ul>\n<p><strong>第三部分：进阶SwiftUI</strong></p>\n<ul>\n<li>第8章：动画与转场<ul>\n<li>基础动画</li>\n<li>自定义动画</li>\n<li>交互式和响应式动画</li>\n<li>转场动画</li>\n</ul>\n</li>\n<li>第9章：复合视图与可复用性<ul>\n<li>组合现有视图</li>\n<li>创建可复用的视图库</li>\n<li>自定义Modifier</li>\n</ul>\n</li>\n<li>第10章：集成Core Data和CloudKit<ul>\n<li>Core Data概念和配置</li>\n<li>SwiftUIT中的Core Data集成</li>\n<li>使用CloudKit进行数据同步</li>\n</ul>\n</li>\n</ul>\n<p><strong>第四部分：平台特定的设计</strong></p>\n<ul>\n<li>第11章：适配多平台<ul>\n<li>Catalyst: 从iOS到macOS</li>\n<li>watchOS特有的UI组件</li>\n<li>tvOS和大屏体验</li>\n</ul>\n</li>\n<li>第12章：Dark Mode和Accessibility<ul>\n<li>支持暗黑模式</li>\n<li>辅助功能的最佳实践</li>\n<li>动态字体与国际化</li>\n</ul>\n</li>\n</ul>\n<p><strong>第五部分：性能优化与测试</strong></p>\n<ul>\n<li>第13章：性能优化<ul>\n<li>诊断和解决性能问题</li>\n<li>延迟加载和内存管理</li>\n<li>视图更新效率优化</li>\n</ul>\n</li>\n<li>第14章：测试与调试<ul>\n<li>单元测试和UI测试</li>\n<li>使用Xcode调试</li>\n<li>预览与条件编译</li>\n</ul>\n</li>\n</ul>\n<p><strong>第六部分：实战案例</strong></p>\n<ul>\n<li>第15章：构建一个完整的应用（Part 1）<ul>\n<li>应用结构规划</li>\n<li>用户界面设计</li>\n<li>应用逻辑实现</li>\n</ul>\n</li>\n<li>第16章：构建一个完整的应用（Part 2）<ul>\n<li>数据持久化</li>\n<li>网络请求和数据处理</li>\n<li>应用测试和发布准备</li>\n</ul>\n</li>\n</ul>\n<p><strong>附录</strong></p>\n<ul>\n<li>A：SwiftUI视图和控件清单</li>\n<li>B：SwiftUI常见问题解答</li>\n<li>C：资源和进一步阅读</li>\n</ul>\n<p><strong>结束语</strong></p>\n<ul>\n<li>对SwiftUI的展望</li>\n<li>社区和支持</li>\n</ul>\n<p><strong>索引</strong></p>\n<hr>\n<p>这个大纲为读者提供了从基础到进阶，再到实际应用开发的完整路径。可以</p>\n<p>根据读者的反馈和最新的SwiftUI更新不断调整和增补内容。</p>\n<p>当然，以下是一段示例前言的草稿，可以用作你书籍的前言部分。</p>\n<hr>\n<p><strong>前言</strong></p>\n<p>欢迎来到《SwiftUI核心技术》，一本旨在探索和解锁Apple最新UI框架——SwiftUI的无限潜力的指南。在这个移动第一的时代，出色的用户界面和顺畅的用户体验是成功应用的关键。随着SwiftUI的出现，Apple开创了一种新的构建UI的方式，它比以往更加直观，更具表现力，且在所有Apple设备上都提供一致的体验。</p>\n<p><strong>SwiftUI的介绍</strong></p>\n<p>SwiftUI是Apple在2019年引入的一个创新的UI工具包，用于在所有Apple平台上构建用户界面。它利用Swift语言的强大功能，通过声明性语法简化了UI开发。SwiftUI不仅提供了一种更简洁、更易于理解的方式来构建UI，而且还具有数据驱动的特点，这意味着UI的每个部分都是根据应用状态的变化来更新的。</p>\n<p><strong>SwiftUI与UIKit的比较</strong></p>\n<p>尽管UIKit已经是iOS应用开发的主导UI框架多年，但SwiftUI带来了许多优势，特别是在创建跨平台UI时。UIKit依赖于命令式编程和手动管理的UIView，而SwiftUI使用声明式代码和自动管理的视图体系结构。这就意味着用SwiftUI可以用更少的代码做更多的工作，同时减少了出错的可能性。不过，对于已经存在的项目，UIKit仍然是必不可少的，因此理解两者的差异对于现代iOS开发者来说至关重要。</p>\n<p><strong>本书适用读者</strong></p>\n<p>无论您是新手程序员还是有经验的开发者，只要您对掌握SwiftUI感兴趣，这本书就是为您准备的。我们假设您已经对Swift语言有了基本的了解，并希望扩展您的知识库来包括UI设计。如果您是从UIKit转型来的开发者，这本书将帮助您理解SwiftUI的独特之处，并指导您如何迁移现有的知识和技能。</p>\n<p><strong>如何使用本书</strong></p>\n<p>《SwiftUI核心技术》是按模块组织的，从基础知识到高级应用，最后是综合案例研究。您可以按顺序阅读以构建坚实的基础，也可以直接跳到对您当前项目最相关的章节。每个概念都伴随着代码示例和最佳实践，以便您可以实践所学，并在实际中应用这些技能。书中还包含了挑战和练习，让您能够测试自己的理解并巩固学习成果。</p>\n<p>当您准备开始您的SwiftUI之旅时，希望这本书成为您的指南，带您更深入地了解如何使用这一令人兴奋的新框架来创造美妙、响应迅速且富有表现力的用户界面。</p>\n<hr>\n<p>希望这段前言能够为您的书籍奠定一个温馨而专业的开场。您可以根据实际需要调整这段文本，以更好地符合您对书籍的愿景。</p>\n<p><strong>第1章：SwiftUI概述</strong></p>\n<p><strong>1. SwiftUI的设计哲学</strong></p>\n<p>苹果公司在2019年WWDC上推出SwiftUI时，开启了iOS、macOS、watchOS和tvOS开发的新篇章。该框架的设计哲学突破了以往UI开发的界限，以优雅且革命性的方式提高了开发速度、改善了代码的质量，并统一了跨平台的用户体验。本节将详细介绍构成SwiftUI设计哲学的核心元素。</p>\n<p><strong>简洁的声明性语法</strong></p>\n<p>SwiftUI的核心是其声明性语法。在传统的命令式编程模型中，开发者需要详细指定如何绘制和更新用户界面的每一个变化。这种方式虽然直接，但随着应用界面变得越来越复杂，代码就会变得难以理解和维护。相比之下，SwiftUI采用声明性方法，允许开发者表达他们想要的界面应该是什么样子，而非如何绘制界面。</p>\n<p>例如，一个按钮的创建和配置，在UIKit中可能需要数行代码来设定它的状态和外观，还要添加响应点击的动作。而在SwiftUI中，同样的按钮只需要几行声明性代码即可完成：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Button</span>(<span class=\"hljs-string\">&quot;点击我&quot;</span>) &#123;<br>    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;按钮被点击&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这样的语法不仅使代码更易读，也使得UI的各个组件能够更容易地重用和组合。</p>\n<p><strong>组件化和可组合性</strong></p>\n<p>SwiftUI强调组件化—创建可重用的UI组件—以及可组合性—将这些组件拼接成复杂的UI。每个SwiftUI视图都是一种结构体，这是一种轻量级的数据类型，非常适合用来描述UI组件。这与UIKit的类和对象相比，可以显著提高性能，特别是在用户界面需要快速重建时。</p>\n<p>此外，SwiftUI的视图可以包含其他视图，这就为开发者提供了极大的灵活性来构建复杂的用户界面。例如，可以创建一个自定义的按钮样式，然后在不同的地方多次使用，而无需重写样式代码。</p>\n<p><strong>一致性和跨平台设计</strong></p>\n<p>SwiftUI的一个显著特点是其跨平台能力。相同的SwiftUI代码可以运行在iOS、macOS、watchOS和tvOS上，无需做出太多修改。这种一致性意味着开发者可以为所有Apple平台构建统一的应用体验，同时允许针对特定平台的优化。</p>\n<p>跨平台设计的好处是显而易见的。开发者可以集中精力于创建出色的用户体验，而不是花费时间在适配不同平台的布局和控件上。SwiftUI通过提供一致的API和控件集，确保了界面在各个设备上都能保持良好的交互和视觉效果。</p>\n<p><strong>数据驱动的UI更新</strong></p>\n<p>SwiftUI的另一个核心特性是数据驱动的UI更新。这意味着UI的状态可以被绑定到应用程序的数据模型上，当数据变化时，UI会自动更新。这种绑定使用了Swift的属性包装器如<code>@State</code>和<code>@Binding</code>，它们提供了一种声明性的方式来定义视图的源数据。</p>\n<p>以一个简单的文本输入为例，在UIKit中，您可能需要实现委托模式来响应文本变化，然后手动更新UI。而在SwiftUI中，您可以这样做：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ContentView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> userName: <span class=\"hljs-type\">String</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;&quot;</span><br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span><br><br> &#123;<br>        <span class=\"hljs-type\">TextField</span>(<span class=\"hljs-string\">&quot;请输入用户名&quot;</span>, text: <span class=\"hljs-variable\">$userName</span>)<br>        <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;您好，<span class=\"hljs-subst\">\\(userName)</span>!&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在这个例子中，<code>TextField</code>的文本被绑定到<code>userName</code>状态上。当用户在文本字段中输入时，<code>userName</code>会自动更新，而且相关的<code>Text</code>视图也会即时反映这个变化。</p>\n<p><strong>总结</strong></p>\n<p>SwiftUI的设计哲学是为了提高开发效率、改善代码质量，并使应用能够快速适应未来的变化。通过其声明性语法、组件化和可组合性、一致性以及数据驱动的UI更新，SwiftUI为现代应用开发树立了新的标准。接下来，我们将进一步探讨SwiftUI是如何实现这些设计理念的，并通过实例展示这些概念在实际开发中的应用。</p>\n<p><strong>2. SwiftUI的架构</strong></p>\n<p>SwiftUI是构建在一系列高效且现代的编程模式和原则之上的，它不仅简化了用户界面的创建，而且通过其独特的架构提升了应用性能和开发效率。在本节中，我们将深入了解构成SwiftUI架构的各个部分，以及它们如何协同工作以创建流畅且动态的用户界面。</p>\n<p><strong>视图层次结构与组件</strong></p>\n<p>在SwiftUI中，一切都是视图。从文本标签(<code>Text</code>)到按钮(<code>Button</code>)，再到整个屏幕(<code>ContentView</code>)，所有的UI组件都是视图。SwiftUI使用一种结构体(<code>struct</code>)来定义视图，这是一个轻量级的数据类型，非常适合描述UI组件。每个视图都知道如何绘制自己，并能定义自己的布局。</p>\n<p>一个关键概念是视图的层次结构，它表示视图的嵌套。父视图可以包含多个子视图，创建出丰富的布局。SwiftUI使用声明性的方法来组织视图层次，这意味着您声明界面应该如何组织，而不是编写代码来动态创建和管理视图对象。</p>\n<p><strong>布局系统</strong></p>\n<p>SwiftUI的布局系统是自适应和响应式的，允许视图以一种非常自然的方式响应外部条件的变化，如设备的屏幕大小或者设备方向。布局是由视图本身以及环境(<code>Environment</code>)中的信息决定的。每个视图提供了一个<code>body</code>属性，描述了其子视图的布局。</p>\n<p>SwiftUI的<code>Stack</code>、<code>List</code>、<code>Grid</code>等布局容器帮助您定义强大而灵活的布局。例如，一个<code>VStack</code>会垂直堆叠其子视图，而一个<code>HStack</code>则会水平堆叠。每个容器都可以包含其他容器，从而创建复杂且响应式的布局结构。</p>\n<p><strong>数据流和绑定</strong></p>\n<p>SwiftUI的架构旨在促进数据流的清晰和一致。它通过使用一系列属性包装器来实现，如<code>@State</code>、<code>@Binding</code>、<code>@ObservedObject</code>和<code>@EnvironmentObject</code>。这些属性包装器提供了不同层级的数据流和状态管理，确保视图与数据保持同步。</p>\n<p><code>@State</code>是一种私有的、视图内的状态管理，用于存储视图的本地数据。<code>@Binding</code>则创建了一个可读写的连接到另一个视图持有的<code>@State</code>的连接，从而允许数据在不同视图间共享。</p>\n<p>对于更复杂的数据管理，<code>@ObservedObject</code>和<code>@EnvironmentObject</code>使得视图能够订阅外部的数据模型。当数据模型标记为<code>ObservableObject</code>并且其内部的数据通过<code>@Published</code>包装器进行更改时，订阅这些模型的视图会自动更新。</p>\n<p><strong>声明性渲染</strong></p>\n<p>SwiftUI的架构在内部使用了一种高效的声明性渲染引擎，它能够智能地重绘改变了的部分而非整个界面。这是通过比较视图的当前状态和新的声明来实现的。当状态发生变化时，SwiftUI计算出最小的差异，并且只更新需要改变的部分。</p>\n<p>这种智能重绘是非常重要的，因为它意味着视图的更新可以非常快速，并且能保持性能，即使在复杂的界面和动画中也是如此。</p>\n<p><strong>Swift与SwiftUI的紧密集成</strong></p>\n<p>SwiftUI与Swift编程语言的紧密集成提供了许多编程上的好处。利用Swift的强类型系统、函数式编程特性和高级语言构造，SwiftUI可以确保代码安全、清晰且易于理解。</p>\n<p>SwiftUI的一切，从其布局系统到与Combine框架的集成，都是为了简化编程模型，允许开发者以一种更直观和高效的方式来构建用户界面。</p>\n<p><strong>总结</strong></p>\n<p>SwiftUI的架构是其强大功能和易用性的基石。通过视图层次结构、响应式布局系统、清晰的数据流和绑定以及高效的声明性渲染，SwiftUI提供了一个坚实的基础来构建现代的跨平台应用。了解这些概念对于充分利用SwiftUI的潜力是至关重要的。在本书的后续章节中，我们将进一步深入探讨每个概念，并通过具体的代码示例来展示它们在实际开发中的应用。</p>\n<p><strong>3. MVVM设计模式在SwiftUI中的应用</strong></p>\n<p>在现代应用开发中，架构模式的选择对于确保代码的可读性、可维护性和可扩展性至关重要。Model-View-ViewModel (MVVM) 是一种被广泛采用的设计模式，尤其是在SwiftUI中，它提供了一种清晰地分离用户界面和业务逻辑的方式。本节将探讨MVVM设计模式，并详细说明它如何在SwiftUI中得到应用。</p>\n<p><strong>MVVM的核心概念</strong></p>\n<p>MVVM设计模式将应用分为三个主要组件：Model、View和ViewModel。</p>\n<ul>\n<li><strong>Model</strong> - 表示应用的数据和业务逻辑。它是纯粹的Swift类或结构体，不含任何UI代码。</li>\n<li><strong>View</strong> - 显示应用的用户界面。在SwiftUI中，所有的UI组件都是视图，从单个按钮到整个屏幕。</li>\n<li><strong>ViewModel</strong> - 作为Model和View之间的桥梁。它包含了展示逻辑，但不包含业务逻辑或者状态管理的代码。</li>\n</ul>\n<p>MVVM通过这种分离，确保了UI代码的简洁性，并允许业务逻辑独立于UI，使其更易于测试和重用。</p>\n<p><strong>ViewModel在SwiftUI中的角色</strong></p>\n<p>在SwiftUI中，ViewModel通常是一个符合<code>ObservableObject</code>协议的Swift类。它会暴露出用于UI显示的数据，并将用户的交互转化为模型更新和视图的状态更改。</p>\n<p>例如，如果您有一个任务列表应用，ViewModel可能包含一个任务数组的状态以及添加新任务的方法。当用户通过界面添加任务时，ViewModel会更新Model，并通知View重新渲染以显示新任务。</p>\n<p><strong>数据绑定和状态管理</strong></p>\n<p>SwiftUI的数据绑定特性与MVVM的配合尤其紧密。使用<code>@Published</code>属性包装器，ViewModel可以提供可观察的数据属性，当这些属性的值变化时，关联的视图可以自动更新。</p>\n<p>此外，SwiftUI的状态管理属性包装器，如<code>@State</code>、<code>@Binding</code>、<code>@StateObject</code>和<code>@EnvironmentObject</code>，进一步简化了ViewModel与View之间数据和状态的同步。</p>\n<p><strong>MVVM的实际应用</strong></p>\n<p>在SwiftUI应用中实施MVVM时，ViewModel的职责包括：</p>\n<ul>\n<li>提供视图所需的数据。</li>\n<li>响应用户输入并更新Model。</li>\n<li>监控Model的变化并通知View更新。</li>\n<li>处理导航和视图间的协调逻辑。</li>\n</ul>\n<p>由于SwiftUI的视图是声明性的，ViewModel成为控制视图状态的中心。开发者不再需要写大量的引导代码来手动更新UI，而是可以依靠SwiftUI的绑定机制和ViewModel来自动处理。</p>\n<p><strong>总结</strong></p>\n<p>MVVM设计模式在SwiftUI中的应用为创建结构化和高效的应用程序提供了框架。通过将业务逻辑移至ViewModel，并利用SwiftUI的响应式数据绑定，开发者能够创建更清晰、更易于维护和扩展的代码。在本书接下来的章节中，我们将通过具体示例深入探讨MVVM模式在SwiftUI应用开发中的具体实现和最佳实践。</p>\n<p><strong>第2章：Swift语言回顾</strong></p>\n<p><strong>1. Swift基础</strong></p>\n<p>Swift 是由苹果公司开发的一种强大的编程语言，旨在为开发者提供一种简单、清晰且高效的语言工具。它既适合新手学习编程，也足以满足专业开发者构建复杂应用的需求。在本节中，我们将回顾Swift语言的基础，为深入学习SwiftUI打下坚实的基础。</p>\n<p><strong>变量和常量</strong></p>\n<p>Swift 使用 <code>var</code> 关键字来声明变量，<code>let</code> 关键字来声明常量。变量是可以被赋予不同值的标识符，而常量一旦设定初始值后则不能更改。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">var</span> greeting <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;Hello, world!&quot;</span><br><span class=\"hljs-keyword\">let</span> pi <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">3.14159</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>数据类型</strong></p>\n<p>Swift 是一种类型安全的语言，这意味着每个变量都有一个明确的类型。Swift 的基本数据类型包括 <code>Int</code>、<code>Float</code>、<code>Double</code>、<code>Bool</code>、<code>String</code> 等。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">var</span> age: <span class=\"hljs-type\">Int</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">30</span><br><span class=\"hljs-keyword\">var</span> price: <span class=\"hljs-type\">Double</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">29.99</span><br><span class=\"hljs-keyword\">var</span> isHidden: <span class=\"hljs-type\">Bool</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">false</span><br><span class=\"hljs-keyword\">var</span> name: <span class=\"hljs-type\">String</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;John Doe&quot;</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>控制流</strong></p>\n<p>Swift 提供了丰富的控制流结构，包括 <code>if</code>、<code>else</code> 条件语句，<code>switch</code> 语句，以及 <code>for-in</code>、<code>while</code> 和 <code>repeat-while</code> 循环。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">if</span> age <span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-number\">18</span> &#123;<br>    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;Adult&quot;</span>)<br>&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;Minor&quot;</span>)<br>&#125;<br><br><span class=\"hljs-keyword\">for</span> index <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">1</span><span class=\"hljs-operator\">...</span><span class=\"hljs-number\">5</span> &#123;<br>    <span class=\"hljs-built_in\">print</span>(index)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>函数</strong></p>\n<p>函数是执行特定任务的自包含代码块。Swift 的函数使用 <code>func</code> 关键字声明，可以接受参数和返回值。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">greet</span>(<span class=\"hljs-params\">person</span>: <span class=\"hljs-type\">String</span>) -&gt; <span class=\"hljs-type\">String</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;Hello, <span class=\"hljs-subst\">\\(person)</span>!&quot;</span><br>&#125;<br><span class=\"hljs-built_in\">print</span>(greet(person: <span class=\"hljs-string\">&quot;Anna&quot;</span>)) <span class=\"hljs-comment\">// Prints &quot;Hello, Anna!&quot;</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>闭包</strong></p>\n<p>闭包是可以在代码中被传递和使用的自包含功能块，类似于其他语言中的匿名函数。闭包捕获并存储它们的上下文中的任何常量和变量的引用。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">let</span> names <span class=\"hljs-operator\">=</span> [<span class=\"hljs-string\">&quot;Chris&quot;</span>, <span class=\"hljs-string\">&quot;Alex&quot;</span>, <span class=\"hljs-string\">&quot;Ewa&quot;</span>, <span class=\"hljs-string\">&quot;Barry&quot;</span>, <span class=\"hljs-string\">&quot;Daniella&quot;</span>]<br><span class=\"hljs-keyword\">var</span> reversedNames <span class=\"hljs-operator\">=</span> names.sorted(by: &#123; <span class=\"hljs-variable\">$0</span> <span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-variable\">$1</span> &#125;)<br></code></pre></td></tr></table></figure>\n\n<p><strong>结构体和类</strong></p>\n<p>Swift 中的结构体和类是构建代码的基本构件。结构体是值类型，而类是引用类型。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Point</span> &#123;<br>    <span class=\"hljs-keyword\">var</span> x: <span class=\"hljs-type\">Int</span><br>    <span class=\"hljs-keyword\">var</span> y: <span class=\"hljs-type\">Int</span><br>&#125;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Vehicle</span> &#123;<br>    <span class=\"hljs-keyword\">var</span> numberOfWheels <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span><br>    <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">description</span>() -&gt; <span class=\"hljs-type\">String</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;<span class=\"hljs-subst\">\\(numberOfWheels)</span> wheel(s)&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>属性和方法</strong></p>\n<p>属性用于存储值，方法用于添加特定的行为。计算属性则提供了一种自定义的 getter 和 setter 来间接获取和设置其他属性或变量的值。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Circle</span> &#123;<br>    <span class=\"hljs-keyword\">var</span> radius: <span class=\"hljs-type\">Double</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span><br>    <span class=\"hljs-keyword\">var</span> circumference: <span class=\"hljs-type\">Double</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> pi <span class=\"hljs-operator\">*</span> radius <span class=\"hljs-operator\">*</span> <span class=\"hljs-number\">2</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>协议和扩展</strong></p>\n<p>协议定义了一组方法和属性的蓝图，类、结构体和枚举可以实现这些协议。扩展则允许你为现有的类型添加新的功能。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">protocol</span> <span class=\"hljs-title class_\">Identifiable</span> &#123;<br>    <span class=\"hljs-keyword\">var</span> id: <span class=\"hljs-type\">String</span> &#123; <span class=\"hljs-keyword\">get</span> <span class=\"hljs-keyword\">set</span> &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">extension</span> <span class=\"hljs-title class_\">String</span> &#123;<br>    <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">capitalizedFirst</span>() -&gt; <span class=\"hljs-type\">String</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">prefix</span>(<span class=\"hljs-number\">1</span>).uppercased() <span class=\"hljs-operator\">+</span> <span class=\"hljs-keyword\">self</span>.lowercased().dropFirst()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>错误处理</strong></p>\n<p>Swift 中的错误处理允许你表示并处理程序执行中可能遇到的错误条件。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title class_\">PrinterError</span>: <span class=\"hljs-title class_\">Error</span> &#123;<br>    <span class=\"hljs-keyword\">case</span> outOfPaper<br>    <span class=\"hljs-keyword\">case</span> noToner<br>    <span class=\"hljs-keyword\">case</span> onFire<br>&#125;<br><br><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">send</span>(<span class=\"hljs-params\">job</span>: <span class=\"hljs-type\">Int</span>, <span class=\"hljs-params\">toPrinter</span> <span class=\"hljs-params\">printerName</span>: <span class=\"hljs-type\">String</span>) <span class=\"hljs-keyword\">throws</span> -&gt; <span class=\"hljs-type\">String</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> printerName <span class=\"hljs-operator\">==</span> <span class=\"hljs-string\">&quot;Never Has Toner&quot;</span> &#123;<br>        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-type\">PrinterError</span>.noToner<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;Job sent&quot;</span><br><br><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>泛型</strong></p>\n<p>泛型允许你写出灵活、可重用的函数和类型，它们可以工作于任何类型。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">swapTwoValues</span>&lt;<span class=\"hljs-type\">T</span>&gt;(<span class=\"hljs-keyword\">_</span> <span class=\"hljs-params\">a</span>: <span class=\"hljs-keyword\">inout</span> <span class=\"hljs-type\">T</span>, <span class=\"hljs-keyword\">_</span> <span class=\"hljs-params\">b</span>: <span class=\"hljs-keyword\">inout</span> <span class=\"hljs-type\">T</span>) &#123;<br>    <span class=\"hljs-keyword\">let</span> temporaryA <span class=\"hljs-operator\">=</span> a<br>    a <span class=\"hljs-operator\">=</span> b<br>    b <span class=\"hljs-operator\">=</span> temporaryA<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>总结</strong></p>\n<p>这些是Swift语言的一些核心概念，掌握它们对于理解SwiftUI的工作方式至关重要。Swift的这些特性提供了构建SwiftUI应用所需的工具和构建块，接下来的章节中我们将看到这些基础如何在实际的SwiftUI编程中得到应用。</p>\n<p><strong>2. 面向协议编程</strong></p>\n<p>面向协议编程（Protocol-Oriented Programming，POP）是Swift语言的一个核心范式。与面向对象编程（Object-Oriented Programming，OOP）关注在类和继承上构建程序的层次结构不同，POP倡导通过定义协议并将它们实现于类、结构体或枚举来构建程序的行为和形态。在本节中，我们将探讨POP的基础，以及如何在Swift中应用这个强大的编程范式。</p>\n<p><strong>协议的定义</strong></p>\n<p>协议定义了一套蓝图，规定了采纳协议的类型必须实现哪些方法和属性。协议可以被类、结构体或枚举类型采纳，以提供所需的实现。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">protocol</span> <span class=\"hljs-title class_\">Identifiable</span> &#123;<br>    <span class=\"hljs-keyword\">var</span> id: <span class=\"hljs-type\">String</span> &#123; <span class=\"hljs-keyword\">get</span> <span class=\"hljs-keyword\">set</span> &#125;<br>    <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">identify</span>()<br>&#125;<br><br><span class=\"hljs-keyword\">extension</span> <span class=\"hljs-title class_\">Identifiable</span> &#123;<br>    <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">identify</span>() &#123;<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;My ID is <span class=\"hljs-subst\">\\(id)</span>.&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在上述例子中，任何采纳<code>Identifiable</code>协议的类型都必须有一个<code>id</code>属性，并且默认提供了一个<code>identify</code>方法的实现。</p>\n<p><strong>面向协议的优势</strong></p>\n<ul>\n<li><strong>复用性</strong>：通过定义协议，您可以创建可在多种类型间复用的方法和属性。</li>\n<li><strong>松耦合</strong>：类型之间的依赖性降低，因为它们依赖于协议，而不是具体的实现。</li>\n<li><strong>灵活性</strong>：可以为不同的类型添加协议扩展，为它们提供特定的功能，而无需修改原有类型代码。</li>\n<li><strong>适应性</strong>：类型可以同时采纳多个协议，易于适配和扩展。</li>\n</ul>\n<p><strong>使用协议定义行为</strong></p>\n<p>一个典型的POP实践是定义一系列协议来代表应用的不同部分可以共享的行为，而不是创建基类。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">protocol</span> <span class=\"hljs-title class_\">Flyable</span> &#123;<br>    <span class=\"hljs-keyword\">var</span> airspeedVelocity: <span class=\"hljs-type\">Double</span> &#123; <span class=\"hljs-keyword\">get</span> &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">protocol</span> <span class=\"hljs-title class_\">Feasible</span> &#123;<br>    <span class=\"hljs-keyword\">var</span> isFeasible: <span class=\"hljs-type\">Bool</span> &#123; <span class=\"hljs-keyword\">get</span> &#125;<br>&#125;<br><br><span class=\"hljs-comment\">// 现在，任何类型都可以采纳Flyable和Feasible协议，不仅限于某个类的子类。</span><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Bird</span>: <span class=\"hljs-title class_\">Flyable</span>, <span class=\"hljs-title class_\">Feasible</span> &#123;<br>    <span class=\"hljs-keyword\">var</span> airspeedVelocity: <span class=\"hljs-type\">Double</span><br>    <span class=\"hljs-keyword\">var</span> isFeasible: <span class=\"hljs-type\">Bool</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>在扩展中采纳协议</strong></p>\n<p>Swift允许在类型的扩展中采纳协议。这意味着即使是先前定义好的类型，也可以被增强来采纳新的协议。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">extension</span> <span class=\"hljs-title class_\">Array</span>: <span class=\"hljs-title class_\">Identifiable</span> <span class=\"hljs-title class_\">where</span> <span class=\"hljs-title class_\">Element</span>: <span class=\"hljs-title class_\">Identifiable</span> &#123;<br>    <span class=\"hljs-keyword\">var</span> id: <span class=\"hljs-type\">String</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">self</span>.map &#123; <span class=\"hljs-variable\">$0</span>.id &#125;.joined(separator: <span class=\"hljs-string\">&quot;, &quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这里，只要数组的元素采纳了<code>Identifiable</code>协议，数组本身就自动采纳了<code>Identifiable</code>。</p>\n<p><strong>关联类型</strong></p>\n<p>协议可以具有关联类型，这是一种未被指定的类型占位符，其具体类型将由协议的采纳者提供。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">protocol</span> <span class=\"hljs-title class_\">Container</span> &#123;<br>    <span class=\"hljs-keyword\">associatedtype</span> <span class=\"hljs-type\">Item</span><br>    <span class=\"hljs-keyword\">mutating</span> <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">append</span>(<span class=\"hljs-keyword\">_</span> <span class=\"hljs-params\">item</span>: <span class=\"hljs-type\">Item</span>)<br>    <span class=\"hljs-keyword\">var</span> count: <span class=\"hljs-type\">Int</span> &#123; <span class=\"hljs-keyword\">get</span> &#125;<br>    <span class=\"hljs-keyword\">subscript</span>(<span class=\"hljs-params\">i</span>: <span class=\"hljs-type\">Int</span>) -&gt; <span class=\"hljs-type\">Item</span> &#123; <span class=\"hljs-keyword\">get</span> &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">IntStack</span>: <span class=\"hljs-title class_\">Container</span> &#123;<br>    <span class=\"hljs-comment\">// 实现Container协议的要求</span><br>    <span class=\"hljs-keyword\">typealias</span> <span class=\"hljs-type\">Item</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">Int</span><br>    <span class=\"hljs-comment\">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>关联类型增加了协议的灵活性，使其可以被不同的类型以不同的方式采纳。</p>\n<p><strong>总结</strong></p>\n<p>面向协议编程是Swift语言的一个核心原则，它鼓励开发者通过协议来定义接口和行为，而不是传统的继承。这样的方法为代码提供了更高的复用性和灵活性，也更加</p>\n<p>安全。在SwiftUI中，您会发现许多UI组件都是基于协议来构建的，这使得自定义和扩展UI变得十分方便和高效。通过本节的学习，您应该对如何使用面向协议编程来构建更强大、更模块化的Swift应用有了更深刻的理解。</p>\n<p><strong>3. Swift中的函数式编程特性</strong></p>\n<p>函数式编程是一种编程范式，它将计算视为数学函数的评估，并避免状态以及可变数据。Swift虽然不是一个纯函数式编程语言，但它融合了许多函数式编程的特性。这些特性可以帮助开发者编写更简洁、更易于理解的代码。在本节中，我们将探索Swift中的函数式编程特性及其在实际编程中的应用。</p>\n<p><strong>不可变性</strong></p>\n<p>在函数式编程中，不可变性是一个核心概念。不可变的数据可以避免副作用和状态变化，这使得程序更容易理解和调试。在Swift中，使用<code>let</code>关键字声明的常量是不可变的。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">let</span> constantArray <span class=\"hljs-operator\">=</span> [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]<br><span class=\"hljs-comment\">// constantArray[0] = 4 // 这行代码将导致编译错误，因为数组是不可变的</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>一等函数</strong></p>\n<p>Swift将函数作为一等公民，这意味着函数可以作为其他函数的参数传递，也可以作为函数的返回值，还可以赋值给变量。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">add</span>(<span class=\"hljs-keyword\">_</span> <span class=\"hljs-params\">a</span>: <span class=\"hljs-type\">Int</span>, <span class=\"hljs-keyword\">_</span> <span class=\"hljs-params\">b</span>: <span class=\"hljs-type\">Int</span>) -&gt; <span class=\"hljs-type\">Int</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> a <span class=\"hljs-operator\">+</span> b<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> mathFunction: (<span class=\"hljs-type\">Int</span>, <span class=\"hljs-type\">Int</span>) -&gt; <span class=\"hljs-type\">Int</span> <span class=\"hljs-operator\">=</span> add<br><span class=\"hljs-built_in\">print</span>(mathFunction(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>)) <span class=\"hljs-comment\">// 输出 5</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>高阶函数</strong></p>\n<p>Swift标准库中提供了多种高阶函数，如<code>map</code>、<code>filter</code>、<code>reduce</code>等，这些函数都可以接受一个函数作为输入。</p>\n<ul>\n<li><code>map</code> 用于将集合中的每个元素通过特定的方法进行转换。</li>\n<li><code>filter</code> 用于选择集合中符合特定条件的元素。</li>\n<li><code>reduce</code> 用于将集合中的元素合并成一个单一的值。</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">let</span> numbers <span class=\"hljs-operator\">=</span> [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>]<br><span class=\"hljs-keyword\">let</span> squaredNumbers <span class=\"hljs-operator\">=</span> numbers.map &#123; <span class=\"hljs-variable\">$0</span> <span class=\"hljs-operator\">*</span> <span class=\"hljs-variable\">$0</span> &#125; <span class=\"hljs-comment\">// [1, 4, 9, 16, 25]</span><br><span class=\"hljs-keyword\">let</span> evenNumbers <span class=\"hljs-operator\">=</span> numbers.filter &#123; <span class=\"hljs-variable\">$0</span> <span class=\"hljs-operator\">%</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-operator\">==</span> <span class=\"hljs-number\">0</span> &#125; <span class=\"hljs-comment\">// [2, 4]</span><br><span class=\"hljs-keyword\">let</span> sumOfNumbers <span class=\"hljs-operator\">=</span> numbers.reduce(<span class=\"hljs-number\">0</span>, <span class=\"hljs-operator\">+</span>) <span class=\"hljs-comment\">// 15</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>闭包</strong></p>\n<p>闭包是自包含的函数代码块，可以在代码中传递和使用。它们尤其适用于函数式编程，因为它们可以捕获和存储任何它们所在上下文中的常量和变量的引用。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">let</span> names <span class=\"hljs-operator\">=</span> [<span class=\"hljs-string\">&quot;Chris&quot;</span>, <span class=\"hljs-string\">&quot;Alex&quot;</span>, <span class=\"hljs-string\">&quot;Ewa&quot;</span>, <span class=\"hljs-string\">&quot;Barry&quot;</span>, <span class=\"hljs-string\">&quot;Daniella&quot;</span>]<br><span class=\"hljs-keyword\">let</span> reversedNames <span class=\"hljs-operator\">=</span> names.sorted(by: &#123; s1, s2 <span class=\"hljs-keyword\">in</span> <span class=\"hljs-keyword\">return</span> s1 <span class=\"hljs-operator\">&gt;</span> s2 &#125;)<br></code></pre></td></tr></table></figure>\n\n<p><strong>柯里化（Currying）</strong></p>\n<p>柯里化是函数式编程中的一个概念，指的是将一个接受多个参数的函数转换成一系列只接受单一参数的函数。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">add</span>(<span class=\"hljs-keyword\">_</span> <span class=\"hljs-params\">a</span>: <span class=\"hljs-type\">Int</span>) -&gt; (<span class=\"hljs-type\">Int</span>) -&gt; <span class=\"hljs-type\">Int</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> &#123; b <span class=\"hljs-keyword\">in</span> <span class=\"hljs-keyword\">return</span> a <span class=\"hljs-operator\">+</span> b &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">let</span> addTwo <span class=\"hljs-operator\">=</span> add(<span class=\"hljs-number\">2</span>)<br><span class=\"hljs-keyword\">let</span> result <span class=\"hljs-operator\">=</span> addTwo(<span class=\"hljs-number\">3</span>) <span class=\"hljs-comment\">// 5</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>惰性求值（Lazy Evaluation）</strong></p>\n<p>Swift中的序列和集合提供了惰性求值的选项，这意味着只有在需要计算值的时候才会进行计算。这可以提高程序的性能，特别是在处理大型数据集时。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">let</span> data <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1</span><span class=\"hljs-operator\">...</span><span class=\"hljs-number\">1000</span><br><span class=\"hljs-keyword\">let</span> result <span class=\"hljs-operator\">=</span> data.lazy.filter &#123; <span class=\"hljs-variable\">$0</span> <span class=\"hljs-operator\">%</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-operator\">==</span> <span class=\"hljs-number\">0</span> &#125;.map &#123; <span class=\"hljs-variable\">$0</span> <span class=\"hljs-operator\">*</span> <span class=\"hljs-number\">2</span> &#125;<br><span class=\"hljs-comment\">// result 的计算将会被延迟，直到实际被需要</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>总结</strong></p>\n<p>Swift的函数式编程特性能够帮助开发者写出更加清晰、简洁和可维护的代码。通过利用不可变性、高阶函数、闭</p>\n<p>包等特性，Swift开发者可以编写出更加表达力强、逻辑清晰的代码。在SwiftUI开发中，这些特性被广泛应用，以实现数据和UI的高效绑定和操作。掌握这些函数式编程的概念将在接下来的章节中帮助读者更好地理解SwiftUI的设计和实现方式。</p>\n"},{"title":"SwiftUI中的模态视图","date":"2023-11-07T13:09:46.000Z","_content":"在 SwiftUI 中，通常我们提到“模态”时，指的是一个全屏或部分屏幕的视图，它会暂时中断用户的当前工作流程以获取用户的注意和交互。在 SwiftUI 中，没有直接命名为 `Modal` 的控件，但模态行为可以通过多种方式实现，如 `sheet`、`fullScreenCover` 以及 `popover`（在 iPad 上）。下面将介绍如何实现模态行为的几种方法。\n\n### 使用 `sheet` 展示模态视图\n\n`sheet` 修饰符可以用来展示一个模态视图，这个视图会覆盖在当前视图的上方，并带有一个背景遮罩。用户必须明确地关闭模态视图才能返回到原始视图。\n\n```swift\nstruct ContentView: View {\n    @State private var showingSheet = false\n\n    var body: some View {\n        Button(\"Show Sheet\") {\n            showingSheet = true\n        }\n        .sheet(isPresented: $showingSheet) {\n            // Sheet的内容\n            ModalContentView()\n        }\n    }\n}\n\nstruct ModalContentView: View {\n    var body: some View {\n        Text(\"This is a modal view.\")\n    }\n}\n```\n\n### 使用 `fullScreenCover` 展示模态视图\n\n`fullScreenCover` 类似于 `sheet`，但是会覆盖整个屏幕，为模态视图提供了更多的空间。\n\n```swift\nstruct ContentView: View {\n    @State private var showingFullScreenModal = false\n\n    var body: some View {\n        Button(\"Show Full-Screen Modal\") {\n            showingFullScreenModal = true\n        }\n        .fullScreenCover(isPresented: $showingFullScreenModal) {\n            FullScreenModalView()\n        }\n    }\n}\n\nstruct FullScreenModalView: View {\n    @Environment(\\.presentationMode) var presentationMode\n\n    var body: some View {\n        Button(\"Dismiss\") {\n            presentationMode.wrappedValue.dismiss()\n        }\n    }\n}\n```\n\n### 使用 `popover` 展示模态视图（仅限 iPad）\n\nPopover 在 iPad 上提供了另一种模态体验，它显示一个浮动的视图，不会覆盖整个屏幕，允许用户在不完全离开当前上下文的情况下与 popover 互动。\n\n```swift\nstruct ContentView: View {\n    @State private var showingPopover = false\n\n    var body: some View {\n        Button(\"Show Popover\") {\n            showingPopover = true\n        }\n        .popover(isPresented: $showingPopover) {\n            Text(\"Popover content here\")\n        }\n    }\n}\n```\n\n### 使用 `NavigationLink` 或 `@State` 和 `@Binding` 触发模态视图\n\n在某些情况下，你可能需要通过更传统的方式来显示一个模态视图，例如使用 `NavigationLink` 或通过程序化地控制视图的显示。\n\n```swift\nstruct ContentView: View {\n    @State private var isModalPresented = false\n\n    var body: some View {\n        Button(action: {\n            isModalPresented = true\n        }) {\n            Text(\"Show Modal\")\n        }\n        .background(\n            NavigationLink(destination: ModalView(), isActive: $isModalPresented) {\n                EmptyView()\n            }\n            .hidden()\n        )\n    }\n}\n\nstruct ModalView: View {\n    var body: some View {\n        Text(\"This is a modal view presented via NavigationLink.\")\n    }\n}\n```\n\n在 SwiftUI 中，这些模态呈现方法都是通过声明式的 API 来控制，使状态变化与视图更新之间保持同步。你需要根据你的应用设计需求来选择使用哪种模态展示方式。","source":"_posts/SwiftUI中的模态视图.md","raw":"---\ntitle: SwiftUI中的模态视图\ndate: 2023-11-07 21:09:46\ncategories:\n- SwiftUI\ntags:\n---\n在 SwiftUI 中，通常我们提到“模态”时，指的是一个全屏或部分屏幕的视图，它会暂时中断用户的当前工作流程以获取用户的注意和交互。在 SwiftUI 中，没有直接命名为 `Modal` 的控件，但模态行为可以通过多种方式实现，如 `sheet`、`fullScreenCover` 以及 `popover`（在 iPad 上）。下面将介绍如何实现模态行为的几种方法。\n\n### 使用 `sheet` 展示模态视图\n\n`sheet` 修饰符可以用来展示一个模态视图，这个视图会覆盖在当前视图的上方，并带有一个背景遮罩。用户必须明确地关闭模态视图才能返回到原始视图。\n\n```swift\nstruct ContentView: View {\n    @State private var showingSheet = false\n\n    var body: some View {\n        Button(\"Show Sheet\") {\n            showingSheet = true\n        }\n        .sheet(isPresented: $showingSheet) {\n            // Sheet的内容\n            ModalContentView()\n        }\n    }\n}\n\nstruct ModalContentView: View {\n    var body: some View {\n        Text(\"This is a modal view.\")\n    }\n}\n```\n\n### 使用 `fullScreenCover` 展示模态视图\n\n`fullScreenCover` 类似于 `sheet`，但是会覆盖整个屏幕，为模态视图提供了更多的空间。\n\n```swift\nstruct ContentView: View {\n    @State private var showingFullScreenModal = false\n\n    var body: some View {\n        Button(\"Show Full-Screen Modal\") {\n            showingFullScreenModal = true\n        }\n        .fullScreenCover(isPresented: $showingFullScreenModal) {\n            FullScreenModalView()\n        }\n    }\n}\n\nstruct FullScreenModalView: View {\n    @Environment(\\.presentationMode) var presentationMode\n\n    var body: some View {\n        Button(\"Dismiss\") {\n            presentationMode.wrappedValue.dismiss()\n        }\n    }\n}\n```\n\n### 使用 `popover` 展示模态视图（仅限 iPad）\n\nPopover 在 iPad 上提供了另一种模态体验，它显示一个浮动的视图，不会覆盖整个屏幕，允许用户在不完全离开当前上下文的情况下与 popover 互动。\n\n```swift\nstruct ContentView: View {\n    @State private var showingPopover = false\n\n    var body: some View {\n        Button(\"Show Popover\") {\n            showingPopover = true\n        }\n        .popover(isPresented: $showingPopover) {\n            Text(\"Popover content here\")\n        }\n    }\n}\n```\n\n### 使用 `NavigationLink` 或 `@State` 和 `@Binding` 触发模态视图\n\n在某些情况下，你可能需要通过更传统的方式来显示一个模态视图，例如使用 `NavigationLink` 或通过程序化地控制视图的显示。\n\n```swift\nstruct ContentView: View {\n    @State private var isModalPresented = false\n\n    var body: some View {\n        Button(action: {\n            isModalPresented = true\n        }) {\n            Text(\"Show Modal\")\n        }\n        .background(\n            NavigationLink(destination: ModalView(), isActive: $isModalPresented) {\n                EmptyView()\n            }\n            .hidden()\n        )\n    }\n}\n\nstruct ModalView: View {\n    var body: some View {\n        Text(\"This is a modal view presented via NavigationLink.\")\n    }\n}\n```\n\n在 SwiftUI 中，这些模态呈现方法都是通过声明式的 API 来控制，使状态变化与视图更新之间保持同步。你需要根据你的应用设计需求来选择使用哪种模态展示方式。","slug":"SwiftUI中的模态视图","published":1,"updated":"2024-03-17T06:12:27.923Z","comments":1,"layout":"post","photos":[],"_id":"clu6up53h001yz67456ks293i","content":"<p>在 SwiftUI 中，通常我们提到“模态”时，指的是一个全屏或部分屏幕的视图，它会暂时中断用户的当前工作流程以获取用户的注意和交互。在 SwiftUI 中，没有直接命名为 <code>Modal</code> 的控件，但模态行为可以通过多种方式实现，如 <code>sheet</code>、<code>fullScreenCover</code> 以及 <code>popover</code>（在 iPad 上）。下面将介绍如何实现模态行为的几种方法。</p>\n<h3 id=\"使用-sheet-展示模态视图\"><a href=\"#使用-sheet-展示模态视图\" class=\"headerlink\" title=\"使用 sheet 展示模态视图\"></a>使用 <code>sheet</code> 展示模态视图</h3><p><code>sheet</code> 修饰符可以用来展示一个模态视图，这个视图会覆盖在当前视图的上方，并带有一个背景遮罩。用户必须明确地关闭模态视图才能返回到原始视图。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ContentView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> showingSheet <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">false</span><br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">Button</span>(<span class=\"hljs-string\">&quot;Show Sheet&quot;</span>) &#123;<br>            showingSheet <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">true</span><br>        &#125;<br>        .sheet(isPresented: <span class=\"hljs-variable\">$showingSheet</span>) &#123;<br>            <span class=\"hljs-comment\">// Sheet的内容</span><br>            <span class=\"hljs-type\">ModalContentView</span>()<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ModalContentView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;This is a modal view.&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"使用-fullScreenCover-展示模态视图\"><a href=\"#使用-fullScreenCover-展示模态视图\" class=\"headerlink\" title=\"使用 fullScreenCover 展示模态视图\"></a>使用 <code>fullScreenCover</code> 展示模态视图</h3><p><code>fullScreenCover</code> 类似于 <code>sheet</code>，但是会覆盖整个屏幕，为模态视图提供了更多的空间。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ContentView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> showingFullScreenModal <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">false</span><br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">Button</span>(<span class=\"hljs-string\">&quot;Show Full-Screen Modal&quot;</span>) &#123;<br>            showingFullScreenModal <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">true</span><br>        &#125;<br>        .fullScreenCover(isPresented: <span class=\"hljs-variable\">$showingFullScreenModal</span>) &#123;<br>            <span class=\"hljs-type\">FullScreenModalView</span>()<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">FullScreenModalView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@Environment</span>(\\.presentationMode) <span class=\"hljs-keyword\">var</span> presentationMode<br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">Button</span>(<span class=\"hljs-string\">&quot;Dismiss&quot;</span>) &#123;<br>            presentationMode.wrappedValue.dismiss()<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"使用-popover-展示模态视图（仅限-iPad）\"><a href=\"#使用-popover-展示模态视图（仅限-iPad）\" class=\"headerlink\" title=\"使用 popover 展示模态视图（仅限 iPad）\"></a>使用 <code>popover</code> 展示模态视图（仅限 iPad）</h3><p>Popover 在 iPad 上提供了另一种模态体验，它显示一个浮动的视图，不会覆盖整个屏幕，允许用户在不完全离开当前上下文的情况下与 popover 互动。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ContentView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> showingPopover <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">false</span><br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">Button</span>(<span class=\"hljs-string\">&quot;Show Popover&quot;</span>) &#123;<br>            showingPopover <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">true</span><br>        &#125;<br>        .popover(isPresented: <span class=\"hljs-variable\">$showingPopover</span>) &#123;<br>            <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Popover content here&quot;</span>)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"使用-NavigationLink-或-State-和-Binding-触发模态视图\"><a href=\"#使用-NavigationLink-或-State-和-Binding-触发模态视图\" class=\"headerlink\" title=\"使用 NavigationLink 或 @State 和 @Binding 触发模态视图\"></a>使用 <code>NavigationLink</code> 或 <code>@State</code> 和 <code>@Binding</code> 触发模态视图</h3><p>在某些情况下，你可能需要通过更传统的方式来显示一个模态视图，例如使用 <code>NavigationLink</code> 或通过程序化地控制视图的显示。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ContentView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> isModalPresented <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">false</span><br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">Button</span>(action: &#123;<br>            isModalPresented <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">true</span><br>        &#125;) &#123;<br>            <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Show Modal&quot;</span>)<br>        &#125;<br>        .background(<br>            <span class=\"hljs-type\">NavigationLink</span>(destination: <span class=\"hljs-type\">ModalView</span>(), isActive: <span class=\"hljs-variable\">$isModalPresented</span>) &#123;<br>                <span class=\"hljs-type\">EmptyView</span>()<br>            &#125;<br>            .hidden()<br>        )<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ModalView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;This is a modal view presented via NavigationLink.&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在 SwiftUI 中，这些模态呈现方法都是通过声明式的 API 来控制，使状态变化与视图更新之间保持同步。你需要根据你的应用设计需求来选择使用哪种模态展示方式。</p>\n","excerpt":"","more":"<p>在 SwiftUI 中，通常我们提到“模态”时，指的是一个全屏或部分屏幕的视图，它会暂时中断用户的当前工作流程以获取用户的注意和交互。在 SwiftUI 中，没有直接命名为 <code>Modal</code> 的控件，但模态行为可以通过多种方式实现，如 <code>sheet</code>、<code>fullScreenCover</code> 以及 <code>popover</code>（在 iPad 上）。下面将介绍如何实现模态行为的几种方法。</p>\n<h3 id=\"使用-sheet-展示模态视图\"><a href=\"#使用-sheet-展示模态视图\" class=\"headerlink\" title=\"使用 sheet 展示模态视图\"></a>使用 <code>sheet</code> 展示模态视图</h3><p><code>sheet</code> 修饰符可以用来展示一个模态视图，这个视图会覆盖在当前视图的上方，并带有一个背景遮罩。用户必须明确地关闭模态视图才能返回到原始视图。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ContentView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> showingSheet <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">false</span><br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">Button</span>(<span class=\"hljs-string\">&quot;Show Sheet&quot;</span>) &#123;<br>            showingSheet <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">true</span><br>        &#125;<br>        .sheet(isPresented: <span class=\"hljs-variable\">$showingSheet</span>) &#123;<br>            <span class=\"hljs-comment\">// Sheet的内容</span><br>            <span class=\"hljs-type\">ModalContentView</span>()<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ModalContentView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;This is a modal view.&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"使用-fullScreenCover-展示模态视图\"><a href=\"#使用-fullScreenCover-展示模态视图\" class=\"headerlink\" title=\"使用 fullScreenCover 展示模态视图\"></a>使用 <code>fullScreenCover</code> 展示模态视图</h3><p><code>fullScreenCover</code> 类似于 <code>sheet</code>，但是会覆盖整个屏幕，为模态视图提供了更多的空间。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ContentView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> showingFullScreenModal <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">false</span><br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">Button</span>(<span class=\"hljs-string\">&quot;Show Full-Screen Modal&quot;</span>) &#123;<br>            showingFullScreenModal <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">true</span><br>        &#125;<br>        .fullScreenCover(isPresented: <span class=\"hljs-variable\">$showingFullScreenModal</span>) &#123;<br>            <span class=\"hljs-type\">FullScreenModalView</span>()<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">FullScreenModalView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@Environment</span>(\\.presentationMode) <span class=\"hljs-keyword\">var</span> presentationMode<br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">Button</span>(<span class=\"hljs-string\">&quot;Dismiss&quot;</span>) &#123;<br>            presentationMode.wrappedValue.dismiss()<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"使用-popover-展示模态视图（仅限-iPad）\"><a href=\"#使用-popover-展示模态视图（仅限-iPad）\" class=\"headerlink\" title=\"使用 popover 展示模态视图（仅限 iPad）\"></a>使用 <code>popover</code> 展示模态视图（仅限 iPad）</h3><p>Popover 在 iPad 上提供了另一种模态体验，它显示一个浮动的视图，不会覆盖整个屏幕，允许用户在不完全离开当前上下文的情况下与 popover 互动。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ContentView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> showingPopover <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">false</span><br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">Button</span>(<span class=\"hljs-string\">&quot;Show Popover&quot;</span>) &#123;<br>            showingPopover <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">true</span><br>        &#125;<br>        .popover(isPresented: <span class=\"hljs-variable\">$showingPopover</span>) &#123;<br>            <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Popover content here&quot;</span>)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"使用-NavigationLink-或-State-和-Binding-触发模态视图\"><a href=\"#使用-NavigationLink-或-State-和-Binding-触发模态视图\" class=\"headerlink\" title=\"使用 NavigationLink 或 @State 和 @Binding 触发模态视图\"></a>使用 <code>NavigationLink</code> 或 <code>@State</code> 和 <code>@Binding</code> 触发模态视图</h3><p>在某些情况下，你可能需要通过更传统的方式来显示一个模态视图，例如使用 <code>NavigationLink</code> 或通过程序化地控制视图的显示。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ContentView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> isModalPresented <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">false</span><br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">Button</span>(action: &#123;<br>            isModalPresented <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">true</span><br>        &#125;) &#123;<br>            <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Show Modal&quot;</span>)<br>        &#125;<br>        .background(<br>            <span class=\"hljs-type\">NavigationLink</span>(destination: <span class=\"hljs-type\">ModalView</span>(), isActive: <span class=\"hljs-variable\">$isModalPresented</span>) &#123;<br>                <span class=\"hljs-type\">EmptyView</span>()<br>            &#125;<br>            .hidden()<br>        )<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ModalView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;This is a modal view presented via NavigationLink.&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在 SwiftUI 中，这些模态呈现方法都是通过声明式的 API 来控制，使状态变化与视图更新之间保持同步。你需要根据你的应用设计需求来选择使用哪种模态展示方式。</p>\n"},{"title":"SwiftUI核心技术4章视图与控件","date":"2023-11-07T16:35:47.000Z","_content":"**第二部分：构建用户界面**\n\n**第4章：视图与控件**\n\n**1. Text和Image**\n\n在SwiftUI中，用户界面是由各种视图组成的，其中最基本的两种视图是`Text`和`Image`。本节将详细探讨如何使用这两种视图来显示文本和图像。\n\n**Text**\n\n`Text`视图用于在应用中显示一行或多行只读文本。它是最常见的视图之一，因为文本是用户交互的基本元素。\n\n**基础用法**\n\n创建一个`Text`视图非常简单，只需要传入一个字符串即可：\n\n```swift\nText(\"Hello, SwiftUI!\")\n```\n\n**样式定制**\n\n`Text`视图提供了多种修饰符来定制文本的显示方式：\n\n- `.font(_:)`：设置字体样式。\n- `.fontWeight(_:)`：设置字体的粗细。\n- `.foregroundColor(_:)`：设置文本颜色。\n- `.lineLimit(_:)`：设置最多显示行数。\n- `.multilineTextAlignment(_:)`：设置多行文本的对齐方式。\n- `.padding(_:)`：为文本周围添加填充。\n\n例如，要创建一个居中对齐、蓝色、加粗的文本，您可以这样写：\n\n```swift\nText(\"Welcome to SwiftUI\")\n    .font(.headline)\n    .fontWeight(.bold)\n    .foregroundColor(.blue)\n    .multilineTextAlignment(.center)\n    .padding()\n```\n\n**国际化和本地化**\n\nSwiftUI还支持文本的国际化和本地化。使用`LocalizedStringKey`初始化`Text`视图，可以确保文本根据用户的设备语言环境显示正确：\n\n```swift\nText(LocalizedStringKey(\"hello_message\"))\n```\n\n**Image**\n\n`Image`视图用于在应用中显示图像。您可以从应用的资产目录、文件系统或网络加载图像。\n\n**从资产目录加载**\n\n最常用的加载图像方式是从Xcode项目的Assets.xcassets目录：\n\n```swift\nImage(\"myImage\")\n```\n\n**图像修饰符**\n\n`Image`视图也可以使用多种修饰符来调整显示的图像：\n\n- `.resizable()`：允许图像根据视图的大小进行拉伸或压缩。\n- `.aspectRatio(_:_:)`：设置图像的宽高比。\n- `.clipShape(_:)`：剪切图像到特定的形状。\n- `.shadow(_:)`：为图像添加阴影。\n\n例如，要创建一个圆形、有阴影的图像，您可以这样写：\n\n```swift\nImage(\"profile_pic\")\n    .resizable()\n    .aspectRatio(contentMode: .fill)\n    .frame(width: 100, height: 100)\n    .clipShape(Circle())\n    .shadow(radius: 10)\n```\n\n**加载和显示网络图像**\n\n要显示来自网络的图像，您通常需要使用SwiftUI的`AsyncImage`视图或结合URLSession自定义一个加载器。由于本节重点是`Image`视图，我们将在后续章节详细探讨如何加载网络图像。\n\n**总结**\n\n`Text`和`Image`是构建SwiftUI应用界面时最基础的元素。它们不仅用法简单，而且通过修饰符提供了强大的样式定制能力。通过合理使用这两种视图，您可以快速构建出丰富多彩且吸引人的界面。接下来的小节，我们将进一步探索SwiftUI中其他重要的视图和控件。\n\n\n**2. Buttons和Toggle**\n\n在SwiftUI中，`Button`和`Toggle`是两种用于用户交互的基本控件。它们使应用可以响应用户的操作，执行任务或更改状态。\n\n**Button**\n\n按钮是用户界面的基本组件，用于响应用户的点击或触摸操作。\n\n**创建按钮**\n\n在SwiftUI中，创建一个按钮需要提供一个动作和一个如何显示的内容：\n\n```swift\nButton(action: {\n    // 在这里执行按钮的动作\n    print(\"按钮被点击\")\n}) {\n    // 提供按钮的内容\n    Text(\"点击我\")\n}\n```\n\n**按钮样式**\n\n您可以使用修饰符来定制按钮的样式。例如，给按钮添加边框、背景色等：\n\n```swift\nButton(\"点击我\") {\n    print(\"按钮被点击\")\n}\n.frame(width: 200, height: 60)\n.background(Color.blue)\n.foregroundColor(.white)\n.cornerRadius(10)\n.padding()\n```\n\nSwiftUI还提供了`buttonStyle(_:)`修饰符来应用预定义的按钮样式。\n\n**Toggle**\n\n`Toggle`是一个开关控件，用于表示和改变一个布尔值的状态。\n\n**创建Toggle**\n\n创建一个`Toggle`同样需要一个绑定的状态和一个显示的标签：\n\n```swift\n@State private var isOn = false\n\nvar body: some View {\n    Toggle(isOn: $isOn) {\n        Text(\"切换状态\")\n    }\n}\n```\n\n在上面的代码中，`isOn`是一个`@State`属性，这意味着它是一个可变状态，当`Toggle`被切换时，视图会自动更新。\n\n**定制Toggle**\n\n可以使用`.toggleStyle(_:)`修饰符来定制`Toggle`的外观。SwiftUI提供了一些内建的样式，如`SwitchToggleStyle`和`CheckboxToggleStyle`（后者在macOS上可用）。\n\n**绑定和控制**\n\n按钮和开关的强大之处在于它们与SwiftUI的数据绑定系统的整合。当您使用`$`前缀创建绑定时，UI 控件将能够直接修改数据，反之亦然。这是SwiftUI声明式编程范式的核心。\n\n**响应用户输入**\n\n通常，按钮和开关会更改应用的状态或触发某个操作。例如，您可能会根据开关的状态显示或隐藏文本视图：\n\n```swift\n@State private var isAccepted = false\n\nvar body: some View {\n    VStack {\n        Toggle(isOn: $isAccepted) {\n            Text(\"接受条款和条件\")\n        }\n\n        Button(\"继续\") {\n            // 可以在这里校验开关状态，例如是否接受了条款和条件\n            proceedWithAction()\n        }\n        .disabled(!isAccepted) // 当不接受条款时禁用按钮\n    }\n}\n```\n\n**总结**\n\n按钮和开关是任何交互式应用程序的基础，它们提供了一种简单有效的方式来收集用户输入并作出反应。SwiftUI的`Button`和`Toggle`视图配合数据绑定，使得创建动态和响应式的用户界面变得异常简单。它们的样式和行为可以通过一系列的修饰符进行定制，以适应您的设计需求。在接下来的小节中，我们将继续探讨如何使用SwiftUI构建更复杂的用户界面元素。\n\n\n**3. TextField和Slider**\n\n在SwiftUI中，创建交互式表单和控制元素是构建现代应用程序不可或缺的一部分。`TextField`和`Slider`是两种常用的控件，它们允许用户输入文本和选择值的范围。\n\n**TextField**\n\n`TextField`是一个用于用户输入文本的控件，它可以接受键盘输入，并且可以对输入的文本进行格式化和校验。\n\n**创建TextField**\n\n创建一个`TextField`通常需要两个参数：一个标签和一个绑定到文本值的变量。\n\n```swift\n@State private var username: String = \"\"\n\nvar body: some View {\n    TextField(\"用户名\", text: $username)\n}\n```\n\n在这个例子中，每当用户在文本字段中输入时，`username`变量都会更新。`@State`属性包装器用于在本地视图状态中存储可变数据。\n\n**定制TextField**\n\n您可以使用修饰符来定制`TextField`的外观和行为，例如设置字体、颜色、对齐方式、键盘类型等。\n\n```swift\nTextField(\"用户名\", text: $username)\n    .textFieldStyle(RoundedBorderTextFieldStyle())\n    .padding()\n    .keyboardType(.default)\n    .autocapitalization(.none)\n    .disableAutocorrection(true)\n```\n\n在这个例子中，我们使用了`textFieldStyle(_:)`来为文本字段设置圆角边框样式，并进行了一些其他的配置。\n\n**Slider**\n\n`Slider`允许用户从一个范围内选择一个值。它可以用于设置音量、选择亮度或应用任何其他需要用户选择一个数值的场景。\n\n**创建Slider**\n\n创建`Slider`至少需要一个绑定到数值的变量和一个值的范围。\n\n```swift\n@State private var sliderValue: Double = 0.5\n\nvar body: some View {\n    Slider(value: $sliderValue, in: 0...1)\n}\n```\n\n这个`Slider`允许用户在0到1之间选择一个值。\n\n**定制Slider**\n\n`Slider`同样可以使用修饰符进行外观和功能的定制。您可以设置步长，决定滑块在变化时是否持续触发更新，以及添加标签。\n\n```swift\nSlider(\n    value: $sliderValue,\n    in: 0...1,\n    step: 0.1,\n    onEditingChanged: { editing in\n        // editing 是一个布尔值，表示是否正在编辑\n        print(\"当前滑块的值：\\(sliderValue)\")\n    }\n)\n.accentColor(.green)\n```\n\n在这个例子中，滑块的步长设置为0.1，且我们还指定了一个闭包，在用户编辑滑块值时触发。\n\n**总结**\n\n`TextField`和`Slider`为SwiftUI应用提供了基本的用户输入功能。通过与`@State`或其他形式的状态管理相结合，它们为开发者提供了创建动态和响应式表单的能力。定制这些控件的外观和行为使它们能够匹配应用程序的设计语言，提供更好的用户体验。在接下来的章节中，我们将探索SwiftUI中的其他高级控件和视图，并学习如何将它们组合在一起以构建复杂和功能丰富的用户界面。\n\n\n**4. 自定义视图和控件**\n\nSwiftUI的真正魅力之一在于它为开发者提供了丰富的自定义视图和控件的能力。通过结合现有的视图和控件以及Swift语言的强大特性，我们可以创建完全定制的用户界面元素，以完美地适应我们的设计需求。\n\n**理解视图的组合**\n\n在SwiftUI中，最基本的自定义视图起始于现有的视图的组合。SwiftUI的视图是可组合的，意味着你可以将简单的视图组合成复杂的视图。比如，我们可以创建一个带有文本和图像的自定义按钮视图：\n\n```swift\nstruct CustomButton: View {\n    var body: some View {\n        HStack {\n            Image(systemName: \"star.fill\")\n                .resizable()\n                .frame(width: 20, height: 20)\n            Text(\"收藏\")\n        }\n        .padding()\n        .background(Color.blue)\n        .foregroundColor(.white)\n        .cornerRadius(10)\n    }\n}\n```\n\n这个`CustomButton`就是一个自定义视图，它可以在任何其他的SwiftUI视图中使用。\n\n**创建完全自定义的视图**\n\n如果需要更高级的自定义，你可以从`View`协议开始，实现自己的`body`属性。这允许你控制视图的渲染方式，并响应用户的输入。\n\n```swift\nstruct CircularProgressView: View {\n    var progress: Double // 从0.0到1.0\n    \n    var body: some View {\n        ZStack {\n            Circle()\n                .stroke(lineWidth: 20)\n                .opacity(0.3)\n                .foregroundColor(Color.blue)\n            \n            Circle()\n                .trim(from: 0.0, to: CGFloat(min(self.progress, 1.0)))\n                .stroke(style: StrokeStyle(lineWidth: 20, lineCap: .round, lineJoin: .round))\n                .foregroundColor(Color.blue)\n                .rotationEffect(Angle(degrees: 270.0))\n                .animation(.linear)\n        }\n    }\n}\n```\n\n在这个例子中，我们创建了一个显示进度的环形视图，它会根据`progress`属性显示不同的填充量。\n\n**响应用户交互**\n\n自定义视图可以通过各种手势识别器来响应用户的交互。例如，你可能会有一个自定义滑块控件，它通过拖动来改变值：\n\n```swift\nstruct CustomSlider: View {\n    @Binding var value: Double // 绑定到外部状态\n    \n    var body: some View {\n        GeometryReader { geometry in\n            Rectangle()\n                .foregroundColor(.gray)\n                .frame(height: 20)\n                .gesture(\n                    DragGesture(minimumDistance: 0)\n                        .onChanged { gesture in\n                            self.value = Double(gesture.location.x / geometry.size.width)\n                        }\n                )\n        }\n    }\n}\n```\n\n在这个例子中，我们使用`GeometryReader`来获取视图的大小，并根据用户拖动的位置来更新`value`。\n\n**保持性能**\n\n在创建自定义视图和控件时，要记住保持它们的性能。这意味着：\n\n- 避免不必要的视图重绘和状态更新。\n- 合理使用`.animation()`和`.transition()`修饰符来为视图变化提供流畅的过渡效果。\n- 当视图层次变得复杂时，考虑使用`drawingGroup()`或`cache`等优化技术。\n\n**总结**\n\nSwiftUI提供了强大的工具集，可以帮助开发者创建精美且功能丰富的自定义视图和控件。通过结合视图的组合、自定义绘制、响应用户输入等技术，你可以创建出完全符合你的设计和功能需求的用户界面元素。记住，自定义视图和控件不仅仅是关于创造外观，更重要的是它们提供了\n\n与用户交互的新方式。随着你的SwiftUI技能的提高，你将能够更有效地利用这些工具，打造出既美观又高效的应用程序。\n","source":"_posts/SwiftUI核心技术4章视图与控件.md","raw":"---\ntitle: SwiftUI核心技术4章视图与控件\ndate: 2023-11-08 00:35:47\ncategories:\n- SwiftUI\ntags:\n---\n**第二部分：构建用户界面**\n\n**第4章：视图与控件**\n\n**1. Text和Image**\n\n在SwiftUI中，用户界面是由各种视图组成的，其中最基本的两种视图是`Text`和`Image`。本节将详细探讨如何使用这两种视图来显示文本和图像。\n\n**Text**\n\n`Text`视图用于在应用中显示一行或多行只读文本。它是最常见的视图之一，因为文本是用户交互的基本元素。\n\n**基础用法**\n\n创建一个`Text`视图非常简单，只需要传入一个字符串即可：\n\n```swift\nText(\"Hello, SwiftUI!\")\n```\n\n**样式定制**\n\n`Text`视图提供了多种修饰符来定制文本的显示方式：\n\n- `.font(_:)`：设置字体样式。\n- `.fontWeight(_:)`：设置字体的粗细。\n- `.foregroundColor(_:)`：设置文本颜色。\n- `.lineLimit(_:)`：设置最多显示行数。\n- `.multilineTextAlignment(_:)`：设置多行文本的对齐方式。\n- `.padding(_:)`：为文本周围添加填充。\n\n例如，要创建一个居中对齐、蓝色、加粗的文本，您可以这样写：\n\n```swift\nText(\"Welcome to SwiftUI\")\n    .font(.headline)\n    .fontWeight(.bold)\n    .foregroundColor(.blue)\n    .multilineTextAlignment(.center)\n    .padding()\n```\n\n**国际化和本地化**\n\nSwiftUI还支持文本的国际化和本地化。使用`LocalizedStringKey`初始化`Text`视图，可以确保文本根据用户的设备语言环境显示正确：\n\n```swift\nText(LocalizedStringKey(\"hello_message\"))\n```\n\n**Image**\n\n`Image`视图用于在应用中显示图像。您可以从应用的资产目录、文件系统或网络加载图像。\n\n**从资产目录加载**\n\n最常用的加载图像方式是从Xcode项目的Assets.xcassets目录：\n\n```swift\nImage(\"myImage\")\n```\n\n**图像修饰符**\n\n`Image`视图也可以使用多种修饰符来调整显示的图像：\n\n- `.resizable()`：允许图像根据视图的大小进行拉伸或压缩。\n- `.aspectRatio(_:_:)`：设置图像的宽高比。\n- `.clipShape(_:)`：剪切图像到特定的形状。\n- `.shadow(_:)`：为图像添加阴影。\n\n例如，要创建一个圆形、有阴影的图像，您可以这样写：\n\n```swift\nImage(\"profile_pic\")\n    .resizable()\n    .aspectRatio(contentMode: .fill)\n    .frame(width: 100, height: 100)\n    .clipShape(Circle())\n    .shadow(radius: 10)\n```\n\n**加载和显示网络图像**\n\n要显示来自网络的图像，您通常需要使用SwiftUI的`AsyncImage`视图或结合URLSession自定义一个加载器。由于本节重点是`Image`视图，我们将在后续章节详细探讨如何加载网络图像。\n\n**总结**\n\n`Text`和`Image`是构建SwiftUI应用界面时最基础的元素。它们不仅用法简单，而且通过修饰符提供了强大的样式定制能力。通过合理使用这两种视图，您可以快速构建出丰富多彩且吸引人的界面。接下来的小节，我们将进一步探索SwiftUI中其他重要的视图和控件。\n\n\n**2. Buttons和Toggle**\n\n在SwiftUI中，`Button`和`Toggle`是两种用于用户交互的基本控件。它们使应用可以响应用户的操作，执行任务或更改状态。\n\n**Button**\n\n按钮是用户界面的基本组件，用于响应用户的点击或触摸操作。\n\n**创建按钮**\n\n在SwiftUI中，创建一个按钮需要提供一个动作和一个如何显示的内容：\n\n```swift\nButton(action: {\n    // 在这里执行按钮的动作\n    print(\"按钮被点击\")\n}) {\n    // 提供按钮的内容\n    Text(\"点击我\")\n}\n```\n\n**按钮样式**\n\n您可以使用修饰符来定制按钮的样式。例如，给按钮添加边框、背景色等：\n\n```swift\nButton(\"点击我\") {\n    print(\"按钮被点击\")\n}\n.frame(width: 200, height: 60)\n.background(Color.blue)\n.foregroundColor(.white)\n.cornerRadius(10)\n.padding()\n```\n\nSwiftUI还提供了`buttonStyle(_:)`修饰符来应用预定义的按钮样式。\n\n**Toggle**\n\n`Toggle`是一个开关控件，用于表示和改变一个布尔值的状态。\n\n**创建Toggle**\n\n创建一个`Toggle`同样需要一个绑定的状态和一个显示的标签：\n\n```swift\n@State private var isOn = false\n\nvar body: some View {\n    Toggle(isOn: $isOn) {\n        Text(\"切换状态\")\n    }\n}\n```\n\n在上面的代码中，`isOn`是一个`@State`属性，这意味着它是一个可变状态，当`Toggle`被切换时，视图会自动更新。\n\n**定制Toggle**\n\n可以使用`.toggleStyle(_:)`修饰符来定制`Toggle`的外观。SwiftUI提供了一些内建的样式，如`SwitchToggleStyle`和`CheckboxToggleStyle`（后者在macOS上可用）。\n\n**绑定和控制**\n\n按钮和开关的强大之处在于它们与SwiftUI的数据绑定系统的整合。当您使用`$`前缀创建绑定时，UI 控件将能够直接修改数据，反之亦然。这是SwiftUI声明式编程范式的核心。\n\n**响应用户输入**\n\n通常，按钮和开关会更改应用的状态或触发某个操作。例如，您可能会根据开关的状态显示或隐藏文本视图：\n\n```swift\n@State private var isAccepted = false\n\nvar body: some View {\n    VStack {\n        Toggle(isOn: $isAccepted) {\n            Text(\"接受条款和条件\")\n        }\n\n        Button(\"继续\") {\n            // 可以在这里校验开关状态，例如是否接受了条款和条件\n            proceedWithAction()\n        }\n        .disabled(!isAccepted) // 当不接受条款时禁用按钮\n    }\n}\n```\n\n**总结**\n\n按钮和开关是任何交互式应用程序的基础，它们提供了一种简单有效的方式来收集用户输入并作出反应。SwiftUI的`Button`和`Toggle`视图配合数据绑定，使得创建动态和响应式的用户界面变得异常简单。它们的样式和行为可以通过一系列的修饰符进行定制，以适应您的设计需求。在接下来的小节中，我们将继续探讨如何使用SwiftUI构建更复杂的用户界面元素。\n\n\n**3. TextField和Slider**\n\n在SwiftUI中，创建交互式表单和控制元素是构建现代应用程序不可或缺的一部分。`TextField`和`Slider`是两种常用的控件，它们允许用户输入文本和选择值的范围。\n\n**TextField**\n\n`TextField`是一个用于用户输入文本的控件，它可以接受键盘输入，并且可以对输入的文本进行格式化和校验。\n\n**创建TextField**\n\n创建一个`TextField`通常需要两个参数：一个标签和一个绑定到文本值的变量。\n\n```swift\n@State private var username: String = \"\"\n\nvar body: some View {\n    TextField(\"用户名\", text: $username)\n}\n```\n\n在这个例子中，每当用户在文本字段中输入时，`username`变量都会更新。`@State`属性包装器用于在本地视图状态中存储可变数据。\n\n**定制TextField**\n\n您可以使用修饰符来定制`TextField`的外观和行为，例如设置字体、颜色、对齐方式、键盘类型等。\n\n```swift\nTextField(\"用户名\", text: $username)\n    .textFieldStyle(RoundedBorderTextFieldStyle())\n    .padding()\n    .keyboardType(.default)\n    .autocapitalization(.none)\n    .disableAutocorrection(true)\n```\n\n在这个例子中，我们使用了`textFieldStyle(_:)`来为文本字段设置圆角边框样式，并进行了一些其他的配置。\n\n**Slider**\n\n`Slider`允许用户从一个范围内选择一个值。它可以用于设置音量、选择亮度或应用任何其他需要用户选择一个数值的场景。\n\n**创建Slider**\n\n创建`Slider`至少需要一个绑定到数值的变量和一个值的范围。\n\n```swift\n@State private var sliderValue: Double = 0.5\n\nvar body: some View {\n    Slider(value: $sliderValue, in: 0...1)\n}\n```\n\n这个`Slider`允许用户在0到1之间选择一个值。\n\n**定制Slider**\n\n`Slider`同样可以使用修饰符进行外观和功能的定制。您可以设置步长，决定滑块在变化时是否持续触发更新，以及添加标签。\n\n```swift\nSlider(\n    value: $sliderValue,\n    in: 0...1,\n    step: 0.1,\n    onEditingChanged: { editing in\n        // editing 是一个布尔值，表示是否正在编辑\n        print(\"当前滑块的值：\\(sliderValue)\")\n    }\n)\n.accentColor(.green)\n```\n\n在这个例子中，滑块的步长设置为0.1，且我们还指定了一个闭包，在用户编辑滑块值时触发。\n\n**总结**\n\n`TextField`和`Slider`为SwiftUI应用提供了基本的用户输入功能。通过与`@State`或其他形式的状态管理相结合，它们为开发者提供了创建动态和响应式表单的能力。定制这些控件的外观和行为使它们能够匹配应用程序的设计语言，提供更好的用户体验。在接下来的章节中，我们将探索SwiftUI中的其他高级控件和视图，并学习如何将它们组合在一起以构建复杂和功能丰富的用户界面。\n\n\n**4. 自定义视图和控件**\n\nSwiftUI的真正魅力之一在于它为开发者提供了丰富的自定义视图和控件的能力。通过结合现有的视图和控件以及Swift语言的强大特性，我们可以创建完全定制的用户界面元素，以完美地适应我们的设计需求。\n\n**理解视图的组合**\n\n在SwiftUI中，最基本的自定义视图起始于现有的视图的组合。SwiftUI的视图是可组合的，意味着你可以将简单的视图组合成复杂的视图。比如，我们可以创建一个带有文本和图像的自定义按钮视图：\n\n```swift\nstruct CustomButton: View {\n    var body: some View {\n        HStack {\n            Image(systemName: \"star.fill\")\n                .resizable()\n                .frame(width: 20, height: 20)\n            Text(\"收藏\")\n        }\n        .padding()\n        .background(Color.blue)\n        .foregroundColor(.white)\n        .cornerRadius(10)\n    }\n}\n```\n\n这个`CustomButton`就是一个自定义视图，它可以在任何其他的SwiftUI视图中使用。\n\n**创建完全自定义的视图**\n\n如果需要更高级的自定义，你可以从`View`协议开始，实现自己的`body`属性。这允许你控制视图的渲染方式，并响应用户的输入。\n\n```swift\nstruct CircularProgressView: View {\n    var progress: Double // 从0.0到1.0\n    \n    var body: some View {\n        ZStack {\n            Circle()\n                .stroke(lineWidth: 20)\n                .opacity(0.3)\n                .foregroundColor(Color.blue)\n            \n            Circle()\n                .trim(from: 0.0, to: CGFloat(min(self.progress, 1.0)))\n                .stroke(style: StrokeStyle(lineWidth: 20, lineCap: .round, lineJoin: .round))\n                .foregroundColor(Color.blue)\n                .rotationEffect(Angle(degrees: 270.0))\n                .animation(.linear)\n        }\n    }\n}\n```\n\n在这个例子中，我们创建了一个显示进度的环形视图，它会根据`progress`属性显示不同的填充量。\n\n**响应用户交互**\n\n自定义视图可以通过各种手势识别器来响应用户的交互。例如，你可能会有一个自定义滑块控件，它通过拖动来改变值：\n\n```swift\nstruct CustomSlider: View {\n    @Binding var value: Double // 绑定到外部状态\n    \n    var body: some View {\n        GeometryReader { geometry in\n            Rectangle()\n                .foregroundColor(.gray)\n                .frame(height: 20)\n                .gesture(\n                    DragGesture(minimumDistance: 0)\n                        .onChanged { gesture in\n                            self.value = Double(gesture.location.x / geometry.size.width)\n                        }\n                )\n        }\n    }\n}\n```\n\n在这个例子中，我们使用`GeometryReader`来获取视图的大小，并根据用户拖动的位置来更新`value`。\n\n**保持性能**\n\n在创建自定义视图和控件时，要记住保持它们的性能。这意味着：\n\n- 避免不必要的视图重绘和状态更新。\n- 合理使用`.animation()`和`.transition()`修饰符来为视图变化提供流畅的过渡效果。\n- 当视图层次变得复杂时，考虑使用`drawingGroup()`或`cache`等优化技术。\n\n**总结**\n\nSwiftUI提供了强大的工具集，可以帮助开发者创建精美且功能丰富的自定义视图和控件。通过结合视图的组合、自定义绘制、响应用户输入等技术，你可以创建出完全符合你的设计和功能需求的用户界面元素。记住，自定义视图和控件不仅仅是关于创造外观，更重要的是它们提供了\n\n与用户交互的新方式。随着你的SwiftUI技能的提高，你将能够更有效地利用这些工具，打造出既美观又高效的应用程序。\n","slug":"SwiftUI核心技术4章视图与控件","published":1,"updated":"2024-03-17T06:11:08.769Z","comments":1,"layout":"post","photos":[],"_id":"clu6up53h0020z6740us1870t","content":"<p><strong>第二部分：构建用户界面</strong></p>\n<p><strong>第4章：视图与控件</strong></p>\n<p><strong>1. Text和Image</strong></p>\n<p>在SwiftUI中，用户界面是由各种视图组成的，其中最基本的两种视图是<code>Text</code>和<code>Image</code>。本节将详细探讨如何使用这两种视图来显示文本和图像。</p>\n<p><strong>Text</strong></p>\n<p><code>Text</code>视图用于在应用中显示一行或多行只读文本。它是最常见的视图之一，因为文本是用户交互的基本元素。</p>\n<p><strong>基础用法</strong></p>\n<p>创建一个<code>Text</code>视图非常简单，只需要传入一个字符串即可：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Hello, SwiftUI!&quot;</span>)<br></code></pre></td></tr></table></figure>\n\n<p><strong>样式定制</strong></p>\n<p><code>Text</code>视图提供了多种修饰符来定制文本的显示方式：</p>\n<ul>\n<li><code>.font(_:)</code>：设置字体样式。</li>\n<li><code>.fontWeight(_:)</code>：设置字体的粗细。</li>\n<li><code>.foregroundColor(_:)</code>：设置文本颜色。</li>\n<li><code>.lineLimit(_:)</code>：设置最多显示行数。</li>\n<li><code>.multilineTextAlignment(_:)</code>：设置多行文本的对齐方式。</li>\n<li><code>.padding(_:)</code>：为文本周围添加填充。</li>\n</ul>\n<p>例如，要创建一个居中对齐、蓝色、加粗的文本，您可以这样写：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Welcome to SwiftUI&quot;</span>)<br>    .font(.headline)<br>    .fontWeight(.bold)<br>    .foregroundColor(.blue)<br>    .multilineTextAlignment(.center)<br>    .padding()<br></code></pre></td></tr></table></figure>\n\n<p><strong>国际化和本地化</strong></p>\n<p>SwiftUI还支持文本的国际化和本地化。使用<code>LocalizedStringKey</code>初始化<code>Text</code>视图，可以确保文本根据用户的设备语言环境显示正确：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Text</span>(<span class=\"hljs-type\">LocalizedStringKey</span>(<span class=\"hljs-string\">&quot;hello_message&quot;</span>))<br></code></pre></td></tr></table></figure>\n\n<p><strong>Image</strong></p>\n<p><code>Image</code>视图用于在应用中显示图像。您可以从应用的资产目录、文件系统或网络加载图像。</p>\n<p><strong>从资产目录加载</strong></p>\n<p>最常用的加载图像方式是从Xcode项目的Assets.xcassets目录：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Image</span>(<span class=\"hljs-string\">&quot;myImage&quot;</span>)<br></code></pre></td></tr></table></figure>\n\n<p><strong>图像修饰符</strong></p>\n<p><code>Image</code>视图也可以使用多种修饰符来调整显示的图像：</p>\n<ul>\n<li><code>.resizable()</code>：允许图像根据视图的大小进行拉伸或压缩。</li>\n<li><code>.aspectRatio(_:_:)</code>：设置图像的宽高比。</li>\n<li><code>.clipShape(_:)</code>：剪切图像到特定的形状。</li>\n<li><code>.shadow(_:)</code>：为图像添加阴影。</li>\n</ul>\n<p>例如，要创建一个圆形、有阴影的图像，您可以这样写：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Image</span>(<span class=\"hljs-string\">&quot;profile_pic&quot;</span>)<br>    .resizable()<br>    .aspectRatio(contentMode: .fill)<br>    .frame(width: <span class=\"hljs-number\">100</span>, height: <span class=\"hljs-number\">100</span>)<br>    .clipShape(<span class=\"hljs-type\">Circle</span>())<br>    .shadow(radius: <span class=\"hljs-number\">10</span>)<br></code></pre></td></tr></table></figure>\n\n<p><strong>加载和显示网络图像</strong></p>\n<p>要显示来自网络的图像，您通常需要使用SwiftUI的<code>AsyncImage</code>视图或结合URLSession自定义一个加载器。由于本节重点是<code>Image</code>视图，我们将在后续章节详细探讨如何加载网络图像。</p>\n<p><strong>总结</strong></p>\n<p><code>Text</code>和<code>Image</code>是构建SwiftUI应用界面时最基础的元素。它们不仅用法简单，而且通过修饰符提供了强大的样式定制能力。通过合理使用这两种视图，您可以快速构建出丰富多彩且吸引人的界面。接下来的小节，我们将进一步探索SwiftUI中其他重要的视图和控件。</p>\n<p><strong>2. Buttons和Toggle</strong></p>\n<p>在SwiftUI中，<code>Button</code>和<code>Toggle</code>是两种用于用户交互的基本控件。它们使应用可以响应用户的操作，执行任务或更改状态。</p>\n<p><strong>Button</strong></p>\n<p>按钮是用户界面的基本组件，用于响应用户的点击或触摸操作。</p>\n<p><strong>创建按钮</strong></p>\n<p>在SwiftUI中，创建一个按钮需要提供一个动作和一个如何显示的内容：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Button</span>(action: &#123;<br>    <span class=\"hljs-comment\">// 在这里执行按钮的动作</span><br>    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;按钮被点击&quot;</span>)<br>&#125;) &#123;<br>    <span class=\"hljs-comment\">// 提供按钮的内容</span><br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;点击我&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>按钮样式</strong></p>\n<p>您可以使用修饰符来定制按钮的样式。例如，给按钮添加边框、背景色等：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Button</span>(<span class=\"hljs-string\">&quot;点击我&quot;</span>) &#123;<br>    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;按钮被点击&quot;</span>)<br>&#125;<br>.frame(width: <span class=\"hljs-number\">200</span>, height: <span class=\"hljs-number\">60</span>)<br>.background(<span class=\"hljs-type\">Color</span>.blue)<br>.foregroundColor(.white)<br>.cornerRadius(<span class=\"hljs-number\">10</span>)<br>.padding()<br></code></pre></td></tr></table></figure>\n\n<p>SwiftUI还提供了<code>buttonStyle(_:)</code>修饰符来应用预定义的按钮样式。</p>\n<p><strong>Toggle</strong></p>\n<p><code>Toggle</code>是一个开关控件，用于表示和改变一个布尔值的状态。</p>\n<p><strong>创建Toggle</strong></p>\n<p>创建一个<code>Toggle</code>同样需要一个绑定的状态和一个显示的标签：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> isOn <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">false</span><br><br><span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>    <span class=\"hljs-type\">Toggle</span>(isOn: <span class=\"hljs-variable\">$isOn</span>) &#123;<br>        <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;切换状态&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在上面的代码中，<code>isOn</code>是一个<code>@State</code>属性，这意味着它是一个可变状态，当<code>Toggle</code>被切换时，视图会自动更新。</p>\n<p><strong>定制Toggle</strong></p>\n<p>可以使用<code>.toggleStyle(_:)</code>修饰符来定制<code>Toggle</code>的外观。SwiftUI提供了一些内建的样式，如<code>SwitchToggleStyle</code>和<code>CheckboxToggleStyle</code>（后者在macOS上可用）。</p>\n<p><strong>绑定和控制</strong></p>\n<p>按钮和开关的强大之处在于它们与SwiftUI的数据绑定系统的整合。当您使用<code>$</code>前缀创建绑定时，UI 控件将能够直接修改数据，反之亦然。这是SwiftUI声明式编程范式的核心。</p>\n<p><strong>响应用户输入</strong></p>\n<p>通常，按钮和开关会更改应用的状态或触发某个操作。例如，您可能会根据开关的状态显示或隐藏文本视图：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> isAccepted <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">false</span><br><br><span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>    <span class=\"hljs-type\">VStack</span> &#123;<br>        <span class=\"hljs-type\">Toggle</span>(isOn: <span class=\"hljs-variable\">$isAccepted</span>) &#123;<br>            <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;接受条款和条件&quot;</span>)<br>        &#125;<br><br>        <span class=\"hljs-type\">Button</span>(<span class=\"hljs-string\">&quot;继续&quot;</span>) &#123;<br>            <span class=\"hljs-comment\">// 可以在这里校验开关状态，例如是否接受了条款和条件</span><br>            proceedWithAction()<br>        &#125;<br>        .disabled(<span class=\"hljs-operator\">!</span>isAccepted) <span class=\"hljs-comment\">// 当不接受条款时禁用按钮</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>总结</strong></p>\n<p>按钮和开关是任何交互式应用程序的基础，它们提供了一种简单有效的方式来收集用户输入并作出反应。SwiftUI的<code>Button</code>和<code>Toggle</code>视图配合数据绑定，使得创建动态和响应式的用户界面变得异常简单。它们的样式和行为可以通过一系列的修饰符进行定制，以适应您的设计需求。在接下来的小节中，我们将继续探讨如何使用SwiftUI构建更复杂的用户界面元素。</p>\n<p><strong>3. TextField和Slider</strong></p>\n<p>在SwiftUI中，创建交互式表单和控制元素是构建现代应用程序不可或缺的一部分。<code>TextField</code>和<code>Slider</code>是两种常用的控件，它们允许用户输入文本和选择值的范围。</p>\n<p><strong>TextField</strong></p>\n<p><code>TextField</code>是一个用于用户输入文本的控件，它可以接受键盘输入，并且可以对输入的文本进行格式化和校验。</p>\n<p><strong>创建TextField</strong></p>\n<p>创建一个<code>TextField</code>通常需要两个参数：一个标签和一个绑定到文本值的变量。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> username: <span class=\"hljs-type\">String</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;&quot;</span><br><br><span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>    <span class=\"hljs-type\">TextField</span>(<span class=\"hljs-string\">&quot;用户名&quot;</span>, text: <span class=\"hljs-variable\">$username</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在这个例子中，每当用户在文本字段中输入时，<code>username</code>变量都会更新。<code>@State</code>属性包装器用于在本地视图状态中存储可变数据。</p>\n<p><strong>定制TextField</strong></p>\n<p>您可以使用修饰符来定制<code>TextField</code>的外观和行为，例如设置字体、颜色、对齐方式、键盘类型等。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">TextField</span>(<span class=\"hljs-string\">&quot;用户名&quot;</span>, text: <span class=\"hljs-variable\">$username</span>)<br>    .textFieldStyle(<span class=\"hljs-type\">RoundedBorderTextFieldStyle</span>())<br>    .padding()<br>    .keyboardType(.default)<br>    .autocapitalization(.none)<br>    .disableAutocorrection(<span class=\"hljs-literal\">true</span>)<br></code></pre></td></tr></table></figure>\n\n<p>在这个例子中，我们使用了<code>textFieldStyle(_:)</code>来为文本字段设置圆角边框样式，并进行了一些其他的配置。</p>\n<p><strong>Slider</strong></p>\n<p><code>Slider</code>允许用户从一个范围内选择一个值。它可以用于设置音量、选择亮度或应用任何其他需要用户选择一个数值的场景。</p>\n<p><strong>创建Slider</strong></p>\n<p>创建<code>Slider</code>至少需要一个绑定到数值的变量和一个值的范围。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> sliderValue: <span class=\"hljs-type\">Double</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0.5</span><br><br><span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>    <span class=\"hljs-type\">Slider</span>(value: <span class=\"hljs-variable\">$sliderValue</span>, in: <span class=\"hljs-number\">0</span><span class=\"hljs-operator\">...</span><span class=\"hljs-number\">1</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这个<code>Slider</code>允许用户在0到1之间选择一个值。</p>\n<p><strong>定制Slider</strong></p>\n<p><code>Slider</code>同样可以使用修饰符进行外观和功能的定制。您可以设置步长，决定滑块在变化时是否持续触发更新，以及添加标签。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Slider</span>(<br>    value: <span class=\"hljs-variable\">$sliderValue</span>,<br>    in: <span class=\"hljs-number\">0</span><span class=\"hljs-operator\">...</span><span class=\"hljs-number\">1</span>,<br>    step: <span class=\"hljs-number\">0.1</span>,<br>    onEditingChanged: &#123; editing <span class=\"hljs-keyword\">in</span><br>        <span class=\"hljs-comment\">// editing 是一个布尔值，表示是否正在编辑</span><br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;当前滑块的值：<span class=\"hljs-subst\">\\(sliderValue)</span>&quot;</span>)<br>    &#125;<br>)<br>.accentColor(.green)<br></code></pre></td></tr></table></figure>\n\n<p>在这个例子中，滑块的步长设置为0.1，且我们还指定了一个闭包，在用户编辑滑块值时触发。</p>\n<p><strong>总结</strong></p>\n<p><code>TextField</code>和<code>Slider</code>为SwiftUI应用提供了基本的用户输入功能。通过与<code>@State</code>或其他形式的状态管理相结合，它们为开发者提供了创建动态和响应式表单的能力。定制这些控件的外观和行为使它们能够匹配应用程序的设计语言，提供更好的用户体验。在接下来的章节中，我们将探索SwiftUI中的其他高级控件和视图，并学习如何将它们组合在一起以构建复杂和功能丰富的用户界面。</p>\n<p><strong>4. 自定义视图和控件</strong></p>\n<p>SwiftUI的真正魅力之一在于它为开发者提供了丰富的自定义视图和控件的能力。通过结合现有的视图和控件以及Swift语言的强大特性，我们可以创建完全定制的用户界面元素，以完美地适应我们的设计需求。</p>\n<p><strong>理解视图的组合</strong></p>\n<p>在SwiftUI中，最基本的自定义视图起始于现有的视图的组合。SwiftUI的视图是可组合的，意味着你可以将简单的视图组合成复杂的视图。比如，我们可以创建一个带有文本和图像的自定义按钮视图：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">CustomButton</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">HStack</span> &#123;<br>            <span class=\"hljs-type\">Image</span>(systemName: <span class=\"hljs-string\">&quot;star.fill&quot;</span>)<br>                .resizable()<br>                .frame(width: <span class=\"hljs-number\">20</span>, height: <span class=\"hljs-number\">20</span>)<br>            <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;收藏&quot;</span>)<br>        &#125;<br>        .padding()<br>        .background(<span class=\"hljs-type\">Color</span>.blue)<br>        .foregroundColor(.white)<br>        .cornerRadius(<span class=\"hljs-number\">10</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这个<code>CustomButton</code>就是一个自定义视图，它可以在任何其他的SwiftUI视图中使用。</p>\n<p><strong>创建完全自定义的视图</strong></p>\n<p>如果需要更高级的自定义，你可以从<code>View</code>协议开始，实现自己的<code>body</code>属性。这允许你控制视图的渲染方式，并响应用户的输入。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">CircularProgressView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-keyword\">var</span> progress: <span class=\"hljs-type\">Double</span> <span class=\"hljs-comment\">// 从0.0到1.0</span><br>    <br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">ZStack</span> &#123;<br>            <span class=\"hljs-type\">Circle</span>()<br>                .stroke(lineWidth: <span class=\"hljs-number\">20</span>)<br>                .opacity(<span class=\"hljs-number\">0.3</span>)<br>                .foregroundColor(<span class=\"hljs-type\">Color</span>.blue)<br>            <br>            <span class=\"hljs-type\">Circle</span>()<br>                .trim(from: <span class=\"hljs-number\">0.0</span>, to: <span class=\"hljs-type\">CGFloat</span>(<span class=\"hljs-built_in\">min</span>(<span class=\"hljs-keyword\">self</span>.progress, <span class=\"hljs-number\">1.0</span>)))<br>                .stroke(style: <span class=\"hljs-type\">StrokeStyle</span>(lineWidth: <span class=\"hljs-number\">20</span>, lineCap: .round, lineJoin: .round))<br>                .foregroundColor(<span class=\"hljs-type\">Color</span>.blue)<br>                .rotationEffect(<span class=\"hljs-type\">Angle</span>(degrees: <span class=\"hljs-number\">270.0</span>))<br>                .animation(.linear)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在这个例子中，我们创建了一个显示进度的环形视图，它会根据<code>progress</code>属性显示不同的填充量。</p>\n<p><strong>响应用户交互</strong></p>\n<p>自定义视图可以通过各种手势识别器来响应用户的交互。例如，你可能会有一个自定义滑块控件，它通过拖动来改变值：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">CustomSlider</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@Binding</span> <span class=\"hljs-keyword\">var</span> value: <span class=\"hljs-type\">Double</span> <span class=\"hljs-comment\">// 绑定到外部状态</span><br>    <br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">GeometryReader</span> &#123; geometry <span class=\"hljs-keyword\">in</span><br>            <span class=\"hljs-type\">Rectangle</span>()<br>                .foregroundColor(.gray)<br>                .frame(height: <span class=\"hljs-number\">20</span>)<br>                .gesture(<br>                    <span class=\"hljs-type\">DragGesture</span>(minimumDistance: <span class=\"hljs-number\">0</span>)<br>                        .onChanged &#123; gesture <span class=\"hljs-keyword\">in</span><br>                            <span class=\"hljs-keyword\">self</span>.value <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">Double</span>(gesture.location.x <span class=\"hljs-operator\">/</span> geometry.size.width)<br>                        &#125;<br>                )<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在这个例子中，我们使用<code>GeometryReader</code>来获取视图的大小，并根据用户拖动的位置来更新<code>value</code>。</p>\n<p><strong>保持性能</strong></p>\n<p>在创建自定义视图和控件时，要记住保持它们的性能。这意味着：</p>\n<ul>\n<li>避免不必要的视图重绘和状态更新。</li>\n<li>合理使用<code>.animation()</code>和<code>.transition()</code>修饰符来为视图变化提供流畅的过渡效果。</li>\n<li>当视图层次变得复杂时，考虑使用<code>drawingGroup()</code>或<code>cache</code>等优化技术。</li>\n</ul>\n<p><strong>总结</strong></p>\n<p>SwiftUI提供了强大的工具集，可以帮助开发者创建精美且功能丰富的自定义视图和控件。通过结合视图的组合、自定义绘制、响应用户输入等技术，你可以创建出完全符合你的设计和功能需求的用户界面元素。记住，自定义视图和控件不仅仅是关于创造外观，更重要的是它们提供了</p>\n<p>与用户交互的新方式。随着你的SwiftUI技能的提高，你将能够更有效地利用这些工具，打造出既美观又高效的应用程序。</p>\n","excerpt":"","more":"<p><strong>第二部分：构建用户界面</strong></p>\n<p><strong>第4章：视图与控件</strong></p>\n<p><strong>1. Text和Image</strong></p>\n<p>在SwiftUI中，用户界面是由各种视图组成的，其中最基本的两种视图是<code>Text</code>和<code>Image</code>。本节将详细探讨如何使用这两种视图来显示文本和图像。</p>\n<p><strong>Text</strong></p>\n<p><code>Text</code>视图用于在应用中显示一行或多行只读文本。它是最常见的视图之一，因为文本是用户交互的基本元素。</p>\n<p><strong>基础用法</strong></p>\n<p>创建一个<code>Text</code>视图非常简单，只需要传入一个字符串即可：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Hello, SwiftUI!&quot;</span>)<br></code></pre></td></tr></table></figure>\n\n<p><strong>样式定制</strong></p>\n<p><code>Text</code>视图提供了多种修饰符来定制文本的显示方式：</p>\n<ul>\n<li><code>.font(_:)</code>：设置字体样式。</li>\n<li><code>.fontWeight(_:)</code>：设置字体的粗细。</li>\n<li><code>.foregroundColor(_:)</code>：设置文本颜色。</li>\n<li><code>.lineLimit(_:)</code>：设置最多显示行数。</li>\n<li><code>.multilineTextAlignment(_:)</code>：设置多行文本的对齐方式。</li>\n<li><code>.padding(_:)</code>：为文本周围添加填充。</li>\n</ul>\n<p>例如，要创建一个居中对齐、蓝色、加粗的文本，您可以这样写：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Welcome to SwiftUI&quot;</span>)<br>    .font(.headline)<br>    .fontWeight(.bold)<br>    .foregroundColor(.blue)<br>    .multilineTextAlignment(.center)<br>    .padding()<br></code></pre></td></tr></table></figure>\n\n<p><strong>国际化和本地化</strong></p>\n<p>SwiftUI还支持文本的国际化和本地化。使用<code>LocalizedStringKey</code>初始化<code>Text</code>视图，可以确保文本根据用户的设备语言环境显示正确：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Text</span>(<span class=\"hljs-type\">LocalizedStringKey</span>(<span class=\"hljs-string\">&quot;hello_message&quot;</span>))<br></code></pre></td></tr></table></figure>\n\n<p><strong>Image</strong></p>\n<p><code>Image</code>视图用于在应用中显示图像。您可以从应用的资产目录、文件系统或网络加载图像。</p>\n<p><strong>从资产目录加载</strong></p>\n<p>最常用的加载图像方式是从Xcode项目的Assets.xcassets目录：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Image</span>(<span class=\"hljs-string\">&quot;myImage&quot;</span>)<br></code></pre></td></tr></table></figure>\n\n<p><strong>图像修饰符</strong></p>\n<p><code>Image</code>视图也可以使用多种修饰符来调整显示的图像：</p>\n<ul>\n<li><code>.resizable()</code>：允许图像根据视图的大小进行拉伸或压缩。</li>\n<li><code>.aspectRatio(_:_:)</code>：设置图像的宽高比。</li>\n<li><code>.clipShape(_:)</code>：剪切图像到特定的形状。</li>\n<li><code>.shadow(_:)</code>：为图像添加阴影。</li>\n</ul>\n<p>例如，要创建一个圆形、有阴影的图像，您可以这样写：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Image</span>(<span class=\"hljs-string\">&quot;profile_pic&quot;</span>)<br>    .resizable()<br>    .aspectRatio(contentMode: .fill)<br>    .frame(width: <span class=\"hljs-number\">100</span>, height: <span class=\"hljs-number\">100</span>)<br>    .clipShape(<span class=\"hljs-type\">Circle</span>())<br>    .shadow(radius: <span class=\"hljs-number\">10</span>)<br></code></pre></td></tr></table></figure>\n\n<p><strong>加载和显示网络图像</strong></p>\n<p>要显示来自网络的图像，您通常需要使用SwiftUI的<code>AsyncImage</code>视图或结合URLSession自定义一个加载器。由于本节重点是<code>Image</code>视图，我们将在后续章节详细探讨如何加载网络图像。</p>\n<p><strong>总结</strong></p>\n<p><code>Text</code>和<code>Image</code>是构建SwiftUI应用界面时最基础的元素。它们不仅用法简单，而且通过修饰符提供了强大的样式定制能力。通过合理使用这两种视图，您可以快速构建出丰富多彩且吸引人的界面。接下来的小节，我们将进一步探索SwiftUI中其他重要的视图和控件。</p>\n<p><strong>2. Buttons和Toggle</strong></p>\n<p>在SwiftUI中，<code>Button</code>和<code>Toggle</code>是两种用于用户交互的基本控件。它们使应用可以响应用户的操作，执行任务或更改状态。</p>\n<p><strong>Button</strong></p>\n<p>按钮是用户界面的基本组件，用于响应用户的点击或触摸操作。</p>\n<p><strong>创建按钮</strong></p>\n<p>在SwiftUI中，创建一个按钮需要提供一个动作和一个如何显示的内容：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Button</span>(action: &#123;<br>    <span class=\"hljs-comment\">// 在这里执行按钮的动作</span><br>    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;按钮被点击&quot;</span>)<br>&#125;) &#123;<br>    <span class=\"hljs-comment\">// 提供按钮的内容</span><br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;点击我&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>按钮样式</strong></p>\n<p>您可以使用修饰符来定制按钮的样式。例如，给按钮添加边框、背景色等：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Button</span>(<span class=\"hljs-string\">&quot;点击我&quot;</span>) &#123;<br>    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;按钮被点击&quot;</span>)<br>&#125;<br>.frame(width: <span class=\"hljs-number\">200</span>, height: <span class=\"hljs-number\">60</span>)<br>.background(<span class=\"hljs-type\">Color</span>.blue)<br>.foregroundColor(.white)<br>.cornerRadius(<span class=\"hljs-number\">10</span>)<br>.padding()<br></code></pre></td></tr></table></figure>\n\n<p>SwiftUI还提供了<code>buttonStyle(_:)</code>修饰符来应用预定义的按钮样式。</p>\n<p><strong>Toggle</strong></p>\n<p><code>Toggle</code>是一个开关控件，用于表示和改变一个布尔值的状态。</p>\n<p><strong>创建Toggle</strong></p>\n<p>创建一个<code>Toggle</code>同样需要一个绑定的状态和一个显示的标签：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> isOn <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">false</span><br><br><span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>    <span class=\"hljs-type\">Toggle</span>(isOn: <span class=\"hljs-variable\">$isOn</span>) &#123;<br>        <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;切换状态&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在上面的代码中，<code>isOn</code>是一个<code>@State</code>属性，这意味着它是一个可变状态，当<code>Toggle</code>被切换时，视图会自动更新。</p>\n<p><strong>定制Toggle</strong></p>\n<p>可以使用<code>.toggleStyle(_:)</code>修饰符来定制<code>Toggle</code>的外观。SwiftUI提供了一些内建的样式，如<code>SwitchToggleStyle</code>和<code>CheckboxToggleStyle</code>（后者在macOS上可用）。</p>\n<p><strong>绑定和控制</strong></p>\n<p>按钮和开关的强大之处在于它们与SwiftUI的数据绑定系统的整合。当您使用<code>$</code>前缀创建绑定时，UI 控件将能够直接修改数据，反之亦然。这是SwiftUI声明式编程范式的核心。</p>\n<p><strong>响应用户输入</strong></p>\n<p>通常，按钮和开关会更改应用的状态或触发某个操作。例如，您可能会根据开关的状态显示或隐藏文本视图：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> isAccepted <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">false</span><br><br><span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>    <span class=\"hljs-type\">VStack</span> &#123;<br>        <span class=\"hljs-type\">Toggle</span>(isOn: <span class=\"hljs-variable\">$isAccepted</span>) &#123;<br>            <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;接受条款和条件&quot;</span>)<br>        &#125;<br><br>        <span class=\"hljs-type\">Button</span>(<span class=\"hljs-string\">&quot;继续&quot;</span>) &#123;<br>            <span class=\"hljs-comment\">// 可以在这里校验开关状态，例如是否接受了条款和条件</span><br>            proceedWithAction()<br>        &#125;<br>        .disabled(<span class=\"hljs-operator\">!</span>isAccepted) <span class=\"hljs-comment\">// 当不接受条款时禁用按钮</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>总结</strong></p>\n<p>按钮和开关是任何交互式应用程序的基础，它们提供了一种简单有效的方式来收集用户输入并作出反应。SwiftUI的<code>Button</code>和<code>Toggle</code>视图配合数据绑定，使得创建动态和响应式的用户界面变得异常简单。它们的样式和行为可以通过一系列的修饰符进行定制，以适应您的设计需求。在接下来的小节中，我们将继续探讨如何使用SwiftUI构建更复杂的用户界面元素。</p>\n<p><strong>3. TextField和Slider</strong></p>\n<p>在SwiftUI中，创建交互式表单和控制元素是构建现代应用程序不可或缺的一部分。<code>TextField</code>和<code>Slider</code>是两种常用的控件，它们允许用户输入文本和选择值的范围。</p>\n<p><strong>TextField</strong></p>\n<p><code>TextField</code>是一个用于用户输入文本的控件，它可以接受键盘输入，并且可以对输入的文本进行格式化和校验。</p>\n<p><strong>创建TextField</strong></p>\n<p>创建一个<code>TextField</code>通常需要两个参数：一个标签和一个绑定到文本值的变量。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> username: <span class=\"hljs-type\">String</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;&quot;</span><br><br><span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>    <span class=\"hljs-type\">TextField</span>(<span class=\"hljs-string\">&quot;用户名&quot;</span>, text: <span class=\"hljs-variable\">$username</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在这个例子中，每当用户在文本字段中输入时，<code>username</code>变量都会更新。<code>@State</code>属性包装器用于在本地视图状态中存储可变数据。</p>\n<p><strong>定制TextField</strong></p>\n<p>您可以使用修饰符来定制<code>TextField</code>的外观和行为，例如设置字体、颜色、对齐方式、键盘类型等。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">TextField</span>(<span class=\"hljs-string\">&quot;用户名&quot;</span>, text: <span class=\"hljs-variable\">$username</span>)<br>    .textFieldStyle(<span class=\"hljs-type\">RoundedBorderTextFieldStyle</span>())<br>    .padding()<br>    .keyboardType(.default)<br>    .autocapitalization(.none)<br>    .disableAutocorrection(<span class=\"hljs-literal\">true</span>)<br></code></pre></td></tr></table></figure>\n\n<p>在这个例子中，我们使用了<code>textFieldStyle(_:)</code>来为文本字段设置圆角边框样式，并进行了一些其他的配置。</p>\n<p><strong>Slider</strong></p>\n<p><code>Slider</code>允许用户从一个范围内选择一个值。它可以用于设置音量、选择亮度或应用任何其他需要用户选择一个数值的场景。</p>\n<p><strong>创建Slider</strong></p>\n<p>创建<code>Slider</code>至少需要一个绑定到数值的变量和一个值的范围。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> sliderValue: <span class=\"hljs-type\">Double</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0.5</span><br><br><span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>    <span class=\"hljs-type\">Slider</span>(value: <span class=\"hljs-variable\">$sliderValue</span>, in: <span class=\"hljs-number\">0</span><span class=\"hljs-operator\">...</span><span class=\"hljs-number\">1</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这个<code>Slider</code>允许用户在0到1之间选择一个值。</p>\n<p><strong>定制Slider</strong></p>\n<p><code>Slider</code>同样可以使用修饰符进行外观和功能的定制。您可以设置步长，决定滑块在变化时是否持续触发更新，以及添加标签。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Slider</span>(<br>    value: <span class=\"hljs-variable\">$sliderValue</span>,<br>    in: <span class=\"hljs-number\">0</span><span class=\"hljs-operator\">...</span><span class=\"hljs-number\">1</span>,<br>    step: <span class=\"hljs-number\">0.1</span>,<br>    onEditingChanged: &#123; editing <span class=\"hljs-keyword\">in</span><br>        <span class=\"hljs-comment\">// editing 是一个布尔值，表示是否正在编辑</span><br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;当前滑块的值：<span class=\"hljs-subst\">\\(sliderValue)</span>&quot;</span>)<br>    &#125;<br>)<br>.accentColor(.green)<br></code></pre></td></tr></table></figure>\n\n<p>在这个例子中，滑块的步长设置为0.1，且我们还指定了一个闭包，在用户编辑滑块值时触发。</p>\n<p><strong>总结</strong></p>\n<p><code>TextField</code>和<code>Slider</code>为SwiftUI应用提供了基本的用户输入功能。通过与<code>@State</code>或其他形式的状态管理相结合，它们为开发者提供了创建动态和响应式表单的能力。定制这些控件的外观和行为使它们能够匹配应用程序的设计语言，提供更好的用户体验。在接下来的章节中，我们将探索SwiftUI中的其他高级控件和视图，并学习如何将它们组合在一起以构建复杂和功能丰富的用户界面。</p>\n<p><strong>4. 自定义视图和控件</strong></p>\n<p>SwiftUI的真正魅力之一在于它为开发者提供了丰富的自定义视图和控件的能力。通过结合现有的视图和控件以及Swift语言的强大特性，我们可以创建完全定制的用户界面元素，以完美地适应我们的设计需求。</p>\n<p><strong>理解视图的组合</strong></p>\n<p>在SwiftUI中，最基本的自定义视图起始于现有的视图的组合。SwiftUI的视图是可组合的，意味着你可以将简单的视图组合成复杂的视图。比如，我们可以创建一个带有文本和图像的自定义按钮视图：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">CustomButton</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">HStack</span> &#123;<br>            <span class=\"hljs-type\">Image</span>(systemName: <span class=\"hljs-string\">&quot;star.fill&quot;</span>)<br>                .resizable()<br>                .frame(width: <span class=\"hljs-number\">20</span>, height: <span class=\"hljs-number\">20</span>)<br>            <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;收藏&quot;</span>)<br>        &#125;<br>        .padding()<br>        .background(<span class=\"hljs-type\">Color</span>.blue)<br>        .foregroundColor(.white)<br>        .cornerRadius(<span class=\"hljs-number\">10</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这个<code>CustomButton</code>就是一个自定义视图，它可以在任何其他的SwiftUI视图中使用。</p>\n<p><strong>创建完全自定义的视图</strong></p>\n<p>如果需要更高级的自定义，你可以从<code>View</code>协议开始，实现自己的<code>body</code>属性。这允许你控制视图的渲染方式，并响应用户的输入。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">CircularProgressView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-keyword\">var</span> progress: <span class=\"hljs-type\">Double</span> <span class=\"hljs-comment\">// 从0.0到1.0</span><br>    <br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">ZStack</span> &#123;<br>            <span class=\"hljs-type\">Circle</span>()<br>                .stroke(lineWidth: <span class=\"hljs-number\">20</span>)<br>                .opacity(<span class=\"hljs-number\">0.3</span>)<br>                .foregroundColor(<span class=\"hljs-type\">Color</span>.blue)<br>            <br>            <span class=\"hljs-type\">Circle</span>()<br>                .trim(from: <span class=\"hljs-number\">0.0</span>, to: <span class=\"hljs-type\">CGFloat</span>(<span class=\"hljs-built_in\">min</span>(<span class=\"hljs-keyword\">self</span>.progress, <span class=\"hljs-number\">1.0</span>)))<br>                .stroke(style: <span class=\"hljs-type\">StrokeStyle</span>(lineWidth: <span class=\"hljs-number\">20</span>, lineCap: .round, lineJoin: .round))<br>                .foregroundColor(<span class=\"hljs-type\">Color</span>.blue)<br>                .rotationEffect(<span class=\"hljs-type\">Angle</span>(degrees: <span class=\"hljs-number\">270.0</span>))<br>                .animation(.linear)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在这个例子中，我们创建了一个显示进度的环形视图，它会根据<code>progress</code>属性显示不同的填充量。</p>\n<p><strong>响应用户交互</strong></p>\n<p>自定义视图可以通过各种手势识别器来响应用户的交互。例如，你可能会有一个自定义滑块控件，它通过拖动来改变值：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">CustomSlider</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@Binding</span> <span class=\"hljs-keyword\">var</span> value: <span class=\"hljs-type\">Double</span> <span class=\"hljs-comment\">// 绑定到外部状态</span><br>    <br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">GeometryReader</span> &#123; geometry <span class=\"hljs-keyword\">in</span><br>            <span class=\"hljs-type\">Rectangle</span>()<br>                .foregroundColor(.gray)<br>                .frame(height: <span class=\"hljs-number\">20</span>)<br>                .gesture(<br>                    <span class=\"hljs-type\">DragGesture</span>(minimumDistance: <span class=\"hljs-number\">0</span>)<br>                        .onChanged &#123; gesture <span class=\"hljs-keyword\">in</span><br>                            <span class=\"hljs-keyword\">self</span>.value <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">Double</span>(gesture.location.x <span class=\"hljs-operator\">/</span> geometry.size.width)<br>                        &#125;<br>                )<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在这个例子中，我们使用<code>GeometryReader</code>来获取视图的大小，并根据用户拖动的位置来更新<code>value</code>。</p>\n<p><strong>保持性能</strong></p>\n<p>在创建自定义视图和控件时，要记住保持它们的性能。这意味着：</p>\n<ul>\n<li>避免不必要的视图重绘和状态更新。</li>\n<li>合理使用<code>.animation()</code>和<code>.transition()</code>修饰符来为视图变化提供流畅的过渡效果。</li>\n<li>当视图层次变得复杂时，考虑使用<code>drawingGroup()</code>或<code>cache</code>等优化技术。</li>\n</ul>\n<p><strong>总结</strong></p>\n<p>SwiftUI提供了强大的工具集，可以帮助开发者创建精美且功能丰富的自定义视图和控件。通过结合视图的组合、自定义绘制、响应用户输入等技术，你可以创建出完全符合你的设计和功能需求的用户界面元素。记住，自定义视图和控件不仅仅是关于创造外观，更重要的是它们提供了</p>\n<p>与用户交互的新方式。随着你的SwiftUI技能的提高，你将能够更有效地利用这些工具，打造出既美观又高效的应用程序。</p>\n"},{"title":"SwiftUI核心技术第11章适配多平台","date":"2023-11-08T01:31:14.000Z","_content":"**第11章：适配多平台**\n\n**第1小节：Catalyst：从iOS到macOS**\n\n随着Apple推出Project Catalyst，现在开发者可以更加轻松地将iOS应用带到macOS平台。这一技术允许一个单一的代码库运行在iPad和Mac上，极大地简化了多平台支持的开发过程。在这一小节，我们将讨论如何使用Catalyst来适配你的iOS应用到macOS。\n\n### Catalyst基础\n\nCatalyst是Apple提供的一套工具和API，使得开发者可以用几乎同样的代码在Mac上运行iPad应用。这不仅减少了开发和维护成本，同时也保持了用户在iOS和macOS平台间的一致体验。\n\n### 启用Catalyst\n\n在Xcode项目中启用Catalyst非常简单。首先打开你的项目设置，在Targets中选择你的iPad应用。然后，在General选项卡中，勾选“Mac”复选框来启用Mac支持。\n\n### 调整界面和布局\n\nmacOS和iOS在用户界面和交互上有所不同。因此，即使是通过Catalyst运行在Mac上的iOS应用，也需要进行一些调整来优化用户体验。\n\n- **窗口和视图尺寸**：Mac应用通常拥有更大的窗口和可调整的大小，你需要确保你的界面能够灵活地适应不同尺寸。\n- **菜单和快捷键**：Mac用户习惯于使用顶部菜单栏和快捷键来执行操作。通过Catalyst，你可以为你的应用添加Mac风格的菜单和响应键盘快捷键。\n- **交互方式**：Mac应用通常使用鼠标或触控板，而不是触摸屏。你需要考虑这一点来调整你的应用交互方式。\n\n### 优化代码和资源\n\n为了在Mac上提供最佳体验，你可能需要根据平台调整代码和资源。\n\n- **条件编译**：使用`#if targetEnvironment(macCatalyst)`来条件性地编译只在Mac上运行的代码。\n- **资源适配**：可能需要提供更高分辨率的图片或者调整用户界面元素来适应Mac的显示器。\n\n### 调试和测试\n\n在将iOS应用转移到Mac时，详细的调试和测试是必不可少的。你需要确保应用在Mac上的表现同样稳定，并提供流畅的用户体验。\n\n- **在Mac上运行和调试**：就像在iOS设备上一样，在Xcode中选择Mac作为目标设备，运行和调试你的应用。\n- **适配性测试**：对于不同的窗口尺寸和屏幕分辨率进行测试，确保布局和界面元素都能正确显示和响应。\n\n### 发布和分发\n\n当你的应用通过Catalyst适配完成后，你可以通过Mac App Store将其发布给全球的用户。这一流程类似于iOS应用的发布，但需要注意的是，你可能需要提供额外的营销材料，如屏幕截图和描述，来适应Mac App Store的展示方式。\n\n### 结论\n\nCatalyst提供了一个强大的桥梁，让开发者能够将iOS应用无缝迁移到Mac平台。这一过程需要细致的界面调整、代码优化以及充分的测试，但最终可以极大地拓宽你的应用市场，并为用户提供跨平台的统一体验。随着技术的发展，Catalyst将继续发展，为开发者和用户带来更多便利。\n\n\n**第2小节：watchOS特有的UI组件**\n\nwatchOS为Apple Watch提供了一个独特的操作系统平台，它的设计重点在于快速查看信息和简洁交互。由于屏幕尺寸有限，watchOS提供了一些专门的UI组件，以满足特定的用户体验需求。在这一小节，我们将探讨watchOS的一些特有UI组件及其设计和实现。\n\n### WKInterfaceController\n\n`WKInterfaceController`是watchOS app中视图控制器的基类，用于管理界面。与iOS的`UIViewController`不同，`WKInterfaceController`更加专注于内容展示和数据流，而非复杂的布局或动画。\n\n### Complications\n\n复杂功能（Complications）允许用户在表盘上直接查看来自应用的关键信息。它们需要使用`CLKComplicationDataSource`协议来提供动态更新的数据。创建Complications需要细心设计图形和文本，以确保信息在极小的空间内清晰可见。\n\n### Notifications\n\nwatchOS的通知设计用于迅速传递信息。使用`UNUserNotificationCenter`，开发者可以设计富媒体通知，甚至允许用户通过交互直接在Apple Watch上回应。\n\n### WKInterfaceTable\n\n`WKInterfaceTable`是watchOS用于显示列表数据的主要UI组件。与iOS的`UITableView`相比，`WKInterfaceTable`的设计更简洁，只支持静态单元格。开发者需要预先定义好所有可能的行类型。\n\n### Digital Crown\n\nDigital Crown是Apple Watch上的旋钮，允许用户进行精细的滚动和选择操作。通过`crownSequencer`，开发者可以检测和响应旋钮的旋转，从而提供一个独特的交互方式。\n\n### Force Touch\n\nForce Touch允许watchOS检测屏幕上的压力级别。这可以用来显示上下文菜单或额外控件，为用户提供更多的操作选择。使用`WKInterfaceDevice`的`play(_:)`方法，还可以给予触觉反馈。\n\n### Interface Objects\n\nwatchOS提供了一系列预定义的界面对象（如`WKInterfaceLabel`，`WKInterfaceImage`等），它们是优化过的，以确保在小屏幕上的最佳显示效果。\n\n### 布局\n\n布局在watchOS中相对简单。所有元素都是垂直或水平排列的，没有自动布局系统。开发者通过设置组（Group）来组织界面，组可以嵌套，以创造更复杂的布局结构。\n\n### 性能和电池寿命\n\n由于Apple Watch的硬件限制，性能优化和电池寿命考量至关重要。应用应当避免过多的背景活动，而且要智能地安排网络请求和数据更新。\n\n### 总结\n\n设计watchOS应用时，开发者必须考虑到平台的独特性，包括小屏幕尺寸和有限的交互方式。通过有效利用watchOS提供的特有UI组件，开发者可以创建出既美观又实用的Apple Watch应用。此外，性能和电池寿命的优化也是watchOS应用设计中不可忽视的一部分。通过精心设计和优化，你的应用将能在这个独特的平台上提供强大功能和良好体验。\n\n\n**第3小节：tvOS和大屏体验**\n\ntvOS是苹果为Apple TV设计的操作系统，它为大屏幕交互提供了特殊的用户体验和设计挑战。tvOS的应用开发不仅要考虑到大屏幕带来的视觉冲击，还要处理与iOS明显不同的用户输入方式。以下是tvOS应用开发的关键点。\n\n### 界面设计\n\n1. **布局** - 由于电视屏幕通常较大，你需要为元素间的距离和尺寸采取不同的考量。确保文字和图标在沙发观看距离仍然清晰可辨。\n\n2. **焦点驱动的交互** - 在tvOS中，用户通过遥控器的触摸板来控制界面上的焦点。应用需要处理焦点变化，并给予用户清晰的视觉反馈。\n\n3. **全屏体验** - 利用大屏幕的优势，提供全屏背景图像和视频，创造沉浸式体验。\n\n### 用户输入\n\n1. **远程控制** - Apple TV Remote的触摸表面提供了基础的轻扫和点击输入，开发者需设计易于用遥控器导航的界面。\n\n2. **游戏控制器** - 对于游戏应用，Apple TV支持MFi游戏控制器，这为复杂交互提供了更多可能。\n\n3. **语音输入** - 利用Siri远程功能，可以为应用添加语音搜索和控制能力。\n\n### 图像和视频\n\n1. **分辨率和图像优化** - Apple TV支持高达4K的分辨率，要求图片和视频内容具有高质量，以适应高分辨率的显示需求。\n\n2. **视频播放** - tvOS对于媒体播放有优化，支持HDR和Dolby Vision。开发者应当使用AVKit来实现视频播放，以确保最佳体验。\n\n### 数据存储和缓存\n\n1. **本地存储限制** - Apple TV对本地数据存储有限制，应用需要通过iCloud或网络来同步和存储大部分数据。\n\n2. **缓存策略** - 为了优化性能和减少加载时间，有效的数据缓存策略是必须的。\n\n### 性能和流畅性\n\n1. **动画和过渡** - 在大屏幕上，动画需要更加平滑和精细，以避免拖影和断续感。\n\n2. **内存管理** - Apple TV的内存资源比移动设备更丰富，但仍然需要高效的内存管理，尤其是在处理高分辨率媒体内容时。\n\n### Accessibility\n\n1. **无障碍功能** - 提供声音指导和简化的控制方案，以确保所有用户都能愉快地使用你的应用。\n\n### 总结\n\ntvOS应用开发是一个大屏幕交互设计和用户体验的全新领域。与手机和平板不同，它要求开发者从居家观看的角度出发，考虑到用户与屏幕之间的距离、环境亮度等因素，从而设计出易于使用、视觉效果出色的界面。此外，由于输入设备的限制和平台特性，tvOS应用需要特别关注焦点管理和用户输入的响应性。通过在设计上投入更多考虑和精心调优性能，你的应用将能在大屏幕上提供卓越的用户体验。","source":"_posts/SwiftUI核心技术第11章适配多平台.md","raw":"---\ntitle: SwiftUI核心技术第11章适配多平台\ndate: 2023-11-08 09:31:14\ncategories:\n- SwiftUI\ntags:\n---\n**第11章：适配多平台**\n\n**第1小节：Catalyst：从iOS到macOS**\n\n随着Apple推出Project Catalyst，现在开发者可以更加轻松地将iOS应用带到macOS平台。这一技术允许一个单一的代码库运行在iPad和Mac上，极大地简化了多平台支持的开发过程。在这一小节，我们将讨论如何使用Catalyst来适配你的iOS应用到macOS。\n\n### Catalyst基础\n\nCatalyst是Apple提供的一套工具和API，使得开发者可以用几乎同样的代码在Mac上运行iPad应用。这不仅减少了开发和维护成本，同时也保持了用户在iOS和macOS平台间的一致体验。\n\n### 启用Catalyst\n\n在Xcode项目中启用Catalyst非常简单。首先打开你的项目设置，在Targets中选择你的iPad应用。然后，在General选项卡中，勾选“Mac”复选框来启用Mac支持。\n\n### 调整界面和布局\n\nmacOS和iOS在用户界面和交互上有所不同。因此，即使是通过Catalyst运行在Mac上的iOS应用，也需要进行一些调整来优化用户体验。\n\n- **窗口和视图尺寸**：Mac应用通常拥有更大的窗口和可调整的大小，你需要确保你的界面能够灵活地适应不同尺寸。\n- **菜单和快捷键**：Mac用户习惯于使用顶部菜单栏和快捷键来执行操作。通过Catalyst，你可以为你的应用添加Mac风格的菜单和响应键盘快捷键。\n- **交互方式**：Mac应用通常使用鼠标或触控板，而不是触摸屏。你需要考虑这一点来调整你的应用交互方式。\n\n### 优化代码和资源\n\n为了在Mac上提供最佳体验，你可能需要根据平台调整代码和资源。\n\n- **条件编译**：使用`#if targetEnvironment(macCatalyst)`来条件性地编译只在Mac上运行的代码。\n- **资源适配**：可能需要提供更高分辨率的图片或者调整用户界面元素来适应Mac的显示器。\n\n### 调试和测试\n\n在将iOS应用转移到Mac时，详细的调试和测试是必不可少的。你需要确保应用在Mac上的表现同样稳定，并提供流畅的用户体验。\n\n- **在Mac上运行和调试**：就像在iOS设备上一样，在Xcode中选择Mac作为目标设备，运行和调试你的应用。\n- **适配性测试**：对于不同的窗口尺寸和屏幕分辨率进行测试，确保布局和界面元素都能正确显示和响应。\n\n### 发布和分发\n\n当你的应用通过Catalyst适配完成后，你可以通过Mac App Store将其发布给全球的用户。这一流程类似于iOS应用的发布，但需要注意的是，你可能需要提供额外的营销材料，如屏幕截图和描述，来适应Mac App Store的展示方式。\n\n### 结论\n\nCatalyst提供了一个强大的桥梁，让开发者能够将iOS应用无缝迁移到Mac平台。这一过程需要细致的界面调整、代码优化以及充分的测试，但最终可以极大地拓宽你的应用市场，并为用户提供跨平台的统一体验。随着技术的发展，Catalyst将继续发展，为开发者和用户带来更多便利。\n\n\n**第2小节：watchOS特有的UI组件**\n\nwatchOS为Apple Watch提供了一个独特的操作系统平台，它的设计重点在于快速查看信息和简洁交互。由于屏幕尺寸有限，watchOS提供了一些专门的UI组件，以满足特定的用户体验需求。在这一小节，我们将探讨watchOS的一些特有UI组件及其设计和实现。\n\n### WKInterfaceController\n\n`WKInterfaceController`是watchOS app中视图控制器的基类，用于管理界面。与iOS的`UIViewController`不同，`WKInterfaceController`更加专注于内容展示和数据流，而非复杂的布局或动画。\n\n### Complications\n\n复杂功能（Complications）允许用户在表盘上直接查看来自应用的关键信息。它们需要使用`CLKComplicationDataSource`协议来提供动态更新的数据。创建Complications需要细心设计图形和文本，以确保信息在极小的空间内清晰可见。\n\n### Notifications\n\nwatchOS的通知设计用于迅速传递信息。使用`UNUserNotificationCenter`，开发者可以设计富媒体通知，甚至允许用户通过交互直接在Apple Watch上回应。\n\n### WKInterfaceTable\n\n`WKInterfaceTable`是watchOS用于显示列表数据的主要UI组件。与iOS的`UITableView`相比，`WKInterfaceTable`的设计更简洁，只支持静态单元格。开发者需要预先定义好所有可能的行类型。\n\n### Digital Crown\n\nDigital Crown是Apple Watch上的旋钮，允许用户进行精细的滚动和选择操作。通过`crownSequencer`，开发者可以检测和响应旋钮的旋转，从而提供一个独特的交互方式。\n\n### Force Touch\n\nForce Touch允许watchOS检测屏幕上的压力级别。这可以用来显示上下文菜单或额外控件，为用户提供更多的操作选择。使用`WKInterfaceDevice`的`play(_:)`方法，还可以给予触觉反馈。\n\n### Interface Objects\n\nwatchOS提供了一系列预定义的界面对象（如`WKInterfaceLabel`，`WKInterfaceImage`等），它们是优化过的，以确保在小屏幕上的最佳显示效果。\n\n### 布局\n\n布局在watchOS中相对简单。所有元素都是垂直或水平排列的，没有自动布局系统。开发者通过设置组（Group）来组织界面，组可以嵌套，以创造更复杂的布局结构。\n\n### 性能和电池寿命\n\n由于Apple Watch的硬件限制，性能优化和电池寿命考量至关重要。应用应当避免过多的背景活动，而且要智能地安排网络请求和数据更新。\n\n### 总结\n\n设计watchOS应用时，开发者必须考虑到平台的独特性，包括小屏幕尺寸和有限的交互方式。通过有效利用watchOS提供的特有UI组件，开发者可以创建出既美观又实用的Apple Watch应用。此外，性能和电池寿命的优化也是watchOS应用设计中不可忽视的一部分。通过精心设计和优化，你的应用将能在这个独特的平台上提供强大功能和良好体验。\n\n\n**第3小节：tvOS和大屏体验**\n\ntvOS是苹果为Apple TV设计的操作系统，它为大屏幕交互提供了特殊的用户体验和设计挑战。tvOS的应用开发不仅要考虑到大屏幕带来的视觉冲击，还要处理与iOS明显不同的用户输入方式。以下是tvOS应用开发的关键点。\n\n### 界面设计\n\n1. **布局** - 由于电视屏幕通常较大，你需要为元素间的距离和尺寸采取不同的考量。确保文字和图标在沙发观看距离仍然清晰可辨。\n\n2. **焦点驱动的交互** - 在tvOS中，用户通过遥控器的触摸板来控制界面上的焦点。应用需要处理焦点变化，并给予用户清晰的视觉反馈。\n\n3. **全屏体验** - 利用大屏幕的优势，提供全屏背景图像和视频，创造沉浸式体验。\n\n### 用户输入\n\n1. **远程控制** - Apple TV Remote的触摸表面提供了基础的轻扫和点击输入，开发者需设计易于用遥控器导航的界面。\n\n2. **游戏控制器** - 对于游戏应用，Apple TV支持MFi游戏控制器，这为复杂交互提供了更多可能。\n\n3. **语音输入** - 利用Siri远程功能，可以为应用添加语音搜索和控制能力。\n\n### 图像和视频\n\n1. **分辨率和图像优化** - Apple TV支持高达4K的分辨率，要求图片和视频内容具有高质量，以适应高分辨率的显示需求。\n\n2. **视频播放** - tvOS对于媒体播放有优化，支持HDR和Dolby Vision。开发者应当使用AVKit来实现视频播放，以确保最佳体验。\n\n### 数据存储和缓存\n\n1. **本地存储限制** - Apple TV对本地数据存储有限制，应用需要通过iCloud或网络来同步和存储大部分数据。\n\n2. **缓存策略** - 为了优化性能和减少加载时间，有效的数据缓存策略是必须的。\n\n### 性能和流畅性\n\n1. **动画和过渡** - 在大屏幕上，动画需要更加平滑和精细，以避免拖影和断续感。\n\n2. **内存管理** - Apple TV的内存资源比移动设备更丰富，但仍然需要高效的内存管理，尤其是在处理高分辨率媒体内容时。\n\n### Accessibility\n\n1. **无障碍功能** - 提供声音指导和简化的控制方案，以确保所有用户都能愉快地使用你的应用。\n\n### 总结\n\ntvOS应用开发是一个大屏幕交互设计和用户体验的全新领域。与手机和平板不同，它要求开发者从居家观看的角度出发，考虑到用户与屏幕之间的距离、环境亮度等因素，从而设计出易于使用、视觉效果出色的界面。此外，由于输入设备的限制和平台特性，tvOS应用需要特别关注焦点管理和用户输入的响应性。通过在设计上投入更多考虑和精心调优性能，你的应用将能在大屏幕上提供卓越的用户体验。","slug":"SwiftUI核心技术第11章适配多平台","published":1,"updated":"2024-03-17T06:11:51.180Z","comments":1,"layout":"post","photos":[],"_id":"clu6up53h0022z674dev55qur","content":"<p><strong>第11章：适配多平台</strong></p>\n<p><strong>第1小节：Catalyst：从iOS到macOS</strong></p>\n<p>随着Apple推出Project Catalyst，现在开发者可以更加轻松地将iOS应用带到macOS平台。这一技术允许一个单一的代码库运行在iPad和Mac上，极大地简化了多平台支持的开发过程。在这一小节，我们将讨论如何使用Catalyst来适配你的iOS应用到macOS。</p>\n<h3 id=\"Catalyst基础\"><a href=\"#Catalyst基础\" class=\"headerlink\" title=\"Catalyst基础\"></a>Catalyst基础</h3><p>Catalyst是Apple提供的一套工具和API，使得开发者可以用几乎同样的代码在Mac上运行iPad应用。这不仅减少了开发和维护成本，同时也保持了用户在iOS和macOS平台间的一致体验。</p>\n<h3 id=\"启用Catalyst\"><a href=\"#启用Catalyst\" class=\"headerlink\" title=\"启用Catalyst\"></a>启用Catalyst</h3><p>在Xcode项目中启用Catalyst非常简单。首先打开你的项目设置，在Targets中选择你的iPad应用。然后，在General选项卡中，勾选“Mac”复选框来启用Mac支持。</p>\n<h3 id=\"调整界面和布局\"><a href=\"#调整界面和布局\" class=\"headerlink\" title=\"调整界面和布局\"></a>调整界面和布局</h3><p>macOS和iOS在用户界面和交互上有所不同。因此，即使是通过Catalyst运行在Mac上的iOS应用，也需要进行一些调整来优化用户体验。</p>\n<ul>\n<li><strong>窗口和视图尺寸</strong>：Mac应用通常拥有更大的窗口和可调整的大小，你需要确保你的界面能够灵活地适应不同尺寸。</li>\n<li><strong>菜单和快捷键</strong>：Mac用户习惯于使用顶部菜单栏和快捷键来执行操作。通过Catalyst，你可以为你的应用添加Mac风格的菜单和响应键盘快捷键。</li>\n<li><strong>交互方式</strong>：Mac应用通常使用鼠标或触控板，而不是触摸屏。你需要考虑这一点来调整你的应用交互方式。</li>\n</ul>\n<h3 id=\"优化代码和资源\"><a href=\"#优化代码和资源\" class=\"headerlink\" title=\"优化代码和资源\"></a>优化代码和资源</h3><p>为了在Mac上提供最佳体验，你可能需要根据平台调整代码和资源。</p>\n<ul>\n<li><strong>条件编译</strong>：使用<code>#if targetEnvironment(macCatalyst)</code>来条件性地编译只在Mac上运行的代码。</li>\n<li><strong>资源适配</strong>：可能需要提供更高分辨率的图片或者调整用户界面元素来适应Mac的显示器。</li>\n</ul>\n<h3 id=\"调试和测试\"><a href=\"#调试和测试\" class=\"headerlink\" title=\"调试和测试\"></a>调试和测试</h3><p>在将iOS应用转移到Mac时，详细的调试和测试是必不可少的。你需要确保应用在Mac上的表现同样稳定，并提供流畅的用户体验。</p>\n<ul>\n<li><strong>在Mac上运行和调试</strong>：就像在iOS设备上一样，在Xcode中选择Mac作为目标设备，运行和调试你的应用。</li>\n<li><strong>适配性测试</strong>：对于不同的窗口尺寸和屏幕分辨率进行测试，确保布局和界面元素都能正确显示和响应。</li>\n</ul>\n<h3 id=\"发布和分发\"><a href=\"#发布和分发\" class=\"headerlink\" title=\"发布和分发\"></a>发布和分发</h3><p>当你的应用通过Catalyst适配完成后，你可以通过Mac App Store将其发布给全球的用户。这一流程类似于iOS应用的发布，但需要注意的是，你可能需要提供额外的营销材料，如屏幕截图和描述，来适应Mac App Store的展示方式。</p>\n<h3 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h3><p>Catalyst提供了一个强大的桥梁，让开发者能够将iOS应用无缝迁移到Mac平台。这一过程需要细致的界面调整、代码优化以及充分的测试，但最终可以极大地拓宽你的应用市场，并为用户提供跨平台的统一体验。随着技术的发展，Catalyst将继续发展，为开发者和用户带来更多便利。</p>\n<p><strong>第2小节：watchOS特有的UI组件</strong></p>\n<p>watchOS为Apple Watch提供了一个独特的操作系统平台，它的设计重点在于快速查看信息和简洁交互。由于屏幕尺寸有限，watchOS提供了一些专门的UI组件，以满足特定的用户体验需求。在这一小节，我们将探讨watchOS的一些特有UI组件及其设计和实现。</p>\n<h3 id=\"WKInterfaceController\"><a href=\"#WKInterfaceController\" class=\"headerlink\" title=\"WKInterfaceController\"></a>WKInterfaceController</h3><p><code>WKInterfaceController</code>是watchOS app中视图控制器的基类，用于管理界面。与iOS的<code>UIViewController</code>不同，<code>WKInterfaceController</code>更加专注于内容展示和数据流，而非复杂的布局或动画。</p>\n<h3 id=\"Complications\"><a href=\"#Complications\" class=\"headerlink\" title=\"Complications\"></a>Complications</h3><p>复杂功能（Complications）允许用户在表盘上直接查看来自应用的关键信息。它们需要使用<code>CLKComplicationDataSource</code>协议来提供动态更新的数据。创建Complications需要细心设计图形和文本，以确保信息在极小的空间内清晰可见。</p>\n<h3 id=\"Notifications\"><a href=\"#Notifications\" class=\"headerlink\" title=\"Notifications\"></a>Notifications</h3><p>watchOS的通知设计用于迅速传递信息。使用<code>UNUserNotificationCenter</code>，开发者可以设计富媒体通知，甚至允许用户通过交互直接在Apple Watch上回应。</p>\n<h3 id=\"WKInterfaceTable\"><a href=\"#WKInterfaceTable\" class=\"headerlink\" title=\"WKInterfaceTable\"></a>WKInterfaceTable</h3><p><code>WKInterfaceTable</code>是watchOS用于显示列表数据的主要UI组件。与iOS的<code>UITableView</code>相比，<code>WKInterfaceTable</code>的设计更简洁，只支持静态单元格。开发者需要预先定义好所有可能的行类型。</p>\n<h3 id=\"Digital-Crown\"><a href=\"#Digital-Crown\" class=\"headerlink\" title=\"Digital Crown\"></a>Digital Crown</h3><p>Digital Crown是Apple Watch上的旋钮，允许用户进行精细的滚动和选择操作。通过<code>crownSequencer</code>，开发者可以检测和响应旋钮的旋转，从而提供一个独特的交互方式。</p>\n<h3 id=\"Force-Touch\"><a href=\"#Force-Touch\" class=\"headerlink\" title=\"Force Touch\"></a>Force Touch</h3><p>Force Touch允许watchOS检测屏幕上的压力级别。这可以用来显示上下文菜单或额外控件，为用户提供更多的操作选择。使用<code>WKInterfaceDevice</code>的<code>play(_:)</code>方法，还可以给予触觉反馈。</p>\n<h3 id=\"Interface-Objects\"><a href=\"#Interface-Objects\" class=\"headerlink\" title=\"Interface Objects\"></a>Interface Objects</h3><p>watchOS提供了一系列预定义的界面对象（如<code>WKInterfaceLabel</code>，<code>WKInterfaceImage</code>等），它们是优化过的，以确保在小屏幕上的最佳显示效果。</p>\n<h3 id=\"布局\"><a href=\"#布局\" class=\"headerlink\" title=\"布局\"></a>布局</h3><p>布局在watchOS中相对简单。所有元素都是垂直或水平排列的，没有自动布局系统。开发者通过设置组（Group）来组织界面，组可以嵌套，以创造更复杂的布局结构。</p>\n<h3 id=\"性能和电池寿命\"><a href=\"#性能和电池寿命\" class=\"headerlink\" title=\"性能和电池寿命\"></a>性能和电池寿命</h3><p>由于Apple Watch的硬件限制，性能优化和电池寿命考量至关重要。应用应当避免过多的背景活动，而且要智能地安排网络请求和数据更新。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>设计watchOS应用时，开发者必须考虑到平台的独特性，包括小屏幕尺寸和有限的交互方式。通过有效利用watchOS提供的特有UI组件，开发者可以创建出既美观又实用的Apple Watch应用。此外，性能和电池寿命的优化也是watchOS应用设计中不可忽视的一部分。通过精心设计和优化，你的应用将能在这个独特的平台上提供强大功能和良好体验。</p>\n<p><strong>第3小节：tvOS和大屏体验</strong></p>\n<p>tvOS是苹果为Apple TV设计的操作系统，它为大屏幕交互提供了特殊的用户体验和设计挑战。tvOS的应用开发不仅要考虑到大屏幕带来的视觉冲击，还要处理与iOS明显不同的用户输入方式。以下是tvOS应用开发的关键点。</p>\n<h3 id=\"界面设计\"><a href=\"#界面设计\" class=\"headerlink\" title=\"界面设计\"></a>界面设计</h3><ol>\n<li><p><strong>布局</strong> - 由于电视屏幕通常较大，你需要为元素间的距离和尺寸采取不同的考量。确保文字和图标在沙发观看距离仍然清晰可辨。</p>\n</li>\n<li><p><strong>焦点驱动的交互</strong> - 在tvOS中，用户通过遥控器的触摸板来控制界面上的焦点。应用需要处理焦点变化，并给予用户清晰的视觉反馈。</p>\n</li>\n<li><p><strong>全屏体验</strong> - 利用大屏幕的优势，提供全屏背景图像和视频，创造沉浸式体验。</p>\n</li>\n</ol>\n<h3 id=\"用户输入\"><a href=\"#用户输入\" class=\"headerlink\" title=\"用户输入\"></a>用户输入</h3><ol>\n<li><p><strong>远程控制</strong> - Apple TV Remote的触摸表面提供了基础的轻扫和点击输入，开发者需设计易于用遥控器导航的界面。</p>\n</li>\n<li><p><strong>游戏控制器</strong> - 对于游戏应用，Apple TV支持MFi游戏控制器，这为复杂交互提供了更多可能。</p>\n</li>\n<li><p><strong>语音输入</strong> - 利用Siri远程功能，可以为应用添加语音搜索和控制能力。</p>\n</li>\n</ol>\n<h3 id=\"图像和视频\"><a href=\"#图像和视频\" class=\"headerlink\" title=\"图像和视频\"></a>图像和视频</h3><ol>\n<li><p><strong>分辨率和图像优化</strong> - Apple TV支持高达4K的分辨率，要求图片和视频内容具有高质量，以适应高分辨率的显示需求。</p>\n</li>\n<li><p><strong>视频播放</strong> - tvOS对于媒体播放有优化，支持HDR和Dolby Vision。开发者应当使用AVKit来实现视频播放，以确保最佳体验。</p>\n</li>\n</ol>\n<h3 id=\"数据存储和缓存\"><a href=\"#数据存储和缓存\" class=\"headerlink\" title=\"数据存储和缓存\"></a>数据存储和缓存</h3><ol>\n<li><p><strong>本地存储限制</strong> - Apple TV对本地数据存储有限制，应用需要通过iCloud或网络来同步和存储大部分数据。</p>\n</li>\n<li><p><strong>缓存策略</strong> - 为了优化性能和减少加载时间，有效的数据缓存策略是必须的。</p>\n</li>\n</ol>\n<h3 id=\"性能和流畅性\"><a href=\"#性能和流畅性\" class=\"headerlink\" title=\"性能和流畅性\"></a>性能和流畅性</h3><ol>\n<li><p><strong>动画和过渡</strong> - 在大屏幕上，动画需要更加平滑和精细，以避免拖影和断续感。</p>\n</li>\n<li><p><strong>内存管理</strong> - Apple TV的内存资源比移动设备更丰富，但仍然需要高效的内存管理，尤其是在处理高分辨率媒体内容时。</p>\n</li>\n</ol>\n<h3 id=\"Accessibility\"><a href=\"#Accessibility\" class=\"headerlink\" title=\"Accessibility\"></a>Accessibility</h3><ol>\n<li><strong>无障碍功能</strong> - 提供声音指导和简化的控制方案，以确保所有用户都能愉快地使用你的应用。</li>\n</ol>\n<h3 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>tvOS应用开发是一个大屏幕交互设计和用户体验的全新领域。与手机和平板不同，它要求开发者从居家观看的角度出发，考虑到用户与屏幕之间的距离、环境亮度等因素，从而设计出易于使用、视觉效果出色的界面。此外，由于输入设备的限制和平台特性，tvOS应用需要特别关注焦点管理和用户输入的响应性。通过在设计上投入更多考虑和精心调优性能，你的应用将能在大屏幕上提供卓越的用户体验。</p>\n","excerpt":"","more":"<p><strong>第11章：适配多平台</strong></p>\n<p><strong>第1小节：Catalyst：从iOS到macOS</strong></p>\n<p>随着Apple推出Project Catalyst，现在开发者可以更加轻松地将iOS应用带到macOS平台。这一技术允许一个单一的代码库运行在iPad和Mac上，极大地简化了多平台支持的开发过程。在这一小节，我们将讨论如何使用Catalyst来适配你的iOS应用到macOS。</p>\n<h3 id=\"Catalyst基础\"><a href=\"#Catalyst基础\" class=\"headerlink\" title=\"Catalyst基础\"></a>Catalyst基础</h3><p>Catalyst是Apple提供的一套工具和API，使得开发者可以用几乎同样的代码在Mac上运行iPad应用。这不仅减少了开发和维护成本，同时也保持了用户在iOS和macOS平台间的一致体验。</p>\n<h3 id=\"启用Catalyst\"><a href=\"#启用Catalyst\" class=\"headerlink\" title=\"启用Catalyst\"></a>启用Catalyst</h3><p>在Xcode项目中启用Catalyst非常简单。首先打开你的项目设置，在Targets中选择你的iPad应用。然后，在General选项卡中，勾选“Mac”复选框来启用Mac支持。</p>\n<h3 id=\"调整界面和布局\"><a href=\"#调整界面和布局\" class=\"headerlink\" title=\"调整界面和布局\"></a>调整界面和布局</h3><p>macOS和iOS在用户界面和交互上有所不同。因此，即使是通过Catalyst运行在Mac上的iOS应用，也需要进行一些调整来优化用户体验。</p>\n<ul>\n<li><strong>窗口和视图尺寸</strong>：Mac应用通常拥有更大的窗口和可调整的大小，你需要确保你的界面能够灵活地适应不同尺寸。</li>\n<li><strong>菜单和快捷键</strong>：Mac用户习惯于使用顶部菜单栏和快捷键来执行操作。通过Catalyst，你可以为你的应用添加Mac风格的菜单和响应键盘快捷键。</li>\n<li><strong>交互方式</strong>：Mac应用通常使用鼠标或触控板，而不是触摸屏。你需要考虑这一点来调整你的应用交互方式。</li>\n</ul>\n<h3 id=\"优化代码和资源\"><a href=\"#优化代码和资源\" class=\"headerlink\" title=\"优化代码和资源\"></a>优化代码和资源</h3><p>为了在Mac上提供最佳体验，你可能需要根据平台调整代码和资源。</p>\n<ul>\n<li><strong>条件编译</strong>：使用<code>#if targetEnvironment(macCatalyst)</code>来条件性地编译只在Mac上运行的代码。</li>\n<li><strong>资源适配</strong>：可能需要提供更高分辨率的图片或者调整用户界面元素来适应Mac的显示器。</li>\n</ul>\n<h3 id=\"调试和测试\"><a href=\"#调试和测试\" class=\"headerlink\" title=\"调试和测试\"></a>调试和测试</h3><p>在将iOS应用转移到Mac时，详细的调试和测试是必不可少的。你需要确保应用在Mac上的表现同样稳定，并提供流畅的用户体验。</p>\n<ul>\n<li><strong>在Mac上运行和调试</strong>：就像在iOS设备上一样，在Xcode中选择Mac作为目标设备，运行和调试你的应用。</li>\n<li><strong>适配性测试</strong>：对于不同的窗口尺寸和屏幕分辨率进行测试，确保布局和界面元素都能正确显示和响应。</li>\n</ul>\n<h3 id=\"发布和分发\"><a href=\"#发布和分发\" class=\"headerlink\" title=\"发布和分发\"></a>发布和分发</h3><p>当你的应用通过Catalyst适配完成后，你可以通过Mac App Store将其发布给全球的用户。这一流程类似于iOS应用的发布，但需要注意的是，你可能需要提供额外的营销材料，如屏幕截图和描述，来适应Mac App Store的展示方式。</p>\n<h3 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h3><p>Catalyst提供了一个强大的桥梁，让开发者能够将iOS应用无缝迁移到Mac平台。这一过程需要细致的界面调整、代码优化以及充分的测试，但最终可以极大地拓宽你的应用市场，并为用户提供跨平台的统一体验。随着技术的发展，Catalyst将继续发展，为开发者和用户带来更多便利。</p>\n<p><strong>第2小节：watchOS特有的UI组件</strong></p>\n<p>watchOS为Apple Watch提供了一个独特的操作系统平台，它的设计重点在于快速查看信息和简洁交互。由于屏幕尺寸有限，watchOS提供了一些专门的UI组件，以满足特定的用户体验需求。在这一小节，我们将探讨watchOS的一些特有UI组件及其设计和实现。</p>\n<h3 id=\"WKInterfaceController\"><a href=\"#WKInterfaceController\" class=\"headerlink\" title=\"WKInterfaceController\"></a>WKInterfaceController</h3><p><code>WKInterfaceController</code>是watchOS app中视图控制器的基类，用于管理界面。与iOS的<code>UIViewController</code>不同，<code>WKInterfaceController</code>更加专注于内容展示和数据流，而非复杂的布局或动画。</p>\n<h3 id=\"Complications\"><a href=\"#Complications\" class=\"headerlink\" title=\"Complications\"></a>Complications</h3><p>复杂功能（Complications）允许用户在表盘上直接查看来自应用的关键信息。它们需要使用<code>CLKComplicationDataSource</code>协议来提供动态更新的数据。创建Complications需要细心设计图形和文本，以确保信息在极小的空间内清晰可见。</p>\n<h3 id=\"Notifications\"><a href=\"#Notifications\" class=\"headerlink\" title=\"Notifications\"></a>Notifications</h3><p>watchOS的通知设计用于迅速传递信息。使用<code>UNUserNotificationCenter</code>，开发者可以设计富媒体通知，甚至允许用户通过交互直接在Apple Watch上回应。</p>\n<h3 id=\"WKInterfaceTable\"><a href=\"#WKInterfaceTable\" class=\"headerlink\" title=\"WKInterfaceTable\"></a>WKInterfaceTable</h3><p><code>WKInterfaceTable</code>是watchOS用于显示列表数据的主要UI组件。与iOS的<code>UITableView</code>相比，<code>WKInterfaceTable</code>的设计更简洁，只支持静态单元格。开发者需要预先定义好所有可能的行类型。</p>\n<h3 id=\"Digital-Crown\"><a href=\"#Digital-Crown\" class=\"headerlink\" title=\"Digital Crown\"></a>Digital Crown</h3><p>Digital Crown是Apple Watch上的旋钮，允许用户进行精细的滚动和选择操作。通过<code>crownSequencer</code>，开发者可以检测和响应旋钮的旋转，从而提供一个独特的交互方式。</p>\n<h3 id=\"Force-Touch\"><a href=\"#Force-Touch\" class=\"headerlink\" title=\"Force Touch\"></a>Force Touch</h3><p>Force Touch允许watchOS检测屏幕上的压力级别。这可以用来显示上下文菜单或额外控件，为用户提供更多的操作选择。使用<code>WKInterfaceDevice</code>的<code>play(_:)</code>方法，还可以给予触觉反馈。</p>\n<h3 id=\"Interface-Objects\"><a href=\"#Interface-Objects\" class=\"headerlink\" title=\"Interface Objects\"></a>Interface Objects</h3><p>watchOS提供了一系列预定义的界面对象（如<code>WKInterfaceLabel</code>，<code>WKInterfaceImage</code>等），它们是优化过的，以确保在小屏幕上的最佳显示效果。</p>\n<h3 id=\"布局\"><a href=\"#布局\" class=\"headerlink\" title=\"布局\"></a>布局</h3><p>布局在watchOS中相对简单。所有元素都是垂直或水平排列的，没有自动布局系统。开发者通过设置组（Group）来组织界面，组可以嵌套，以创造更复杂的布局结构。</p>\n<h3 id=\"性能和电池寿命\"><a href=\"#性能和电池寿命\" class=\"headerlink\" title=\"性能和电池寿命\"></a>性能和电池寿命</h3><p>由于Apple Watch的硬件限制，性能优化和电池寿命考量至关重要。应用应当避免过多的背景活动，而且要智能地安排网络请求和数据更新。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>设计watchOS应用时，开发者必须考虑到平台的独特性，包括小屏幕尺寸和有限的交互方式。通过有效利用watchOS提供的特有UI组件，开发者可以创建出既美观又实用的Apple Watch应用。此外，性能和电池寿命的优化也是watchOS应用设计中不可忽视的一部分。通过精心设计和优化，你的应用将能在这个独特的平台上提供强大功能和良好体验。</p>\n<p><strong>第3小节：tvOS和大屏体验</strong></p>\n<p>tvOS是苹果为Apple TV设计的操作系统，它为大屏幕交互提供了特殊的用户体验和设计挑战。tvOS的应用开发不仅要考虑到大屏幕带来的视觉冲击，还要处理与iOS明显不同的用户输入方式。以下是tvOS应用开发的关键点。</p>\n<h3 id=\"界面设计\"><a href=\"#界面设计\" class=\"headerlink\" title=\"界面设计\"></a>界面设计</h3><ol>\n<li><p><strong>布局</strong> - 由于电视屏幕通常较大，你需要为元素间的距离和尺寸采取不同的考量。确保文字和图标在沙发观看距离仍然清晰可辨。</p>\n</li>\n<li><p><strong>焦点驱动的交互</strong> - 在tvOS中，用户通过遥控器的触摸板来控制界面上的焦点。应用需要处理焦点变化，并给予用户清晰的视觉反馈。</p>\n</li>\n<li><p><strong>全屏体验</strong> - 利用大屏幕的优势，提供全屏背景图像和视频，创造沉浸式体验。</p>\n</li>\n</ol>\n<h3 id=\"用户输入\"><a href=\"#用户输入\" class=\"headerlink\" title=\"用户输入\"></a>用户输入</h3><ol>\n<li><p><strong>远程控制</strong> - Apple TV Remote的触摸表面提供了基础的轻扫和点击输入，开发者需设计易于用遥控器导航的界面。</p>\n</li>\n<li><p><strong>游戏控制器</strong> - 对于游戏应用，Apple TV支持MFi游戏控制器，这为复杂交互提供了更多可能。</p>\n</li>\n<li><p><strong>语音输入</strong> - 利用Siri远程功能，可以为应用添加语音搜索和控制能力。</p>\n</li>\n</ol>\n<h3 id=\"图像和视频\"><a href=\"#图像和视频\" class=\"headerlink\" title=\"图像和视频\"></a>图像和视频</h3><ol>\n<li><p><strong>分辨率和图像优化</strong> - Apple TV支持高达4K的分辨率，要求图片和视频内容具有高质量，以适应高分辨率的显示需求。</p>\n</li>\n<li><p><strong>视频播放</strong> - tvOS对于媒体播放有优化，支持HDR和Dolby Vision。开发者应当使用AVKit来实现视频播放，以确保最佳体验。</p>\n</li>\n</ol>\n<h3 id=\"数据存储和缓存\"><a href=\"#数据存储和缓存\" class=\"headerlink\" title=\"数据存储和缓存\"></a>数据存储和缓存</h3><ol>\n<li><p><strong>本地存储限制</strong> - Apple TV对本地数据存储有限制，应用需要通过iCloud或网络来同步和存储大部分数据。</p>\n</li>\n<li><p><strong>缓存策略</strong> - 为了优化性能和减少加载时间，有效的数据缓存策略是必须的。</p>\n</li>\n</ol>\n<h3 id=\"性能和流畅性\"><a href=\"#性能和流畅性\" class=\"headerlink\" title=\"性能和流畅性\"></a>性能和流畅性</h3><ol>\n<li><p><strong>动画和过渡</strong> - 在大屏幕上，动画需要更加平滑和精细，以避免拖影和断续感。</p>\n</li>\n<li><p><strong>内存管理</strong> - Apple TV的内存资源比移动设备更丰富，但仍然需要高效的内存管理，尤其是在处理高分辨率媒体内容时。</p>\n</li>\n</ol>\n<h3 id=\"Accessibility\"><a href=\"#Accessibility\" class=\"headerlink\" title=\"Accessibility\"></a>Accessibility</h3><ol>\n<li><strong>无障碍功能</strong> - 提供声音指导和简化的控制方案，以确保所有用户都能愉快地使用你的应用。</li>\n</ol>\n<h3 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>tvOS应用开发是一个大屏幕交互设计和用户体验的全新领域。与手机和平板不同，它要求开发者从居家观看的角度出发，考虑到用户与屏幕之间的距离、环境亮度等因素，从而设计出易于使用、视觉效果出色的界面。此外，由于输入设备的限制和平台特性，tvOS应用需要特别关注焦点管理和用户输入的响应性。通过在设计上投入更多考虑和精心调优性能，你的应用将能在大屏幕上提供卓越的用户体验。</p>\n"},{"title":"SwiftUI核心技术第10章集成Core Data和CloudKit","date":"2023-11-08T01:20:39.000Z","_content":"**第10章：集成Core Data和CloudKit**\n\n**第1小节：Core Data概念和配置**\n\nCore Data是Apple提供的一套强大的框架，用于iOS、macOS、watchOS和tvOS应用的数据管理。它提供了对象图管理和持久化支持，使得开发者可以高效地存储和查询数据而无需直接操作数据库。在本小节中，我们将深入了解Core Data的基本概念，并指导如何在SwiftUI应用中进行配置。\n\n**Core Data的关键概念**\n\n1. **托管对象模型（Managed Object Model）**：作为Core Data的基础，定义了应用的数据模型。它通常通过Xcode的数据模型编辑器图形化地创建，并保存为.xcdatamodeld文件。\n\n2. **托管对象上下文（Managed Object Context）**：是在应用和数据库之间进行交互的主要接口。它管理应用中的数据对象。\n\n3. **持久化存储协调器（Persistent Store Coordinator）**：负责管理数据的存储。它连接数据模型和数据存储。\n\n4. **托管对象（Managed Object）**：对数据模型中定义的实体（Entity）的实例，它在上下文中被管理。\n\n5. **实体（Entity）**：数据模型中定义的一个数据结构，对应于传统数据库中的表。\n\n6. **属性（Attribute）**：实体中的字段，用来定义存储数据的类型。\n\n7. **关系（Relationship）**：定义实体间的连接，类似于数据库中的外键。\n\n8. **获取请求（Fetch Request）**：用来查询数据模型，返回一个或多个托管对象。\n\n**配置Core Data**\n\n在SwiftUI中配置Core Data通常遵循以下步骤：\n\n1. **创建数据模型**：在Xcode中新建一个数据模型文件，并添加必要的实体和属性。\n\n2. **添加Core Data堆栈**：设置托管对象模型、持久化存储协调器和托管对象上下文。在Xcode项目模板中，如果选择了使用Core Data，则大部分配置已由模板自动生成。\n\n3. **初始化Core Data堆栈**：通常在应用启动时进行，例如在`AppDelegate`或`SceneDelegate`中。\n\n4. **在SwiftUI视图中使用**：在SwiftUI视图中，通过环境变量`@Environment(\\.managedObjectContext)`访问托管对象上下文。\n\n**示例代码：配置Core Data环境**\n\n```swift\nimport CoreData\n\n// 通常在AppDelegate或类似的地方进行初始化\nclass DataController: ObservableObject {\n    let container: NSPersistentContainer\n\n    init() {\n        container = NSPersistentContainer(name: \"Model\")\n        container.loadPersistentStores { (storeDescription, error) in\n            if let error = error as NSError? {\n                // 实际应用中应处理错误，这里简化了处理\n                fatalError(\"Unresolved error \\(error), \\(error.userInfo)\")\n            }\n        }\n    }\n}\n\n// SwiftUI视图中使用\nstruct ContentView: View {\n    @Environment(\\.managedObjectContext) var managedObjectContext\n\n    var body: some View {\n        // ...\n    }\n}\n```\n\n在上述代码中，`DataController`负责初始化Core Data堆栈，并加载持久化存储。在SwiftUI视图中，我们通过`@Environment`属性包装器注入了托管对象上下文，以便在视图中使用。\n\n**总结**\n\nCore Data是一个强大的框架，它为数据持久化和管理提供了丰富的功能。理解其核心概念并在SwiftUI项目中进行正确配置，是高效使用该框架的关键。随后的小节中，我们将探讨如何使用Core Data进行数据的创建、读取、更新和删除操作，以及如何将Core Data与CloudKit集成，实现数据的云同步。\n\n\n**第2小节：SwiftUI中的Core Data集成**\n\n在SwiftUI应用中集成Core Data可以让我们更加便捷地管理模型层数据。这个过程涉及到模型定义、上下文管理和视图更新。在本小节，我们将详细介绍如何在SwiftUI中集成Core Data。\n\n**模型定义**\n\n模型定义是使用Core Data的第一步。在Xcode的模型编辑器中，您可以定义实体、属性和关系。这些模型元素代表了应用中的数据结构。对于每一个实体，Core Data都能自动生成对应的`NSManagedObject`子类，您可以直接在代码中使用。\n\n**示例代码：定义一个Person实体**\n\n```swift\nimport CoreData\n\n// 假设在.xcdatamodeld文件中已经定义了Person实体及其属性\npublic class Person: NSManagedObject {\n    @NSManaged public var id: UUID\n    @NSManaged public var name: String\n    @NSManaged public var age: Int16\n}\n```\n\n**集成到SwiftUI视图**\n\n在SwiftUI中，通过`@FetchRequest`属性包装器可以创建对Core Data实体的查询请求，并将结果直接绑定到用户界面。当底层数据变化时，界面也会自动更新。\n\n**示例代码：使用`@FetchRequest`展示数据**\n\n```swift\nimport SwiftUI\nimport CoreData\n\nstruct PersonListView: View {\n    @Environment(\\.managedObjectContext) private var viewContext\n    @FetchRequest(\n        sortDescriptors: [NSSortDescriptor(keyPath: \\Person.name, ascending: true)],\n        animation: .default)\n    private var persons: FetchedResults<Person>\n\n    var body: some View {\n        List {\n            ForEach(persons, id: \\.id) { person in\n                Text(person.name)\n            }\n        }\n    }\n}\n```\n\n在上面的代码中，`@FetchRequest`初始化了一个请求来获取所有`Person`对象，并按`name`属性升序排序。`persons`数组将自动更新，以反映数据库中的数据。\n\n**数据操作**\n\n对于Core Data中的数据，您可以使用托管对象上下文（`NSManagedObjectContext`）进行操作，包括创建新对象、修改属性、保存更改或删除对象。\n\n**示例代码：添加新Person对象**\n\n```swift\nfunc addPerson(name: String, age: Int16) {\n    let newPerson = Person(context: viewContext)\n    newPerson.id = UUID()\n    newPerson.name = name\n    newPerson.age = age\n\n    do {\n        try viewContext.save()\n    } catch {\n        // 这里处理错误\n        let nsError = error as NSError\n        fatalError(\"Unresolved error \\(nsError), \\(nsError.userInfo)\")\n    }\n}\n```\n\n**SwiftUI中的Context传递**\n\n在SwiftUI应用中，托管对象上下文是通过环境传递的。这意味着您可以在应用的顶层视图中设置上下文，并通过环境变量在子视图中访问。\n\n```swift\n@main\nstruct MyApp: App {\n    let dataController = DataController()\n\n    var body: some Scene {\n        WindowGroup {\n            ContentView()\n                .environment(\\.managedObjectContext, dataController.container.viewContext)\n        }\n    }\n}\n```\n\n在`ContentView`或其任何子视图中，您都可以通过`@Environment`来获取上下文。\n\n**总结**\n\nSwiftUI与Core Data的集成使得数据管理变得直观和无缝。通过定义数据模型、执行数据操作以及将数据变化反馈到UI，可以构建出响应式的用户界面。确保正确地处理数据操作中的错误，并在需要的地方更新视图。接下来的小节将深入探讨如何优化数据操作，以及如何将Core Data与CloudKit结合使用，实现数据的云同步和共享。\n\n\n**第3小节：使用CloudKit进行数据同步**\n\nCore Data与CloudKit的集成为数据提供了一个强大的云同步功能。通过这种集成，用户可以在不同的设备之间无缝同步数据，同时还可以分享数据到其他用户。在本小节中，我们将深入探讨如何设置和使用CloudKit进行数据同步。\n\n### CloudKit 概述\n\nCloudKit是苹果提供的一个后端存储解决方案，它可以让开发者存储数据在iCloud上，实现跨设备的数据同步。与Core Data集成后，CloudKit可以自动处理网络请求、数据缓存以及差异合并等复杂任务。\n\n### 设置CloudKit\n\n在Xcode中启用CloudKit非常简单。首先需要在应用的Capabilities选项中打开iCloud，并勾选CloudKit。这样做将为您的应用创建一个iCloud container。\n\n然后，确保您的Core Data模型设置正确。在.xcdatamodeld文件的数据模型编辑器中，选择模型文件，然后在Model Inspector中勾选“Use CloudKit”。\n\n### 模型和记录类型\n\n在CloudKit中，每个Core Data实体将映射到一个CloudKit记录类型（CKRecordType）。实体的属性和关系将映射为记录的字段。在设置实体时，需要注意数据类型的兼容性，以确保顺利映射。\n\n### 数据同步\n\n#### 初始化同步\n\n使用`NSPersistentCloudKitContainer`作为您的持久化容器，可以实现Core Data和CloudKit之间的数据同步。在应用启动时，你需要设置持久化容器来初始化CloudKit同步。\n\n```swift\nimport CoreData\n\nclass DataController: ObservableObject {\n    let container: NSPersistentCloudKitContainer\n\n    init() {\n        container = NSPersistentCloudKitContainer(name: \"Model\")\n\n        guard let description = container.persistentStoreDescriptions.first else {\n            fatalError(\"Persistent store description was not found.\")\n        }\n        \n        description.setOption(true as NSNumber, forKey: NSPersistentStoreRemoteChangeNotificationPostOptionKey)\n        \n        container.loadPersistentStores { storeDescription, error in\n            if let error = error as NSError? {\n                fatalError(\"Unresolved error \\(error), \\(error.userInfo)\")\n            }\n        }\n    }\n}\n```\n\n在上述代码中，`NSPersistentStoreRemoteChangeNotificationPostOptionKey`选项允许您接收到数据变更通知。\n\n#### 监听数据变化\n\n为了让您的用户界面响应CloudKit的数据变更，您可以监听`NSPersistentStoreRemoteChange`通知。每当CloudKit中的数据发生变化时，都会发送通知，并且您可以更新UI。\n\n```swift\nNotificationCenter.default.addObserver(\n    self,\n    selector: #selector(handleDataChangeNotification(_:)),\n    name: .NSPersistentStoreRemoteChange,\n    object: nil\n)\n\n@objc\nfunc handleDataChangeNotification(_ notification: Notification) {\n    // 在这里处理数据变化，更新UI\n}\n```\n\n### 数据冲突和合并\n\n处理数据冲突是云同步的重要方面。Core Data和CloudKit集成提供了一种自动的冲突解决策略。默认情况下，最后写入的数据将会“赢”，覆盖之前的数据。如果需要，也可以自定义冲突解决策略。\n\n### 调试和错误处理\n\n当处理云同步时，调试和错误处理是不可或缺的。您应当仔细检查错误日志，并对可能的同步错误做出反应。\n\n### 总结\n\n将Core Data与CloudKit集成，为应用添加云同步功能，可以极大地改善用户体验。通过简单的设置和API调用，您可以实现数据在多个设备间的同步，并允许用户之间共享数据。确保在实现过程中，处理好初始化同步、数据变更监听、数据冲突及错误处理等关键环节。在后续小节中，我们将讨论如何利用Cloud\n\nKit的高级特性来构建更为复杂的云同步方案。","source":"_posts/SwiftUI核心技术第10章集成Core-Data和CloudKit.md","raw":"---\ntitle: SwiftUI核心技术第10章集成Core Data和CloudKit\ndate: 2023-11-08 09:20:39\ncategories:\n- SwiftUI\ntags:\n---\n**第10章：集成Core Data和CloudKit**\n\n**第1小节：Core Data概念和配置**\n\nCore Data是Apple提供的一套强大的框架，用于iOS、macOS、watchOS和tvOS应用的数据管理。它提供了对象图管理和持久化支持，使得开发者可以高效地存储和查询数据而无需直接操作数据库。在本小节中，我们将深入了解Core Data的基本概念，并指导如何在SwiftUI应用中进行配置。\n\n**Core Data的关键概念**\n\n1. **托管对象模型（Managed Object Model）**：作为Core Data的基础，定义了应用的数据模型。它通常通过Xcode的数据模型编辑器图形化地创建，并保存为.xcdatamodeld文件。\n\n2. **托管对象上下文（Managed Object Context）**：是在应用和数据库之间进行交互的主要接口。它管理应用中的数据对象。\n\n3. **持久化存储协调器（Persistent Store Coordinator）**：负责管理数据的存储。它连接数据模型和数据存储。\n\n4. **托管对象（Managed Object）**：对数据模型中定义的实体（Entity）的实例，它在上下文中被管理。\n\n5. **实体（Entity）**：数据模型中定义的一个数据结构，对应于传统数据库中的表。\n\n6. **属性（Attribute）**：实体中的字段，用来定义存储数据的类型。\n\n7. **关系（Relationship）**：定义实体间的连接，类似于数据库中的外键。\n\n8. **获取请求（Fetch Request）**：用来查询数据模型，返回一个或多个托管对象。\n\n**配置Core Data**\n\n在SwiftUI中配置Core Data通常遵循以下步骤：\n\n1. **创建数据模型**：在Xcode中新建一个数据模型文件，并添加必要的实体和属性。\n\n2. **添加Core Data堆栈**：设置托管对象模型、持久化存储协调器和托管对象上下文。在Xcode项目模板中，如果选择了使用Core Data，则大部分配置已由模板自动生成。\n\n3. **初始化Core Data堆栈**：通常在应用启动时进行，例如在`AppDelegate`或`SceneDelegate`中。\n\n4. **在SwiftUI视图中使用**：在SwiftUI视图中，通过环境变量`@Environment(\\.managedObjectContext)`访问托管对象上下文。\n\n**示例代码：配置Core Data环境**\n\n```swift\nimport CoreData\n\n// 通常在AppDelegate或类似的地方进行初始化\nclass DataController: ObservableObject {\n    let container: NSPersistentContainer\n\n    init() {\n        container = NSPersistentContainer(name: \"Model\")\n        container.loadPersistentStores { (storeDescription, error) in\n            if let error = error as NSError? {\n                // 实际应用中应处理错误，这里简化了处理\n                fatalError(\"Unresolved error \\(error), \\(error.userInfo)\")\n            }\n        }\n    }\n}\n\n// SwiftUI视图中使用\nstruct ContentView: View {\n    @Environment(\\.managedObjectContext) var managedObjectContext\n\n    var body: some View {\n        // ...\n    }\n}\n```\n\n在上述代码中，`DataController`负责初始化Core Data堆栈，并加载持久化存储。在SwiftUI视图中，我们通过`@Environment`属性包装器注入了托管对象上下文，以便在视图中使用。\n\n**总结**\n\nCore Data是一个强大的框架，它为数据持久化和管理提供了丰富的功能。理解其核心概念并在SwiftUI项目中进行正确配置，是高效使用该框架的关键。随后的小节中，我们将探讨如何使用Core Data进行数据的创建、读取、更新和删除操作，以及如何将Core Data与CloudKit集成，实现数据的云同步。\n\n\n**第2小节：SwiftUI中的Core Data集成**\n\n在SwiftUI应用中集成Core Data可以让我们更加便捷地管理模型层数据。这个过程涉及到模型定义、上下文管理和视图更新。在本小节，我们将详细介绍如何在SwiftUI中集成Core Data。\n\n**模型定义**\n\n模型定义是使用Core Data的第一步。在Xcode的模型编辑器中，您可以定义实体、属性和关系。这些模型元素代表了应用中的数据结构。对于每一个实体，Core Data都能自动生成对应的`NSManagedObject`子类，您可以直接在代码中使用。\n\n**示例代码：定义一个Person实体**\n\n```swift\nimport CoreData\n\n// 假设在.xcdatamodeld文件中已经定义了Person实体及其属性\npublic class Person: NSManagedObject {\n    @NSManaged public var id: UUID\n    @NSManaged public var name: String\n    @NSManaged public var age: Int16\n}\n```\n\n**集成到SwiftUI视图**\n\n在SwiftUI中，通过`@FetchRequest`属性包装器可以创建对Core Data实体的查询请求，并将结果直接绑定到用户界面。当底层数据变化时，界面也会自动更新。\n\n**示例代码：使用`@FetchRequest`展示数据**\n\n```swift\nimport SwiftUI\nimport CoreData\n\nstruct PersonListView: View {\n    @Environment(\\.managedObjectContext) private var viewContext\n    @FetchRequest(\n        sortDescriptors: [NSSortDescriptor(keyPath: \\Person.name, ascending: true)],\n        animation: .default)\n    private var persons: FetchedResults<Person>\n\n    var body: some View {\n        List {\n            ForEach(persons, id: \\.id) { person in\n                Text(person.name)\n            }\n        }\n    }\n}\n```\n\n在上面的代码中，`@FetchRequest`初始化了一个请求来获取所有`Person`对象，并按`name`属性升序排序。`persons`数组将自动更新，以反映数据库中的数据。\n\n**数据操作**\n\n对于Core Data中的数据，您可以使用托管对象上下文（`NSManagedObjectContext`）进行操作，包括创建新对象、修改属性、保存更改或删除对象。\n\n**示例代码：添加新Person对象**\n\n```swift\nfunc addPerson(name: String, age: Int16) {\n    let newPerson = Person(context: viewContext)\n    newPerson.id = UUID()\n    newPerson.name = name\n    newPerson.age = age\n\n    do {\n        try viewContext.save()\n    } catch {\n        // 这里处理错误\n        let nsError = error as NSError\n        fatalError(\"Unresolved error \\(nsError), \\(nsError.userInfo)\")\n    }\n}\n```\n\n**SwiftUI中的Context传递**\n\n在SwiftUI应用中，托管对象上下文是通过环境传递的。这意味着您可以在应用的顶层视图中设置上下文，并通过环境变量在子视图中访问。\n\n```swift\n@main\nstruct MyApp: App {\n    let dataController = DataController()\n\n    var body: some Scene {\n        WindowGroup {\n            ContentView()\n                .environment(\\.managedObjectContext, dataController.container.viewContext)\n        }\n    }\n}\n```\n\n在`ContentView`或其任何子视图中，您都可以通过`@Environment`来获取上下文。\n\n**总结**\n\nSwiftUI与Core Data的集成使得数据管理变得直观和无缝。通过定义数据模型、执行数据操作以及将数据变化反馈到UI，可以构建出响应式的用户界面。确保正确地处理数据操作中的错误，并在需要的地方更新视图。接下来的小节将深入探讨如何优化数据操作，以及如何将Core Data与CloudKit结合使用，实现数据的云同步和共享。\n\n\n**第3小节：使用CloudKit进行数据同步**\n\nCore Data与CloudKit的集成为数据提供了一个强大的云同步功能。通过这种集成，用户可以在不同的设备之间无缝同步数据，同时还可以分享数据到其他用户。在本小节中，我们将深入探讨如何设置和使用CloudKit进行数据同步。\n\n### CloudKit 概述\n\nCloudKit是苹果提供的一个后端存储解决方案，它可以让开发者存储数据在iCloud上，实现跨设备的数据同步。与Core Data集成后，CloudKit可以自动处理网络请求、数据缓存以及差异合并等复杂任务。\n\n### 设置CloudKit\n\n在Xcode中启用CloudKit非常简单。首先需要在应用的Capabilities选项中打开iCloud，并勾选CloudKit。这样做将为您的应用创建一个iCloud container。\n\n然后，确保您的Core Data模型设置正确。在.xcdatamodeld文件的数据模型编辑器中，选择模型文件，然后在Model Inspector中勾选“Use CloudKit”。\n\n### 模型和记录类型\n\n在CloudKit中，每个Core Data实体将映射到一个CloudKit记录类型（CKRecordType）。实体的属性和关系将映射为记录的字段。在设置实体时，需要注意数据类型的兼容性，以确保顺利映射。\n\n### 数据同步\n\n#### 初始化同步\n\n使用`NSPersistentCloudKitContainer`作为您的持久化容器，可以实现Core Data和CloudKit之间的数据同步。在应用启动时，你需要设置持久化容器来初始化CloudKit同步。\n\n```swift\nimport CoreData\n\nclass DataController: ObservableObject {\n    let container: NSPersistentCloudKitContainer\n\n    init() {\n        container = NSPersistentCloudKitContainer(name: \"Model\")\n\n        guard let description = container.persistentStoreDescriptions.first else {\n            fatalError(\"Persistent store description was not found.\")\n        }\n        \n        description.setOption(true as NSNumber, forKey: NSPersistentStoreRemoteChangeNotificationPostOptionKey)\n        \n        container.loadPersistentStores { storeDescription, error in\n            if let error = error as NSError? {\n                fatalError(\"Unresolved error \\(error), \\(error.userInfo)\")\n            }\n        }\n    }\n}\n```\n\n在上述代码中，`NSPersistentStoreRemoteChangeNotificationPostOptionKey`选项允许您接收到数据变更通知。\n\n#### 监听数据变化\n\n为了让您的用户界面响应CloudKit的数据变更，您可以监听`NSPersistentStoreRemoteChange`通知。每当CloudKit中的数据发生变化时，都会发送通知，并且您可以更新UI。\n\n```swift\nNotificationCenter.default.addObserver(\n    self,\n    selector: #selector(handleDataChangeNotification(_:)),\n    name: .NSPersistentStoreRemoteChange,\n    object: nil\n)\n\n@objc\nfunc handleDataChangeNotification(_ notification: Notification) {\n    // 在这里处理数据变化，更新UI\n}\n```\n\n### 数据冲突和合并\n\n处理数据冲突是云同步的重要方面。Core Data和CloudKit集成提供了一种自动的冲突解决策略。默认情况下，最后写入的数据将会“赢”，覆盖之前的数据。如果需要，也可以自定义冲突解决策略。\n\n### 调试和错误处理\n\n当处理云同步时，调试和错误处理是不可或缺的。您应当仔细检查错误日志，并对可能的同步错误做出反应。\n\n### 总结\n\n将Core Data与CloudKit集成，为应用添加云同步功能，可以极大地改善用户体验。通过简单的设置和API调用，您可以实现数据在多个设备间的同步，并允许用户之间共享数据。确保在实现过程中，处理好初始化同步、数据变更监听、数据冲突及错误处理等关键环节。在后续小节中，我们将讨论如何利用Cloud\n\nKit的高级特性来构建更为复杂的云同步方案。","slug":"SwiftUI核心技术第10章集成Core-Data和CloudKit","published":1,"updated":"2024-03-17T06:11:48.022Z","comments":1,"layout":"post","photos":[],"_id":"clu6up53h0024z67499gag7dm","content":"<p><strong>第10章：集成Core Data和CloudKit</strong></p>\n<p><strong>第1小节：Core Data概念和配置</strong></p>\n<p>Core Data是Apple提供的一套强大的框架，用于iOS、macOS、watchOS和tvOS应用的数据管理。它提供了对象图管理和持久化支持，使得开发者可以高效地存储和查询数据而无需直接操作数据库。在本小节中，我们将深入了解Core Data的基本概念，并指导如何在SwiftUI应用中进行配置。</p>\n<p><strong>Core Data的关键概念</strong></p>\n<ol>\n<li><p><strong>托管对象模型（Managed Object Model）</strong>：作为Core Data的基础，定义了应用的数据模型。它通常通过Xcode的数据模型编辑器图形化地创建，并保存为.xcdatamodeld文件。</p>\n</li>\n<li><p><strong>托管对象上下文（Managed Object Context）</strong>：是在应用和数据库之间进行交互的主要接口。它管理应用中的数据对象。</p>\n</li>\n<li><p><strong>持久化存储协调器（Persistent Store Coordinator）</strong>：负责管理数据的存储。它连接数据模型和数据存储。</p>\n</li>\n<li><p><strong>托管对象（Managed Object）</strong>：对数据模型中定义的实体（Entity）的实例，它在上下文中被管理。</p>\n</li>\n<li><p><strong>实体（Entity）</strong>：数据模型中定义的一个数据结构，对应于传统数据库中的表。</p>\n</li>\n<li><p><strong>属性（Attribute）</strong>：实体中的字段，用来定义存储数据的类型。</p>\n</li>\n<li><p><strong>关系（Relationship）</strong>：定义实体间的连接，类似于数据库中的外键。</p>\n</li>\n<li><p><strong>获取请求（Fetch Request）</strong>：用来查询数据模型，返回一个或多个托管对象。</p>\n</li>\n</ol>\n<p><strong>配置Core Data</strong></p>\n<p>在SwiftUI中配置Core Data通常遵循以下步骤：</p>\n<ol>\n<li><p><strong>创建数据模型</strong>：在Xcode中新建一个数据模型文件，并添加必要的实体和属性。</p>\n</li>\n<li><p><strong>添加Core Data堆栈</strong>：设置托管对象模型、持久化存储协调器和托管对象上下文。在Xcode项目模板中，如果选择了使用Core Data，则大部分配置已由模板自动生成。</p>\n</li>\n<li><p><strong>初始化Core Data堆栈</strong>：通常在应用启动时进行，例如在<code>AppDelegate</code>或<code>SceneDelegate</code>中。</p>\n</li>\n<li><p><strong>在SwiftUI视图中使用</strong>：在SwiftUI视图中，通过环境变量<code>@Environment(\\.managedObjectContext)</code>访问托管对象上下文。</p>\n</li>\n</ol>\n<p><strong>示例代码：配置Core Data环境</strong></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">import</span> CoreData<br><br><span class=\"hljs-comment\">// 通常在AppDelegate或类似的地方进行初始化</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">DataController</span>: <span class=\"hljs-title class_\">ObservableObject</span> &#123;<br>    <span class=\"hljs-keyword\">let</span> container: <span class=\"hljs-type\">NSPersistentContainer</span><br><br>    <span class=\"hljs-keyword\">init</span>() &#123;<br>        container <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">NSPersistentContainer</span>(name: <span class=\"hljs-string\">&quot;Model&quot;</span>)<br>        container.loadPersistentStores &#123; (storeDescription, error) <span class=\"hljs-keyword\">in</span><br>            <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">let</span> error <span class=\"hljs-operator\">=</span> error <span class=\"hljs-keyword\">as</span> <span class=\"hljs-type\">NSError</span>? &#123;<br>                <span class=\"hljs-comment\">// 实际应用中应处理错误，这里简化了处理</span><br>                <span class=\"hljs-built_in\">fatalError</span>(<span class=\"hljs-string\">&quot;Unresolved error <span class=\"hljs-subst\">\\(error)</span>, <span class=\"hljs-subst\">\\(error.userInfo)</span>&quot;</span>)<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\">// SwiftUI视图中使用</span><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ContentView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@Environment</span>(\\.managedObjectContext) <span class=\"hljs-keyword\">var</span> managedObjectContext<br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-comment\">// ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在上述代码中，<code>DataController</code>负责初始化Core Data堆栈，并加载持久化存储。在SwiftUI视图中，我们通过<code>@Environment</code>属性包装器注入了托管对象上下文，以便在视图中使用。</p>\n<p><strong>总结</strong></p>\n<p>Core Data是一个强大的框架，它为数据持久化和管理提供了丰富的功能。理解其核心概念并在SwiftUI项目中进行正确配置，是高效使用该框架的关键。随后的小节中，我们将探讨如何使用Core Data进行数据的创建、读取、更新和删除操作，以及如何将Core Data与CloudKit集成，实现数据的云同步。</p>\n<p><strong>第2小节：SwiftUI中的Core Data集成</strong></p>\n<p>在SwiftUI应用中集成Core Data可以让我们更加便捷地管理模型层数据。这个过程涉及到模型定义、上下文管理和视图更新。在本小节，我们将详细介绍如何在SwiftUI中集成Core Data。</p>\n<p><strong>模型定义</strong></p>\n<p>模型定义是使用Core Data的第一步。在Xcode的模型编辑器中，您可以定义实体、属性和关系。这些模型元素代表了应用中的数据结构。对于每一个实体，Core Data都能自动生成对应的<code>NSManagedObject</code>子类，您可以直接在代码中使用。</p>\n<p><strong>示例代码：定义一个Person实体</strong></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">import</span> CoreData<br><br><span class=\"hljs-comment\">// 假设在.xcdatamodeld文件中已经定义了Person实体及其属性</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Person</span>: <span class=\"hljs-title class_\">NSManagedObject</span> &#123;<br>    <span class=\"hljs-keyword\">@NSManaged</span> <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">var</span> id: <span class=\"hljs-type\">UUID</span><br>    <span class=\"hljs-keyword\">@NSManaged</span> <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">var</span> name: <span class=\"hljs-type\">String</span><br>    <span class=\"hljs-keyword\">@NSManaged</span> <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">var</span> age: <span class=\"hljs-type\">Int16</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>集成到SwiftUI视图</strong></p>\n<p>在SwiftUI中，通过<code>@FetchRequest</code>属性包装器可以创建对Core Data实体的查询请求，并将结果直接绑定到用户界面。当底层数据变化时，界面也会自动更新。</p>\n<p><strong>示例代码：使用<code>@FetchRequest</code>展示数据</strong></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">import</span> SwiftUI<br><span class=\"hljs-keyword\">import</span> CoreData<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">PersonListView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@Environment</span>(\\.managedObjectContext) <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> viewContext<br>    <span class=\"hljs-meta\">@FetchRequest</span>(<br>        sortDescriptors: [<span class=\"hljs-type\">NSSortDescriptor</span>(keyPath: \\<span class=\"hljs-type\">Person</span>.name, ascending: <span class=\"hljs-literal\">true</span>)],<br>        animation: .default)<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> persons: <span class=\"hljs-type\">FetchedResults</span>&lt;<span class=\"hljs-type\">Person</span>&gt;<br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">List</span> &#123;<br>            <span class=\"hljs-type\">ForEach</span>(persons, id: \\.id) &#123; person <span class=\"hljs-keyword\">in</span><br>                <span class=\"hljs-type\">Text</span>(person.name)<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在上面的代码中，<code>@FetchRequest</code>初始化了一个请求来获取所有<code>Person</code>对象，并按<code>name</code>属性升序排序。<code>persons</code>数组将自动更新，以反映数据库中的数据。</p>\n<p><strong>数据操作</strong></p>\n<p>对于Core Data中的数据，您可以使用托管对象上下文（<code>NSManagedObjectContext</code>）进行操作，包括创建新对象、修改属性、保存更改或删除对象。</p>\n<p><strong>示例代码：添加新Person对象</strong></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">addPerson</span>(<span class=\"hljs-params\">name</span>: <span class=\"hljs-type\">String</span>, <span class=\"hljs-params\">age</span>: <span class=\"hljs-type\">Int16</span>) &#123;<br>    <span class=\"hljs-keyword\">let</span> newPerson <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">Person</span>(context: viewContext)<br>    newPerson.id <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">UUID</span>()<br>    newPerson.name <span class=\"hljs-operator\">=</span> name<br>    newPerson.age <span class=\"hljs-operator\">=</span> age<br><br>    <span class=\"hljs-keyword\">do</span> &#123;<br>        <span class=\"hljs-keyword\">try</span> viewContext.save()<br>    &#125; <span class=\"hljs-keyword\">catch</span> &#123;<br>        <span class=\"hljs-comment\">// 这里处理错误</span><br>        <span class=\"hljs-keyword\">let</span> nsError <span class=\"hljs-operator\">=</span> error <span class=\"hljs-keyword\">as</span> <span class=\"hljs-type\">NSError</span><br>        <span class=\"hljs-built_in\">fatalError</span>(<span class=\"hljs-string\">&quot;Unresolved error <span class=\"hljs-subst\">\\(nsError)</span>, <span class=\"hljs-subst\">\\(nsError.userInfo)</span>&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>SwiftUI中的Context传递</strong></p>\n<p>在SwiftUI应用中，托管对象上下文是通过环境传递的。这意味着您可以在应用的顶层视图中设置上下文，并通过环境变量在子视图中访问。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">@main</span><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">MyApp</span>: <span class=\"hljs-title class_\">App</span> &#123;<br>    <span class=\"hljs-keyword\">let</span> dataController <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">DataController</span>()<br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">Scene</span> &#123;<br>        <span class=\"hljs-type\">WindowGroup</span> &#123;<br>            <span class=\"hljs-type\">ContentView</span>()<br>                .environment(\\.managedObjectContext, dataController.container.viewContext)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在<code>ContentView</code>或其任何子视图中，您都可以通过<code>@Environment</code>来获取上下文。</p>\n<p><strong>总结</strong></p>\n<p>SwiftUI与Core Data的集成使得数据管理变得直观和无缝。通过定义数据模型、执行数据操作以及将数据变化反馈到UI，可以构建出响应式的用户界面。确保正确地处理数据操作中的错误，并在需要的地方更新视图。接下来的小节将深入探讨如何优化数据操作，以及如何将Core Data与CloudKit结合使用，实现数据的云同步和共享。</p>\n<p><strong>第3小节：使用CloudKit进行数据同步</strong></p>\n<p>Core Data与CloudKit的集成为数据提供了一个强大的云同步功能。通过这种集成，用户可以在不同的设备之间无缝同步数据，同时还可以分享数据到其他用户。在本小节中，我们将深入探讨如何设置和使用CloudKit进行数据同步。</p>\n<h3 id=\"CloudKit-概述\"><a href=\"#CloudKit-概述\" class=\"headerlink\" title=\"CloudKit 概述\"></a>CloudKit 概述</h3><p>CloudKit是苹果提供的一个后端存储解决方案，它可以让开发者存储数据在iCloud上，实现跨设备的数据同步。与Core Data集成后，CloudKit可以自动处理网络请求、数据缓存以及差异合并等复杂任务。</p>\n<h3 id=\"设置CloudKit\"><a href=\"#设置CloudKit\" class=\"headerlink\" title=\"设置CloudKit\"></a>设置CloudKit</h3><p>在Xcode中启用CloudKit非常简单。首先需要在应用的Capabilities选项中打开iCloud，并勾选CloudKit。这样做将为您的应用创建一个iCloud container。</p>\n<p>然后，确保您的Core Data模型设置正确。在.xcdatamodeld文件的数据模型编辑器中，选择模型文件，然后在Model Inspector中勾选“Use CloudKit”。</p>\n<h3 id=\"模型和记录类型\"><a href=\"#模型和记录类型\" class=\"headerlink\" title=\"模型和记录类型\"></a>模型和记录类型</h3><p>在CloudKit中，每个Core Data实体将映射到一个CloudKit记录类型（CKRecordType）。实体的属性和关系将映射为记录的字段。在设置实体时，需要注意数据类型的兼容性，以确保顺利映射。</p>\n<h3 id=\"数据同步\"><a href=\"#数据同步\" class=\"headerlink\" title=\"数据同步\"></a>数据同步</h3><h4 id=\"初始化同步\"><a href=\"#初始化同步\" class=\"headerlink\" title=\"初始化同步\"></a>初始化同步</h4><p>使用<code>NSPersistentCloudKitContainer</code>作为您的持久化容器，可以实现Core Data和CloudKit之间的数据同步。在应用启动时，你需要设置持久化容器来初始化CloudKit同步。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">import</span> CoreData<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">DataController</span>: <span class=\"hljs-title class_\">ObservableObject</span> &#123;<br>    <span class=\"hljs-keyword\">let</span> container: <span class=\"hljs-type\">NSPersistentCloudKitContainer</span><br><br>    <span class=\"hljs-keyword\">init</span>() &#123;<br>        container <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">NSPersistentCloudKitContainer</span>(name: <span class=\"hljs-string\">&quot;Model&quot;</span>)<br><br>        <span class=\"hljs-keyword\">guard</span> <span class=\"hljs-keyword\">let</span> description <span class=\"hljs-operator\">=</span> container.persistentStoreDescriptions.first <span class=\"hljs-keyword\">else</span> &#123;<br>            <span class=\"hljs-built_in\">fatalError</span>(<span class=\"hljs-string\">&quot;Persistent store description was not found.&quot;</span>)<br>        &#125;<br>        <br>        description.setOption(<span class=\"hljs-literal\">true</span> <span class=\"hljs-keyword\">as</span> <span class=\"hljs-type\">NSNumber</span>, forKey: <span class=\"hljs-type\">NSPersistentStoreRemoteChangeNotificationPostOptionKey</span>)<br>        <br>        container.loadPersistentStores &#123; storeDescription, error <span class=\"hljs-keyword\">in</span><br>            <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">let</span> error <span class=\"hljs-operator\">=</span> error <span class=\"hljs-keyword\">as</span> <span class=\"hljs-type\">NSError</span>? &#123;<br>                <span class=\"hljs-built_in\">fatalError</span>(<span class=\"hljs-string\">&quot;Unresolved error <span class=\"hljs-subst\">\\(error)</span>, <span class=\"hljs-subst\">\\(error.userInfo)</span>&quot;</span>)<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在上述代码中，<code>NSPersistentStoreRemoteChangeNotificationPostOptionKey</code>选项允许您接收到数据变更通知。</p>\n<h4 id=\"监听数据变化\"><a href=\"#监听数据变化\" class=\"headerlink\" title=\"监听数据变化\"></a>监听数据变化</h4><p>为了让您的用户界面响应CloudKit的数据变更，您可以监听<code>NSPersistentStoreRemoteChange</code>通知。每当CloudKit中的数据发生变化时，都会发送通知，并且您可以更新UI。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">NotificationCenter</span>.default.addObserver(<br>    <span class=\"hljs-keyword\">self</span>,<br>    selector: <span class=\"hljs-keyword\">#selector</span>(handleDataChangeNotification(<span class=\"hljs-keyword\">_</span>:)),<br>    name: .<span class=\"hljs-type\">NSPersistentStoreRemoteChange</span>,<br>    object: <span class=\"hljs-literal\">nil</span><br>)<br><br><span class=\"hljs-keyword\">@objc</span><br><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">handleDataChangeNotification</span>(<span class=\"hljs-keyword\">_</span> <span class=\"hljs-params\">notification</span>: <span class=\"hljs-type\">Notification</span>) &#123;<br>    <span class=\"hljs-comment\">// 在这里处理数据变化，更新UI</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"数据冲突和合并\"><a href=\"#数据冲突和合并\" class=\"headerlink\" title=\"数据冲突和合并\"></a>数据冲突和合并</h3><p>处理数据冲突是云同步的重要方面。Core Data和CloudKit集成提供了一种自动的冲突解决策略。默认情况下，最后写入的数据将会“赢”，覆盖之前的数据。如果需要，也可以自定义冲突解决策略。</p>\n<h3 id=\"调试和错误处理\"><a href=\"#调试和错误处理\" class=\"headerlink\" title=\"调试和错误处理\"></a>调试和错误处理</h3><p>当处理云同步时，调试和错误处理是不可或缺的。您应当仔细检查错误日志，并对可能的同步错误做出反应。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>将Core Data与CloudKit集成，为应用添加云同步功能，可以极大地改善用户体验。通过简单的设置和API调用，您可以实现数据在多个设备间的同步，并允许用户之间共享数据。确保在实现过程中，处理好初始化同步、数据变更监听、数据冲突及错误处理等关键环节。在后续小节中，我们将讨论如何利用Cloud</p>\n<p>Kit的高级特性来构建更为复杂的云同步方案。</p>\n","excerpt":"","more":"<p><strong>第10章：集成Core Data和CloudKit</strong></p>\n<p><strong>第1小节：Core Data概念和配置</strong></p>\n<p>Core Data是Apple提供的一套强大的框架，用于iOS、macOS、watchOS和tvOS应用的数据管理。它提供了对象图管理和持久化支持，使得开发者可以高效地存储和查询数据而无需直接操作数据库。在本小节中，我们将深入了解Core Data的基本概念，并指导如何在SwiftUI应用中进行配置。</p>\n<p><strong>Core Data的关键概念</strong></p>\n<ol>\n<li><p><strong>托管对象模型（Managed Object Model）</strong>：作为Core Data的基础，定义了应用的数据模型。它通常通过Xcode的数据模型编辑器图形化地创建，并保存为.xcdatamodeld文件。</p>\n</li>\n<li><p><strong>托管对象上下文（Managed Object Context）</strong>：是在应用和数据库之间进行交互的主要接口。它管理应用中的数据对象。</p>\n</li>\n<li><p><strong>持久化存储协调器（Persistent Store Coordinator）</strong>：负责管理数据的存储。它连接数据模型和数据存储。</p>\n</li>\n<li><p><strong>托管对象（Managed Object）</strong>：对数据模型中定义的实体（Entity）的实例，它在上下文中被管理。</p>\n</li>\n<li><p><strong>实体（Entity）</strong>：数据模型中定义的一个数据结构，对应于传统数据库中的表。</p>\n</li>\n<li><p><strong>属性（Attribute）</strong>：实体中的字段，用来定义存储数据的类型。</p>\n</li>\n<li><p><strong>关系（Relationship）</strong>：定义实体间的连接，类似于数据库中的外键。</p>\n</li>\n<li><p><strong>获取请求（Fetch Request）</strong>：用来查询数据模型，返回一个或多个托管对象。</p>\n</li>\n</ol>\n<p><strong>配置Core Data</strong></p>\n<p>在SwiftUI中配置Core Data通常遵循以下步骤：</p>\n<ol>\n<li><p><strong>创建数据模型</strong>：在Xcode中新建一个数据模型文件，并添加必要的实体和属性。</p>\n</li>\n<li><p><strong>添加Core Data堆栈</strong>：设置托管对象模型、持久化存储协调器和托管对象上下文。在Xcode项目模板中，如果选择了使用Core Data，则大部分配置已由模板自动生成。</p>\n</li>\n<li><p><strong>初始化Core Data堆栈</strong>：通常在应用启动时进行，例如在<code>AppDelegate</code>或<code>SceneDelegate</code>中。</p>\n</li>\n<li><p><strong>在SwiftUI视图中使用</strong>：在SwiftUI视图中，通过环境变量<code>@Environment(\\.managedObjectContext)</code>访问托管对象上下文。</p>\n</li>\n</ol>\n<p><strong>示例代码：配置Core Data环境</strong></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">import</span> CoreData<br><br><span class=\"hljs-comment\">// 通常在AppDelegate或类似的地方进行初始化</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">DataController</span>: <span class=\"hljs-title class_\">ObservableObject</span> &#123;<br>    <span class=\"hljs-keyword\">let</span> container: <span class=\"hljs-type\">NSPersistentContainer</span><br><br>    <span class=\"hljs-keyword\">init</span>() &#123;<br>        container <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">NSPersistentContainer</span>(name: <span class=\"hljs-string\">&quot;Model&quot;</span>)<br>        container.loadPersistentStores &#123; (storeDescription, error) <span class=\"hljs-keyword\">in</span><br>            <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">let</span> error <span class=\"hljs-operator\">=</span> error <span class=\"hljs-keyword\">as</span> <span class=\"hljs-type\">NSError</span>? &#123;<br>                <span class=\"hljs-comment\">// 实际应用中应处理错误，这里简化了处理</span><br>                <span class=\"hljs-built_in\">fatalError</span>(<span class=\"hljs-string\">&quot;Unresolved error <span class=\"hljs-subst\">\\(error)</span>, <span class=\"hljs-subst\">\\(error.userInfo)</span>&quot;</span>)<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\">// SwiftUI视图中使用</span><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ContentView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@Environment</span>(\\.managedObjectContext) <span class=\"hljs-keyword\">var</span> managedObjectContext<br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-comment\">// ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在上述代码中，<code>DataController</code>负责初始化Core Data堆栈，并加载持久化存储。在SwiftUI视图中，我们通过<code>@Environment</code>属性包装器注入了托管对象上下文，以便在视图中使用。</p>\n<p><strong>总结</strong></p>\n<p>Core Data是一个强大的框架，它为数据持久化和管理提供了丰富的功能。理解其核心概念并在SwiftUI项目中进行正确配置，是高效使用该框架的关键。随后的小节中，我们将探讨如何使用Core Data进行数据的创建、读取、更新和删除操作，以及如何将Core Data与CloudKit集成，实现数据的云同步。</p>\n<p><strong>第2小节：SwiftUI中的Core Data集成</strong></p>\n<p>在SwiftUI应用中集成Core Data可以让我们更加便捷地管理模型层数据。这个过程涉及到模型定义、上下文管理和视图更新。在本小节，我们将详细介绍如何在SwiftUI中集成Core Data。</p>\n<p><strong>模型定义</strong></p>\n<p>模型定义是使用Core Data的第一步。在Xcode的模型编辑器中，您可以定义实体、属性和关系。这些模型元素代表了应用中的数据结构。对于每一个实体，Core Data都能自动生成对应的<code>NSManagedObject</code>子类，您可以直接在代码中使用。</p>\n<p><strong>示例代码：定义一个Person实体</strong></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">import</span> CoreData<br><br><span class=\"hljs-comment\">// 假设在.xcdatamodeld文件中已经定义了Person实体及其属性</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Person</span>: <span class=\"hljs-title class_\">NSManagedObject</span> &#123;<br>    <span class=\"hljs-keyword\">@NSManaged</span> <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">var</span> id: <span class=\"hljs-type\">UUID</span><br>    <span class=\"hljs-keyword\">@NSManaged</span> <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">var</span> name: <span class=\"hljs-type\">String</span><br>    <span class=\"hljs-keyword\">@NSManaged</span> <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">var</span> age: <span class=\"hljs-type\">Int16</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>集成到SwiftUI视图</strong></p>\n<p>在SwiftUI中，通过<code>@FetchRequest</code>属性包装器可以创建对Core Data实体的查询请求，并将结果直接绑定到用户界面。当底层数据变化时，界面也会自动更新。</p>\n<p><strong>示例代码：使用<code>@FetchRequest</code>展示数据</strong></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">import</span> SwiftUI<br><span class=\"hljs-keyword\">import</span> CoreData<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">PersonListView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@Environment</span>(\\.managedObjectContext) <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> viewContext<br>    <span class=\"hljs-meta\">@FetchRequest</span>(<br>        sortDescriptors: [<span class=\"hljs-type\">NSSortDescriptor</span>(keyPath: \\<span class=\"hljs-type\">Person</span>.name, ascending: <span class=\"hljs-literal\">true</span>)],<br>        animation: .default)<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> persons: <span class=\"hljs-type\">FetchedResults</span>&lt;<span class=\"hljs-type\">Person</span>&gt;<br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">List</span> &#123;<br>            <span class=\"hljs-type\">ForEach</span>(persons, id: \\.id) &#123; person <span class=\"hljs-keyword\">in</span><br>                <span class=\"hljs-type\">Text</span>(person.name)<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在上面的代码中，<code>@FetchRequest</code>初始化了一个请求来获取所有<code>Person</code>对象，并按<code>name</code>属性升序排序。<code>persons</code>数组将自动更新，以反映数据库中的数据。</p>\n<p><strong>数据操作</strong></p>\n<p>对于Core Data中的数据，您可以使用托管对象上下文（<code>NSManagedObjectContext</code>）进行操作，包括创建新对象、修改属性、保存更改或删除对象。</p>\n<p><strong>示例代码：添加新Person对象</strong></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">addPerson</span>(<span class=\"hljs-params\">name</span>: <span class=\"hljs-type\">String</span>, <span class=\"hljs-params\">age</span>: <span class=\"hljs-type\">Int16</span>) &#123;<br>    <span class=\"hljs-keyword\">let</span> newPerson <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">Person</span>(context: viewContext)<br>    newPerson.id <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">UUID</span>()<br>    newPerson.name <span class=\"hljs-operator\">=</span> name<br>    newPerson.age <span class=\"hljs-operator\">=</span> age<br><br>    <span class=\"hljs-keyword\">do</span> &#123;<br>        <span class=\"hljs-keyword\">try</span> viewContext.save()<br>    &#125; <span class=\"hljs-keyword\">catch</span> &#123;<br>        <span class=\"hljs-comment\">// 这里处理错误</span><br>        <span class=\"hljs-keyword\">let</span> nsError <span class=\"hljs-operator\">=</span> error <span class=\"hljs-keyword\">as</span> <span class=\"hljs-type\">NSError</span><br>        <span class=\"hljs-built_in\">fatalError</span>(<span class=\"hljs-string\">&quot;Unresolved error <span class=\"hljs-subst\">\\(nsError)</span>, <span class=\"hljs-subst\">\\(nsError.userInfo)</span>&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>SwiftUI中的Context传递</strong></p>\n<p>在SwiftUI应用中，托管对象上下文是通过环境传递的。这意味着您可以在应用的顶层视图中设置上下文，并通过环境变量在子视图中访问。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">@main</span><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">MyApp</span>: <span class=\"hljs-title class_\">App</span> &#123;<br>    <span class=\"hljs-keyword\">let</span> dataController <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">DataController</span>()<br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">Scene</span> &#123;<br>        <span class=\"hljs-type\">WindowGroup</span> &#123;<br>            <span class=\"hljs-type\">ContentView</span>()<br>                .environment(\\.managedObjectContext, dataController.container.viewContext)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在<code>ContentView</code>或其任何子视图中，您都可以通过<code>@Environment</code>来获取上下文。</p>\n<p><strong>总结</strong></p>\n<p>SwiftUI与Core Data的集成使得数据管理变得直观和无缝。通过定义数据模型、执行数据操作以及将数据变化反馈到UI，可以构建出响应式的用户界面。确保正确地处理数据操作中的错误，并在需要的地方更新视图。接下来的小节将深入探讨如何优化数据操作，以及如何将Core Data与CloudKit结合使用，实现数据的云同步和共享。</p>\n<p><strong>第3小节：使用CloudKit进行数据同步</strong></p>\n<p>Core Data与CloudKit的集成为数据提供了一个强大的云同步功能。通过这种集成，用户可以在不同的设备之间无缝同步数据，同时还可以分享数据到其他用户。在本小节中，我们将深入探讨如何设置和使用CloudKit进行数据同步。</p>\n<h3 id=\"CloudKit-概述\"><a href=\"#CloudKit-概述\" class=\"headerlink\" title=\"CloudKit 概述\"></a>CloudKit 概述</h3><p>CloudKit是苹果提供的一个后端存储解决方案，它可以让开发者存储数据在iCloud上，实现跨设备的数据同步。与Core Data集成后，CloudKit可以自动处理网络请求、数据缓存以及差异合并等复杂任务。</p>\n<h3 id=\"设置CloudKit\"><a href=\"#设置CloudKit\" class=\"headerlink\" title=\"设置CloudKit\"></a>设置CloudKit</h3><p>在Xcode中启用CloudKit非常简单。首先需要在应用的Capabilities选项中打开iCloud，并勾选CloudKit。这样做将为您的应用创建一个iCloud container。</p>\n<p>然后，确保您的Core Data模型设置正确。在.xcdatamodeld文件的数据模型编辑器中，选择模型文件，然后在Model Inspector中勾选“Use CloudKit”。</p>\n<h3 id=\"模型和记录类型\"><a href=\"#模型和记录类型\" class=\"headerlink\" title=\"模型和记录类型\"></a>模型和记录类型</h3><p>在CloudKit中，每个Core Data实体将映射到一个CloudKit记录类型（CKRecordType）。实体的属性和关系将映射为记录的字段。在设置实体时，需要注意数据类型的兼容性，以确保顺利映射。</p>\n<h3 id=\"数据同步\"><a href=\"#数据同步\" class=\"headerlink\" title=\"数据同步\"></a>数据同步</h3><h4 id=\"初始化同步\"><a href=\"#初始化同步\" class=\"headerlink\" title=\"初始化同步\"></a>初始化同步</h4><p>使用<code>NSPersistentCloudKitContainer</code>作为您的持久化容器，可以实现Core Data和CloudKit之间的数据同步。在应用启动时，你需要设置持久化容器来初始化CloudKit同步。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">import</span> CoreData<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">DataController</span>: <span class=\"hljs-title class_\">ObservableObject</span> &#123;<br>    <span class=\"hljs-keyword\">let</span> container: <span class=\"hljs-type\">NSPersistentCloudKitContainer</span><br><br>    <span class=\"hljs-keyword\">init</span>() &#123;<br>        container <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">NSPersistentCloudKitContainer</span>(name: <span class=\"hljs-string\">&quot;Model&quot;</span>)<br><br>        <span class=\"hljs-keyword\">guard</span> <span class=\"hljs-keyword\">let</span> description <span class=\"hljs-operator\">=</span> container.persistentStoreDescriptions.first <span class=\"hljs-keyword\">else</span> &#123;<br>            <span class=\"hljs-built_in\">fatalError</span>(<span class=\"hljs-string\">&quot;Persistent store description was not found.&quot;</span>)<br>        &#125;<br>        <br>        description.setOption(<span class=\"hljs-literal\">true</span> <span class=\"hljs-keyword\">as</span> <span class=\"hljs-type\">NSNumber</span>, forKey: <span class=\"hljs-type\">NSPersistentStoreRemoteChangeNotificationPostOptionKey</span>)<br>        <br>        container.loadPersistentStores &#123; storeDescription, error <span class=\"hljs-keyword\">in</span><br>            <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">let</span> error <span class=\"hljs-operator\">=</span> error <span class=\"hljs-keyword\">as</span> <span class=\"hljs-type\">NSError</span>? &#123;<br>                <span class=\"hljs-built_in\">fatalError</span>(<span class=\"hljs-string\">&quot;Unresolved error <span class=\"hljs-subst\">\\(error)</span>, <span class=\"hljs-subst\">\\(error.userInfo)</span>&quot;</span>)<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在上述代码中，<code>NSPersistentStoreRemoteChangeNotificationPostOptionKey</code>选项允许您接收到数据变更通知。</p>\n<h4 id=\"监听数据变化\"><a href=\"#监听数据变化\" class=\"headerlink\" title=\"监听数据变化\"></a>监听数据变化</h4><p>为了让您的用户界面响应CloudKit的数据变更，您可以监听<code>NSPersistentStoreRemoteChange</code>通知。每当CloudKit中的数据发生变化时，都会发送通知，并且您可以更新UI。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">NotificationCenter</span>.default.addObserver(<br>    <span class=\"hljs-keyword\">self</span>,<br>    selector: <span class=\"hljs-keyword\">#selector</span>(handleDataChangeNotification(<span class=\"hljs-keyword\">_</span>:)),<br>    name: .<span class=\"hljs-type\">NSPersistentStoreRemoteChange</span>,<br>    object: <span class=\"hljs-literal\">nil</span><br>)<br><br><span class=\"hljs-keyword\">@objc</span><br><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">handleDataChangeNotification</span>(<span class=\"hljs-keyword\">_</span> <span class=\"hljs-params\">notification</span>: <span class=\"hljs-type\">Notification</span>) &#123;<br>    <span class=\"hljs-comment\">// 在这里处理数据变化，更新UI</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"数据冲突和合并\"><a href=\"#数据冲突和合并\" class=\"headerlink\" title=\"数据冲突和合并\"></a>数据冲突和合并</h3><p>处理数据冲突是云同步的重要方面。Core Data和CloudKit集成提供了一种自动的冲突解决策略。默认情况下，最后写入的数据将会“赢”，覆盖之前的数据。如果需要，也可以自定义冲突解决策略。</p>\n<h3 id=\"调试和错误处理\"><a href=\"#调试和错误处理\" class=\"headerlink\" title=\"调试和错误处理\"></a>调试和错误处理</h3><p>当处理云同步时，调试和错误处理是不可或缺的。您应当仔细检查错误日志，并对可能的同步错误做出反应。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>将Core Data与CloudKit集成，为应用添加云同步功能，可以极大地改善用户体验。通过简单的设置和API调用，您可以实现数据在多个设备间的同步，并允许用户之间共享数据。确保在实现过程中，处理好初始化同步、数据变更监听、数据冲突及错误处理等关键环节。在后续小节中，我们将讨论如何利用Cloud</p>\n<p>Kit的高级特性来构建更为复杂的云同步方案。</p>\n"},{"title":"SwiftUI核心技术第12章Dark Mode和Accessibility","date":"2023-11-08T01:33:25.000Z","_content":"**第12章：Dark Mode和Accessibility**\n\n**第1小节：支持暗黑模式**\n\n随着用户对于在不同光照条件下使用设备的需求增加，暗黑模式（Dark Mode）成为了现代应用设计不可或缺的一部分。它不仅有助于减少在低光环境下使用设备时的眼睛疲劳，还能为电池续航带来好处，特别是在OLED屏幕上。此外，暗黑模式还能为用户提供一个更为集中和减少分心的视觉环境。\n\n### 理解暗黑模式\n\n1. **色彩转换** - 暗黑模式不仅仅是将背景设置为黑色和文本设置为白色那么简单。它涉及到色彩配色的整体调整，以确保可读性、可访问性和品牌一致性。\n\n2. **图层和深度** - 暗色背景提升了颜色对比，这意味着阴影和高亮可以用来模拟层次感和深度。\n\n3. **用户控制** - 用户应当能够选择在明亮或暗黑模式下使用应用，或让应用跟随系统设置自动切换。\n\n### 设计指南\n\n1. **颜色主题** - 定义一套色彩主题，包括在暗黑模式下使用的色彩。应使用较亮的色调和透明度来增加层次感，同时避免使用纯白色，以减少对比度导致的刺眼感。\n\n2. **组件和控件** - 确保所有UI组件和控件在暗黑模式下都是可见的，并且它们的状态（如激活、禁用）在两种模式下都清晰。\n\n3. **图片和媒体** - 对于暗黑模式，应考虑使用较暗的图片和插图，或者为图片添加蒙版或过滤器，以适应暗背景。\n\n4. **文本对比度** - 文本应当足够对比，以确保在暗背景下的可读性。对于文本阴影和轮廓也应进行调整。\n\n### 技术实现\n\n1. **Asset Catalogs** - 在Xcode的Asset Catalogs中，可以为每种颜色定义亮色和暗色两个版本。\n\n2. **CSS支持** - 在Web内容中，可以使用CSS的`prefers-color-scheme`查询来为网页添加暗黑模式支持。\n\n3. **SwiftUI** - 在SwiftUI中，可以通过`.environment(\\.colorScheme, .dark)`为预览添加暗黑模式的支持。对于动态颜色，可以使用`Color`结构体内置的暗黑模式适配。\n\n4. **UIKit** - 在UIKit中，可以使用`traitCollection.userInterfaceStyle`来检查当前的界面风格，并在需要时调整UI元素的样式。\n\n### 最佳实践\n\n1. **测试** - 在两种模式下都对应用进行全面的测试，确保UI元素的可见性和功能的可用性。\n\n2. **用户设置** - 提供设置选项，允许用户根据个人喜好切换模式。\n\n3. **跟随系统** - 默认情况下，应用应当跟随系统的暗黑模式设置，以保持用户体验的一致性。\n\n4. **节能考量** - 利用暗黑模式的节能优势，在OLED屏幕上通过使用更多真正的黑色来减少能耗。\n\n5. **无障碍** - 确保暗黑模\n\n式下的色彩对比满足无障碍标准，以便色弱和视力障碍用户也能舒适使用。\n\n通过以上的设计和技术实现指南，开发者可以为其应用成功地集成暗黑模式，不仅提高了应用的美观性，同时也照顾到了用户的实际使用需求和舒适度。\n\n\n**第2小节：辅助功能的最佳实践**\n\n辅助功能（Accessibility）是确保所有用户，包括那些有视力、听力、运动或学习障碍的人，能够有效使用你的应用的关键组成部分。对于应用开发者来说，这不仅仅是一项法律义务或道德责任，更是一种设计上的优秀实践，它能够扩大应用的潜在用户群体，并提升用户体验。\n\n### 认识辅助功能的范畴\n\n1. **多感官接入** - 保证信息的传递不仅限于一种感官，例如，对于视觉信息，提供文本描述或声音解释。\n\n2. **易用性** - 确保应用的操作简单明了，尤其是对于运动障碍用户，考虑到触摸目标的大小和屏幕的可达性。\n\n3. **可见性** - 包含字体大小的调整、高对比度模式以及颜色不是传达重要信息的唯一方式。\n\n4. **认知考虑** - 设计简洁、一致的界面，减少认知负担，特别是为了那些有认知障碍的用户。\n\n### 设计指南\n\n1. **文本可读性** - 提供文本大小调整的功能，支持系统级别的“辅助功能”设置。\n\n2. **高对比度** - 提供高对比度主题或模式，辅以清晰的字体，帮助视觉障碍用户更好地识别内容。\n\n3. **颜色盲友好** - 设计UI时不要完全依赖颜色来区分元素或传达信息，使用图形符号或标签作为辅助。\n\n4. **标签和说明** - 所有的交互控件都应该有清晰的标签，辅以适当的声音或触觉反馈。\n\n5. **语音控制** - 支持通过语音命令进行控制，为那些无法使用传统输入设备的用户提供便利。\n\n### 技术实现\n\n1. **VoiceOver/Speak Screen** - 确保SwiftUI或UIKit组件正确实现了辅助功能标签和行为，以便VoiceOver能够读取屏幕上的内容。\n\n2. **动态字体大小** - 使用`UIFont.preferredFont(forTextStyle:)`和SwiftUI中的`.font(.system(size:))`来响应用户的字体大小设置。\n\n3. **UIAccessibility协议** - 通过实现相关的UIAccessibility协议来自定义非标准UI组件的辅助功能行为。\n\n4. **辅助功能快捷方式** - 通过设置快捷方式让用户能够快速访问常用的辅助功能。\n\n### 最佳实践\n\n1. **持续测试** - 在开发过程中，经常使用辅助功能进行测试，确保所有用户在使用应用时的体验一致。\n\n2. **社群参与** - 与残障社群合作，获取真实的反馈，并根据这些反馈改进产品。\n\n3. **遵循标准** - 遵循WCAG（Web Content Accessibility Guidelines）等国际标准来设计和开发应用。\n\n4. **教育和文档** - 提供有关如何使用应用中辅助功能的文档或视频教程。\n\n5. **UI测试和自动化** - 利用自动化测试框架来验证辅助功能的实现，确保在应用更新后功能依然可用。\n\n通过实施这些最\n\n佳实践，开发者不仅能够提供一个包容性更强的应用体验，同时也能满足日益增长的多样化用户需求，构建起更加广泛的用户基础。\n\n\n**第3小节：动态字体与国际化**\n\n设计一个能够轻松适应不同语言和区域设置的用户界面，以及支持动态字体大小调整，是为了确保应用能够覆盖更广泛的用户群体，特别是那些有特定阅读需求的用户。\n\n### 动态字体的重要性\n\n动态字体允许用户根据自己的视力需求来调整字体的大小。这对于那些需要辅助设备阅读的用户尤为重要。\n\n### 实现动态字体\n\n1. **使用系统字体尺寸** - 利用系统提供的字体大小，如在SwiftUI中使用`.font(.system(size:))`。\n\n2. **响应用户设置** - 应用应该能够响应并遵循用户的辅助功能设置，比如“更大字体”选项。\n\n3. **字体可伸缩性** - 保证应用的布局可以适应不同的字体大小而不会破坏界面设计。\n\n4. **自定义字体的辅助功能** - 如果使用自定义字体，确保它们能够与系统的辅助功能设置兼容，如使用`UIFontMetrics`来调整。\n\n### 国际化的挑战\n\n国际化不仅仅是将文本翻译成不同的语言，还需要考虑到文化差异、布局方向（例如从右到左的语言）、日期和时间格式以及货币单位。\n\n### 实现国际化\n\n1. **本地化字符串** - 使用本地化字符串文件（`.strings`）和键值对来管理应用中的文本。\n\n2. **自适应布局** - 确保UI能够适应不同的文本长度和布局方向。\n\n3. **日期和数字格式** - 使用`DateFormatter`和`NumberFormatter`来处理日期和数字的本地化格式。\n\n4. **资源的国际化** - 包括图像等资源的国际化，确保它们在不同文化中同样适用。\n\n### 最佳实践\n\n1. **全面测试** - 在不同的语言和辅助功能设置下测试应用，确保所有功能正常工作。\n\n2. **持续的本地化和国际化** - 让本地化和国际化成为开发流程的一部分，不断更新和完善。\n\n3. **伪本地化测试** - 使用伪本地化来测试应用的布局是否能够适应文字长度的变化。\n\n4. **文化敏感性** - 在设计和开发应用时，考虑到不同文化背景下的用户需求和习俗。\n\n5. **动态字体和布局测试** - 使用Xcode中的辅助功能检查器来预览应用在不同字体大小下的表现。\n\n通过实施这些策略，开发者可以确保他们的应用不仅在不同地区和文化中使用无障碍，而且可以为所有用户提供一个更加个性化和易于使用的体验。","source":"_posts/SwiftUI核心技术第12章Dark-Mode和Accessibility.md","raw":"---\ntitle: SwiftUI核心技术第12章Dark Mode和Accessibility\ndate: 2023-11-08 09:33:25\ncategories:\n- SwiftUI\ntags:\n---\n**第12章：Dark Mode和Accessibility**\n\n**第1小节：支持暗黑模式**\n\n随着用户对于在不同光照条件下使用设备的需求增加，暗黑模式（Dark Mode）成为了现代应用设计不可或缺的一部分。它不仅有助于减少在低光环境下使用设备时的眼睛疲劳，还能为电池续航带来好处，特别是在OLED屏幕上。此外，暗黑模式还能为用户提供一个更为集中和减少分心的视觉环境。\n\n### 理解暗黑模式\n\n1. **色彩转换** - 暗黑模式不仅仅是将背景设置为黑色和文本设置为白色那么简单。它涉及到色彩配色的整体调整，以确保可读性、可访问性和品牌一致性。\n\n2. **图层和深度** - 暗色背景提升了颜色对比，这意味着阴影和高亮可以用来模拟层次感和深度。\n\n3. **用户控制** - 用户应当能够选择在明亮或暗黑模式下使用应用，或让应用跟随系统设置自动切换。\n\n### 设计指南\n\n1. **颜色主题** - 定义一套色彩主题，包括在暗黑模式下使用的色彩。应使用较亮的色调和透明度来增加层次感，同时避免使用纯白色，以减少对比度导致的刺眼感。\n\n2. **组件和控件** - 确保所有UI组件和控件在暗黑模式下都是可见的，并且它们的状态（如激活、禁用）在两种模式下都清晰。\n\n3. **图片和媒体** - 对于暗黑模式，应考虑使用较暗的图片和插图，或者为图片添加蒙版或过滤器，以适应暗背景。\n\n4. **文本对比度** - 文本应当足够对比，以确保在暗背景下的可读性。对于文本阴影和轮廓也应进行调整。\n\n### 技术实现\n\n1. **Asset Catalogs** - 在Xcode的Asset Catalogs中，可以为每种颜色定义亮色和暗色两个版本。\n\n2. **CSS支持** - 在Web内容中，可以使用CSS的`prefers-color-scheme`查询来为网页添加暗黑模式支持。\n\n3. **SwiftUI** - 在SwiftUI中，可以通过`.environment(\\.colorScheme, .dark)`为预览添加暗黑模式的支持。对于动态颜色，可以使用`Color`结构体内置的暗黑模式适配。\n\n4. **UIKit** - 在UIKit中，可以使用`traitCollection.userInterfaceStyle`来检查当前的界面风格，并在需要时调整UI元素的样式。\n\n### 最佳实践\n\n1. **测试** - 在两种模式下都对应用进行全面的测试，确保UI元素的可见性和功能的可用性。\n\n2. **用户设置** - 提供设置选项，允许用户根据个人喜好切换模式。\n\n3. **跟随系统** - 默认情况下，应用应当跟随系统的暗黑模式设置，以保持用户体验的一致性。\n\n4. **节能考量** - 利用暗黑模式的节能优势，在OLED屏幕上通过使用更多真正的黑色来减少能耗。\n\n5. **无障碍** - 确保暗黑模\n\n式下的色彩对比满足无障碍标准，以便色弱和视力障碍用户也能舒适使用。\n\n通过以上的设计和技术实现指南，开发者可以为其应用成功地集成暗黑模式，不仅提高了应用的美观性，同时也照顾到了用户的实际使用需求和舒适度。\n\n\n**第2小节：辅助功能的最佳实践**\n\n辅助功能（Accessibility）是确保所有用户，包括那些有视力、听力、运动或学习障碍的人，能够有效使用你的应用的关键组成部分。对于应用开发者来说，这不仅仅是一项法律义务或道德责任，更是一种设计上的优秀实践，它能够扩大应用的潜在用户群体，并提升用户体验。\n\n### 认识辅助功能的范畴\n\n1. **多感官接入** - 保证信息的传递不仅限于一种感官，例如，对于视觉信息，提供文本描述或声音解释。\n\n2. **易用性** - 确保应用的操作简单明了，尤其是对于运动障碍用户，考虑到触摸目标的大小和屏幕的可达性。\n\n3. **可见性** - 包含字体大小的调整、高对比度模式以及颜色不是传达重要信息的唯一方式。\n\n4. **认知考虑** - 设计简洁、一致的界面，减少认知负担，特别是为了那些有认知障碍的用户。\n\n### 设计指南\n\n1. **文本可读性** - 提供文本大小调整的功能，支持系统级别的“辅助功能”设置。\n\n2. **高对比度** - 提供高对比度主题或模式，辅以清晰的字体，帮助视觉障碍用户更好地识别内容。\n\n3. **颜色盲友好** - 设计UI时不要完全依赖颜色来区分元素或传达信息，使用图形符号或标签作为辅助。\n\n4. **标签和说明** - 所有的交互控件都应该有清晰的标签，辅以适当的声音或触觉反馈。\n\n5. **语音控制** - 支持通过语音命令进行控制，为那些无法使用传统输入设备的用户提供便利。\n\n### 技术实现\n\n1. **VoiceOver/Speak Screen** - 确保SwiftUI或UIKit组件正确实现了辅助功能标签和行为，以便VoiceOver能够读取屏幕上的内容。\n\n2. **动态字体大小** - 使用`UIFont.preferredFont(forTextStyle:)`和SwiftUI中的`.font(.system(size:))`来响应用户的字体大小设置。\n\n3. **UIAccessibility协议** - 通过实现相关的UIAccessibility协议来自定义非标准UI组件的辅助功能行为。\n\n4. **辅助功能快捷方式** - 通过设置快捷方式让用户能够快速访问常用的辅助功能。\n\n### 最佳实践\n\n1. **持续测试** - 在开发过程中，经常使用辅助功能进行测试，确保所有用户在使用应用时的体验一致。\n\n2. **社群参与** - 与残障社群合作，获取真实的反馈，并根据这些反馈改进产品。\n\n3. **遵循标准** - 遵循WCAG（Web Content Accessibility Guidelines）等国际标准来设计和开发应用。\n\n4. **教育和文档** - 提供有关如何使用应用中辅助功能的文档或视频教程。\n\n5. **UI测试和自动化** - 利用自动化测试框架来验证辅助功能的实现，确保在应用更新后功能依然可用。\n\n通过实施这些最\n\n佳实践，开发者不仅能够提供一个包容性更强的应用体验，同时也能满足日益增长的多样化用户需求，构建起更加广泛的用户基础。\n\n\n**第3小节：动态字体与国际化**\n\n设计一个能够轻松适应不同语言和区域设置的用户界面，以及支持动态字体大小调整，是为了确保应用能够覆盖更广泛的用户群体，特别是那些有特定阅读需求的用户。\n\n### 动态字体的重要性\n\n动态字体允许用户根据自己的视力需求来调整字体的大小。这对于那些需要辅助设备阅读的用户尤为重要。\n\n### 实现动态字体\n\n1. **使用系统字体尺寸** - 利用系统提供的字体大小，如在SwiftUI中使用`.font(.system(size:))`。\n\n2. **响应用户设置** - 应用应该能够响应并遵循用户的辅助功能设置，比如“更大字体”选项。\n\n3. **字体可伸缩性** - 保证应用的布局可以适应不同的字体大小而不会破坏界面设计。\n\n4. **自定义字体的辅助功能** - 如果使用自定义字体，确保它们能够与系统的辅助功能设置兼容，如使用`UIFontMetrics`来调整。\n\n### 国际化的挑战\n\n国际化不仅仅是将文本翻译成不同的语言，还需要考虑到文化差异、布局方向（例如从右到左的语言）、日期和时间格式以及货币单位。\n\n### 实现国际化\n\n1. **本地化字符串** - 使用本地化字符串文件（`.strings`）和键值对来管理应用中的文本。\n\n2. **自适应布局** - 确保UI能够适应不同的文本长度和布局方向。\n\n3. **日期和数字格式** - 使用`DateFormatter`和`NumberFormatter`来处理日期和数字的本地化格式。\n\n4. **资源的国际化** - 包括图像等资源的国际化，确保它们在不同文化中同样适用。\n\n### 最佳实践\n\n1. **全面测试** - 在不同的语言和辅助功能设置下测试应用，确保所有功能正常工作。\n\n2. **持续的本地化和国际化** - 让本地化和国际化成为开发流程的一部分，不断更新和完善。\n\n3. **伪本地化测试** - 使用伪本地化来测试应用的布局是否能够适应文字长度的变化。\n\n4. **文化敏感性** - 在设计和开发应用时，考虑到不同文化背景下的用户需求和习俗。\n\n5. **动态字体和布局测试** - 使用Xcode中的辅助功能检查器来预览应用在不同字体大小下的表现。\n\n通过实施这些策略，开发者可以确保他们的应用不仅在不同地区和文化中使用无障碍，而且可以为所有用户提供一个更加个性化和易于使用的体验。","slug":"SwiftUI核心技术第12章Dark-Mode和Accessibility","published":1,"updated":"2024-03-17T06:11:54.398Z","comments":1,"layout":"post","photos":[],"_id":"clu6up53h0026z67434q76ll3","content":"<p><strong>第12章：Dark Mode和Accessibility</strong></p>\n<p><strong>第1小节：支持暗黑模式</strong></p>\n<p>随着用户对于在不同光照条件下使用设备的需求增加，暗黑模式（Dark Mode）成为了现代应用设计不可或缺的一部分。它不仅有助于减少在低光环境下使用设备时的眼睛疲劳，还能为电池续航带来好处，特别是在OLED屏幕上。此外，暗黑模式还能为用户提供一个更为集中和减少分心的视觉环境。</p>\n<h3 id=\"理解暗黑模式\"><a href=\"#理解暗黑模式\" class=\"headerlink\" title=\"理解暗黑模式\"></a>理解暗黑模式</h3><ol>\n<li><p><strong>色彩转换</strong> - 暗黑模式不仅仅是将背景设置为黑色和文本设置为白色那么简单。它涉及到色彩配色的整体调整，以确保可读性、可访问性和品牌一致性。</p>\n</li>\n<li><p><strong>图层和深度</strong> - 暗色背景提升了颜色对比，这意味着阴影和高亮可以用来模拟层次感和深度。</p>\n</li>\n<li><p><strong>用户控制</strong> - 用户应当能够选择在明亮或暗黑模式下使用应用，或让应用跟随系统设置自动切换。</p>\n</li>\n</ol>\n<h3 id=\"设计指南\"><a href=\"#设计指南\" class=\"headerlink\" title=\"设计指南\"></a>设计指南</h3><ol>\n<li><p><strong>颜色主题</strong> - 定义一套色彩主题，包括在暗黑模式下使用的色彩。应使用较亮的色调和透明度来增加层次感，同时避免使用纯白色，以减少对比度导致的刺眼感。</p>\n</li>\n<li><p><strong>组件和控件</strong> - 确保所有UI组件和控件在暗黑模式下都是可见的，并且它们的状态（如激活、禁用）在两种模式下都清晰。</p>\n</li>\n<li><p><strong>图片和媒体</strong> - 对于暗黑模式，应考虑使用较暗的图片和插图，或者为图片添加蒙版或过滤器，以适应暗背景。</p>\n</li>\n<li><p><strong>文本对比度</strong> - 文本应当足够对比，以确保在暗背景下的可读性。对于文本阴影和轮廓也应进行调整。</p>\n</li>\n</ol>\n<h3 id=\"技术实现\"><a href=\"#技术实现\" class=\"headerlink\" title=\"技术实现\"></a>技术实现</h3><ol>\n<li><p><strong>Asset Catalogs</strong> - 在Xcode的Asset Catalogs中，可以为每种颜色定义亮色和暗色两个版本。</p>\n</li>\n<li><p><strong>CSS支持</strong> - 在Web内容中，可以使用CSS的<code>prefers-color-scheme</code>查询来为网页添加暗黑模式支持。</p>\n</li>\n<li><p><strong>SwiftUI</strong> - 在SwiftUI中，可以通过<code>.environment(\\.colorScheme, .dark)</code>为预览添加暗黑模式的支持。对于动态颜色，可以使用<code>Color</code>结构体内置的暗黑模式适配。</p>\n</li>\n<li><p><strong>UIKit</strong> - 在UIKit中，可以使用<code>traitCollection.userInterfaceStyle</code>来检查当前的界面风格，并在需要时调整UI元素的样式。</p>\n</li>\n</ol>\n<h3 id=\"最佳实践\"><a href=\"#最佳实践\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h3><ol>\n<li><p><strong>测试</strong> - 在两种模式下都对应用进行全面的测试，确保UI元素的可见性和功能的可用性。</p>\n</li>\n<li><p><strong>用户设置</strong> - 提供设置选项，允许用户根据个人喜好切换模式。</p>\n</li>\n<li><p><strong>跟随系统</strong> - 默认情况下，应用应当跟随系统的暗黑模式设置，以保持用户体验的一致性。</p>\n</li>\n<li><p><strong>节能考量</strong> - 利用暗黑模式的节能优势，在OLED屏幕上通过使用更多真正的黑色来减少能耗。</p>\n</li>\n<li><p><strong>无障碍</strong> - 确保暗黑模</p>\n</li>\n</ol>\n<p>式下的色彩对比满足无障碍标准，以便色弱和视力障碍用户也能舒适使用。</p>\n<p>通过以上的设计和技术实现指南，开发者可以为其应用成功地集成暗黑模式，不仅提高了应用的美观性，同时也照顾到了用户的实际使用需求和舒适度。</p>\n<p><strong>第2小节：辅助功能的最佳实践</strong></p>\n<p>辅助功能（Accessibility）是确保所有用户，包括那些有视力、听力、运动或学习障碍的人，能够有效使用你的应用的关键组成部分。对于应用开发者来说，这不仅仅是一项法律义务或道德责任，更是一种设计上的优秀实践，它能够扩大应用的潜在用户群体，并提升用户体验。</p>\n<h3 id=\"认识辅助功能的范畴\"><a href=\"#认识辅助功能的范畴\" class=\"headerlink\" title=\"认识辅助功能的范畴\"></a>认识辅助功能的范畴</h3><ol>\n<li><p><strong>多感官接入</strong> - 保证信息的传递不仅限于一种感官，例如，对于视觉信息，提供文本描述或声音解释。</p>\n</li>\n<li><p><strong>易用性</strong> - 确保应用的操作简单明了，尤其是对于运动障碍用户，考虑到触摸目标的大小和屏幕的可达性。</p>\n</li>\n<li><p><strong>可见性</strong> - 包含字体大小的调整、高对比度模式以及颜色不是传达重要信息的唯一方式。</p>\n</li>\n<li><p><strong>认知考虑</strong> - 设计简洁、一致的界面，减少认知负担，特别是为了那些有认知障碍的用户。</p>\n</li>\n</ol>\n<h3 id=\"设计指南-1\"><a href=\"#设计指南-1\" class=\"headerlink\" title=\"设计指南\"></a>设计指南</h3><ol>\n<li><p><strong>文本可读性</strong> - 提供文本大小调整的功能，支持系统级别的“辅助功能”设置。</p>\n</li>\n<li><p><strong>高对比度</strong> - 提供高对比度主题或模式，辅以清晰的字体，帮助视觉障碍用户更好地识别内容。</p>\n</li>\n<li><p><strong>颜色盲友好</strong> - 设计UI时不要完全依赖颜色来区分元素或传达信息，使用图形符号或标签作为辅助。</p>\n</li>\n<li><p><strong>标签和说明</strong> - 所有的交互控件都应该有清晰的标签，辅以适当的声音或触觉反馈。</p>\n</li>\n<li><p><strong>语音控制</strong> - 支持通过语音命令进行控制，为那些无法使用传统输入设备的用户提供便利。</p>\n</li>\n</ol>\n<h3 id=\"技术实现-1\"><a href=\"#技术实现-1\" class=\"headerlink\" title=\"技术实现\"></a>技术实现</h3><ol>\n<li><p><strong>VoiceOver&#x2F;Speak Screen</strong> - 确保SwiftUI或UIKit组件正确实现了辅助功能标签和行为，以便VoiceOver能够读取屏幕上的内容。</p>\n</li>\n<li><p><strong>动态字体大小</strong> - 使用<code>UIFont.preferredFont(forTextStyle:)</code>和SwiftUI中的<code>.font(.system(size:))</code>来响应用户的字体大小设置。</p>\n</li>\n<li><p><strong>UIAccessibility协议</strong> - 通过实现相关的UIAccessibility协议来自定义非标准UI组件的辅助功能行为。</p>\n</li>\n<li><p><strong>辅助功能快捷方式</strong> - 通过设置快捷方式让用户能够快速访问常用的辅助功能。</p>\n</li>\n</ol>\n<h3 id=\"最佳实践-1\"><a href=\"#最佳实践-1\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h3><ol>\n<li><p><strong>持续测试</strong> - 在开发过程中，经常使用辅助功能进行测试，确保所有用户在使用应用时的体验一致。</p>\n</li>\n<li><p><strong>社群参与</strong> - 与残障社群合作，获取真实的反馈，并根据这些反馈改进产品。</p>\n</li>\n<li><p><strong>遵循标准</strong> - 遵循WCAG（Web Content Accessibility Guidelines）等国际标准来设计和开发应用。</p>\n</li>\n<li><p><strong>教育和文档</strong> - 提供有关如何使用应用中辅助功能的文档或视频教程。</p>\n</li>\n<li><p><strong>UI测试和自动化</strong> - 利用自动化测试框架来验证辅助功能的实现，确保在应用更新后功能依然可用。</p>\n</li>\n</ol>\n<p>通过实施这些最</p>\n<p>佳实践，开发者不仅能够提供一个包容性更强的应用体验，同时也能满足日益增长的多样化用户需求，构建起更加广泛的用户基础。</p>\n<p><strong>第3小节：动态字体与国际化</strong></p>\n<p>设计一个能够轻松适应不同语言和区域设置的用户界面，以及支持动态字体大小调整，是为了确保应用能够覆盖更广泛的用户群体，特别是那些有特定阅读需求的用户。</p>\n<h3 id=\"动态字体的重要性\"><a href=\"#动态字体的重要性\" class=\"headerlink\" title=\"动态字体的重要性\"></a>动态字体的重要性</h3><p>动态字体允许用户根据自己的视力需求来调整字体的大小。这对于那些需要辅助设备阅读的用户尤为重要。</p>\n<h3 id=\"实现动态字体\"><a href=\"#实现动态字体\" class=\"headerlink\" title=\"实现动态字体\"></a>实现动态字体</h3><ol>\n<li><p><strong>使用系统字体尺寸</strong> - 利用系统提供的字体大小，如在SwiftUI中使用<code>.font(.system(size:))</code>。</p>\n</li>\n<li><p><strong>响应用户设置</strong> - 应用应该能够响应并遵循用户的辅助功能设置，比如“更大字体”选项。</p>\n</li>\n<li><p><strong>字体可伸缩性</strong> - 保证应用的布局可以适应不同的字体大小而不会破坏界面设计。</p>\n</li>\n<li><p><strong>自定义字体的辅助功能</strong> - 如果使用自定义字体，确保它们能够与系统的辅助功能设置兼容，如使用<code>UIFontMetrics</code>来调整。</p>\n</li>\n</ol>\n<h3 id=\"国际化的挑战\"><a href=\"#国际化的挑战\" class=\"headerlink\" title=\"国际化的挑战\"></a>国际化的挑战</h3><p>国际化不仅仅是将文本翻译成不同的语言，还需要考虑到文化差异、布局方向（例如从右到左的语言）、日期和时间格式以及货币单位。</p>\n<h3 id=\"实现国际化\"><a href=\"#实现国际化\" class=\"headerlink\" title=\"实现国际化\"></a>实现国际化</h3><ol>\n<li><p><strong>本地化字符串</strong> - 使用本地化字符串文件（<code>.strings</code>）和键值对来管理应用中的文本。</p>\n</li>\n<li><p><strong>自适应布局</strong> - 确保UI能够适应不同的文本长度和布局方向。</p>\n</li>\n<li><p><strong>日期和数字格式</strong> - 使用<code>DateFormatter</code>和<code>NumberFormatter</code>来处理日期和数字的本地化格式。</p>\n</li>\n<li><p><strong>资源的国际化</strong> - 包括图像等资源的国际化，确保它们在不同文化中同样适用。</p>\n</li>\n</ol>\n<h3 id=\"最佳实践-2\"><a href=\"#最佳实践-2\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h3><ol>\n<li><p><strong>全面测试</strong> - 在不同的语言和辅助功能设置下测试应用，确保所有功能正常工作。</p>\n</li>\n<li><p><strong>持续的本地化和国际化</strong> - 让本地化和国际化成为开发流程的一部分，不断更新和完善。</p>\n</li>\n<li><p><strong>伪本地化测试</strong> - 使用伪本地化来测试应用的布局是否能够适应文字长度的变化。</p>\n</li>\n<li><p><strong>文化敏感性</strong> - 在设计和开发应用时，考虑到不同文化背景下的用户需求和习俗。</p>\n</li>\n<li><p><strong>动态字体和布局测试</strong> - 使用Xcode中的辅助功能检查器来预览应用在不同字体大小下的表现。</p>\n</li>\n</ol>\n<p>通过实施这些策略，开发者可以确保他们的应用不仅在不同地区和文化中使用无障碍，而且可以为所有用户提供一个更加个性化和易于使用的体验。</p>\n","excerpt":"","more":"<p><strong>第12章：Dark Mode和Accessibility</strong></p>\n<p><strong>第1小节：支持暗黑模式</strong></p>\n<p>随着用户对于在不同光照条件下使用设备的需求增加，暗黑模式（Dark Mode）成为了现代应用设计不可或缺的一部分。它不仅有助于减少在低光环境下使用设备时的眼睛疲劳，还能为电池续航带来好处，特别是在OLED屏幕上。此外，暗黑模式还能为用户提供一个更为集中和减少分心的视觉环境。</p>\n<h3 id=\"理解暗黑模式\"><a href=\"#理解暗黑模式\" class=\"headerlink\" title=\"理解暗黑模式\"></a>理解暗黑模式</h3><ol>\n<li><p><strong>色彩转换</strong> - 暗黑模式不仅仅是将背景设置为黑色和文本设置为白色那么简单。它涉及到色彩配色的整体调整，以确保可读性、可访问性和品牌一致性。</p>\n</li>\n<li><p><strong>图层和深度</strong> - 暗色背景提升了颜色对比，这意味着阴影和高亮可以用来模拟层次感和深度。</p>\n</li>\n<li><p><strong>用户控制</strong> - 用户应当能够选择在明亮或暗黑模式下使用应用，或让应用跟随系统设置自动切换。</p>\n</li>\n</ol>\n<h3 id=\"设计指南\"><a href=\"#设计指南\" class=\"headerlink\" title=\"设计指南\"></a>设计指南</h3><ol>\n<li><p><strong>颜色主题</strong> - 定义一套色彩主题，包括在暗黑模式下使用的色彩。应使用较亮的色调和透明度来增加层次感，同时避免使用纯白色，以减少对比度导致的刺眼感。</p>\n</li>\n<li><p><strong>组件和控件</strong> - 确保所有UI组件和控件在暗黑模式下都是可见的，并且它们的状态（如激活、禁用）在两种模式下都清晰。</p>\n</li>\n<li><p><strong>图片和媒体</strong> - 对于暗黑模式，应考虑使用较暗的图片和插图，或者为图片添加蒙版或过滤器，以适应暗背景。</p>\n</li>\n<li><p><strong>文本对比度</strong> - 文本应当足够对比，以确保在暗背景下的可读性。对于文本阴影和轮廓也应进行调整。</p>\n</li>\n</ol>\n<h3 id=\"技术实现\"><a href=\"#技术实现\" class=\"headerlink\" title=\"技术实现\"></a>技术实现</h3><ol>\n<li><p><strong>Asset Catalogs</strong> - 在Xcode的Asset Catalogs中，可以为每种颜色定义亮色和暗色两个版本。</p>\n</li>\n<li><p><strong>CSS支持</strong> - 在Web内容中，可以使用CSS的<code>prefers-color-scheme</code>查询来为网页添加暗黑模式支持。</p>\n</li>\n<li><p><strong>SwiftUI</strong> - 在SwiftUI中，可以通过<code>.environment(\\.colorScheme, .dark)</code>为预览添加暗黑模式的支持。对于动态颜色，可以使用<code>Color</code>结构体内置的暗黑模式适配。</p>\n</li>\n<li><p><strong>UIKit</strong> - 在UIKit中，可以使用<code>traitCollection.userInterfaceStyle</code>来检查当前的界面风格，并在需要时调整UI元素的样式。</p>\n</li>\n</ol>\n<h3 id=\"最佳实践\"><a href=\"#最佳实践\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h3><ol>\n<li><p><strong>测试</strong> - 在两种模式下都对应用进行全面的测试，确保UI元素的可见性和功能的可用性。</p>\n</li>\n<li><p><strong>用户设置</strong> - 提供设置选项，允许用户根据个人喜好切换模式。</p>\n</li>\n<li><p><strong>跟随系统</strong> - 默认情况下，应用应当跟随系统的暗黑模式设置，以保持用户体验的一致性。</p>\n</li>\n<li><p><strong>节能考量</strong> - 利用暗黑模式的节能优势，在OLED屏幕上通过使用更多真正的黑色来减少能耗。</p>\n</li>\n<li><p><strong>无障碍</strong> - 确保暗黑模</p>\n</li>\n</ol>\n<p>式下的色彩对比满足无障碍标准，以便色弱和视力障碍用户也能舒适使用。</p>\n<p>通过以上的设计和技术实现指南，开发者可以为其应用成功地集成暗黑模式，不仅提高了应用的美观性，同时也照顾到了用户的实际使用需求和舒适度。</p>\n<p><strong>第2小节：辅助功能的最佳实践</strong></p>\n<p>辅助功能（Accessibility）是确保所有用户，包括那些有视力、听力、运动或学习障碍的人，能够有效使用你的应用的关键组成部分。对于应用开发者来说，这不仅仅是一项法律义务或道德责任，更是一种设计上的优秀实践，它能够扩大应用的潜在用户群体，并提升用户体验。</p>\n<h3 id=\"认识辅助功能的范畴\"><a href=\"#认识辅助功能的范畴\" class=\"headerlink\" title=\"认识辅助功能的范畴\"></a>认识辅助功能的范畴</h3><ol>\n<li><p><strong>多感官接入</strong> - 保证信息的传递不仅限于一种感官，例如，对于视觉信息，提供文本描述或声音解释。</p>\n</li>\n<li><p><strong>易用性</strong> - 确保应用的操作简单明了，尤其是对于运动障碍用户，考虑到触摸目标的大小和屏幕的可达性。</p>\n</li>\n<li><p><strong>可见性</strong> - 包含字体大小的调整、高对比度模式以及颜色不是传达重要信息的唯一方式。</p>\n</li>\n<li><p><strong>认知考虑</strong> - 设计简洁、一致的界面，减少认知负担，特别是为了那些有认知障碍的用户。</p>\n</li>\n</ol>\n<h3 id=\"设计指南-1\"><a href=\"#设计指南-1\" class=\"headerlink\" title=\"设计指南\"></a>设计指南</h3><ol>\n<li><p><strong>文本可读性</strong> - 提供文本大小调整的功能，支持系统级别的“辅助功能”设置。</p>\n</li>\n<li><p><strong>高对比度</strong> - 提供高对比度主题或模式，辅以清晰的字体，帮助视觉障碍用户更好地识别内容。</p>\n</li>\n<li><p><strong>颜色盲友好</strong> - 设计UI时不要完全依赖颜色来区分元素或传达信息，使用图形符号或标签作为辅助。</p>\n</li>\n<li><p><strong>标签和说明</strong> - 所有的交互控件都应该有清晰的标签，辅以适当的声音或触觉反馈。</p>\n</li>\n<li><p><strong>语音控制</strong> - 支持通过语音命令进行控制，为那些无法使用传统输入设备的用户提供便利。</p>\n</li>\n</ol>\n<h3 id=\"技术实现-1\"><a href=\"#技术实现-1\" class=\"headerlink\" title=\"技术实现\"></a>技术实现</h3><ol>\n<li><p><strong>VoiceOver&#x2F;Speak Screen</strong> - 确保SwiftUI或UIKit组件正确实现了辅助功能标签和行为，以便VoiceOver能够读取屏幕上的内容。</p>\n</li>\n<li><p><strong>动态字体大小</strong> - 使用<code>UIFont.preferredFont(forTextStyle:)</code>和SwiftUI中的<code>.font(.system(size:))</code>来响应用户的字体大小设置。</p>\n</li>\n<li><p><strong>UIAccessibility协议</strong> - 通过实现相关的UIAccessibility协议来自定义非标准UI组件的辅助功能行为。</p>\n</li>\n<li><p><strong>辅助功能快捷方式</strong> - 通过设置快捷方式让用户能够快速访问常用的辅助功能。</p>\n</li>\n</ol>\n<h3 id=\"最佳实践-1\"><a href=\"#最佳实践-1\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h3><ol>\n<li><p><strong>持续测试</strong> - 在开发过程中，经常使用辅助功能进行测试，确保所有用户在使用应用时的体验一致。</p>\n</li>\n<li><p><strong>社群参与</strong> - 与残障社群合作，获取真实的反馈，并根据这些反馈改进产品。</p>\n</li>\n<li><p><strong>遵循标准</strong> - 遵循WCAG（Web Content Accessibility Guidelines）等国际标准来设计和开发应用。</p>\n</li>\n<li><p><strong>教育和文档</strong> - 提供有关如何使用应用中辅助功能的文档或视频教程。</p>\n</li>\n<li><p><strong>UI测试和自动化</strong> - 利用自动化测试框架来验证辅助功能的实现，确保在应用更新后功能依然可用。</p>\n</li>\n</ol>\n<p>通过实施这些最</p>\n<p>佳实践，开发者不仅能够提供一个包容性更强的应用体验，同时也能满足日益增长的多样化用户需求，构建起更加广泛的用户基础。</p>\n<p><strong>第3小节：动态字体与国际化</strong></p>\n<p>设计一个能够轻松适应不同语言和区域设置的用户界面，以及支持动态字体大小调整，是为了确保应用能够覆盖更广泛的用户群体，特别是那些有特定阅读需求的用户。</p>\n<h3 id=\"动态字体的重要性\"><a href=\"#动态字体的重要性\" class=\"headerlink\" title=\"动态字体的重要性\"></a>动态字体的重要性</h3><p>动态字体允许用户根据自己的视力需求来调整字体的大小。这对于那些需要辅助设备阅读的用户尤为重要。</p>\n<h3 id=\"实现动态字体\"><a href=\"#实现动态字体\" class=\"headerlink\" title=\"实现动态字体\"></a>实现动态字体</h3><ol>\n<li><p><strong>使用系统字体尺寸</strong> - 利用系统提供的字体大小，如在SwiftUI中使用<code>.font(.system(size:))</code>。</p>\n</li>\n<li><p><strong>响应用户设置</strong> - 应用应该能够响应并遵循用户的辅助功能设置，比如“更大字体”选项。</p>\n</li>\n<li><p><strong>字体可伸缩性</strong> - 保证应用的布局可以适应不同的字体大小而不会破坏界面设计。</p>\n</li>\n<li><p><strong>自定义字体的辅助功能</strong> - 如果使用自定义字体，确保它们能够与系统的辅助功能设置兼容，如使用<code>UIFontMetrics</code>来调整。</p>\n</li>\n</ol>\n<h3 id=\"国际化的挑战\"><a href=\"#国际化的挑战\" class=\"headerlink\" title=\"国际化的挑战\"></a>国际化的挑战</h3><p>国际化不仅仅是将文本翻译成不同的语言，还需要考虑到文化差异、布局方向（例如从右到左的语言）、日期和时间格式以及货币单位。</p>\n<h3 id=\"实现国际化\"><a href=\"#实现国际化\" class=\"headerlink\" title=\"实现国际化\"></a>实现国际化</h3><ol>\n<li><p><strong>本地化字符串</strong> - 使用本地化字符串文件（<code>.strings</code>）和键值对来管理应用中的文本。</p>\n</li>\n<li><p><strong>自适应布局</strong> - 确保UI能够适应不同的文本长度和布局方向。</p>\n</li>\n<li><p><strong>日期和数字格式</strong> - 使用<code>DateFormatter</code>和<code>NumberFormatter</code>来处理日期和数字的本地化格式。</p>\n</li>\n<li><p><strong>资源的国际化</strong> - 包括图像等资源的国际化，确保它们在不同文化中同样适用。</p>\n</li>\n</ol>\n<h3 id=\"最佳实践-2\"><a href=\"#最佳实践-2\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h3><ol>\n<li><p><strong>全面测试</strong> - 在不同的语言和辅助功能设置下测试应用，确保所有功能正常工作。</p>\n</li>\n<li><p><strong>持续的本地化和国际化</strong> - 让本地化和国际化成为开发流程的一部分，不断更新和完善。</p>\n</li>\n<li><p><strong>伪本地化测试</strong> - 使用伪本地化来测试应用的布局是否能够适应文字长度的变化。</p>\n</li>\n<li><p><strong>文化敏感性</strong> - 在设计和开发应用时，考虑到不同文化背景下的用户需求和习俗。</p>\n</li>\n<li><p><strong>动态字体和布局测试</strong> - 使用Xcode中的辅助功能检查器来预览应用在不同字体大小下的表现。</p>\n</li>\n</ol>\n<p>通过实施这些策略，开发者可以确保他们的应用不仅在不同地区和文化中使用无障碍，而且可以为所有用户提供一个更加个性化和易于使用的体验。</p>\n"},{"title":"SwiftUI核心技术第3章环境搭建","date":"2023-11-07T16:28:17.000Z","_content":"\n**1. Xcode和SwiftUI**\n\n为了开始使用SwiftUI，您需要安装Xcode，这是Apple提供的官方集成开发环境（IDE）。Xcode提供了构建iOS、iPadOS、macOS、watchOS和tvOS应用的所有工具和资源。SwiftUI是Xcode的一部分，是一个用于设计和开发用户界面的框架。在这一节中，我们将指导您如何设置Xcode和开始使用SwiftUI。\n\n**安装Xcode**\n\n1. **从Mac App Store下载Xcode**\n   \n   Xcode是免费的，可以直接从Mac App Store下载。确保您的Mac操作系统是最新的，因为新版本的Xcode通常只能在最新或次新的操作系统上运行。\n\n2. **启动Xcode并安装额外组件**\n\n   当您第一次打开Xcode时，它可能会提示您安装额外的必需组件。按照提示进行安装。\n\n3. **接受Xcode许可协议**\n\n   在安装组件之前，您可能需要接受Xcode的许可协议。您可以通过Xcode或使用终端命令行来完成这一步骤。\n\n**配置Xcode**\n\n安装完成后，您可能需要进行一些基础配置：\n\n1. **设置开发者账户**\n\n   在Xcode的Preferences（偏好设置）中，您可以登录您的Apple开发者账户。如果您还没有账户，您需要注册一个。\n\n2. **下载模拟器或配置开发设备**\n\n   如果您打算在真实设备上运行应用，需要在Xcode中配置您的iOS设备。否则，您可以下载并使用模拟器。\n\n**创建SwiftUI项目**\n\n1. **打开Xcode并创建一个新的项目**\n\n   选择“Create a new Xcode project”（创建一个新的Xcode项目）。\n\n2. **选择项目模板**\n\n   在模板选择器中，选择“App”作为您的项目模板。\n\n3. **配置项目设置**\n\n   您需要填写项目名称、团队、组织名称、组织标识符以及选择您想要支持的平台。\n\n4. **选择SwiftUI作为界面**\n\n   在创建项目时，确保在“User Interface”选项中选择“SwiftUI”。\n\n**探索SwiftUI**\n\n1. **Canvas**\n\n   Xcode提供了一个实时预览界面（Canvas），您可以看到SwiftUI代码的实时渲染结果。通过点击Canvas右上角的“Resume”按钮，可以启动或刷新预览。\n\n2. **Inspector**\n\n   Xcode的Inspector可以帮助您调整SwiftUI视图的属性，您可以直接通过图形界面来调整代码，而不需要编写任何代码。\n\n3. **代码编辑器**\n\n   Xcode的代码编辑器是您编写Swift和SwiftUI代码的地方。它提供了代码高亮、自动完成等功能，这可以极大提升编码效率。\n\n**构建和运行**\n\n1. **选择目标**\n\n   在Xcode顶部的工具栏中，您可以选择要在哪个模拟器或真实设备上运行您的应用。\n\n2. **构建并运行应用**\n\n   点击工具栏中的“Run”按钮（或使用快捷键`Command + R`）来构建并运行您的应用。如果一切设置正确，您应该能看到您的SwiftUI应用在模拟器或设备上运行。\n\n**总结**\n\n设置Xcode并开始使用SwiftUI是开发现代iOS应用的第一步。通过Xcode，您可以使用SwiftUI框架来创建美观、响应迅速且易于维护的用户界面。本节提供了有关如何安装和配置Xcode、创建新的SwiftUI项目以及构建和运行应用的基本信息。掌握这些基础知识后，您将准备好深入探索SwiftUI的强大功能，并开始构建您自己的应用。\n\n**2. Swift Package Manager**\n\nSwift Package Manager（简称SPM）是Apple官方提供的一个用于自动化Swift代码的依赖管理和分发的工具。它与Xcode紧密集成，允许开发者方便地添加、更新和管理依赖库。\n\n**SPM的概念**\n\n1. **包（Package）**：是一个或多个库的集合，它们共享一个构建设置和版本号。\n2. **库（Library）**：是可复用代码的集合，用于构建程序或其他库。\n3. **依赖（Dependency）**：是您的项目需要的外部库或包。\n\n**使用Swift Package Manager**\n\n1. **创建Package.swift**\n\n   为了使用SPM，您的项目需要一个`Package.swift`文件，这是一个定义了包的名称、平台、Swift版本和依赖的清单文件。以下是一个基本的`Package.swift`示例：\n\n   ```swift\n   // swift-tools-version:5.3\n   import PackageDescription\n\n   let package = Package(\n       name: \"MyLibrary\",\n       platforms: [\n          .macOS(.v10_15), .iOS(.v13)\n       ],\n       products: [\n           .library(\n               name: \"MyLibrary\",\n               targets: [\"MyLibrary\"]),\n       ],\n       dependencies: [\n           .package(url: \"https://github.com/someone/Something.git\", from: \"1.0.0\"),\n       ],\n       targets: [\n           .target(\n               name: \"MyLibrary\",\n               dependencies: []),\n           .testTarget(\n               name: \"MyLibraryTests\",\n               dependencies: [\"MyLibrary\"]),\n       ]\n   )\n   ```\n\n2. **添加依赖**\n\n   在`Package.swift`文件中，您可以添加其他包作为依赖。SPM将自动下载和链接这些依赖。\n\n3. **集成到Xcode项目**\n\n   您可以通过Xcode直接添加SPM依赖：\n   - 打开Xcode项目或工作区。\n   - 选择“File” > “Swift Packages” > “Add Package Dependency...”。\n   - 输入包的Git存储库URL，然后选择一个版本号或分支。\n   - 选择要添加到哪个目标，然后完成集成流程。\n\n4. **使用命令行**\n\n   您也可以通过命令行界面使用SPM：\n   - `swift build`：构建您的项目。\n   - `swift test`：测试您的项目。\n   - `swift run`：运行您的项目。\n   - `swift package update`：更新您的依赖。\n\n**管理依赖版本**\n\nSPM支持多种方式指定依赖版本：\n- 指定一个具体版本号。\n- 指定一个版本范围。\n- 使用分支名称或提交哈希。\n\n例如：\n\n```swift\n.package(url: \"https://github.com/someone/Something.git\", .exact(\"1.0.0\"))\n.package(url: \"https://github.com/someone/Something.git\", from: \"1.0.0\")\n.package(url: \"https://github.com/someone/Something.git\", .branch(\"main\"))\n```\n\n**总结**\n\nSwift Package Manager是一个强大的依赖管理工具，它简化了Swift项目中库和依赖的管理。通过声明式的`Package.swift`文件和Xcode的集成，SPM使得添加、更新和维护依赖变得既简单又可靠。了解SPM是现代Swift开发的重要组成部分，尤其是当您开始构建更大型且依赖多个第三方库的项目时。掌握SPM的使用将帮助您保持项目的清洁和组织，提高构建的可复用性和可维护性。\n\n\n**3. 创建第一个SwiftUI应用**\n\n进入到SwiftUI世界的第一步是创建您的第一个SwiftUI应用。本节将指导您完成创建和运行一个基本的SwiftUI应用程序的步骤，让您快速体验到SwiftUI开发的流畅和直观。\n\n**设置项目**\n\n1. **启动Xcode**：\n   打开Xcode。在欢迎屏幕上选择“Create a new Xcode project”或在菜单栏选择“File” > “New” > “Project”。\n\n2. **选择模板**：\n   在项目模板选择界面，选择“App”作为项目模板。这将创建一个包含所有必需文件的iOS应用程序项目。\n\n3. **项目配置**：\n   在“Choose options for your new project”界面，填写项目的详细信息：\n   - `Product Name`：应用程序的名称。\n   - `Team`：如果您已注册Apple开发者计划并设置了Xcode，选择您的开发者团队。\n   - `Organization Identifier`：通常是您或您公司的域名反写（例如com.example）。\n   - `Interface`：确保选择“SwiftUI”。\n   - `Language`：选择“Swift”。\n   - `Lifecycle`：根据您的需求选择“SwiftUI App”。\n   - `Use Core Data`：如果不需要，保持未选中状态。\n   - `Include Tests`：如果您打算写测试，选择相应的测试复选框。\n\n4. **选择保存位置**：\n   选择一个适合您项目的位置，并且如果您想使用版本控制（例如Git），确保选中“Create Git repository”。\n\n**探索SwiftUI工作区**\n\n1. **Project Navigator**：\n   在Xcode左侧的侧边栏中，您可以看到Project Navigator，它展示了项目中所有的文件和资源。\n\n2. **ContentView.swift**：\n   这是您的SwiftUI视图代码所在的文件。Xcode默认为您提供了一个包含Text视图的简单SwiftUI视图。\n\n3. **Preview**：\n   Xcode支持SwiftUI的实时预览。如果Preview未自动显示，您可以点击代码编辑器顶部的“Resume”按钮来加载它。\n\n**编写SwiftUI代码**\n\n1. **修改ContentView**：\n   - 用以下代码替换`ContentView`结构体中的内容：\n\n     ```swift\n     struct ContentView: View {\n         var body: some View {\n             Text(\"Hello, SwiftUI!\")\n                 .padding()\n         }\n     }\n     ```\n\n2. **使用Preview**：\n   - 使用Preview功能，您可以实时看到代码更改的效果。如果预览未显示，点击“Resume”按钮。\n\n**运行应用**\n\n1. **选择模拟器或设备**：\n   在Xcode工具栏中，选择一个模拟器或连接的设备作为目标。\n\n2. **构建并运行**：\n   点击工具栏中的“Run”按钮或使用快捷键`Command + R`来编译并运行您的应用。\n\n3. **查看结果**：\n   您的应用程序将启动，并在所选模拟器或设备上显示“Hello, SwiftUI!”文本。\n\n**总结**\n\n恭喜您！通过完成这些步骤，您已经成功创建并运行了您的第一个SwiftUI应用。这只是一个开始，SwiftUI有着非常丰富的视图和控件供您使用，通过学习和实验，您将能够构建出功能强大且界面美观的应用程序。接下来的章节中，我们将进一步深入探索SwiftUI提供的各种构建用户界面的工具和技术。\n","source":"_posts/SwiftUI核心技术第3章环境搭建.md","raw":"---\ntitle: SwiftUI核心技术第3章环境搭建\ndate: 2023-11-08 00:28:17\ncategories:\n- SwiftUI\ntags:\n---\n\n**1. Xcode和SwiftUI**\n\n为了开始使用SwiftUI，您需要安装Xcode，这是Apple提供的官方集成开发环境（IDE）。Xcode提供了构建iOS、iPadOS、macOS、watchOS和tvOS应用的所有工具和资源。SwiftUI是Xcode的一部分，是一个用于设计和开发用户界面的框架。在这一节中，我们将指导您如何设置Xcode和开始使用SwiftUI。\n\n**安装Xcode**\n\n1. **从Mac App Store下载Xcode**\n   \n   Xcode是免费的，可以直接从Mac App Store下载。确保您的Mac操作系统是最新的，因为新版本的Xcode通常只能在最新或次新的操作系统上运行。\n\n2. **启动Xcode并安装额外组件**\n\n   当您第一次打开Xcode时，它可能会提示您安装额外的必需组件。按照提示进行安装。\n\n3. **接受Xcode许可协议**\n\n   在安装组件之前，您可能需要接受Xcode的许可协议。您可以通过Xcode或使用终端命令行来完成这一步骤。\n\n**配置Xcode**\n\n安装完成后，您可能需要进行一些基础配置：\n\n1. **设置开发者账户**\n\n   在Xcode的Preferences（偏好设置）中，您可以登录您的Apple开发者账户。如果您还没有账户，您需要注册一个。\n\n2. **下载模拟器或配置开发设备**\n\n   如果您打算在真实设备上运行应用，需要在Xcode中配置您的iOS设备。否则，您可以下载并使用模拟器。\n\n**创建SwiftUI项目**\n\n1. **打开Xcode并创建一个新的项目**\n\n   选择“Create a new Xcode project”（创建一个新的Xcode项目）。\n\n2. **选择项目模板**\n\n   在模板选择器中，选择“App”作为您的项目模板。\n\n3. **配置项目设置**\n\n   您需要填写项目名称、团队、组织名称、组织标识符以及选择您想要支持的平台。\n\n4. **选择SwiftUI作为界面**\n\n   在创建项目时，确保在“User Interface”选项中选择“SwiftUI”。\n\n**探索SwiftUI**\n\n1. **Canvas**\n\n   Xcode提供了一个实时预览界面（Canvas），您可以看到SwiftUI代码的实时渲染结果。通过点击Canvas右上角的“Resume”按钮，可以启动或刷新预览。\n\n2. **Inspector**\n\n   Xcode的Inspector可以帮助您调整SwiftUI视图的属性，您可以直接通过图形界面来调整代码，而不需要编写任何代码。\n\n3. **代码编辑器**\n\n   Xcode的代码编辑器是您编写Swift和SwiftUI代码的地方。它提供了代码高亮、自动完成等功能，这可以极大提升编码效率。\n\n**构建和运行**\n\n1. **选择目标**\n\n   在Xcode顶部的工具栏中，您可以选择要在哪个模拟器或真实设备上运行您的应用。\n\n2. **构建并运行应用**\n\n   点击工具栏中的“Run”按钮（或使用快捷键`Command + R`）来构建并运行您的应用。如果一切设置正确，您应该能看到您的SwiftUI应用在模拟器或设备上运行。\n\n**总结**\n\n设置Xcode并开始使用SwiftUI是开发现代iOS应用的第一步。通过Xcode，您可以使用SwiftUI框架来创建美观、响应迅速且易于维护的用户界面。本节提供了有关如何安装和配置Xcode、创建新的SwiftUI项目以及构建和运行应用的基本信息。掌握这些基础知识后，您将准备好深入探索SwiftUI的强大功能，并开始构建您自己的应用。\n\n**2. Swift Package Manager**\n\nSwift Package Manager（简称SPM）是Apple官方提供的一个用于自动化Swift代码的依赖管理和分发的工具。它与Xcode紧密集成，允许开发者方便地添加、更新和管理依赖库。\n\n**SPM的概念**\n\n1. **包（Package）**：是一个或多个库的集合，它们共享一个构建设置和版本号。\n2. **库（Library）**：是可复用代码的集合，用于构建程序或其他库。\n3. **依赖（Dependency）**：是您的项目需要的外部库或包。\n\n**使用Swift Package Manager**\n\n1. **创建Package.swift**\n\n   为了使用SPM，您的项目需要一个`Package.swift`文件，这是一个定义了包的名称、平台、Swift版本和依赖的清单文件。以下是一个基本的`Package.swift`示例：\n\n   ```swift\n   // swift-tools-version:5.3\n   import PackageDescription\n\n   let package = Package(\n       name: \"MyLibrary\",\n       platforms: [\n          .macOS(.v10_15), .iOS(.v13)\n       ],\n       products: [\n           .library(\n               name: \"MyLibrary\",\n               targets: [\"MyLibrary\"]),\n       ],\n       dependencies: [\n           .package(url: \"https://github.com/someone/Something.git\", from: \"1.0.0\"),\n       ],\n       targets: [\n           .target(\n               name: \"MyLibrary\",\n               dependencies: []),\n           .testTarget(\n               name: \"MyLibraryTests\",\n               dependencies: [\"MyLibrary\"]),\n       ]\n   )\n   ```\n\n2. **添加依赖**\n\n   在`Package.swift`文件中，您可以添加其他包作为依赖。SPM将自动下载和链接这些依赖。\n\n3. **集成到Xcode项目**\n\n   您可以通过Xcode直接添加SPM依赖：\n   - 打开Xcode项目或工作区。\n   - 选择“File” > “Swift Packages” > “Add Package Dependency...”。\n   - 输入包的Git存储库URL，然后选择一个版本号或分支。\n   - 选择要添加到哪个目标，然后完成集成流程。\n\n4. **使用命令行**\n\n   您也可以通过命令行界面使用SPM：\n   - `swift build`：构建您的项目。\n   - `swift test`：测试您的项目。\n   - `swift run`：运行您的项目。\n   - `swift package update`：更新您的依赖。\n\n**管理依赖版本**\n\nSPM支持多种方式指定依赖版本：\n- 指定一个具体版本号。\n- 指定一个版本范围。\n- 使用分支名称或提交哈希。\n\n例如：\n\n```swift\n.package(url: \"https://github.com/someone/Something.git\", .exact(\"1.0.0\"))\n.package(url: \"https://github.com/someone/Something.git\", from: \"1.0.0\")\n.package(url: \"https://github.com/someone/Something.git\", .branch(\"main\"))\n```\n\n**总结**\n\nSwift Package Manager是一个强大的依赖管理工具，它简化了Swift项目中库和依赖的管理。通过声明式的`Package.swift`文件和Xcode的集成，SPM使得添加、更新和维护依赖变得既简单又可靠。了解SPM是现代Swift开发的重要组成部分，尤其是当您开始构建更大型且依赖多个第三方库的项目时。掌握SPM的使用将帮助您保持项目的清洁和组织，提高构建的可复用性和可维护性。\n\n\n**3. 创建第一个SwiftUI应用**\n\n进入到SwiftUI世界的第一步是创建您的第一个SwiftUI应用。本节将指导您完成创建和运行一个基本的SwiftUI应用程序的步骤，让您快速体验到SwiftUI开发的流畅和直观。\n\n**设置项目**\n\n1. **启动Xcode**：\n   打开Xcode。在欢迎屏幕上选择“Create a new Xcode project”或在菜单栏选择“File” > “New” > “Project”。\n\n2. **选择模板**：\n   在项目模板选择界面，选择“App”作为项目模板。这将创建一个包含所有必需文件的iOS应用程序项目。\n\n3. **项目配置**：\n   在“Choose options for your new project”界面，填写项目的详细信息：\n   - `Product Name`：应用程序的名称。\n   - `Team`：如果您已注册Apple开发者计划并设置了Xcode，选择您的开发者团队。\n   - `Organization Identifier`：通常是您或您公司的域名反写（例如com.example）。\n   - `Interface`：确保选择“SwiftUI”。\n   - `Language`：选择“Swift”。\n   - `Lifecycle`：根据您的需求选择“SwiftUI App”。\n   - `Use Core Data`：如果不需要，保持未选中状态。\n   - `Include Tests`：如果您打算写测试，选择相应的测试复选框。\n\n4. **选择保存位置**：\n   选择一个适合您项目的位置，并且如果您想使用版本控制（例如Git），确保选中“Create Git repository”。\n\n**探索SwiftUI工作区**\n\n1. **Project Navigator**：\n   在Xcode左侧的侧边栏中，您可以看到Project Navigator，它展示了项目中所有的文件和资源。\n\n2. **ContentView.swift**：\n   这是您的SwiftUI视图代码所在的文件。Xcode默认为您提供了一个包含Text视图的简单SwiftUI视图。\n\n3. **Preview**：\n   Xcode支持SwiftUI的实时预览。如果Preview未自动显示，您可以点击代码编辑器顶部的“Resume”按钮来加载它。\n\n**编写SwiftUI代码**\n\n1. **修改ContentView**：\n   - 用以下代码替换`ContentView`结构体中的内容：\n\n     ```swift\n     struct ContentView: View {\n         var body: some View {\n             Text(\"Hello, SwiftUI!\")\n                 .padding()\n         }\n     }\n     ```\n\n2. **使用Preview**：\n   - 使用Preview功能，您可以实时看到代码更改的效果。如果预览未显示，点击“Resume”按钮。\n\n**运行应用**\n\n1. **选择模拟器或设备**：\n   在Xcode工具栏中，选择一个模拟器或连接的设备作为目标。\n\n2. **构建并运行**：\n   点击工具栏中的“Run”按钮或使用快捷键`Command + R`来编译并运行您的应用。\n\n3. **查看结果**：\n   您的应用程序将启动，并在所选模拟器或设备上显示“Hello, SwiftUI!”文本。\n\n**总结**\n\n恭喜您！通过完成这些步骤，您已经成功创建并运行了您的第一个SwiftUI应用。这只是一个开始，SwiftUI有着非常丰富的视图和控件供您使用，通过学习和实验，您将能够构建出功能强大且界面美观的应用程序。接下来的章节中，我们将进一步深入探索SwiftUI提供的各种构建用户界面的工具和技术。\n","slug":"SwiftUI核心技术第3章环境搭建","published":1,"updated":"2024-03-17T06:11:12.787Z","comments":1,"layout":"post","photos":[],"_id":"clu6up53i0028z6745a62g4f1","content":"<p><strong>1. Xcode和SwiftUI</strong></p>\n<p>为了开始使用SwiftUI，您需要安装Xcode，这是Apple提供的官方集成开发环境（IDE）。Xcode提供了构建iOS、iPadOS、macOS、watchOS和tvOS应用的所有工具和资源。SwiftUI是Xcode的一部分，是一个用于设计和开发用户界面的框架。在这一节中，我们将指导您如何设置Xcode和开始使用SwiftUI。</p>\n<p><strong>安装Xcode</strong></p>\n<ol>\n<li><p><strong>从Mac App Store下载Xcode</strong></p>\n<p>Xcode是免费的，可以直接从Mac App Store下载。确保您的Mac操作系统是最新的，因为新版本的Xcode通常只能在最新或次新的操作系统上运行。</p>\n</li>\n<li><p><strong>启动Xcode并安装额外组件</strong></p>\n<p>当您第一次打开Xcode时，它可能会提示您安装额外的必需组件。按照提示进行安装。</p>\n</li>\n<li><p><strong>接受Xcode许可协议</strong></p>\n<p>在安装组件之前，您可能需要接受Xcode的许可协议。您可以通过Xcode或使用终端命令行来完成这一步骤。</p>\n</li>\n</ol>\n<p><strong>配置Xcode</strong></p>\n<p>安装完成后，您可能需要进行一些基础配置：</p>\n<ol>\n<li><p><strong>设置开发者账户</strong></p>\n<p>在Xcode的Preferences（偏好设置）中，您可以登录您的Apple开发者账户。如果您还没有账户，您需要注册一个。</p>\n</li>\n<li><p><strong>下载模拟器或配置开发设备</strong></p>\n<p>如果您打算在真实设备上运行应用，需要在Xcode中配置您的iOS设备。否则，您可以下载并使用模拟器。</p>\n</li>\n</ol>\n<p><strong>创建SwiftUI项目</strong></p>\n<ol>\n<li><p><strong>打开Xcode并创建一个新的项目</strong></p>\n<p>选择“Create a new Xcode project”（创建一个新的Xcode项目）。</p>\n</li>\n<li><p><strong>选择项目模板</strong></p>\n<p>在模板选择器中，选择“App”作为您的项目模板。</p>\n</li>\n<li><p><strong>配置项目设置</strong></p>\n<p>您需要填写项目名称、团队、组织名称、组织标识符以及选择您想要支持的平台。</p>\n</li>\n<li><p><strong>选择SwiftUI作为界面</strong></p>\n<p>在创建项目时，确保在“User Interface”选项中选择“SwiftUI”。</p>\n</li>\n</ol>\n<p><strong>探索SwiftUI</strong></p>\n<ol>\n<li><p><strong>Canvas</strong></p>\n<p>Xcode提供了一个实时预览界面（Canvas），您可以看到SwiftUI代码的实时渲染结果。通过点击Canvas右上角的“Resume”按钮，可以启动或刷新预览。</p>\n</li>\n<li><p><strong>Inspector</strong></p>\n<p>Xcode的Inspector可以帮助您调整SwiftUI视图的属性，您可以直接通过图形界面来调整代码，而不需要编写任何代码。</p>\n</li>\n<li><p><strong>代码编辑器</strong></p>\n<p>Xcode的代码编辑器是您编写Swift和SwiftUI代码的地方。它提供了代码高亮、自动完成等功能，这可以极大提升编码效率。</p>\n</li>\n</ol>\n<p><strong>构建和运行</strong></p>\n<ol>\n<li><p><strong>选择目标</strong></p>\n<p>在Xcode顶部的工具栏中，您可以选择要在哪个模拟器或真实设备上运行您的应用。</p>\n</li>\n<li><p><strong>构建并运行应用</strong></p>\n<p>点击工具栏中的“Run”按钮（或使用快捷键<code>Command + R</code>）来构建并运行您的应用。如果一切设置正确，您应该能看到您的SwiftUI应用在模拟器或设备上运行。</p>\n</li>\n</ol>\n<p><strong>总结</strong></p>\n<p>设置Xcode并开始使用SwiftUI是开发现代iOS应用的第一步。通过Xcode，您可以使用SwiftUI框架来创建美观、响应迅速且易于维护的用户界面。本节提供了有关如何安装和配置Xcode、创建新的SwiftUI项目以及构建和运行应用的基本信息。掌握这些基础知识后，您将准备好深入探索SwiftUI的强大功能，并开始构建您自己的应用。</p>\n<p><strong>2. Swift Package Manager</strong></p>\n<p>Swift Package Manager（简称SPM）是Apple官方提供的一个用于自动化Swift代码的依赖管理和分发的工具。它与Xcode紧密集成，允许开发者方便地添加、更新和管理依赖库。</p>\n<p><strong>SPM的概念</strong></p>\n<ol>\n<li><strong>包（Package）</strong>：是一个或多个库的集合，它们共享一个构建设置和版本号。</li>\n<li><strong>库（Library）</strong>：是可复用代码的集合，用于构建程序或其他库。</li>\n<li><strong>依赖（Dependency）</strong>：是您的项目需要的外部库或包。</li>\n</ol>\n<p><strong>使用Swift Package Manager</strong></p>\n<ol>\n<li><p><strong>创建Package.swift</strong></p>\n<p>为了使用SPM，您的项目需要一个<code>Package.swift</code>文件，这是一个定义了包的名称、平台、Swift版本和依赖的清单文件。以下是一个基本的<code>Package.swift</code>示例：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-comment\">// swift-tools-version:5.3</span><br><span class=\"hljs-keyword\">import</span> PackageDescription<br><br><span class=\"hljs-keyword\">let</span> package <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">Package</span>(<br>    name: <span class=\"hljs-string\">&quot;MyLibrary&quot;</span>,<br>    platforms: [<br>       .macOS(.v10_15), .iOS(.v13)<br>    ],<br>    products: [<br>        .library(<br>            name: <span class=\"hljs-string\">&quot;MyLibrary&quot;</span>,<br>            targets: [<span class=\"hljs-string\">&quot;MyLibrary&quot;</span>]),<br>    ],<br>    dependencies: [<br>        .package(url: <span class=\"hljs-string\">&quot;https://github.com/someone/Something.git&quot;</span>, from: <span class=\"hljs-string\">&quot;1.0.0&quot;</span>),<br>    ],<br>    targets: [<br>        .target(<br>            name: <span class=\"hljs-string\">&quot;MyLibrary&quot;</span>,<br>            dependencies: []),<br>        .testTarget(<br>            name: <span class=\"hljs-string\">&quot;MyLibraryTests&quot;</span>,<br>            dependencies: [<span class=\"hljs-string\">&quot;MyLibrary&quot;</span>]),<br>    ]<br>)<br></code></pre></td></tr></table></figure>\n</li>\n<li><p><strong>添加依赖</strong></p>\n<p>在<code>Package.swift</code>文件中，您可以添加其他包作为依赖。SPM将自动下载和链接这些依赖。</p>\n</li>\n<li><p><strong>集成到Xcode项目</strong></p>\n<p>您可以通过Xcode直接添加SPM依赖：</p>\n<ul>\n<li>打开Xcode项目或工作区。</li>\n<li>选择“File” &gt; “Swift Packages” &gt; “Add Package Dependency…”。</li>\n<li>输入包的Git存储库URL，然后选择一个版本号或分支。</li>\n<li>选择要添加到哪个目标，然后完成集成流程。</li>\n</ul>\n</li>\n<li><p><strong>使用命令行</strong></p>\n<p>您也可以通过命令行界面使用SPM：</p>\n<ul>\n<li><code>swift build</code>：构建您的项目。</li>\n<li><code>swift test</code>：测试您的项目。</li>\n<li><code>swift run</code>：运行您的项目。</li>\n<li><code>swift package update</code>：更新您的依赖。</li>\n</ul>\n</li>\n</ol>\n<p><strong>管理依赖版本</strong></p>\n<p>SPM支持多种方式指定依赖版本：</p>\n<ul>\n<li>指定一个具体版本号。</li>\n<li>指定一个版本范围。</li>\n<li>使用分支名称或提交哈希。</li>\n</ul>\n<p>例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\">.package(url: <span class=\"hljs-string\">&quot;https://github.com/someone/Something.git&quot;</span>, .exact(<span class=\"hljs-string\">&quot;1.0.0&quot;</span>))<br>.package(url: <span class=\"hljs-string\">&quot;https://github.com/someone/Something.git&quot;</span>, from: <span class=\"hljs-string\">&quot;1.0.0&quot;</span>)<br>.package(url: <span class=\"hljs-string\">&quot;https://github.com/someone/Something.git&quot;</span>, .branch(<span class=\"hljs-string\">&quot;main&quot;</span>))<br></code></pre></td></tr></table></figure>\n\n<p><strong>总结</strong></p>\n<p>Swift Package Manager是一个强大的依赖管理工具，它简化了Swift项目中库和依赖的管理。通过声明式的<code>Package.swift</code>文件和Xcode的集成，SPM使得添加、更新和维护依赖变得既简单又可靠。了解SPM是现代Swift开发的重要组成部分，尤其是当您开始构建更大型且依赖多个第三方库的项目时。掌握SPM的使用将帮助您保持项目的清洁和组织，提高构建的可复用性和可维护性。</p>\n<p><strong>3. 创建第一个SwiftUI应用</strong></p>\n<p>进入到SwiftUI世界的第一步是创建您的第一个SwiftUI应用。本节将指导您完成创建和运行一个基本的SwiftUI应用程序的步骤，让您快速体验到SwiftUI开发的流畅和直观。</p>\n<p><strong>设置项目</strong></p>\n<ol>\n<li><p><strong>启动Xcode</strong>：<br>打开Xcode。在欢迎屏幕上选择“Create a new Xcode project”或在菜单栏选择“File” &gt; “New” &gt; “Project”。</p>\n</li>\n<li><p><strong>选择模板</strong>：<br>在项目模板选择界面，选择“App”作为项目模板。这将创建一个包含所有必需文件的iOS应用程序项目。</p>\n</li>\n<li><p><strong>项目配置</strong>：<br>在“Choose options for your new project”界面，填写项目的详细信息：</p>\n<ul>\n<li><code>Product Name</code>：应用程序的名称。</li>\n<li><code>Team</code>：如果您已注册Apple开发者计划并设置了Xcode，选择您的开发者团队。</li>\n<li><code>Organization Identifier</code>：通常是您或您公司的域名反写（例如com.example）。</li>\n<li><code>Interface</code>：确保选择“SwiftUI”。</li>\n<li><code>Language</code>：选择“Swift”。</li>\n<li><code>Lifecycle</code>：根据您的需求选择“SwiftUI App”。</li>\n<li><code>Use Core Data</code>：如果不需要，保持未选中状态。</li>\n<li><code>Include Tests</code>：如果您打算写测试，选择相应的测试复选框。</li>\n</ul>\n</li>\n<li><p><strong>选择保存位置</strong>：<br>选择一个适合您项目的位置，并且如果您想使用版本控制（例如Git），确保选中“Create Git repository”。</p>\n</li>\n</ol>\n<p><strong>探索SwiftUI工作区</strong></p>\n<ol>\n<li><p><strong>Project Navigator</strong>：<br>在Xcode左侧的侧边栏中，您可以看到Project Navigator，它展示了项目中所有的文件和资源。</p>\n</li>\n<li><p><strong>ContentView.swift</strong>：<br>这是您的SwiftUI视图代码所在的文件。Xcode默认为您提供了一个包含Text视图的简单SwiftUI视图。</p>\n</li>\n<li><p><strong>Preview</strong>：<br>Xcode支持SwiftUI的实时预览。如果Preview未自动显示，您可以点击代码编辑器顶部的“Resume”按钮来加载它。</p>\n</li>\n</ol>\n<p><strong>编写SwiftUI代码</strong></p>\n<ol>\n<li><p><strong>修改ContentView</strong>：</p>\n<ul>\n<li><p>用以下代码替换<code>ContentView</code>结构体中的内容：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ContentView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Hello, SwiftUI!&quot;</span>)<br>            .padding()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p><strong>使用Preview</strong>：</p>\n<ul>\n<li>使用Preview功能，您可以实时看到代码更改的效果。如果预览未显示，点击“Resume”按钮。</li>\n</ul>\n</li>\n</ol>\n<p><strong>运行应用</strong></p>\n<ol>\n<li><p><strong>选择模拟器或设备</strong>：<br>在Xcode工具栏中，选择一个模拟器或连接的设备作为目标。</p>\n</li>\n<li><p><strong>构建并运行</strong>：<br>点击工具栏中的“Run”按钮或使用快捷键<code>Command + R</code>来编译并运行您的应用。</p>\n</li>\n<li><p><strong>查看结果</strong>：<br>您的应用程序将启动，并在所选模拟器或设备上显示“Hello, SwiftUI!”文本。</p>\n</li>\n</ol>\n<p><strong>总结</strong></p>\n<p>恭喜您！通过完成这些步骤，您已经成功创建并运行了您的第一个SwiftUI应用。这只是一个开始，SwiftUI有着非常丰富的视图和控件供您使用，通过学习和实验，您将能够构建出功能强大且界面美观的应用程序。接下来的章节中，我们将进一步深入探索SwiftUI提供的各种构建用户界面的工具和技术。</p>\n","excerpt":"","more":"<p><strong>1. Xcode和SwiftUI</strong></p>\n<p>为了开始使用SwiftUI，您需要安装Xcode，这是Apple提供的官方集成开发环境（IDE）。Xcode提供了构建iOS、iPadOS、macOS、watchOS和tvOS应用的所有工具和资源。SwiftUI是Xcode的一部分，是一个用于设计和开发用户界面的框架。在这一节中，我们将指导您如何设置Xcode和开始使用SwiftUI。</p>\n<p><strong>安装Xcode</strong></p>\n<ol>\n<li><p><strong>从Mac App Store下载Xcode</strong></p>\n<p>Xcode是免费的，可以直接从Mac App Store下载。确保您的Mac操作系统是最新的，因为新版本的Xcode通常只能在最新或次新的操作系统上运行。</p>\n</li>\n<li><p><strong>启动Xcode并安装额外组件</strong></p>\n<p>当您第一次打开Xcode时，它可能会提示您安装额外的必需组件。按照提示进行安装。</p>\n</li>\n<li><p><strong>接受Xcode许可协议</strong></p>\n<p>在安装组件之前，您可能需要接受Xcode的许可协议。您可以通过Xcode或使用终端命令行来完成这一步骤。</p>\n</li>\n</ol>\n<p><strong>配置Xcode</strong></p>\n<p>安装完成后，您可能需要进行一些基础配置：</p>\n<ol>\n<li><p><strong>设置开发者账户</strong></p>\n<p>在Xcode的Preferences（偏好设置）中，您可以登录您的Apple开发者账户。如果您还没有账户，您需要注册一个。</p>\n</li>\n<li><p><strong>下载模拟器或配置开发设备</strong></p>\n<p>如果您打算在真实设备上运行应用，需要在Xcode中配置您的iOS设备。否则，您可以下载并使用模拟器。</p>\n</li>\n</ol>\n<p><strong>创建SwiftUI项目</strong></p>\n<ol>\n<li><p><strong>打开Xcode并创建一个新的项目</strong></p>\n<p>选择“Create a new Xcode project”（创建一个新的Xcode项目）。</p>\n</li>\n<li><p><strong>选择项目模板</strong></p>\n<p>在模板选择器中，选择“App”作为您的项目模板。</p>\n</li>\n<li><p><strong>配置项目设置</strong></p>\n<p>您需要填写项目名称、团队、组织名称、组织标识符以及选择您想要支持的平台。</p>\n</li>\n<li><p><strong>选择SwiftUI作为界面</strong></p>\n<p>在创建项目时，确保在“User Interface”选项中选择“SwiftUI”。</p>\n</li>\n</ol>\n<p><strong>探索SwiftUI</strong></p>\n<ol>\n<li><p><strong>Canvas</strong></p>\n<p>Xcode提供了一个实时预览界面（Canvas），您可以看到SwiftUI代码的实时渲染结果。通过点击Canvas右上角的“Resume”按钮，可以启动或刷新预览。</p>\n</li>\n<li><p><strong>Inspector</strong></p>\n<p>Xcode的Inspector可以帮助您调整SwiftUI视图的属性，您可以直接通过图形界面来调整代码，而不需要编写任何代码。</p>\n</li>\n<li><p><strong>代码编辑器</strong></p>\n<p>Xcode的代码编辑器是您编写Swift和SwiftUI代码的地方。它提供了代码高亮、自动完成等功能，这可以极大提升编码效率。</p>\n</li>\n</ol>\n<p><strong>构建和运行</strong></p>\n<ol>\n<li><p><strong>选择目标</strong></p>\n<p>在Xcode顶部的工具栏中，您可以选择要在哪个模拟器或真实设备上运行您的应用。</p>\n</li>\n<li><p><strong>构建并运行应用</strong></p>\n<p>点击工具栏中的“Run”按钮（或使用快捷键<code>Command + R</code>）来构建并运行您的应用。如果一切设置正确，您应该能看到您的SwiftUI应用在模拟器或设备上运行。</p>\n</li>\n</ol>\n<p><strong>总结</strong></p>\n<p>设置Xcode并开始使用SwiftUI是开发现代iOS应用的第一步。通过Xcode，您可以使用SwiftUI框架来创建美观、响应迅速且易于维护的用户界面。本节提供了有关如何安装和配置Xcode、创建新的SwiftUI项目以及构建和运行应用的基本信息。掌握这些基础知识后，您将准备好深入探索SwiftUI的强大功能，并开始构建您自己的应用。</p>\n<p><strong>2. Swift Package Manager</strong></p>\n<p>Swift Package Manager（简称SPM）是Apple官方提供的一个用于自动化Swift代码的依赖管理和分发的工具。它与Xcode紧密集成，允许开发者方便地添加、更新和管理依赖库。</p>\n<p><strong>SPM的概念</strong></p>\n<ol>\n<li><strong>包（Package）</strong>：是一个或多个库的集合，它们共享一个构建设置和版本号。</li>\n<li><strong>库（Library）</strong>：是可复用代码的集合，用于构建程序或其他库。</li>\n<li><strong>依赖（Dependency）</strong>：是您的项目需要的外部库或包。</li>\n</ol>\n<p><strong>使用Swift Package Manager</strong></p>\n<ol>\n<li><p><strong>创建Package.swift</strong></p>\n<p>为了使用SPM，您的项目需要一个<code>Package.swift</code>文件，这是一个定义了包的名称、平台、Swift版本和依赖的清单文件。以下是一个基本的<code>Package.swift</code>示例：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-comment\">// swift-tools-version:5.3</span><br><span class=\"hljs-keyword\">import</span> PackageDescription<br><br><span class=\"hljs-keyword\">let</span> package <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">Package</span>(<br>    name: <span class=\"hljs-string\">&quot;MyLibrary&quot;</span>,<br>    platforms: [<br>       .macOS(.v10_15), .iOS(.v13)<br>    ],<br>    products: [<br>        .library(<br>            name: <span class=\"hljs-string\">&quot;MyLibrary&quot;</span>,<br>            targets: [<span class=\"hljs-string\">&quot;MyLibrary&quot;</span>]),<br>    ],<br>    dependencies: [<br>        .package(url: <span class=\"hljs-string\">&quot;https://github.com/someone/Something.git&quot;</span>, from: <span class=\"hljs-string\">&quot;1.0.0&quot;</span>),<br>    ],<br>    targets: [<br>        .target(<br>            name: <span class=\"hljs-string\">&quot;MyLibrary&quot;</span>,<br>            dependencies: []),<br>        .testTarget(<br>            name: <span class=\"hljs-string\">&quot;MyLibraryTests&quot;</span>,<br>            dependencies: [<span class=\"hljs-string\">&quot;MyLibrary&quot;</span>]),<br>    ]<br>)<br></code></pre></td></tr></table></figure>\n</li>\n<li><p><strong>添加依赖</strong></p>\n<p>在<code>Package.swift</code>文件中，您可以添加其他包作为依赖。SPM将自动下载和链接这些依赖。</p>\n</li>\n<li><p><strong>集成到Xcode项目</strong></p>\n<p>您可以通过Xcode直接添加SPM依赖：</p>\n<ul>\n<li>打开Xcode项目或工作区。</li>\n<li>选择“File” &gt; “Swift Packages” &gt; “Add Package Dependency…”。</li>\n<li>输入包的Git存储库URL，然后选择一个版本号或分支。</li>\n<li>选择要添加到哪个目标，然后完成集成流程。</li>\n</ul>\n</li>\n<li><p><strong>使用命令行</strong></p>\n<p>您也可以通过命令行界面使用SPM：</p>\n<ul>\n<li><code>swift build</code>：构建您的项目。</li>\n<li><code>swift test</code>：测试您的项目。</li>\n<li><code>swift run</code>：运行您的项目。</li>\n<li><code>swift package update</code>：更新您的依赖。</li>\n</ul>\n</li>\n</ol>\n<p><strong>管理依赖版本</strong></p>\n<p>SPM支持多种方式指定依赖版本：</p>\n<ul>\n<li>指定一个具体版本号。</li>\n<li>指定一个版本范围。</li>\n<li>使用分支名称或提交哈希。</li>\n</ul>\n<p>例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\">.package(url: <span class=\"hljs-string\">&quot;https://github.com/someone/Something.git&quot;</span>, .exact(<span class=\"hljs-string\">&quot;1.0.0&quot;</span>))<br>.package(url: <span class=\"hljs-string\">&quot;https://github.com/someone/Something.git&quot;</span>, from: <span class=\"hljs-string\">&quot;1.0.0&quot;</span>)<br>.package(url: <span class=\"hljs-string\">&quot;https://github.com/someone/Something.git&quot;</span>, .branch(<span class=\"hljs-string\">&quot;main&quot;</span>))<br></code></pre></td></tr></table></figure>\n\n<p><strong>总结</strong></p>\n<p>Swift Package Manager是一个强大的依赖管理工具，它简化了Swift项目中库和依赖的管理。通过声明式的<code>Package.swift</code>文件和Xcode的集成，SPM使得添加、更新和维护依赖变得既简单又可靠。了解SPM是现代Swift开发的重要组成部分，尤其是当您开始构建更大型且依赖多个第三方库的项目时。掌握SPM的使用将帮助您保持项目的清洁和组织，提高构建的可复用性和可维护性。</p>\n<p><strong>3. 创建第一个SwiftUI应用</strong></p>\n<p>进入到SwiftUI世界的第一步是创建您的第一个SwiftUI应用。本节将指导您完成创建和运行一个基本的SwiftUI应用程序的步骤，让您快速体验到SwiftUI开发的流畅和直观。</p>\n<p><strong>设置项目</strong></p>\n<ol>\n<li><p><strong>启动Xcode</strong>：<br>打开Xcode。在欢迎屏幕上选择“Create a new Xcode project”或在菜单栏选择“File” &gt; “New” &gt; “Project”。</p>\n</li>\n<li><p><strong>选择模板</strong>：<br>在项目模板选择界面，选择“App”作为项目模板。这将创建一个包含所有必需文件的iOS应用程序项目。</p>\n</li>\n<li><p><strong>项目配置</strong>：<br>在“Choose options for your new project”界面，填写项目的详细信息：</p>\n<ul>\n<li><code>Product Name</code>：应用程序的名称。</li>\n<li><code>Team</code>：如果您已注册Apple开发者计划并设置了Xcode，选择您的开发者团队。</li>\n<li><code>Organization Identifier</code>：通常是您或您公司的域名反写（例如com.example）。</li>\n<li><code>Interface</code>：确保选择“SwiftUI”。</li>\n<li><code>Language</code>：选择“Swift”。</li>\n<li><code>Lifecycle</code>：根据您的需求选择“SwiftUI App”。</li>\n<li><code>Use Core Data</code>：如果不需要，保持未选中状态。</li>\n<li><code>Include Tests</code>：如果您打算写测试，选择相应的测试复选框。</li>\n</ul>\n</li>\n<li><p><strong>选择保存位置</strong>：<br>选择一个适合您项目的位置，并且如果您想使用版本控制（例如Git），确保选中“Create Git repository”。</p>\n</li>\n</ol>\n<p><strong>探索SwiftUI工作区</strong></p>\n<ol>\n<li><p><strong>Project Navigator</strong>：<br>在Xcode左侧的侧边栏中，您可以看到Project Navigator，它展示了项目中所有的文件和资源。</p>\n</li>\n<li><p><strong>ContentView.swift</strong>：<br>这是您的SwiftUI视图代码所在的文件。Xcode默认为您提供了一个包含Text视图的简单SwiftUI视图。</p>\n</li>\n<li><p><strong>Preview</strong>：<br>Xcode支持SwiftUI的实时预览。如果Preview未自动显示，您可以点击代码编辑器顶部的“Resume”按钮来加载它。</p>\n</li>\n</ol>\n<p><strong>编写SwiftUI代码</strong></p>\n<ol>\n<li><p><strong>修改ContentView</strong>：</p>\n<ul>\n<li><p>用以下代码替换<code>ContentView</code>结构体中的内容：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ContentView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Hello, SwiftUI!&quot;</span>)<br>            .padding()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p><strong>使用Preview</strong>：</p>\n<ul>\n<li>使用Preview功能，您可以实时看到代码更改的效果。如果预览未显示，点击“Resume”按钮。</li>\n</ul>\n</li>\n</ol>\n<p><strong>运行应用</strong></p>\n<ol>\n<li><p><strong>选择模拟器或设备</strong>：<br>在Xcode工具栏中，选择一个模拟器或连接的设备作为目标。</p>\n</li>\n<li><p><strong>构建并运行</strong>：<br>点击工具栏中的“Run”按钮或使用快捷键<code>Command + R</code>来编译并运行您的应用。</p>\n</li>\n<li><p><strong>查看结果</strong>：<br>您的应用程序将启动，并在所选模拟器或设备上显示“Hello, SwiftUI!”文本。</p>\n</li>\n</ol>\n<p><strong>总结</strong></p>\n<p>恭喜您！通过完成这些步骤，您已经成功创建并运行了您的第一个SwiftUI应用。这只是一个开始，SwiftUI有着非常丰富的视图和控件供您使用，通过学习和实验，您将能够构建出功能强大且界面美观的应用程序。接下来的章节中，我们将进一步深入探索SwiftUI提供的各种构建用户界面的工具和技术。</p>\n"},{"title":"SwiftUI核心技术第14章测试与调试","date":"2023-11-08T01:49:07.000Z","_content":"**第1小节：单元测试和UI测试**\n\n在软件开发过程中，测试是确保应用质量的关键步骤。SwiftUI应用的测试主要分为单元测试和UI测试两种。单元测试确保代码逻辑的正确性，而UI测试确保用户界面的行为与期望一致。本节将详细介绍如何在SwiftUI中实施有效的单元测试和UI测试策略。\n\n### 单元测试\n\n单元测试是在最小的代码单位级别上验证功能正确性的测试。在Swift中，单元测试通常是针对独立的函数或对象进行的。\n\n#### 设计可测试的代码\n\n- **解耦和模块化**：确保代码是松耦合和高内聚的，这样更容易编写测试。\n- **依赖注入**：通过依赖注入可以在测试时替换实际的依赖，以实现更精确的测试。\n- **使用协议和Mock对象**：定义接口并在测试中使用Mock对象来模拟真实对象。\n\n#### 编写单元测试\n\n- **XCTest框架**：使用Xcode集成的XCTest框架编写测试用例。\n- **Assert函数**：使用assert函数（如`XCTAssertTrue`, `XCTAssertEqual`等）验证预期结果。\n- **测试边界条件**：确保测试边界情况和异常情况。\n\n### UI测试\n\nUI测试模拟用户与应用界面的交互，验证UI元素的存在性、状态和应用的响应性。\n\n#### 配置UI测试环境\n\n- **使用XCTestUI框架**：XCTestUI提供了一套工具用于编写UI测试。\n- **Accessibility标识**：给UI元素设置Accessibility标识，以便测试脚本可以准确地定位它们。\n\n#### 编写UI测试脚本\n\n- **记录UI交互**：Xcode提供了UI测试录制功能，可以自动生成用户交互的基本代码。\n- **编写测试用例**：基于录制的代码，编写完整的测试用例来验证特定的UI行为。\n- **断言验证**：使用断言来验证UI状态是否符合预期。\n\n### 测试最佳实践\n\n- **持续集成（CI）**：将测试集成到持续集成流程中，确保每次提交都通过测试。\n- **代码覆盖率**：监控代码覆盖率，尽量使之覆盖所有的代码路径。\n- **性能测试**：包含性能测试来验证关键功能的响应时间。\n- **定期回归测试**：每次代码更新后进行回归测试，确保新改动没有引入新的错误。\n\n通过遵循上述方法，您可以为SwiftUI应用实施一套全面的测试策略，显著提高应用的质量和可靠性。记得，测试是一个持续的过程，应随着应用的迭代而不断更新和完善。\n\n\n**第2小节：使用Xcode调试**\n\n调试是发现、定位并修正编程错误过程。Xcode提供了强大的调试工具，它们可以帮助开发者理解代码在运行时的行为，并有效地找到并解决问题。在这一小节中，我们将深入探讨如何使用Xcode来调试SwiftUI应用。\n\n### 断点（Breakpoints）\n\n断点是调试中的一个核心概念，它允许你在特定的代码行暂停代码执行，以便你可以检查此时的变量状态和应用逻辑。\n\n#### 设置断点\n\n- **标准断点**：点击Xcode编辑器左侧的边栏，即可在代码行旁设置断点。\n- **条件断点**：断点可设置条件，使之仅在满足特定条件时才触发。\n- **动作断点**：在触发断点时自动执行一个特定的动作，如打印一条日志信息。\n\n### 调试面板\n\n当代码在断点处停止时，Xcode的调试面板会提供多种工具来帮助你理解代码的状态。\n\n- **变量查看器**：显示当前作用域内所有变量的值。\n- **调用堆栈查看器**：查看函数调用堆栈，了解当前代码执行的路径。\n- **内存检查器**：检查应用的内存使用情况，发现潜在的内存泄露。\n\n### 控制流\n\n使用调试面板的控件来控制应用的执行流。\n\n- **继续执行**（Continue）：继续执行代码直到下一个断点。\n- **逐步执行**（Step Over）：执行当前行，并在下一行停止。\n- **深入执行**（Step Into）：如果当前行调用了一个函数，进入该函数内部。\n- **跳出执行**（Step Out）：从当前函数跳出，回到上一层函数。\n\n### LLDB调试器\n\nLLDB是Xcode使用的底层调试器。你可以使用LLDB控制台来执行更复杂的调试命令。\n\n- **打印变量**：使用`po`命令打印变量的描述。\n- **设置变量值**：直接在调试会话中修改变量的值。\n- **执行表达式**：使用`expr`命令执行代码表达式。\n\n### 性能分析\n\nXcode的Instrument工具可以用来分析应用的性能问题。\n\n- **时间分析器**：查看CPU的使用情况以及代码执行的时间。\n- **内存分析器**：分析应用的内存使用模式和潜在的内存泄露。\n- **网络分析器**：检查应用的网络请求和响应。\n\n### Xcode调试技巧\n\n- **视图调试**（View Debugging）：可视化地检查UI元素的布局和属性。\n- **条件表达式**：使用条件表达式来精确控制断点的触发时机。\n- **符号断点**：在特定的系统函数或方法调用时触发断点。\n\n通过熟练使用Xcode的调试工具，你将能够更快地发现问题所在，并对SwiftUI应用进行高效的故障排查。记得，耐心和细心是调试过程中的良师益友，不断实践将使你成为更高效的开发者。\n\n\n**第3小节：预览与条件编译**\n\nSwiftUI 的预览功能是其最具革命性的特点之一，它允许开发者在不运行整个应用的情况下快速迭代和测试其视图。条件编译则是一种控制代码在不同环境下如何编译的方法。在这一小节中，我们将讨论如何使用这两个强大的功能来提高开发效率和代码质量。\n\n### 使用SwiftUI预览\n\nSwiftUI的`Canvas`视图提供了一个实时预览，它显示了你的用户界面组件在实际应用中的外观和表现。以下是如何高效使用SwiftUI预览的指南：\n\n- **基本预览**：每个SwiftUI视图都可以有一个或多个预览。通过创建`PreviewProvider`的实现，你可以快速看到你的UI更改的效果。\n- **多设备预览**：在预览提供者中，你可以设置多个预览设备和配置，同时查看在不同设备和方向上的界面表现。\n- **动态预览**：通过添加预览参数，如不同的字体大小、颜色主题（包括Dark Mode）和辅助功能设置，你可以查看你的视图在不同用户设置下的表现。\n- **交互式预览**：你可以在Canvas中与UI交互，例如点击按钮或切换开关，这有助于测试视图的响应性。\n- **实时数据预览**：将模型对象注入到预览中，使你可以用实际数据来展示和测试视图。\n\n### 条件编译\n\n在Swift中，可以使用编译配置来为不同的编译目标提供不同的代码路径。这对于处理开发和生产环境的差异至关重要。\n\n- **编译标志**：使用`#if`、`#elseif`和`#endif`指令来控制哪些代码块应被编译。这常用于开发和生产环境的日志记录和配置。\n- **平台特定代码**：可以检查`os(macOS)`、`os(iOS)`等条件，来编写只在特定操作系统上编译的代码。\n- **功能特性检查**：使用`canImport(module)`来确定是否可以导入一个特定的模块，这在跨多个Swift版本或平台时很有用。\n- **调试与发布区分**：使用`DEBUG`标识符来保证某些代码仅在调试构建中编译，而在发布构建中不会包含这些代码。\n\n### 组合预览与条件编译\n\n将SwiftUI预览和条件编译相结合，可以创建更为强大和灵活的开发环境。\n\n- **预览特定配置**：为不同的预览目标配置不同的环境变量或者模拟数据。\n- **隐藏调试UI**：使用条件编译隐藏调试时用到的UI元素，以免它们出现在生产版本的应用中。\n\n通过利用这些工具，你可以确保在开发过程中，你的应用表现出色，并且在上线前能有效地去除所有不必要的测试代码。这样的实践不仅可以提高代码的质量，也能显著减少调试和测试时的工作量。预览和条件编译应当成为每一个SwiftUI开发者工具箱中的核心部分。","source":"_posts/SwiftUI核心技术第14章测试与调试.md","raw":"---\ntitle: SwiftUI核心技术第14章测试与调试\ndate: 2023-11-08 09:49:07\ncategories:\n- SwiftUI\ntags:\n---\n**第1小节：单元测试和UI测试**\n\n在软件开发过程中，测试是确保应用质量的关键步骤。SwiftUI应用的测试主要分为单元测试和UI测试两种。单元测试确保代码逻辑的正确性，而UI测试确保用户界面的行为与期望一致。本节将详细介绍如何在SwiftUI中实施有效的单元测试和UI测试策略。\n\n### 单元测试\n\n单元测试是在最小的代码单位级别上验证功能正确性的测试。在Swift中，单元测试通常是针对独立的函数或对象进行的。\n\n#### 设计可测试的代码\n\n- **解耦和模块化**：确保代码是松耦合和高内聚的，这样更容易编写测试。\n- **依赖注入**：通过依赖注入可以在测试时替换实际的依赖，以实现更精确的测试。\n- **使用协议和Mock对象**：定义接口并在测试中使用Mock对象来模拟真实对象。\n\n#### 编写单元测试\n\n- **XCTest框架**：使用Xcode集成的XCTest框架编写测试用例。\n- **Assert函数**：使用assert函数（如`XCTAssertTrue`, `XCTAssertEqual`等）验证预期结果。\n- **测试边界条件**：确保测试边界情况和异常情况。\n\n### UI测试\n\nUI测试模拟用户与应用界面的交互，验证UI元素的存在性、状态和应用的响应性。\n\n#### 配置UI测试环境\n\n- **使用XCTestUI框架**：XCTestUI提供了一套工具用于编写UI测试。\n- **Accessibility标识**：给UI元素设置Accessibility标识，以便测试脚本可以准确地定位它们。\n\n#### 编写UI测试脚本\n\n- **记录UI交互**：Xcode提供了UI测试录制功能，可以自动生成用户交互的基本代码。\n- **编写测试用例**：基于录制的代码，编写完整的测试用例来验证特定的UI行为。\n- **断言验证**：使用断言来验证UI状态是否符合预期。\n\n### 测试最佳实践\n\n- **持续集成（CI）**：将测试集成到持续集成流程中，确保每次提交都通过测试。\n- **代码覆盖率**：监控代码覆盖率，尽量使之覆盖所有的代码路径。\n- **性能测试**：包含性能测试来验证关键功能的响应时间。\n- **定期回归测试**：每次代码更新后进行回归测试，确保新改动没有引入新的错误。\n\n通过遵循上述方法，您可以为SwiftUI应用实施一套全面的测试策略，显著提高应用的质量和可靠性。记得，测试是一个持续的过程，应随着应用的迭代而不断更新和完善。\n\n\n**第2小节：使用Xcode调试**\n\n调试是发现、定位并修正编程错误过程。Xcode提供了强大的调试工具，它们可以帮助开发者理解代码在运行时的行为，并有效地找到并解决问题。在这一小节中，我们将深入探讨如何使用Xcode来调试SwiftUI应用。\n\n### 断点（Breakpoints）\n\n断点是调试中的一个核心概念，它允许你在特定的代码行暂停代码执行，以便你可以检查此时的变量状态和应用逻辑。\n\n#### 设置断点\n\n- **标准断点**：点击Xcode编辑器左侧的边栏，即可在代码行旁设置断点。\n- **条件断点**：断点可设置条件，使之仅在满足特定条件时才触发。\n- **动作断点**：在触发断点时自动执行一个特定的动作，如打印一条日志信息。\n\n### 调试面板\n\n当代码在断点处停止时，Xcode的调试面板会提供多种工具来帮助你理解代码的状态。\n\n- **变量查看器**：显示当前作用域内所有变量的值。\n- **调用堆栈查看器**：查看函数调用堆栈，了解当前代码执行的路径。\n- **内存检查器**：检查应用的内存使用情况，发现潜在的内存泄露。\n\n### 控制流\n\n使用调试面板的控件来控制应用的执行流。\n\n- **继续执行**（Continue）：继续执行代码直到下一个断点。\n- **逐步执行**（Step Over）：执行当前行，并在下一行停止。\n- **深入执行**（Step Into）：如果当前行调用了一个函数，进入该函数内部。\n- **跳出执行**（Step Out）：从当前函数跳出，回到上一层函数。\n\n### LLDB调试器\n\nLLDB是Xcode使用的底层调试器。你可以使用LLDB控制台来执行更复杂的调试命令。\n\n- **打印变量**：使用`po`命令打印变量的描述。\n- **设置变量值**：直接在调试会话中修改变量的值。\n- **执行表达式**：使用`expr`命令执行代码表达式。\n\n### 性能分析\n\nXcode的Instrument工具可以用来分析应用的性能问题。\n\n- **时间分析器**：查看CPU的使用情况以及代码执行的时间。\n- **内存分析器**：分析应用的内存使用模式和潜在的内存泄露。\n- **网络分析器**：检查应用的网络请求和响应。\n\n### Xcode调试技巧\n\n- **视图调试**（View Debugging）：可视化地检查UI元素的布局和属性。\n- **条件表达式**：使用条件表达式来精确控制断点的触发时机。\n- **符号断点**：在特定的系统函数或方法调用时触发断点。\n\n通过熟练使用Xcode的调试工具，你将能够更快地发现问题所在，并对SwiftUI应用进行高效的故障排查。记得，耐心和细心是调试过程中的良师益友，不断实践将使你成为更高效的开发者。\n\n\n**第3小节：预览与条件编译**\n\nSwiftUI 的预览功能是其最具革命性的特点之一，它允许开发者在不运行整个应用的情况下快速迭代和测试其视图。条件编译则是一种控制代码在不同环境下如何编译的方法。在这一小节中，我们将讨论如何使用这两个强大的功能来提高开发效率和代码质量。\n\n### 使用SwiftUI预览\n\nSwiftUI的`Canvas`视图提供了一个实时预览，它显示了你的用户界面组件在实际应用中的外观和表现。以下是如何高效使用SwiftUI预览的指南：\n\n- **基本预览**：每个SwiftUI视图都可以有一个或多个预览。通过创建`PreviewProvider`的实现，你可以快速看到你的UI更改的效果。\n- **多设备预览**：在预览提供者中，你可以设置多个预览设备和配置，同时查看在不同设备和方向上的界面表现。\n- **动态预览**：通过添加预览参数，如不同的字体大小、颜色主题（包括Dark Mode）和辅助功能设置，你可以查看你的视图在不同用户设置下的表现。\n- **交互式预览**：你可以在Canvas中与UI交互，例如点击按钮或切换开关，这有助于测试视图的响应性。\n- **实时数据预览**：将模型对象注入到预览中，使你可以用实际数据来展示和测试视图。\n\n### 条件编译\n\n在Swift中，可以使用编译配置来为不同的编译目标提供不同的代码路径。这对于处理开发和生产环境的差异至关重要。\n\n- **编译标志**：使用`#if`、`#elseif`和`#endif`指令来控制哪些代码块应被编译。这常用于开发和生产环境的日志记录和配置。\n- **平台特定代码**：可以检查`os(macOS)`、`os(iOS)`等条件，来编写只在特定操作系统上编译的代码。\n- **功能特性检查**：使用`canImport(module)`来确定是否可以导入一个特定的模块，这在跨多个Swift版本或平台时很有用。\n- **调试与发布区分**：使用`DEBUG`标识符来保证某些代码仅在调试构建中编译，而在发布构建中不会包含这些代码。\n\n### 组合预览与条件编译\n\n将SwiftUI预览和条件编译相结合，可以创建更为强大和灵活的开发环境。\n\n- **预览特定配置**：为不同的预览目标配置不同的环境变量或者模拟数据。\n- **隐藏调试UI**：使用条件编译隐藏调试时用到的UI元素，以免它们出现在生产版本的应用中。\n\n通过利用这些工具，你可以确保在开发过程中，你的应用表现出色，并且在上线前能有效地去除所有不必要的测试代码。这样的实践不仅可以提高代码的质量，也能显著减少调试和测试时的工作量。预览和条件编译应当成为每一个SwiftUI开发者工具箱中的核心部分。","slug":"SwiftUI核心技术第14章测试与调试","published":1,"updated":"2024-03-17T06:12:01.380Z","comments":1,"layout":"post","photos":[],"_id":"clu6up53i002az674250tcbfu","content":"<p><strong>第1小节：单元测试和UI测试</strong></p>\n<p>在软件开发过程中，测试是确保应用质量的关键步骤。SwiftUI应用的测试主要分为单元测试和UI测试两种。单元测试确保代码逻辑的正确性，而UI测试确保用户界面的行为与期望一致。本节将详细介绍如何在SwiftUI中实施有效的单元测试和UI测试策略。</p>\n<h3 id=\"单元测试\"><a href=\"#单元测试\" class=\"headerlink\" title=\"单元测试\"></a>单元测试</h3><p>单元测试是在最小的代码单位级别上验证功能正确性的测试。在Swift中，单元测试通常是针对独立的函数或对象进行的。</p>\n<h4 id=\"设计可测试的代码\"><a href=\"#设计可测试的代码\" class=\"headerlink\" title=\"设计可测试的代码\"></a>设计可测试的代码</h4><ul>\n<li><strong>解耦和模块化</strong>：确保代码是松耦合和高内聚的，这样更容易编写测试。</li>\n<li><strong>依赖注入</strong>：通过依赖注入可以在测试时替换实际的依赖，以实现更精确的测试。</li>\n<li><strong>使用协议和Mock对象</strong>：定义接口并在测试中使用Mock对象来模拟真实对象。</li>\n</ul>\n<h4 id=\"编写单元测试\"><a href=\"#编写单元测试\" class=\"headerlink\" title=\"编写单元测试\"></a>编写单元测试</h4><ul>\n<li><strong>XCTest框架</strong>：使用Xcode集成的XCTest框架编写测试用例。</li>\n<li><strong>Assert函数</strong>：使用assert函数（如<code>XCTAssertTrue</code>, <code>XCTAssertEqual</code>等）验证预期结果。</li>\n<li><strong>测试边界条件</strong>：确保测试边界情况和异常情况。</li>\n</ul>\n<h3 id=\"UI测试\"><a href=\"#UI测试\" class=\"headerlink\" title=\"UI测试\"></a>UI测试</h3><p>UI测试模拟用户与应用界面的交互，验证UI元素的存在性、状态和应用的响应性。</p>\n<h4 id=\"配置UI测试环境\"><a href=\"#配置UI测试环境\" class=\"headerlink\" title=\"配置UI测试环境\"></a>配置UI测试环境</h4><ul>\n<li><strong>使用XCTestUI框架</strong>：XCTestUI提供了一套工具用于编写UI测试。</li>\n<li><strong>Accessibility标识</strong>：给UI元素设置Accessibility标识，以便测试脚本可以准确地定位它们。</li>\n</ul>\n<h4 id=\"编写UI测试脚本\"><a href=\"#编写UI测试脚本\" class=\"headerlink\" title=\"编写UI测试脚本\"></a>编写UI测试脚本</h4><ul>\n<li><strong>记录UI交互</strong>：Xcode提供了UI测试录制功能，可以自动生成用户交互的基本代码。</li>\n<li><strong>编写测试用例</strong>：基于录制的代码，编写完整的测试用例来验证特定的UI行为。</li>\n<li><strong>断言验证</strong>：使用断言来验证UI状态是否符合预期。</li>\n</ul>\n<h3 id=\"测试最佳实践\"><a href=\"#测试最佳实践\" class=\"headerlink\" title=\"测试最佳实践\"></a>测试最佳实践</h3><ul>\n<li><strong>持续集成（CI）</strong>：将测试集成到持续集成流程中，确保每次提交都通过测试。</li>\n<li><strong>代码覆盖率</strong>：监控代码覆盖率，尽量使之覆盖所有的代码路径。</li>\n<li><strong>性能测试</strong>：包含性能测试来验证关键功能的响应时间。</li>\n<li><strong>定期回归测试</strong>：每次代码更新后进行回归测试，确保新改动没有引入新的错误。</li>\n</ul>\n<p>通过遵循上述方法，您可以为SwiftUI应用实施一套全面的测试策略，显著提高应用的质量和可靠性。记得，测试是一个持续的过程，应随着应用的迭代而不断更新和完善。</p>\n<p><strong>第2小节：使用Xcode调试</strong></p>\n<p>调试是发现、定位并修正编程错误过程。Xcode提供了强大的调试工具，它们可以帮助开发者理解代码在运行时的行为，并有效地找到并解决问题。在这一小节中，我们将深入探讨如何使用Xcode来调试SwiftUI应用。</p>\n<h3 id=\"断点（Breakpoints）\"><a href=\"#断点（Breakpoints）\" class=\"headerlink\" title=\"断点（Breakpoints）\"></a>断点（Breakpoints）</h3><p>断点是调试中的一个核心概念，它允许你在特定的代码行暂停代码执行，以便你可以检查此时的变量状态和应用逻辑。</p>\n<h4 id=\"设置断点\"><a href=\"#设置断点\" class=\"headerlink\" title=\"设置断点\"></a>设置断点</h4><ul>\n<li><strong>标准断点</strong>：点击Xcode编辑器左侧的边栏，即可在代码行旁设置断点。</li>\n<li><strong>条件断点</strong>：断点可设置条件，使之仅在满足特定条件时才触发。</li>\n<li><strong>动作断点</strong>：在触发断点时自动执行一个特定的动作，如打印一条日志信息。</li>\n</ul>\n<h3 id=\"调试面板\"><a href=\"#调试面板\" class=\"headerlink\" title=\"调试面板\"></a>调试面板</h3><p>当代码在断点处停止时，Xcode的调试面板会提供多种工具来帮助你理解代码的状态。</p>\n<ul>\n<li><strong>变量查看器</strong>：显示当前作用域内所有变量的值。</li>\n<li><strong>调用堆栈查看器</strong>：查看函数调用堆栈，了解当前代码执行的路径。</li>\n<li><strong>内存检查器</strong>：检查应用的内存使用情况，发现潜在的内存泄露。</li>\n</ul>\n<h3 id=\"控制流\"><a href=\"#控制流\" class=\"headerlink\" title=\"控制流\"></a>控制流</h3><p>使用调试面板的控件来控制应用的执行流。</p>\n<ul>\n<li><strong>继续执行</strong>（Continue）：继续执行代码直到下一个断点。</li>\n<li><strong>逐步执行</strong>（Step Over）：执行当前行，并在下一行停止。</li>\n<li><strong>深入执行</strong>（Step Into）：如果当前行调用了一个函数，进入该函数内部。</li>\n<li><strong>跳出执行</strong>（Step Out）：从当前函数跳出，回到上一层函数。</li>\n</ul>\n<h3 id=\"LLDB调试器\"><a href=\"#LLDB调试器\" class=\"headerlink\" title=\"LLDB调试器\"></a>LLDB调试器</h3><p>LLDB是Xcode使用的底层调试器。你可以使用LLDB控制台来执行更复杂的调试命令。</p>\n<ul>\n<li><strong>打印变量</strong>：使用<code>po</code>命令打印变量的描述。</li>\n<li><strong>设置变量值</strong>：直接在调试会话中修改变量的值。</li>\n<li><strong>执行表达式</strong>：使用<code>expr</code>命令执行代码表达式。</li>\n</ul>\n<h3 id=\"性能分析\"><a href=\"#性能分析\" class=\"headerlink\" title=\"性能分析\"></a>性能分析</h3><p>Xcode的Instrument工具可以用来分析应用的性能问题。</p>\n<ul>\n<li><strong>时间分析器</strong>：查看CPU的使用情况以及代码执行的时间。</li>\n<li><strong>内存分析器</strong>：分析应用的内存使用模式和潜在的内存泄露。</li>\n<li><strong>网络分析器</strong>：检查应用的网络请求和响应。</li>\n</ul>\n<h3 id=\"Xcode调试技巧\"><a href=\"#Xcode调试技巧\" class=\"headerlink\" title=\"Xcode调试技巧\"></a>Xcode调试技巧</h3><ul>\n<li><strong>视图调试</strong>（View Debugging）：可视化地检查UI元素的布局和属性。</li>\n<li><strong>条件表达式</strong>：使用条件表达式来精确控制断点的触发时机。</li>\n<li><strong>符号断点</strong>：在特定的系统函数或方法调用时触发断点。</li>\n</ul>\n<p>通过熟练使用Xcode的调试工具，你将能够更快地发现问题所在，并对SwiftUI应用进行高效的故障排查。记得，耐心和细心是调试过程中的良师益友，不断实践将使你成为更高效的开发者。</p>\n<p><strong>第3小节：预览与条件编译</strong></p>\n<p>SwiftUI 的预览功能是其最具革命性的特点之一，它允许开发者在不运行整个应用的情况下快速迭代和测试其视图。条件编译则是一种控制代码在不同环境下如何编译的方法。在这一小节中，我们将讨论如何使用这两个强大的功能来提高开发效率和代码质量。</p>\n<h3 id=\"使用SwiftUI预览\"><a href=\"#使用SwiftUI预览\" class=\"headerlink\" title=\"使用SwiftUI预览\"></a>使用SwiftUI预览</h3><p>SwiftUI的<code>Canvas</code>视图提供了一个实时预览，它显示了你的用户界面组件在实际应用中的外观和表现。以下是如何高效使用SwiftUI预览的指南：</p>\n<ul>\n<li><strong>基本预览</strong>：每个SwiftUI视图都可以有一个或多个预览。通过创建<code>PreviewProvider</code>的实现，你可以快速看到你的UI更改的效果。</li>\n<li><strong>多设备预览</strong>：在预览提供者中，你可以设置多个预览设备和配置，同时查看在不同设备和方向上的界面表现。</li>\n<li><strong>动态预览</strong>：通过添加预览参数，如不同的字体大小、颜色主题（包括Dark Mode）和辅助功能设置，你可以查看你的视图在不同用户设置下的表现。</li>\n<li><strong>交互式预览</strong>：你可以在Canvas中与UI交互，例如点击按钮或切换开关，这有助于测试视图的响应性。</li>\n<li><strong>实时数据预览</strong>：将模型对象注入到预览中，使你可以用实际数据来展示和测试视图。</li>\n</ul>\n<h3 id=\"条件编译\"><a href=\"#条件编译\" class=\"headerlink\" title=\"条件编译\"></a>条件编译</h3><p>在Swift中，可以使用编译配置来为不同的编译目标提供不同的代码路径。这对于处理开发和生产环境的差异至关重要。</p>\n<ul>\n<li><strong>编译标志</strong>：使用<code>#if</code>、<code>#elseif</code>和<code>#endif</code>指令来控制哪些代码块应被编译。这常用于开发和生产环境的日志记录和配置。</li>\n<li><strong>平台特定代码</strong>：可以检查<code>os(macOS)</code>、<code>os(iOS)</code>等条件，来编写只在特定操作系统上编译的代码。</li>\n<li><strong>功能特性检查</strong>：使用<code>canImport(module)</code>来确定是否可以导入一个特定的模块，这在跨多个Swift版本或平台时很有用。</li>\n<li><strong>调试与发布区分</strong>：使用<code>DEBUG</code>标识符来保证某些代码仅在调试构建中编译，而在发布构建中不会包含这些代码。</li>\n</ul>\n<h3 id=\"组合预览与条件编译\"><a href=\"#组合预览与条件编译\" class=\"headerlink\" title=\"组合预览与条件编译\"></a>组合预览与条件编译</h3><p>将SwiftUI预览和条件编译相结合，可以创建更为强大和灵活的开发环境。</p>\n<ul>\n<li><strong>预览特定配置</strong>：为不同的预览目标配置不同的环境变量或者模拟数据。</li>\n<li><strong>隐藏调试UI</strong>：使用条件编译隐藏调试时用到的UI元素，以免它们出现在生产版本的应用中。</li>\n</ul>\n<p>通过利用这些工具，你可以确保在开发过程中，你的应用表现出色，并且在上线前能有效地去除所有不必要的测试代码。这样的实践不仅可以提高代码的质量，也能显著减少调试和测试时的工作量。预览和条件编译应当成为每一个SwiftUI开发者工具箱中的核心部分。</p>\n","excerpt":"","more":"<p><strong>第1小节：单元测试和UI测试</strong></p>\n<p>在软件开发过程中，测试是确保应用质量的关键步骤。SwiftUI应用的测试主要分为单元测试和UI测试两种。单元测试确保代码逻辑的正确性，而UI测试确保用户界面的行为与期望一致。本节将详细介绍如何在SwiftUI中实施有效的单元测试和UI测试策略。</p>\n<h3 id=\"单元测试\"><a href=\"#单元测试\" class=\"headerlink\" title=\"单元测试\"></a>单元测试</h3><p>单元测试是在最小的代码单位级别上验证功能正确性的测试。在Swift中，单元测试通常是针对独立的函数或对象进行的。</p>\n<h4 id=\"设计可测试的代码\"><a href=\"#设计可测试的代码\" class=\"headerlink\" title=\"设计可测试的代码\"></a>设计可测试的代码</h4><ul>\n<li><strong>解耦和模块化</strong>：确保代码是松耦合和高内聚的，这样更容易编写测试。</li>\n<li><strong>依赖注入</strong>：通过依赖注入可以在测试时替换实际的依赖，以实现更精确的测试。</li>\n<li><strong>使用协议和Mock对象</strong>：定义接口并在测试中使用Mock对象来模拟真实对象。</li>\n</ul>\n<h4 id=\"编写单元测试\"><a href=\"#编写单元测试\" class=\"headerlink\" title=\"编写单元测试\"></a>编写单元测试</h4><ul>\n<li><strong>XCTest框架</strong>：使用Xcode集成的XCTest框架编写测试用例。</li>\n<li><strong>Assert函数</strong>：使用assert函数（如<code>XCTAssertTrue</code>, <code>XCTAssertEqual</code>等）验证预期结果。</li>\n<li><strong>测试边界条件</strong>：确保测试边界情况和异常情况。</li>\n</ul>\n<h3 id=\"UI测试\"><a href=\"#UI测试\" class=\"headerlink\" title=\"UI测试\"></a>UI测试</h3><p>UI测试模拟用户与应用界面的交互，验证UI元素的存在性、状态和应用的响应性。</p>\n<h4 id=\"配置UI测试环境\"><a href=\"#配置UI测试环境\" class=\"headerlink\" title=\"配置UI测试环境\"></a>配置UI测试环境</h4><ul>\n<li><strong>使用XCTestUI框架</strong>：XCTestUI提供了一套工具用于编写UI测试。</li>\n<li><strong>Accessibility标识</strong>：给UI元素设置Accessibility标识，以便测试脚本可以准确地定位它们。</li>\n</ul>\n<h4 id=\"编写UI测试脚本\"><a href=\"#编写UI测试脚本\" class=\"headerlink\" title=\"编写UI测试脚本\"></a>编写UI测试脚本</h4><ul>\n<li><strong>记录UI交互</strong>：Xcode提供了UI测试录制功能，可以自动生成用户交互的基本代码。</li>\n<li><strong>编写测试用例</strong>：基于录制的代码，编写完整的测试用例来验证特定的UI行为。</li>\n<li><strong>断言验证</strong>：使用断言来验证UI状态是否符合预期。</li>\n</ul>\n<h3 id=\"测试最佳实践\"><a href=\"#测试最佳实践\" class=\"headerlink\" title=\"测试最佳实践\"></a>测试最佳实践</h3><ul>\n<li><strong>持续集成（CI）</strong>：将测试集成到持续集成流程中，确保每次提交都通过测试。</li>\n<li><strong>代码覆盖率</strong>：监控代码覆盖率，尽量使之覆盖所有的代码路径。</li>\n<li><strong>性能测试</strong>：包含性能测试来验证关键功能的响应时间。</li>\n<li><strong>定期回归测试</strong>：每次代码更新后进行回归测试，确保新改动没有引入新的错误。</li>\n</ul>\n<p>通过遵循上述方法，您可以为SwiftUI应用实施一套全面的测试策略，显著提高应用的质量和可靠性。记得，测试是一个持续的过程，应随着应用的迭代而不断更新和完善。</p>\n<p><strong>第2小节：使用Xcode调试</strong></p>\n<p>调试是发现、定位并修正编程错误过程。Xcode提供了强大的调试工具，它们可以帮助开发者理解代码在运行时的行为，并有效地找到并解决问题。在这一小节中，我们将深入探讨如何使用Xcode来调试SwiftUI应用。</p>\n<h3 id=\"断点（Breakpoints）\"><a href=\"#断点（Breakpoints）\" class=\"headerlink\" title=\"断点（Breakpoints）\"></a>断点（Breakpoints）</h3><p>断点是调试中的一个核心概念，它允许你在特定的代码行暂停代码执行，以便你可以检查此时的变量状态和应用逻辑。</p>\n<h4 id=\"设置断点\"><a href=\"#设置断点\" class=\"headerlink\" title=\"设置断点\"></a>设置断点</h4><ul>\n<li><strong>标准断点</strong>：点击Xcode编辑器左侧的边栏，即可在代码行旁设置断点。</li>\n<li><strong>条件断点</strong>：断点可设置条件，使之仅在满足特定条件时才触发。</li>\n<li><strong>动作断点</strong>：在触发断点时自动执行一个特定的动作，如打印一条日志信息。</li>\n</ul>\n<h3 id=\"调试面板\"><a href=\"#调试面板\" class=\"headerlink\" title=\"调试面板\"></a>调试面板</h3><p>当代码在断点处停止时，Xcode的调试面板会提供多种工具来帮助你理解代码的状态。</p>\n<ul>\n<li><strong>变量查看器</strong>：显示当前作用域内所有变量的值。</li>\n<li><strong>调用堆栈查看器</strong>：查看函数调用堆栈，了解当前代码执行的路径。</li>\n<li><strong>内存检查器</strong>：检查应用的内存使用情况，发现潜在的内存泄露。</li>\n</ul>\n<h3 id=\"控制流\"><a href=\"#控制流\" class=\"headerlink\" title=\"控制流\"></a>控制流</h3><p>使用调试面板的控件来控制应用的执行流。</p>\n<ul>\n<li><strong>继续执行</strong>（Continue）：继续执行代码直到下一个断点。</li>\n<li><strong>逐步执行</strong>（Step Over）：执行当前行，并在下一行停止。</li>\n<li><strong>深入执行</strong>（Step Into）：如果当前行调用了一个函数，进入该函数内部。</li>\n<li><strong>跳出执行</strong>（Step Out）：从当前函数跳出，回到上一层函数。</li>\n</ul>\n<h3 id=\"LLDB调试器\"><a href=\"#LLDB调试器\" class=\"headerlink\" title=\"LLDB调试器\"></a>LLDB调试器</h3><p>LLDB是Xcode使用的底层调试器。你可以使用LLDB控制台来执行更复杂的调试命令。</p>\n<ul>\n<li><strong>打印变量</strong>：使用<code>po</code>命令打印变量的描述。</li>\n<li><strong>设置变量值</strong>：直接在调试会话中修改变量的值。</li>\n<li><strong>执行表达式</strong>：使用<code>expr</code>命令执行代码表达式。</li>\n</ul>\n<h3 id=\"性能分析\"><a href=\"#性能分析\" class=\"headerlink\" title=\"性能分析\"></a>性能分析</h3><p>Xcode的Instrument工具可以用来分析应用的性能问题。</p>\n<ul>\n<li><strong>时间分析器</strong>：查看CPU的使用情况以及代码执行的时间。</li>\n<li><strong>内存分析器</strong>：分析应用的内存使用模式和潜在的内存泄露。</li>\n<li><strong>网络分析器</strong>：检查应用的网络请求和响应。</li>\n</ul>\n<h3 id=\"Xcode调试技巧\"><a href=\"#Xcode调试技巧\" class=\"headerlink\" title=\"Xcode调试技巧\"></a>Xcode调试技巧</h3><ul>\n<li><strong>视图调试</strong>（View Debugging）：可视化地检查UI元素的布局和属性。</li>\n<li><strong>条件表达式</strong>：使用条件表达式来精确控制断点的触发时机。</li>\n<li><strong>符号断点</strong>：在特定的系统函数或方法调用时触发断点。</li>\n</ul>\n<p>通过熟练使用Xcode的调试工具，你将能够更快地发现问题所在，并对SwiftUI应用进行高效的故障排查。记得，耐心和细心是调试过程中的良师益友，不断实践将使你成为更高效的开发者。</p>\n<p><strong>第3小节：预览与条件编译</strong></p>\n<p>SwiftUI 的预览功能是其最具革命性的特点之一，它允许开发者在不运行整个应用的情况下快速迭代和测试其视图。条件编译则是一种控制代码在不同环境下如何编译的方法。在这一小节中，我们将讨论如何使用这两个强大的功能来提高开发效率和代码质量。</p>\n<h3 id=\"使用SwiftUI预览\"><a href=\"#使用SwiftUI预览\" class=\"headerlink\" title=\"使用SwiftUI预览\"></a>使用SwiftUI预览</h3><p>SwiftUI的<code>Canvas</code>视图提供了一个实时预览，它显示了你的用户界面组件在实际应用中的外观和表现。以下是如何高效使用SwiftUI预览的指南：</p>\n<ul>\n<li><strong>基本预览</strong>：每个SwiftUI视图都可以有一个或多个预览。通过创建<code>PreviewProvider</code>的实现，你可以快速看到你的UI更改的效果。</li>\n<li><strong>多设备预览</strong>：在预览提供者中，你可以设置多个预览设备和配置，同时查看在不同设备和方向上的界面表现。</li>\n<li><strong>动态预览</strong>：通过添加预览参数，如不同的字体大小、颜色主题（包括Dark Mode）和辅助功能设置，你可以查看你的视图在不同用户设置下的表现。</li>\n<li><strong>交互式预览</strong>：你可以在Canvas中与UI交互，例如点击按钮或切换开关，这有助于测试视图的响应性。</li>\n<li><strong>实时数据预览</strong>：将模型对象注入到预览中，使你可以用实际数据来展示和测试视图。</li>\n</ul>\n<h3 id=\"条件编译\"><a href=\"#条件编译\" class=\"headerlink\" title=\"条件编译\"></a>条件编译</h3><p>在Swift中，可以使用编译配置来为不同的编译目标提供不同的代码路径。这对于处理开发和生产环境的差异至关重要。</p>\n<ul>\n<li><strong>编译标志</strong>：使用<code>#if</code>、<code>#elseif</code>和<code>#endif</code>指令来控制哪些代码块应被编译。这常用于开发和生产环境的日志记录和配置。</li>\n<li><strong>平台特定代码</strong>：可以检查<code>os(macOS)</code>、<code>os(iOS)</code>等条件，来编写只在特定操作系统上编译的代码。</li>\n<li><strong>功能特性检查</strong>：使用<code>canImport(module)</code>来确定是否可以导入一个特定的模块，这在跨多个Swift版本或平台时很有用。</li>\n<li><strong>调试与发布区分</strong>：使用<code>DEBUG</code>标识符来保证某些代码仅在调试构建中编译，而在发布构建中不会包含这些代码。</li>\n</ul>\n<h3 id=\"组合预览与条件编译\"><a href=\"#组合预览与条件编译\" class=\"headerlink\" title=\"组合预览与条件编译\"></a>组合预览与条件编译</h3><p>将SwiftUI预览和条件编译相结合，可以创建更为强大和灵活的开发环境。</p>\n<ul>\n<li><strong>预览特定配置</strong>：为不同的预览目标配置不同的环境变量或者模拟数据。</li>\n<li><strong>隐藏调试UI</strong>：使用条件编译隐藏调试时用到的UI元素，以免它们出现在生产版本的应用中。</li>\n</ul>\n<p>通过利用这些工具，你可以确保在开发过程中，你的应用表现出色，并且在上线前能有效地去除所有不必要的测试代码。这样的实践不仅可以提高代码的质量，也能显著减少调试和测试时的工作量。预览和条件编译应当成为每一个SwiftUI开发者工具箱中的核心部分。</p>\n"},{"title":"SwiftUI核心技术第15章构建一个聊天APP","date":"2023-11-08T02:24:42.000Z","_content":"**第1小节：应用结构规划**\n\n在开发一个新的应用时，规划应用的结构是成功的关键。一个良好设计的应用结构可以提高代码的可维护性和扩展性，并使团队合作变得更加高效。本小节我们将讨论如何为我们的聊天应用进行结构规划。\n\n### 应用概览\n\n我们的聊天应用将具备以下基本功能：\n\n- 用户注册与登录\n- 好友列表管理\n- 实时消息传递\n- 个人与群组聊天\n- 消息通知\n\n### 架构模式\n\n首先，我们需要选择一个适合于聊天应用的架构模式。考虑到SwiftUI的特性，我们选择MVVM（Model-View-ViewModel）作为主要架构，因为它能够很好地与SwiftUI的声明式UI和数据流工作模式配合。\n\n### 分层设计\n\n我们的应用将分为以下几层：\n\n1. **视图层（View）**：负责展示用户界面，捕获用户输入。\n2. **视图模型层（ViewModel）**：处理视图逻辑，响应用户输入，与模型层通信。\n3. **模型层（Model）**：定义数据结构和业务逻辑。\n4. **网络层**：处理所有网络通信，例如发送和接收消息。\n5. **数据库层**：负责数据持久化，存储历史消息和用户数据。\n\n### 目录结构\n\n为了支持这种分层设计，我们的项目目录将如下组织：\n\n```\nChatApp/\n├── Views/\n│   ├── LoginView.swift\n│   ├── ChatListView.swift\n│   ├── ChatView.swift\n│   └── ...\n├── ViewModels/\n│   ├── LoginViewModel.swift\n│   ├── ChatListViewModel.swift\n│   ├── ChatViewModel.swift\n│   └── ...\n├── Models/\n│   ├── User.swift\n│   ├── Message.swift\n│   ├── Conversation.swift\n│   └── ...\n├── Services/\n│   ├── AuthenticationService.swift\n│   ├── ChatService.swift\n│   ├── NotificationService.swift\n│   └── ...\n└── Utilities/\n    ├── Constants.swift\n    ├── Extensions.swift\n    └── ...\n```\n\n### 功能模块划分\n\n接下来，我们将应用分解为几个核心模块：\n\n- **用户认证模块**：包括用户注册、登录和验证。\n- **联系人模块**：用户的好友列表，添加和删除联系人。\n- **聊天模块**：展示消息历史，发送新消息，消息推送。\n- **设置模块**：用户可以修改个人信息，设置应用选项等。\n\n### 数据流规划\n\n由于聊天应用需要实时的数据更新，我们将使用Combine框架来处理数据的发布和订阅，以确保用户界面能够响应数据的变化。\n\n- 使用`@Published`属性包装器来自动管理数据的发布。\n- `ViewModels`将订阅`Models`的变化，并更新视图状态。\n- 视图将绑定到视图模型的发布者，以获得数据变更的通知。\n\n### 安全和隐私\n\n聊天应用需要格外注意安全和隐私：\n\n- 采用安全的认证机制，如OAuth 2.0。\n- 传输层加密，确保数据传输的安全。\n- 数据库加密存储敏感信息。\n\n### 用户体验（UX）\n\n用户体验是聊天应用成功的关键，我们需要确保：\n\n- 界面简洁明了，易于导航。\n- 消息即时传送，无明显延迟。\n- 有声音和震动的通知反馈。\n\n通过仔细规\n\n划应用结构，我们为聊天应用的开发奠定了坚实的基础。后续小节中，我们将深入每个模块，开始具体的设计和编码工作。\n\n\n**第2小节：用户界面设计**\n\n用户界面（UI）设计是创建聊天应用的重要组成部分。一个直观、易用且美观的UI将极大地提升用户体验。在这一小节，我们将概述聊天应用的用户界面设计过程，包括布局、组件选择、颜色和动画的应用等方面。\n\n### UI设计原则\n\n在设计界面之前，我们首先确定几个核心设计原则：\n\n- **一致性**：整个应用的设计风格保持一致，包括按钮样式、字体、颜色等。\n- **简洁性**：避免不必要的元素，使用户可以集中于聊天功能。\n- **直观性**：确保用户能够直观地理解如何使用应用，无需额外学习。\n- **响应式**：界面应该能够适应不同设备和屏幕大小。\n\n### 布局设计\n\n布局是UI设计的基础，我们将采用如下布局策略：\n\n- **导航栏**：位于屏幕顶部，包含用户的状态和导航控件。\n- **消息列表**：主屏幕显示消息列表，一览无余。\n- **输入区**：屏幕底部为消息输入区，包括文本输入框和发送按钮。\n- **设置菜单**：通过导航栏访问，包括个人资料编辑和应用设置。\n\n### 组件设计\n\n我们将使用SwiftUI来构建以下组件：\n\n- **CustomButton**：自定义按钮，用于登录、发送消息等。\n- **ChatBubble**：聊天气泡，区分自己和他人的消息。\n- **UserAvatar**：用户头像，显示在消息旁边和好友列表中。\n- **TextField**：自定义文本输入框，支持多行文本输入和表情。\n\n### 颜色和主题\n\n颜色方案将支持暗黑模式和光亮模式，我们将定义一组基础颜色：\n\n- **主色调**：定义应用的主题颜色，如蓝色或绿色。\n- **辅助色**：用于强调按钮或重要信息。\n- **背景色**：分为深色和浅色变体，适应不同模式。\n- **文字色**：确保在任何背景色上都清晰可见。\n\n### 图标和图形\n\n应用中的图标和图形将采用矢量图形，以确保在不同分辨率下都能清晰显示。我们将为每个主要功能选择直观的图标。\n\n### 动画\n\n为了提升用户体验，我们将在以下方面应用动画：\n\n- **页面切换**：平滑过渡，增强用户操作的连贯感。\n- **消息发送**：消息框飞入聊天区域的动画。\n- **加载指示器**：在等待网络响应时提供动态反馈。\n\n### 响应式设计\n\n我们的UI设计将采用响应式方法，以适应不同的设备和屏幕尺寸：\n\n- **自适应布局**：使用`Stacks`、`Grids`和`Flexible Spaces`确保组件在不同屏幕上都能正确布局。\n- **动态字体大小**：支持系统字体大小设置，适应用户的阅读需求。\n\n### 交互设计\n\n最后，交互设计也是我们关注的重点：\n\n- **触控反馈**：按钮和可交互元素将提供触觉反馈。\n- **滑动删除**：在消息列表中轻松\n\n滑动来删除消息或撤回。\n\n通过上述设计，我们将创建一个美观、直观且功能强大的聊天应用用户界面。接下来，我们将在小节中进一步详细说明每个组件和功能的实现过程。\n\n\n**第3小节：应用逻辑实现**\n\n构建一个聊天应用不仅仅是设计外观上的美观与实用，应用的核心在于其逻辑实现。在本小节，我们将探讨如何在SwiftUI框架下实现聊天应用的基本逻辑，包括消息的发送与接收、状态管理以及实时更新等功能。\n\n### 基础逻辑构建\n\n首先，我们需要建立应用的数据模型和业务逻辑层，这通常涉及以下几个关键部分：\n\n- **用户模型（User Model）**：定义用户的基本信息，如用户名、头像、状态等。\n- **消息模型（Message Model）**：定义消息的数据结构，包含发送者、接收者、消息内容、发送时间等。\n- **会话列表（Conversations List）**：存储用户的聊天会话，每个会话包含多条消息。\n- **数据管理器（Data Manager）**：负责处理数据的存取、更新以及同步。\n\n### 消息发送与接收\n\n聊天的核心功能是消息的发送与接收，我们将通过以下步骤来实现：\n\n1. **输入与发送**：\n   - 使用`TextField`或`TextView`获取用户输入的消息文本。\n   - 当用户点击发送按钮时，通过数据管理器将消息对象保存到会话列表中。\n\n2. **消息展示**：\n   - 使用`ScrollView`和`LazyVStack`展示消息列表。\n   - 对于每条消息，使用`ChatBubble`视图来展示，根据发送者是自己还是对方来调整样式和位置。\n\n3. **实时更新**：\n   - 通过`Combine`框架监听数据变化，实现消息的实时更新。\n   - 当有新消息时，更新UI以展示新消息。\n\n### 状态管理\n\n在SwiftUI中，状态管理是一个重要的概念，它确保UI的正确性和数据的同步。我们将使用`@State`、`@Binding`、`@ObservedObject`等属性包装器来管理状态：\n\n- **用户状态**：使用`@State`管理用户的在线状态，比如在线、离开、忙碌等。\n- **消息状态**：使用`@ObservedObject`监控消息的发送和接收状态。\n\n### 实时更新和同步\n\n为了实现聊天应用中的实时互动，我们将使用WebSocket或者Apple的`CloudKit`来进行网络通信，实现消息的即时推送：\n\n- **WebSocket连接**：建立WebSocket连接来监听服务器发来的新消息。\n- **CloudKit同步**：如果使用`CloudKit`，则设置相应的记录类型和订阅，以便于新消息到来时可以立即更新。\n\n### 聊天功能拓展\n\n除了基础的文本消息，我们还可以实现以下几个功能：\n\n- **图片和视频发送**：允许用户发送媒体文件，并在聊天气泡中预览。\n- **消息状态标记**：如已读、已发送等状态的标记。\n- **通知与提醒**：通过本地通知或推送通知，告知用户新消息的到来。\n\n### 异常处理\n\n在实现聊天逻辑时，还需要考虑异常情况的处理：\n\n- **网络异常**：当网络不稳定或断开时，给用户适当的反馈，并尝试重新连接。\n- **数据持久化**：确保消息在本地被保存，即使应用关闭后也能恢复历史消息。\n\n### 测试\n\n开发过程中，持续进行单元测试和集成测试来确保各个功能的可靠性，包括：\n\n- **逻辑测试**：对数据管理器和业务逻辑层进行测试。\n- **UI测试**：确保消息正确显示，\n\n用户交互按预期工作。\n\n### 总结\n\n在本小节中，我们详细探讨了构建聊天应用的应用逻辑实现。从用户界面的交互到后端的数据处理，每一步都是为了提供流畅而可靠的用户体验。通过上述步骤的实现，我们的聊天应用将能够处理实时的消息交流，拥有健壮的逻辑处理能力以及优雅的错误处理机制。接下来的小节，我们将继续深入探讨应用的其他关键功能和实现细节。\n\n**第4小节：数据持久化**\n\n在聊天应用中，数据持久化是保证用户信息、消息历史以及应用状态在不同会话间能够得到保存和恢复的关键技术。不仅仅是为了增强用户体验，数据持久化同样是数据安全和隐私的重要组成部分。在本小节中，我们将讨论在SwiftUI应用中实现数据持久化的策略和技术。\n\n### 持久化选项\n\nSwiftUI应用中，我们可以选择多种方式来实现数据持久化：\n\n1. **UserDefaults**：适合存储少量的用户偏好设置或简单的应用状态。\n2. **文件系统**：适合存储大量数据，如日志文件或者用户生成的内容。\n3. **SQLite数据库**：适合复杂的数据结构和大量数据的管理。\n4. **Core Data**：苹果推荐的解决方案，集成了SQLite，并提供了丰富的数据管理功能。\n5. **CloudKit**：允许数据在设备间同步，同时保留在iCloud上。\n\n### Core Data集成\n\n我们将以Core Data为例，探讨如何在SwiftUI聊天应用中实现数据持久化。\n\n- **设置Core Data堆栈**：这包括了`NSPersistentContainer`的创建和配置，它将负责管理数据模型和协调数据存储。\n- **定义数据模型**：在`.xcdatamodeld`文件中定义实体（Entity），包括`User`和`Message`等，并设置好它们的属性和关系。\n- **管理上下文（Context）**：使用`NSManagedObjectContext`来管理对象的生命周期，实现数据的增删改查操作。\n\n### 数据存储和检索\n\n- **存储消息**：当用户发送消息时，创建`Message`的实例，并通过上下文将其插入到持久化存储中。\n- **读取会话**：加载聊天会话时，从Core Data中检索相关联的`Message`实例，根据时间戳排序后显示在界面上。\n\n### 同步和更新\n\n- **监听数据变化**：利用`NSFetchedResultsController`监听Core Data模型的变化，当新消息被插入时，自动刷新UI。\n- **后台更新**：通过`performBackgroundTask`方法在后台线程上进行数据更新操作，以避免阻塞UI线程。\n\n### 错误处理\n\n- **处理Core Data错误**：在进行数据操作时，正确处理`NSManagedObjectContext`的保存（save）操作可能出现的错误。\n- **数据迁移**：为了应对未来数据模型的变化，实现Core Data的数据迁移策略。\n\n### 测试与维护\n\n- **单元测试**：为数据模型的创建、更新、删除编写单元测试，确保数据层逻辑的正确性。\n- **数据清理**：实现数据清理策略，比如删除过旧的消息，避免数据库不断增大。\n\n### 总结\n\n数据持久化不仅能提高用户体验，同时对于保证数据的安全性和完整性也至关重要。通过使用Core Data，我们可以为聊天应用提供一个强大、灵活且易于维护的数据存储方案。在聊天应用中实现了数据持久化之后，无论用户何时回到应用，都能够立即接入到他们离开时的状态，保持流畅的聊天体验。在下一小节中，我们将进一步探讨如何将我们的聊天应用与云服务（如CloudKit）整合，实现跨设备的数据同步功能。\n\n**第5小节：网络请求和数据处理**\n\n当我们在构建一个现代的聊天应用时，网络请求成为了一个核心部分，它负责从远程服务器获取数据以及将数据推送到服务器。在本小节中，我们将介绍如何在聊天应用中处理网络请求和数据。\n\n### 设计API接口\n\n在开始编写代码之前，我们需要设计我们聊天应用所需的API接口。这些接口应包括：\n\n- 用户注册与登录\n- 消息发送与接收\n- 用户状态更新\n- 好友列表和消息历史获取\n\nAPI设计应该遵循RESTful原则或者使用更现代的GraphQL。\n\n### 使用Swift的网络框架\n\nSwift提供了多种网络请求的方法，如`URLSession`，它是一个强大且灵活的网络通信框架。\n\n- **创建网络请求**：使用`URLRequest`构建请求，包括URL、HTTP方法（如GET、POST）、请求头和请求体。\n- **发送请求和接收响应**：利用`URLSession`发起请求，并通过`URLSessionDataTask`处理回调。\n- **解析JSON数据**：使用`JSONDecoder`将服务器返回的JSON数据解析成Swift的结构体。\n\n### 异步和等待\n\nSwiftUI 与 Swift 5.5 引入的 async/await 一起，可以大大简化异步网络请求的处理。\n\n- **异步函数**：定义异步函数来发起网络请求，使用`await`关键字等待响应。\n- **错误处理**：使用`do-catch`语句捕获并处理网络请求或数据解析中可能发生的错误。\n\n### 数据模型和解析\n\n定义数据模型来对应API返回的数据格式。\n\n```swift\nstruct User: Codable {\n    var id: String\n    var name: String\n    // ...\n}\n\nstruct Message: Codable {\n    var senderId: String\n    var receiverId: String\n    var content: String\n    var timestamp: Date\n    // ...\n}\n```\n\n使用`Codable`协议自动将JSON数据和模型进行映射。\n\n### 实时聊天功能\n\n对于聊天应用来说，实时通讯是必不可少的。WebSocket 是一种在单个TCP连接上进行全双工通讯的协议。\n\n- **使用WebSocket**：通过`URLSessionWebSocketTask`来与服务器建立WebSocket连接。\n- **接收消息**：监听WebSocket的消息事件来实时接收新消息。\n- **发送消息**：发送消息通过WebSocket实时传递给其他用户。\n\n### 网络状态监听\n\n考虑到网络状态可能时常变化，应用应能响应网络状态的改变。\n\n- **使用Reachability**：检测网络连接状态，根据网络状况提示用户或执行重连策略。\n- **网络指示器**：提供用户界面反馈，例如当应用正在进行网络请求时显示加载指示器。\n\n### 安全性\n\n安全性是聊天应用中一个重要的议题。\n\n- **使用HTTPS**：确保所有的网络请求都通过安全的HTTP连接进行。\n- **身份验证**：使用OAuth、JWT等机制来管理和验证用户身份。\n- **数据加密**：对敏感数据进行加密，确保即使在传输过程中数据被截获也无法被解读。\n\n### 测试\n\n网络请求的测试至关重要。\n\n- **单元测试**：为网络请求编写单元测试，使用Mock对象来模拟网络响应。\n- **集成测试**：确保网络请求与应用其他部分的整合运行无误。\n\n### 总结\n\n网络请求和数据处理是构建聊天应用的核心部分。利用Swift的现代编程特性和网络框架，我们可以有效地发送请求、接收响应、处理数据，并保证用户信息的安全性。在下一小节中，我们将讨论如何\n\n实现跨平台的消息推送通知，这是提升用户体验的另一个关键点。\n\n**第6小节：应用测试和发布准备**\n\n在开发完一个应用后，进行彻底的测试并做好发布前的各种准备工作是至关重要的。这一步骤确保了你的应用能够在广泛发布之前，满足质量标准，减少可能的错误或问题，为最终用户提供良好的体验。\n\n### 应用测试\n\n**单元测试**：为应用的每一个独立模块编写单元测试，验证逻辑的正确性。在聊天应用中，需要确保消息处理、用户认证、数据解析等核心功能的准确无误。\n\n```swift\nimport XCTest\n@testable import ChatApp\n\nclass ChatAppTests: XCTestCase {\n    func testMessageParsing() {\n        let json = \"{ \\\"senderId\\\": \\\"1\\\", \\\"receiverId\\\": \\\"2\\\", \\\"content\\\": \\\"Hello\\\" }\"\n        let data = Data(json.utf8)\n        let message = try? JSONDecoder().decode(Message.self, from: data)\n        XCTAssertNotNil(message)\n    }\n}\n```\n\n**集成测试**：检查应用中各个模块之间的交互是否正确。这包括用户界面流程的测试，确保视图控制器和视图模型间的交互按预期工作。\n\n**性能测试**：确保应用的性能达标。例如，消息加载和发送的速度要快，内存消耗要低。\n\n**安全性测试**：验证应用的安全措施，包括数据加密和身份验证流程。\n\n### 用户界面测试\n\n**UI测试**：自动化测试用户界面，确保用户的交互行为如点击、滚动、输入等能够产生预期的结果。\n\n```swift\nimport XCTest\n\nclass ChatAppUITests: XCTestCase {\n    func testChatFlow() {\n        let app = XCUIApplication()\n        app.launch()\n        \n        let messageTextField = app.textFields[\"messageTextField\"]\n        messageTextField.tap()\n        messageTextField.typeText(\"Hello, World!\")\n        \n        let sendButton = app.buttons[\"sendButton\"]\n        sendButton.tap()\n        \n        // 验证消息是否显示在聊天界面上\n        let chatBubble = app.staticTexts[\"Hello, World!\"]\n        XCTAssertTrue(chatBubble.exists)\n    }\n}\n```\n\n**可访问性测试**：确保应用支持VoiceOver等辅助功能，使得所有用户都能使用你的应用。\n\n### 发布前的准备\n\n**Beta测试**：通过TestFlight或类似的服务，发布应用的测试版本，邀请用户参与beta测试。\n\n**性能优化**：回顾代码，查找并优化可能的性能瓶颈，如减少不必要的网络请求，优化图片加载。\n\n**本地化**：确保应用支持多语言，包括界面文本和用户内容的适当本地化。\n\n**应用商店优化（ASO）**：为了在应用商店中获得更好的曝光，优化应用的标题、描述、关键字和截图。\n\n**隐私政策和用户协议**：准备并审核应用的隐私政策和用户协议文档，确保符合法律法规和应用商店的要求。\n\n**备份和恢复策略**：确保应用支持数据备份和恢复功能，以便用户更换设备后可以恢复数据。\n\n### 总结\n\n确保你的聊天应用在发布前通过了各种形式的测试，这包括了功能、性能、安全性和用户界面的测试。同时，完成发布前的各项准备工作，确保你的应用在上架后能够吸引用户并且避免法律风险。","source":"_posts/SwiftUI核心技术第15章构建一个聊天APP.md","raw":"---\ntitle: SwiftUI核心技术第15章构建一个聊天APP\ndate: 2023-11-08 10:24:42\ncategories:\n- SwiftUI\ntags:\n---\n**第1小节：应用结构规划**\n\n在开发一个新的应用时，规划应用的结构是成功的关键。一个良好设计的应用结构可以提高代码的可维护性和扩展性，并使团队合作变得更加高效。本小节我们将讨论如何为我们的聊天应用进行结构规划。\n\n### 应用概览\n\n我们的聊天应用将具备以下基本功能：\n\n- 用户注册与登录\n- 好友列表管理\n- 实时消息传递\n- 个人与群组聊天\n- 消息通知\n\n### 架构模式\n\n首先，我们需要选择一个适合于聊天应用的架构模式。考虑到SwiftUI的特性，我们选择MVVM（Model-View-ViewModel）作为主要架构，因为它能够很好地与SwiftUI的声明式UI和数据流工作模式配合。\n\n### 分层设计\n\n我们的应用将分为以下几层：\n\n1. **视图层（View）**：负责展示用户界面，捕获用户输入。\n2. **视图模型层（ViewModel）**：处理视图逻辑，响应用户输入，与模型层通信。\n3. **模型层（Model）**：定义数据结构和业务逻辑。\n4. **网络层**：处理所有网络通信，例如发送和接收消息。\n5. **数据库层**：负责数据持久化，存储历史消息和用户数据。\n\n### 目录结构\n\n为了支持这种分层设计，我们的项目目录将如下组织：\n\n```\nChatApp/\n├── Views/\n│   ├── LoginView.swift\n│   ├── ChatListView.swift\n│   ├── ChatView.swift\n│   └── ...\n├── ViewModels/\n│   ├── LoginViewModel.swift\n│   ├── ChatListViewModel.swift\n│   ├── ChatViewModel.swift\n│   └── ...\n├── Models/\n│   ├── User.swift\n│   ├── Message.swift\n│   ├── Conversation.swift\n│   └── ...\n├── Services/\n│   ├── AuthenticationService.swift\n│   ├── ChatService.swift\n│   ├── NotificationService.swift\n│   └── ...\n└── Utilities/\n    ├── Constants.swift\n    ├── Extensions.swift\n    └── ...\n```\n\n### 功能模块划分\n\n接下来，我们将应用分解为几个核心模块：\n\n- **用户认证模块**：包括用户注册、登录和验证。\n- **联系人模块**：用户的好友列表，添加和删除联系人。\n- **聊天模块**：展示消息历史，发送新消息，消息推送。\n- **设置模块**：用户可以修改个人信息，设置应用选项等。\n\n### 数据流规划\n\n由于聊天应用需要实时的数据更新，我们将使用Combine框架来处理数据的发布和订阅，以确保用户界面能够响应数据的变化。\n\n- 使用`@Published`属性包装器来自动管理数据的发布。\n- `ViewModels`将订阅`Models`的变化，并更新视图状态。\n- 视图将绑定到视图模型的发布者，以获得数据变更的通知。\n\n### 安全和隐私\n\n聊天应用需要格外注意安全和隐私：\n\n- 采用安全的认证机制，如OAuth 2.0。\n- 传输层加密，确保数据传输的安全。\n- 数据库加密存储敏感信息。\n\n### 用户体验（UX）\n\n用户体验是聊天应用成功的关键，我们需要确保：\n\n- 界面简洁明了，易于导航。\n- 消息即时传送，无明显延迟。\n- 有声音和震动的通知反馈。\n\n通过仔细规\n\n划应用结构，我们为聊天应用的开发奠定了坚实的基础。后续小节中，我们将深入每个模块，开始具体的设计和编码工作。\n\n\n**第2小节：用户界面设计**\n\n用户界面（UI）设计是创建聊天应用的重要组成部分。一个直观、易用且美观的UI将极大地提升用户体验。在这一小节，我们将概述聊天应用的用户界面设计过程，包括布局、组件选择、颜色和动画的应用等方面。\n\n### UI设计原则\n\n在设计界面之前，我们首先确定几个核心设计原则：\n\n- **一致性**：整个应用的设计风格保持一致，包括按钮样式、字体、颜色等。\n- **简洁性**：避免不必要的元素，使用户可以集中于聊天功能。\n- **直观性**：确保用户能够直观地理解如何使用应用，无需额外学习。\n- **响应式**：界面应该能够适应不同设备和屏幕大小。\n\n### 布局设计\n\n布局是UI设计的基础，我们将采用如下布局策略：\n\n- **导航栏**：位于屏幕顶部，包含用户的状态和导航控件。\n- **消息列表**：主屏幕显示消息列表，一览无余。\n- **输入区**：屏幕底部为消息输入区，包括文本输入框和发送按钮。\n- **设置菜单**：通过导航栏访问，包括个人资料编辑和应用设置。\n\n### 组件设计\n\n我们将使用SwiftUI来构建以下组件：\n\n- **CustomButton**：自定义按钮，用于登录、发送消息等。\n- **ChatBubble**：聊天气泡，区分自己和他人的消息。\n- **UserAvatar**：用户头像，显示在消息旁边和好友列表中。\n- **TextField**：自定义文本输入框，支持多行文本输入和表情。\n\n### 颜色和主题\n\n颜色方案将支持暗黑模式和光亮模式，我们将定义一组基础颜色：\n\n- **主色调**：定义应用的主题颜色，如蓝色或绿色。\n- **辅助色**：用于强调按钮或重要信息。\n- **背景色**：分为深色和浅色变体，适应不同模式。\n- **文字色**：确保在任何背景色上都清晰可见。\n\n### 图标和图形\n\n应用中的图标和图形将采用矢量图形，以确保在不同分辨率下都能清晰显示。我们将为每个主要功能选择直观的图标。\n\n### 动画\n\n为了提升用户体验，我们将在以下方面应用动画：\n\n- **页面切换**：平滑过渡，增强用户操作的连贯感。\n- **消息发送**：消息框飞入聊天区域的动画。\n- **加载指示器**：在等待网络响应时提供动态反馈。\n\n### 响应式设计\n\n我们的UI设计将采用响应式方法，以适应不同的设备和屏幕尺寸：\n\n- **自适应布局**：使用`Stacks`、`Grids`和`Flexible Spaces`确保组件在不同屏幕上都能正确布局。\n- **动态字体大小**：支持系统字体大小设置，适应用户的阅读需求。\n\n### 交互设计\n\n最后，交互设计也是我们关注的重点：\n\n- **触控反馈**：按钮和可交互元素将提供触觉反馈。\n- **滑动删除**：在消息列表中轻松\n\n滑动来删除消息或撤回。\n\n通过上述设计，我们将创建一个美观、直观且功能强大的聊天应用用户界面。接下来，我们将在小节中进一步详细说明每个组件和功能的实现过程。\n\n\n**第3小节：应用逻辑实现**\n\n构建一个聊天应用不仅仅是设计外观上的美观与实用，应用的核心在于其逻辑实现。在本小节，我们将探讨如何在SwiftUI框架下实现聊天应用的基本逻辑，包括消息的发送与接收、状态管理以及实时更新等功能。\n\n### 基础逻辑构建\n\n首先，我们需要建立应用的数据模型和业务逻辑层，这通常涉及以下几个关键部分：\n\n- **用户模型（User Model）**：定义用户的基本信息，如用户名、头像、状态等。\n- **消息模型（Message Model）**：定义消息的数据结构，包含发送者、接收者、消息内容、发送时间等。\n- **会话列表（Conversations List）**：存储用户的聊天会话，每个会话包含多条消息。\n- **数据管理器（Data Manager）**：负责处理数据的存取、更新以及同步。\n\n### 消息发送与接收\n\n聊天的核心功能是消息的发送与接收，我们将通过以下步骤来实现：\n\n1. **输入与发送**：\n   - 使用`TextField`或`TextView`获取用户输入的消息文本。\n   - 当用户点击发送按钮时，通过数据管理器将消息对象保存到会话列表中。\n\n2. **消息展示**：\n   - 使用`ScrollView`和`LazyVStack`展示消息列表。\n   - 对于每条消息，使用`ChatBubble`视图来展示，根据发送者是自己还是对方来调整样式和位置。\n\n3. **实时更新**：\n   - 通过`Combine`框架监听数据变化，实现消息的实时更新。\n   - 当有新消息时，更新UI以展示新消息。\n\n### 状态管理\n\n在SwiftUI中，状态管理是一个重要的概念，它确保UI的正确性和数据的同步。我们将使用`@State`、`@Binding`、`@ObservedObject`等属性包装器来管理状态：\n\n- **用户状态**：使用`@State`管理用户的在线状态，比如在线、离开、忙碌等。\n- **消息状态**：使用`@ObservedObject`监控消息的发送和接收状态。\n\n### 实时更新和同步\n\n为了实现聊天应用中的实时互动，我们将使用WebSocket或者Apple的`CloudKit`来进行网络通信，实现消息的即时推送：\n\n- **WebSocket连接**：建立WebSocket连接来监听服务器发来的新消息。\n- **CloudKit同步**：如果使用`CloudKit`，则设置相应的记录类型和订阅，以便于新消息到来时可以立即更新。\n\n### 聊天功能拓展\n\n除了基础的文本消息，我们还可以实现以下几个功能：\n\n- **图片和视频发送**：允许用户发送媒体文件，并在聊天气泡中预览。\n- **消息状态标记**：如已读、已发送等状态的标记。\n- **通知与提醒**：通过本地通知或推送通知，告知用户新消息的到来。\n\n### 异常处理\n\n在实现聊天逻辑时，还需要考虑异常情况的处理：\n\n- **网络异常**：当网络不稳定或断开时，给用户适当的反馈，并尝试重新连接。\n- **数据持久化**：确保消息在本地被保存，即使应用关闭后也能恢复历史消息。\n\n### 测试\n\n开发过程中，持续进行单元测试和集成测试来确保各个功能的可靠性，包括：\n\n- **逻辑测试**：对数据管理器和业务逻辑层进行测试。\n- **UI测试**：确保消息正确显示，\n\n用户交互按预期工作。\n\n### 总结\n\n在本小节中，我们详细探讨了构建聊天应用的应用逻辑实现。从用户界面的交互到后端的数据处理，每一步都是为了提供流畅而可靠的用户体验。通过上述步骤的实现，我们的聊天应用将能够处理实时的消息交流，拥有健壮的逻辑处理能力以及优雅的错误处理机制。接下来的小节，我们将继续深入探讨应用的其他关键功能和实现细节。\n\n**第4小节：数据持久化**\n\n在聊天应用中，数据持久化是保证用户信息、消息历史以及应用状态在不同会话间能够得到保存和恢复的关键技术。不仅仅是为了增强用户体验，数据持久化同样是数据安全和隐私的重要组成部分。在本小节中，我们将讨论在SwiftUI应用中实现数据持久化的策略和技术。\n\n### 持久化选项\n\nSwiftUI应用中，我们可以选择多种方式来实现数据持久化：\n\n1. **UserDefaults**：适合存储少量的用户偏好设置或简单的应用状态。\n2. **文件系统**：适合存储大量数据，如日志文件或者用户生成的内容。\n3. **SQLite数据库**：适合复杂的数据结构和大量数据的管理。\n4. **Core Data**：苹果推荐的解决方案，集成了SQLite，并提供了丰富的数据管理功能。\n5. **CloudKit**：允许数据在设备间同步，同时保留在iCloud上。\n\n### Core Data集成\n\n我们将以Core Data为例，探讨如何在SwiftUI聊天应用中实现数据持久化。\n\n- **设置Core Data堆栈**：这包括了`NSPersistentContainer`的创建和配置，它将负责管理数据模型和协调数据存储。\n- **定义数据模型**：在`.xcdatamodeld`文件中定义实体（Entity），包括`User`和`Message`等，并设置好它们的属性和关系。\n- **管理上下文（Context）**：使用`NSManagedObjectContext`来管理对象的生命周期，实现数据的增删改查操作。\n\n### 数据存储和检索\n\n- **存储消息**：当用户发送消息时，创建`Message`的实例，并通过上下文将其插入到持久化存储中。\n- **读取会话**：加载聊天会话时，从Core Data中检索相关联的`Message`实例，根据时间戳排序后显示在界面上。\n\n### 同步和更新\n\n- **监听数据变化**：利用`NSFetchedResultsController`监听Core Data模型的变化，当新消息被插入时，自动刷新UI。\n- **后台更新**：通过`performBackgroundTask`方法在后台线程上进行数据更新操作，以避免阻塞UI线程。\n\n### 错误处理\n\n- **处理Core Data错误**：在进行数据操作时，正确处理`NSManagedObjectContext`的保存（save）操作可能出现的错误。\n- **数据迁移**：为了应对未来数据模型的变化，实现Core Data的数据迁移策略。\n\n### 测试与维护\n\n- **单元测试**：为数据模型的创建、更新、删除编写单元测试，确保数据层逻辑的正确性。\n- **数据清理**：实现数据清理策略，比如删除过旧的消息，避免数据库不断增大。\n\n### 总结\n\n数据持久化不仅能提高用户体验，同时对于保证数据的安全性和完整性也至关重要。通过使用Core Data，我们可以为聊天应用提供一个强大、灵活且易于维护的数据存储方案。在聊天应用中实现了数据持久化之后，无论用户何时回到应用，都能够立即接入到他们离开时的状态，保持流畅的聊天体验。在下一小节中，我们将进一步探讨如何将我们的聊天应用与云服务（如CloudKit）整合，实现跨设备的数据同步功能。\n\n**第5小节：网络请求和数据处理**\n\n当我们在构建一个现代的聊天应用时，网络请求成为了一个核心部分，它负责从远程服务器获取数据以及将数据推送到服务器。在本小节中，我们将介绍如何在聊天应用中处理网络请求和数据。\n\n### 设计API接口\n\n在开始编写代码之前，我们需要设计我们聊天应用所需的API接口。这些接口应包括：\n\n- 用户注册与登录\n- 消息发送与接收\n- 用户状态更新\n- 好友列表和消息历史获取\n\nAPI设计应该遵循RESTful原则或者使用更现代的GraphQL。\n\n### 使用Swift的网络框架\n\nSwift提供了多种网络请求的方法，如`URLSession`，它是一个强大且灵活的网络通信框架。\n\n- **创建网络请求**：使用`URLRequest`构建请求，包括URL、HTTP方法（如GET、POST）、请求头和请求体。\n- **发送请求和接收响应**：利用`URLSession`发起请求，并通过`URLSessionDataTask`处理回调。\n- **解析JSON数据**：使用`JSONDecoder`将服务器返回的JSON数据解析成Swift的结构体。\n\n### 异步和等待\n\nSwiftUI 与 Swift 5.5 引入的 async/await 一起，可以大大简化异步网络请求的处理。\n\n- **异步函数**：定义异步函数来发起网络请求，使用`await`关键字等待响应。\n- **错误处理**：使用`do-catch`语句捕获并处理网络请求或数据解析中可能发生的错误。\n\n### 数据模型和解析\n\n定义数据模型来对应API返回的数据格式。\n\n```swift\nstruct User: Codable {\n    var id: String\n    var name: String\n    // ...\n}\n\nstruct Message: Codable {\n    var senderId: String\n    var receiverId: String\n    var content: String\n    var timestamp: Date\n    // ...\n}\n```\n\n使用`Codable`协议自动将JSON数据和模型进行映射。\n\n### 实时聊天功能\n\n对于聊天应用来说，实时通讯是必不可少的。WebSocket 是一种在单个TCP连接上进行全双工通讯的协议。\n\n- **使用WebSocket**：通过`URLSessionWebSocketTask`来与服务器建立WebSocket连接。\n- **接收消息**：监听WebSocket的消息事件来实时接收新消息。\n- **发送消息**：发送消息通过WebSocket实时传递给其他用户。\n\n### 网络状态监听\n\n考虑到网络状态可能时常变化，应用应能响应网络状态的改变。\n\n- **使用Reachability**：检测网络连接状态，根据网络状况提示用户或执行重连策略。\n- **网络指示器**：提供用户界面反馈，例如当应用正在进行网络请求时显示加载指示器。\n\n### 安全性\n\n安全性是聊天应用中一个重要的议题。\n\n- **使用HTTPS**：确保所有的网络请求都通过安全的HTTP连接进行。\n- **身份验证**：使用OAuth、JWT等机制来管理和验证用户身份。\n- **数据加密**：对敏感数据进行加密，确保即使在传输过程中数据被截获也无法被解读。\n\n### 测试\n\n网络请求的测试至关重要。\n\n- **单元测试**：为网络请求编写单元测试，使用Mock对象来模拟网络响应。\n- **集成测试**：确保网络请求与应用其他部分的整合运行无误。\n\n### 总结\n\n网络请求和数据处理是构建聊天应用的核心部分。利用Swift的现代编程特性和网络框架，我们可以有效地发送请求、接收响应、处理数据，并保证用户信息的安全性。在下一小节中，我们将讨论如何\n\n实现跨平台的消息推送通知，这是提升用户体验的另一个关键点。\n\n**第6小节：应用测试和发布准备**\n\n在开发完一个应用后，进行彻底的测试并做好发布前的各种准备工作是至关重要的。这一步骤确保了你的应用能够在广泛发布之前，满足质量标准，减少可能的错误或问题，为最终用户提供良好的体验。\n\n### 应用测试\n\n**单元测试**：为应用的每一个独立模块编写单元测试，验证逻辑的正确性。在聊天应用中，需要确保消息处理、用户认证、数据解析等核心功能的准确无误。\n\n```swift\nimport XCTest\n@testable import ChatApp\n\nclass ChatAppTests: XCTestCase {\n    func testMessageParsing() {\n        let json = \"{ \\\"senderId\\\": \\\"1\\\", \\\"receiverId\\\": \\\"2\\\", \\\"content\\\": \\\"Hello\\\" }\"\n        let data = Data(json.utf8)\n        let message = try? JSONDecoder().decode(Message.self, from: data)\n        XCTAssertNotNil(message)\n    }\n}\n```\n\n**集成测试**：检查应用中各个模块之间的交互是否正确。这包括用户界面流程的测试，确保视图控制器和视图模型间的交互按预期工作。\n\n**性能测试**：确保应用的性能达标。例如，消息加载和发送的速度要快，内存消耗要低。\n\n**安全性测试**：验证应用的安全措施，包括数据加密和身份验证流程。\n\n### 用户界面测试\n\n**UI测试**：自动化测试用户界面，确保用户的交互行为如点击、滚动、输入等能够产生预期的结果。\n\n```swift\nimport XCTest\n\nclass ChatAppUITests: XCTestCase {\n    func testChatFlow() {\n        let app = XCUIApplication()\n        app.launch()\n        \n        let messageTextField = app.textFields[\"messageTextField\"]\n        messageTextField.tap()\n        messageTextField.typeText(\"Hello, World!\")\n        \n        let sendButton = app.buttons[\"sendButton\"]\n        sendButton.tap()\n        \n        // 验证消息是否显示在聊天界面上\n        let chatBubble = app.staticTexts[\"Hello, World!\"]\n        XCTAssertTrue(chatBubble.exists)\n    }\n}\n```\n\n**可访问性测试**：确保应用支持VoiceOver等辅助功能，使得所有用户都能使用你的应用。\n\n### 发布前的准备\n\n**Beta测试**：通过TestFlight或类似的服务，发布应用的测试版本，邀请用户参与beta测试。\n\n**性能优化**：回顾代码，查找并优化可能的性能瓶颈，如减少不必要的网络请求，优化图片加载。\n\n**本地化**：确保应用支持多语言，包括界面文本和用户内容的适当本地化。\n\n**应用商店优化（ASO）**：为了在应用商店中获得更好的曝光，优化应用的标题、描述、关键字和截图。\n\n**隐私政策和用户协议**：准备并审核应用的隐私政策和用户协议文档，确保符合法律法规和应用商店的要求。\n\n**备份和恢复策略**：确保应用支持数据备份和恢复功能，以便用户更换设备后可以恢复数据。\n\n### 总结\n\n确保你的聊天应用在发布前通过了各种形式的测试，这包括了功能、性能、安全性和用户界面的测试。同时，完成发布前的各项准备工作，确保你的应用在上架后能够吸引用户并且避免法律风险。","slug":"SwiftUI核心技术第15章构建一个聊天APP","published":1,"updated":"2024-03-17T06:12:04.584Z","comments":1,"layout":"post","photos":[],"_id":"clu6up53i002cz674a78ldz8q","content":"<p><strong>第1小节：应用结构规划</strong></p>\n<p>在开发一个新的应用时，规划应用的结构是成功的关键。一个良好设计的应用结构可以提高代码的可维护性和扩展性，并使团队合作变得更加高效。本小节我们将讨论如何为我们的聊天应用进行结构规划。</p>\n<h3 id=\"应用概览\"><a href=\"#应用概览\" class=\"headerlink\" title=\"应用概览\"></a>应用概览</h3><p>我们的聊天应用将具备以下基本功能：</p>\n<ul>\n<li>用户注册与登录</li>\n<li>好友列表管理</li>\n<li>实时消息传递</li>\n<li>个人与群组聊天</li>\n<li>消息通知</li>\n</ul>\n<h3 id=\"架构模式\"><a href=\"#架构模式\" class=\"headerlink\" title=\"架构模式\"></a>架构模式</h3><p>首先，我们需要选择一个适合于聊天应用的架构模式。考虑到SwiftUI的特性，我们选择MVVM（Model-View-ViewModel）作为主要架构，因为它能够很好地与SwiftUI的声明式UI和数据流工作模式配合。</p>\n<h3 id=\"分层设计\"><a href=\"#分层设计\" class=\"headerlink\" title=\"分层设计\"></a>分层设计</h3><p>我们的应用将分为以下几层：</p>\n<ol>\n<li><strong>视图层（View）</strong>：负责展示用户界面，捕获用户输入。</li>\n<li><strong>视图模型层（ViewModel）</strong>：处理视图逻辑，响应用户输入，与模型层通信。</li>\n<li><strong>模型层（Model）</strong>：定义数据结构和业务逻辑。</li>\n<li><strong>网络层</strong>：处理所有网络通信，例如发送和接收消息。</li>\n<li><strong>数据库层</strong>：负责数据持久化，存储历史消息和用户数据。</li>\n</ol>\n<h3 id=\"目录结构\"><a href=\"#目录结构\" class=\"headerlink\" title=\"目录结构\"></a>目录结构</h3><p>为了支持这种分层设计，我们的项目目录将如下组织：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">ChatApp/<br>├── Views/<br>│   ├── LoginView<span class=\"hljs-selector-class\">.swift</span><br>│   ├── ChatListView<span class=\"hljs-selector-class\">.swift</span><br>│   ├── ChatView<span class=\"hljs-selector-class\">.swift</span><br>│   └── ...<br>├── ViewModels/<br>│   ├── LoginViewModel<span class=\"hljs-selector-class\">.swift</span><br>│   ├── ChatListViewModel<span class=\"hljs-selector-class\">.swift</span><br>│   ├── ChatViewModel<span class=\"hljs-selector-class\">.swift</span><br>│   └── ...<br>├── Models/<br>│   ├── User<span class=\"hljs-selector-class\">.swift</span><br>│   ├── Message<span class=\"hljs-selector-class\">.swift</span><br>│   ├── Conversation<span class=\"hljs-selector-class\">.swift</span><br>│   └── ...<br>├── Services/<br>│   ├── AuthenticationService<span class=\"hljs-selector-class\">.swift</span><br>│   ├── ChatService<span class=\"hljs-selector-class\">.swift</span><br>│   ├── NotificationService<span class=\"hljs-selector-class\">.swift</span><br>│   └── ...<br>└── Utilities/<br>    ├── Constants<span class=\"hljs-selector-class\">.swift</span><br>    ├── Extensions<span class=\"hljs-selector-class\">.swift</span><br>    └── ...<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"功能模块划分\"><a href=\"#功能模块划分\" class=\"headerlink\" title=\"功能模块划分\"></a>功能模块划分</h3><p>接下来，我们将应用分解为几个核心模块：</p>\n<ul>\n<li><strong>用户认证模块</strong>：包括用户注册、登录和验证。</li>\n<li><strong>联系人模块</strong>：用户的好友列表，添加和删除联系人。</li>\n<li><strong>聊天模块</strong>：展示消息历史，发送新消息，消息推送。</li>\n<li><strong>设置模块</strong>：用户可以修改个人信息，设置应用选项等。</li>\n</ul>\n<h3 id=\"数据流规划\"><a href=\"#数据流规划\" class=\"headerlink\" title=\"数据流规划\"></a>数据流规划</h3><p>由于聊天应用需要实时的数据更新，我们将使用Combine框架来处理数据的发布和订阅，以确保用户界面能够响应数据的变化。</p>\n<ul>\n<li>使用<code>@Published</code>属性包装器来自动管理数据的发布。</li>\n<li><code>ViewModels</code>将订阅<code>Models</code>的变化，并更新视图状态。</li>\n<li>视图将绑定到视图模型的发布者，以获得数据变更的通知。</li>\n</ul>\n<h3 id=\"安全和隐私\"><a href=\"#安全和隐私\" class=\"headerlink\" title=\"安全和隐私\"></a>安全和隐私</h3><p>聊天应用需要格外注意安全和隐私：</p>\n<ul>\n<li>采用安全的认证机制，如OAuth 2.0。</li>\n<li>传输层加密，确保数据传输的安全。</li>\n<li>数据库加密存储敏感信息。</li>\n</ul>\n<h3 id=\"用户体验（UX）\"><a href=\"#用户体验（UX）\" class=\"headerlink\" title=\"用户体验（UX）\"></a>用户体验（UX）</h3><p>用户体验是聊天应用成功的关键，我们需要确保：</p>\n<ul>\n<li>界面简洁明了，易于导航。</li>\n<li>消息即时传送，无明显延迟。</li>\n<li>有声音和震动的通知反馈。</li>\n</ul>\n<p>通过仔细规</p>\n<p>划应用结构，我们为聊天应用的开发奠定了坚实的基础。后续小节中，我们将深入每个模块，开始具体的设计和编码工作。</p>\n<p><strong>第2小节：用户界面设计</strong></p>\n<p>用户界面（UI）设计是创建聊天应用的重要组成部分。一个直观、易用且美观的UI将极大地提升用户体验。在这一小节，我们将概述聊天应用的用户界面设计过程，包括布局、组件选择、颜色和动画的应用等方面。</p>\n<h3 id=\"UI设计原则\"><a href=\"#UI设计原则\" class=\"headerlink\" title=\"UI设计原则\"></a>UI设计原则</h3><p>在设计界面之前，我们首先确定几个核心设计原则：</p>\n<ul>\n<li><strong>一致性</strong>：整个应用的设计风格保持一致，包括按钮样式、字体、颜色等。</li>\n<li><strong>简洁性</strong>：避免不必要的元素，使用户可以集中于聊天功能。</li>\n<li><strong>直观性</strong>：确保用户能够直观地理解如何使用应用，无需额外学习。</li>\n<li><strong>响应式</strong>：界面应该能够适应不同设备和屏幕大小。</li>\n</ul>\n<h3 id=\"布局设计\"><a href=\"#布局设计\" class=\"headerlink\" title=\"布局设计\"></a>布局设计</h3><p>布局是UI设计的基础，我们将采用如下布局策略：</p>\n<ul>\n<li><strong>导航栏</strong>：位于屏幕顶部，包含用户的状态和导航控件。</li>\n<li><strong>消息列表</strong>：主屏幕显示消息列表，一览无余。</li>\n<li><strong>输入区</strong>：屏幕底部为消息输入区，包括文本输入框和发送按钮。</li>\n<li><strong>设置菜单</strong>：通过导航栏访问，包括个人资料编辑和应用设置。</li>\n</ul>\n<h3 id=\"组件设计\"><a href=\"#组件设计\" class=\"headerlink\" title=\"组件设计\"></a>组件设计</h3><p>我们将使用SwiftUI来构建以下组件：</p>\n<ul>\n<li><strong>CustomButton</strong>：自定义按钮，用于登录、发送消息等。</li>\n<li><strong>ChatBubble</strong>：聊天气泡，区分自己和他人的消息。</li>\n<li><strong>UserAvatar</strong>：用户头像，显示在消息旁边和好友列表中。</li>\n<li><strong>TextField</strong>：自定义文本输入框，支持多行文本输入和表情。</li>\n</ul>\n<h3 id=\"颜色和主题\"><a href=\"#颜色和主题\" class=\"headerlink\" title=\"颜色和主题\"></a>颜色和主题</h3><p>颜色方案将支持暗黑模式和光亮模式，我们将定义一组基础颜色：</p>\n<ul>\n<li><strong>主色调</strong>：定义应用的主题颜色，如蓝色或绿色。</li>\n<li><strong>辅助色</strong>：用于强调按钮或重要信息。</li>\n<li><strong>背景色</strong>：分为深色和浅色变体，适应不同模式。</li>\n<li><strong>文字色</strong>：确保在任何背景色上都清晰可见。</li>\n</ul>\n<h3 id=\"图标和图形\"><a href=\"#图标和图形\" class=\"headerlink\" title=\"图标和图形\"></a>图标和图形</h3><p>应用中的图标和图形将采用矢量图形，以确保在不同分辨率下都能清晰显示。我们将为每个主要功能选择直观的图标。</p>\n<h3 id=\"动画\"><a href=\"#动画\" class=\"headerlink\" title=\"动画\"></a>动画</h3><p>为了提升用户体验，我们将在以下方面应用动画：</p>\n<ul>\n<li><strong>页面切换</strong>：平滑过渡，增强用户操作的连贯感。</li>\n<li><strong>消息发送</strong>：消息框飞入聊天区域的动画。</li>\n<li><strong>加载指示器</strong>：在等待网络响应时提供动态反馈。</li>\n</ul>\n<h3 id=\"响应式设计\"><a href=\"#响应式设计\" class=\"headerlink\" title=\"响应式设计\"></a>响应式设计</h3><p>我们的UI设计将采用响应式方法，以适应不同的设备和屏幕尺寸：</p>\n<ul>\n<li><strong>自适应布局</strong>：使用<code>Stacks</code>、<code>Grids</code>和<code>Flexible Spaces</code>确保组件在不同屏幕上都能正确布局。</li>\n<li><strong>动态字体大小</strong>：支持系统字体大小设置，适应用户的阅读需求。</li>\n</ul>\n<h3 id=\"交互设计\"><a href=\"#交互设计\" class=\"headerlink\" title=\"交互设计\"></a>交互设计</h3><p>最后，交互设计也是我们关注的重点：</p>\n<ul>\n<li><strong>触控反馈</strong>：按钮和可交互元素将提供触觉反馈。</li>\n<li><strong>滑动删除</strong>：在消息列表中轻松</li>\n</ul>\n<p>滑动来删除消息或撤回。</p>\n<p>通过上述设计，我们将创建一个美观、直观且功能强大的聊天应用用户界面。接下来，我们将在小节中进一步详细说明每个组件和功能的实现过程。</p>\n<p><strong>第3小节：应用逻辑实现</strong></p>\n<p>构建一个聊天应用不仅仅是设计外观上的美观与实用，应用的核心在于其逻辑实现。在本小节，我们将探讨如何在SwiftUI框架下实现聊天应用的基本逻辑，包括消息的发送与接收、状态管理以及实时更新等功能。</p>\n<h3 id=\"基础逻辑构建\"><a href=\"#基础逻辑构建\" class=\"headerlink\" title=\"基础逻辑构建\"></a>基础逻辑构建</h3><p>首先，我们需要建立应用的数据模型和业务逻辑层，这通常涉及以下几个关键部分：</p>\n<ul>\n<li><strong>用户模型（User Model）</strong>：定义用户的基本信息，如用户名、头像、状态等。</li>\n<li><strong>消息模型（Message Model）</strong>：定义消息的数据结构，包含发送者、接收者、消息内容、发送时间等。</li>\n<li><strong>会话列表（Conversations List）</strong>：存储用户的聊天会话，每个会话包含多条消息。</li>\n<li><strong>数据管理器（Data Manager）</strong>：负责处理数据的存取、更新以及同步。</li>\n</ul>\n<h3 id=\"消息发送与接收\"><a href=\"#消息发送与接收\" class=\"headerlink\" title=\"消息发送与接收\"></a>消息发送与接收</h3><p>聊天的核心功能是消息的发送与接收，我们将通过以下步骤来实现：</p>\n<ol>\n<li><p><strong>输入与发送</strong>：</p>\n<ul>\n<li>使用<code>TextField</code>或<code>TextView</code>获取用户输入的消息文本。</li>\n<li>当用户点击发送按钮时，通过数据管理器将消息对象保存到会话列表中。</li>\n</ul>\n</li>\n<li><p><strong>消息展示</strong>：</p>\n<ul>\n<li>使用<code>ScrollView</code>和<code>LazyVStack</code>展示消息列表。</li>\n<li>对于每条消息，使用<code>ChatBubble</code>视图来展示，根据发送者是自己还是对方来调整样式和位置。</li>\n</ul>\n</li>\n<li><p><strong>实时更新</strong>：</p>\n<ul>\n<li>通过<code>Combine</code>框架监听数据变化，实现消息的实时更新。</li>\n<li>当有新消息时，更新UI以展示新消息。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"状态管理\"><a href=\"#状态管理\" class=\"headerlink\" title=\"状态管理\"></a>状态管理</h3><p>在SwiftUI中，状态管理是一个重要的概念，它确保UI的正确性和数据的同步。我们将使用<code>@State</code>、<code>@Binding</code>、<code>@ObservedObject</code>等属性包装器来管理状态：</p>\n<ul>\n<li><strong>用户状态</strong>：使用<code>@State</code>管理用户的在线状态，比如在线、离开、忙碌等。</li>\n<li><strong>消息状态</strong>：使用<code>@ObservedObject</code>监控消息的发送和接收状态。</li>\n</ul>\n<h3 id=\"实时更新和同步\"><a href=\"#实时更新和同步\" class=\"headerlink\" title=\"实时更新和同步\"></a>实时更新和同步</h3><p>为了实现聊天应用中的实时互动，我们将使用WebSocket或者Apple的<code>CloudKit</code>来进行网络通信，实现消息的即时推送：</p>\n<ul>\n<li><strong>WebSocket连接</strong>：建立WebSocket连接来监听服务器发来的新消息。</li>\n<li><strong>CloudKit同步</strong>：如果使用<code>CloudKit</code>，则设置相应的记录类型和订阅，以便于新消息到来时可以立即更新。</li>\n</ul>\n<h3 id=\"聊天功能拓展\"><a href=\"#聊天功能拓展\" class=\"headerlink\" title=\"聊天功能拓展\"></a>聊天功能拓展</h3><p>除了基础的文本消息，我们还可以实现以下几个功能：</p>\n<ul>\n<li><strong>图片和视频发送</strong>：允许用户发送媒体文件，并在聊天气泡中预览。</li>\n<li><strong>消息状态标记</strong>：如已读、已发送等状态的标记。</li>\n<li><strong>通知与提醒</strong>：通过本地通知或推送通知，告知用户新消息的到来。</li>\n</ul>\n<h3 id=\"异常处理\"><a href=\"#异常处理\" class=\"headerlink\" title=\"异常处理\"></a>异常处理</h3><p>在实现聊天逻辑时，还需要考虑异常情况的处理：</p>\n<ul>\n<li><strong>网络异常</strong>：当网络不稳定或断开时，给用户适当的反馈，并尝试重新连接。</li>\n<li><strong>数据持久化</strong>：确保消息在本地被保存，即使应用关闭后也能恢复历史消息。</li>\n</ul>\n<h3 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h3><p>开发过程中，持续进行单元测试和集成测试来确保各个功能的可靠性，包括：</p>\n<ul>\n<li><strong>逻辑测试</strong>：对数据管理器和业务逻辑层进行测试。</li>\n<li><strong>UI测试</strong>：确保消息正确显示，</li>\n</ul>\n<p>用户交互按预期工作。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>在本小节中，我们详细探讨了构建聊天应用的应用逻辑实现。从用户界面的交互到后端的数据处理，每一步都是为了提供流畅而可靠的用户体验。通过上述步骤的实现，我们的聊天应用将能够处理实时的消息交流，拥有健壮的逻辑处理能力以及优雅的错误处理机制。接下来的小节，我们将继续深入探讨应用的其他关键功能和实现细节。</p>\n<p><strong>第4小节：数据持久化</strong></p>\n<p>在聊天应用中，数据持久化是保证用户信息、消息历史以及应用状态在不同会话间能够得到保存和恢复的关键技术。不仅仅是为了增强用户体验，数据持久化同样是数据安全和隐私的重要组成部分。在本小节中，我们将讨论在SwiftUI应用中实现数据持久化的策略和技术。</p>\n<h3 id=\"持久化选项\"><a href=\"#持久化选项\" class=\"headerlink\" title=\"持久化选项\"></a>持久化选项</h3><p>SwiftUI应用中，我们可以选择多种方式来实现数据持久化：</p>\n<ol>\n<li><strong>UserDefaults</strong>：适合存储少量的用户偏好设置或简单的应用状态。</li>\n<li><strong>文件系统</strong>：适合存储大量数据，如日志文件或者用户生成的内容。</li>\n<li><strong>SQLite数据库</strong>：适合复杂的数据结构和大量数据的管理。</li>\n<li><strong>Core Data</strong>：苹果推荐的解决方案，集成了SQLite，并提供了丰富的数据管理功能。</li>\n<li><strong>CloudKit</strong>：允许数据在设备间同步，同时保留在iCloud上。</li>\n</ol>\n<h3 id=\"Core-Data集成\"><a href=\"#Core-Data集成\" class=\"headerlink\" title=\"Core Data集成\"></a>Core Data集成</h3><p>我们将以Core Data为例，探讨如何在SwiftUI聊天应用中实现数据持久化。</p>\n<ul>\n<li><strong>设置Core Data堆栈</strong>：这包括了<code>NSPersistentContainer</code>的创建和配置，它将负责管理数据模型和协调数据存储。</li>\n<li><strong>定义数据模型</strong>：在<code>.xcdatamodeld</code>文件中定义实体（Entity），包括<code>User</code>和<code>Message</code>等，并设置好它们的属性和关系。</li>\n<li><strong>管理上下文（Context）</strong>：使用<code>NSManagedObjectContext</code>来管理对象的生命周期，实现数据的增删改查操作。</li>\n</ul>\n<h3 id=\"数据存储和检索\"><a href=\"#数据存储和检索\" class=\"headerlink\" title=\"数据存储和检索\"></a>数据存储和检索</h3><ul>\n<li><strong>存储消息</strong>：当用户发送消息时，创建<code>Message</code>的实例，并通过上下文将其插入到持久化存储中。</li>\n<li><strong>读取会话</strong>：加载聊天会话时，从Core Data中检索相关联的<code>Message</code>实例，根据时间戳排序后显示在界面上。</li>\n</ul>\n<h3 id=\"同步和更新\"><a href=\"#同步和更新\" class=\"headerlink\" title=\"同步和更新\"></a>同步和更新</h3><ul>\n<li><strong>监听数据变化</strong>：利用<code>NSFetchedResultsController</code>监听Core Data模型的变化，当新消息被插入时，自动刷新UI。</li>\n<li><strong>后台更新</strong>：通过<code>performBackgroundTask</code>方法在后台线程上进行数据更新操作，以避免阻塞UI线程。</li>\n</ul>\n<h3 id=\"错误处理\"><a href=\"#错误处理\" class=\"headerlink\" title=\"错误处理\"></a>错误处理</h3><ul>\n<li><strong>处理Core Data错误</strong>：在进行数据操作时，正确处理<code>NSManagedObjectContext</code>的保存（save）操作可能出现的错误。</li>\n<li><strong>数据迁移</strong>：为了应对未来数据模型的变化，实现Core Data的数据迁移策略。</li>\n</ul>\n<h3 id=\"测试与维护\"><a href=\"#测试与维护\" class=\"headerlink\" title=\"测试与维护\"></a>测试与维护</h3><ul>\n<li><strong>单元测试</strong>：为数据模型的创建、更新、删除编写单元测试，确保数据层逻辑的正确性。</li>\n<li><strong>数据清理</strong>：实现数据清理策略，比如删除过旧的消息，避免数据库不断增大。</li>\n</ul>\n<h3 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>数据持久化不仅能提高用户体验，同时对于保证数据的安全性和完整性也至关重要。通过使用Core Data，我们可以为聊天应用提供一个强大、灵活且易于维护的数据存储方案。在聊天应用中实现了数据持久化之后，无论用户何时回到应用，都能够立即接入到他们离开时的状态，保持流畅的聊天体验。在下一小节中，我们将进一步探讨如何将我们的聊天应用与云服务（如CloudKit）整合，实现跨设备的数据同步功能。</p>\n<p><strong>第5小节：网络请求和数据处理</strong></p>\n<p>当我们在构建一个现代的聊天应用时，网络请求成为了一个核心部分，它负责从远程服务器获取数据以及将数据推送到服务器。在本小节中，我们将介绍如何在聊天应用中处理网络请求和数据。</p>\n<h3 id=\"设计API接口\"><a href=\"#设计API接口\" class=\"headerlink\" title=\"设计API接口\"></a>设计API接口</h3><p>在开始编写代码之前，我们需要设计我们聊天应用所需的API接口。这些接口应包括：</p>\n<ul>\n<li>用户注册与登录</li>\n<li>消息发送与接收</li>\n<li>用户状态更新</li>\n<li>好友列表和消息历史获取</li>\n</ul>\n<p>API设计应该遵循RESTful原则或者使用更现代的GraphQL。</p>\n<h3 id=\"使用Swift的网络框架\"><a href=\"#使用Swift的网络框架\" class=\"headerlink\" title=\"使用Swift的网络框架\"></a>使用Swift的网络框架</h3><p>Swift提供了多种网络请求的方法，如<code>URLSession</code>，它是一个强大且灵活的网络通信框架。</p>\n<ul>\n<li><strong>创建网络请求</strong>：使用<code>URLRequest</code>构建请求，包括URL、HTTP方法（如GET、POST）、请求头和请求体。</li>\n<li><strong>发送请求和接收响应</strong>：利用<code>URLSession</code>发起请求，并通过<code>URLSessionDataTask</code>处理回调。</li>\n<li><strong>解析JSON数据</strong>：使用<code>JSONDecoder</code>将服务器返回的JSON数据解析成Swift的结构体。</li>\n</ul>\n<h3 id=\"异步和等待\"><a href=\"#异步和等待\" class=\"headerlink\" title=\"异步和等待\"></a>异步和等待</h3><p>SwiftUI 与 Swift 5.5 引入的 async&#x2F;await 一起，可以大大简化异步网络请求的处理。</p>\n<ul>\n<li><strong>异步函数</strong>：定义异步函数来发起网络请求，使用<code>await</code>关键字等待响应。</li>\n<li><strong>错误处理</strong>：使用<code>do-catch</code>语句捕获并处理网络请求或数据解析中可能发生的错误。</li>\n</ul>\n<h3 id=\"数据模型和解析\"><a href=\"#数据模型和解析\" class=\"headerlink\" title=\"数据模型和解析\"></a>数据模型和解析</h3><p>定义数据模型来对应API返回的数据格式。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">User</span>: <span class=\"hljs-title class_\">Codable</span> &#123;<br>    <span class=\"hljs-keyword\">var</span> id: <span class=\"hljs-type\">String</span><br>    <span class=\"hljs-keyword\">var</span> name: <span class=\"hljs-type\">String</span><br>    <span class=\"hljs-comment\">// ...</span><br>&#125;<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Message</span>: <span class=\"hljs-title class_\">Codable</span> &#123;<br>    <span class=\"hljs-keyword\">var</span> senderId: <span class=\"hljs-type\">String</span><br>    <span class=\"hljs-keyword\">var</span> receiverId: <span class=\"hljs-type\">String</span><br>    <span class=\"hljs-keyword\">var</span> content: <span class=\"hljs-type\">String</span><br>    <span class=\"hljs-keyword\">var</span> timestamp: <span class=\"hljs-type\">Date</span><br>    <span class=\"hljs-comment\">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>使用<code>Codable</code>协议自动将JSON数据和模型进行映射。</p>\n<h3 id=\"实时聊天功能\"><a href=\"#实时聊天功能\" class=\"headerlink\" title=\"实时聊天功能\"></a>实时聊天功能</h3><p>对于聊天应用来说，实时通讯是必不可少的。WebSocket 是一种在单个TCP连接上进行全双工通讯的协议。</p>\n<ul>\n<li><strong>使用WebSocket</strong>：通过<code>URLSessionWebSocketTask</code>来与服务器建立WebSocket连接。</li>\n<li><strong>接收消息</strong>：监听WebSocket的消息事件来实时接收新消息。</li>\n<li><strong>发送消息</strong>：发送消息通过WebSocket实时传递给其他用户。</li>\n</ul>\n<h3 id=\"网络状态监听\"><a href=\"#网络状态监听\" class=\"headerlink\" title=\"网络状态监听\"></a>网络状态监听</h3><p>考虑到网络状态可能时常变化，应用应能响应网络状态的改变。</p>\n<ul>\n<li><strong>使用Reachability</strong>：检测网络连接状态，根据网络状况提示用户或执行重连策略。</li>\n<li><strong>网络指示器</strong>：提供用户界面反馈，例如当应用正在进行网络请求时显示加载指示器。</li>\n</ul>\n<h3 id=\"安全性\"><a href=\"#安全性\" class=\"headerlink\" title=\"安全性\"></a>安全性</h3><p>安全性是聊天应用中一个重要的议题。</p>\n<ul>\n<li><strong>使用HTTPS</strong>：确保所有的网络请求都通过安全的HTTP连接进行。</li>\n<li><strong>身份验证</strong>：使用OAuth、JWT等机制来管理和验证用户身份。</li>\n<li><strong>数据加密</strong>：对敏感数据进行加密，确保即使在传输过程中数据被截获也无法被解读。</li>\n</ul>\n<h3 id=\"测试-1\"><a href=\"#测试-1\" class=\"headerlink\" title=\"测试\"></a>测试</h3><p>网络请求的测试至关重要。</p>\n<ul>\n<li><strong>单元测试</strong>：为网络请求编写单元测试，使用Mock对象来模拟网络响应。</li>\n<li><strong>集成测试</strong>：确保网络请求与应用其他部分的整合运行无误。</li>\n</ul>\n<h3 id=\"总结-2\"><a href=\"#总结-2\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>网络请求和数据处理是构建聊天应用的核心部分。利用Swift的现代编程特性和网络框架，我们可以有效地发送请求、接收响应、处理数据，并保证用户信息的安全性。在下一小节中，我们将讨论如何</p>\n<p>实现跨平台的消息推送通知，这是提升用户体验的另一个关键点。</p>\n<p><strong>第6小节：应用测试和发布准备</strong></p>\n<p>在开发完一个应用后，进行彻底的测试并做好发布前的各种准备工作是至关重要的。这一步骤确保了你的应用能够在广泛发布之前，满足质量标准，减少可能的错误或问题，为最终用户提供良好的体验。</p>\n<h3 id=\"应用测试\"><a href=\"#应用测试\" class=\"headerlink\" title=\"应用测试\"></a>应用测试</h3><p><strong>单元测试</strong>：为应用的每一个独立模块编写单元测试，验证逻辑的正确性。在聊天应用中，需要确保消息处理、用户认证、数据解析等核心功能的准确无误。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">import</span> XCTest<br><span class=\"hljs-keyword\">@testable</span> <span class=\"hljs-keyword\">import</span> ChatApp<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ChatAppTests</span>: <span class=\"hljs-title class_\">XCTestCase</span> &#123;<br>    <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">testMessageParsing</span>() &#123;<br>        <span class=\"hljs-keyword\">let</span> json <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;&#123; <span class=\"hljs-subst\">\\&quot;</span>senderId<span class=\"hljs-subst\">\\&quot;</span>: <span class=\"hljs-subst\">\\&quot;</span>1<span class=\"hljs-subst\">\\&quot;</span>, <span class=\"hljs-subst\">\\&quot;</span>receiverId<span class=\"hljs-subst\">\\&quot;</span>: <span class=\"hljs-subst\">\\&quot;</span>2<span class=\"hljs-subst\">\\&quot;</span>, <span class=\"hljs-subst\">\\&quot;</span>content<span class=\"hljs-subst\">\\&quot;</span>: <span class=\"hljs-subst\">\\&quot;</span>Hello<span class=\"hljs-subst\">\\&quot;</span> &#125;&quot;</span><br>        <span class=\"hljs-keyword\">let</span> data <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">Data</span>(json.utf8)<br>        <span class=\"hljs-keyword\">let</span> message <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">try?</span> <span class=\"hljs-type\">JSONDecoder</span>().decode(<span class=\"hljs-type\">Message</span>.<span class=\"hljs-keyword\">self</span>, from: data)<br>        <span class=\"hljs-type\">XCTAssertNotNil</span>(message)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>集成测试</strong>：检查应用中各个模块之间的交互是否正确。这包括用户界面流程的测试，确保视图控制器和视图模型间的交互按预期工作。</p>\n<p><strong>性能测试</strong>：确保应用的性能达标。例如，消息加载和发送的速度要快，内存消耗要低。</p>\n<p><strong>安全性测试</strong>：验证应用的安全措施，包括数据加密和身份验证流程。</p>\n<h3 id=\"用户界面测试\"><a href=\"#用户界面测试\" class=\"headerlink\" title=\"用户界面测试\"></a>用户界面测试</h3><p><strong>UI测试</strong>：自动化测试用户界面，确保用户的交互行为如点击、滚动、输入等能够产生预期的结果。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">import</span> XCTest<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ChatAppUITests</span>: <span class=\"hljs-title class_\">XCTestCase</span> &#123;<br>    <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">testChatFlow</span>() &#123;<br>        <span class=\"hljs-keyword\">let</span> app <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">XCUIApplication</span>()<br>        app.launch()<br>        <br>        <span class=\"hljs-keyword\">let</span> messageTextField <span class=\"hljs-operator\">=</span> app.textFields[<span class=\"hljs-string\">&quot;messageTextField&quot;</span>]<br>        messageTextField.tap()<br>        messageTextField.typeText(<span class=\"hljs-string\">&quot;Hello, World!&quot;</span>)<br>        <br>        <span class=\"hljs-keyword\">let</span> sendButton <span class=\"hljs-operator\">=</span> app.buttons[<span class=\"hljs-string\">&quot;sendButton&quot;</span>]<br>        sendButton.tap()<br>        <br>        <span class=\"hljs-comment\">// 验证消息是否显示在聊天界面上</span><br>        <span class=\"hljs-keyword\">let</span> chatBubble <span class=\"hljs-operator\">=</span> app.staticTexts[<span class=\"hljs-string\">&quot;Hello, World!&quot;</span>]<br>        <span class=\"hljs-type\">XCTAssertTrue</span>(chatBubble.exists)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>可访问性测试</strong>：确保应用支持VoiceOver等辅助功能，使得所有用户都能使用你的应用。</p>\n<h3 id=\"发布前的准备\"><a href=\"#发布前的准备\" class=\"headerlink\" title=\"发布前的准备\"></a>发布前的准备</h3><p><strong>Beta测试</strong>：通过TestFlight或类似的服务，发布应用的测试版本，邀请用户参与beta测试。</p>\n<p><strong>性能优化</strong>：回顾代码，查找并优化可能的性能瓶颈，如减少不必要的网络请求，优化图片加载。</p>\n<p><strong>本地化</strong>：确保应用支持多语言，包括界面文本和用户内容的适当本地化。</p>\n<p><strong>应用商店优化（ASO）</strong>：为了在应用商店中获得更好的曝光，优化应用的标题、描述、关键字和截图。</p>\n<p><strong>隐私政策和用户协议</strong>：准备并审核应用的隐私政策和用户协议文档，确保符合法律法规和应用商店的要求。</p>\n<p><strong>备份和恢复策略</strong>：确保应用支持数据备份和恢复功能，以便用户更换设备后可以恢复数据。</p>\n<h3 id=\"总结-3\"><a href=\"#总结-3\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>确保你的聊天应用在发布前通过了各种形式的测试，这包括了功能、性能、安全性和用户界面的测试。同时，完成发布前的各项准备工作，确保你的应用在上架后能够吸引用户并且避免法律风险。</p>\n","excerpt":"","more":"<p><strong>第1小节：应用结构规划</strong></p>\n<p>在开发一个新的应用时，规划应用的结构是成功的关键。一个良好设计的应用结构可以提高代码的可维护性和扩展性，并使团队合作变得更加高效。本小节我们将讨论如何为我们的聊天应用进行结构规划。</p>\n<h3 id=\"应用概览\"><a href=\"#应用概览\" class=\"headerlink\" title=\"应用概览\"></a>应用概览</h3><p>我们的聊天应用将具备以下基本功能：</p>\n<ul>\n<li>用户注册与登录</li>\n<li>好友列表管理</li>\n<li>实时消息传递</li>\n<li>个人与群组聊天</li>\n<li>消息通知</li>\n</ul>\n<h3 id=\"架构模式\"><a href=\"#架构模式\" class=\"headerlink\" title=\"架构模式\"></a>架构模式</h3><p>首先，我们需要选择一个适合于聊天应用的架构模式。考虑到SwiftUI的特性，我们选择MVVM（Model-View-ViewModel）作为主要架构，因为它能够很好地与SwiftUI的声明式UI和数据流工作模式配合。</p>\n<h3 id=\"分层设计\"><a href=\"#分层设计\" class=\"headerlink\" title=\"分层设计\"></a>分层设计</h3><p>我们的应用将分为以下几层：</p>\n<ol>\n<li><strong>视图层（View）</strong>：负责展示用户界面，捕获用户输入。</li>\n<li><strong>视图模型层（ViewModel）</strong>：处理视图逻辑，响应用户输入，与模型层通信。</li>\n<li><strong>模型层（Model）</strong>：定义数据结构和业务逻辑。</li>\n<li><strong>网络层</strong>：处理所有网络通信，例如发送和接收消息。</li>\n<li><strong>数据库层</strong>：负责数据持久化，存储历史消息和用户数据。</li>\n</ol>\n<h3 id=\"目录结构\"><a href=\"#目录结构\" class=\"headerlink\" title=\"目录结构\"></a>目录结构</h3><p>为了支持这种分层设计，我们的项目目录将如下组织：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">ChatApp/<br>├── Views/<br>│   ├── LoginView<span class=\"hljs-selector-class\">.swift</span><br>│   ├── ChatListView<span class=\"hljs-selector-class\">.swift</span><br>│   ├── ChatView<span class=\"hljs-selector-class\">.swift</span><br>│   └── ...<br>├── ViewModels/<br>│   ├── LoginViewModel<span class=\"hljs-selector-class\">.swift</span><br>│   ├── ChatListViewModel<span class=\"hljs-selector-class\">.swift</span><br>│   ├── ChatViewModel<span class=\"hljs-selector-class\">.swift</span><br>│   └── ...<br>├── Models/<br>│   ├── User<span class=\"hljs-selector-class\">.swift</span><br>│   ├── Message<span class=\"hljs-selector-class\">.swift</span><br>│   ├── Conversation<span class=\"hljs-selector-class\">.swift</span><br>│   └── ...<br>├── Services/<br>│   ├── AuthenticationService<span class=\"hljs-selector-class\">.swift</span><br>│   ├── ChatService<span class=\"hljs-selector-class\">.swift</span><br>│   ├── NotificationService<span class=\"hljs-selector-class\">.swift</span><br>│   └── ...<br>└── Utilities/<br>    ├── Constants<span class=\"hljs-selector-class\">.swift</span><br>    ├── Extensions<span class=\"hljs-selector-class\">.swift</span><br>    └── ...<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"功能模块划分\"><a href=\"#功能模块划分\" class=\"headerlink\" title=\"功能模块划分\"></a>功能模块划分</h3><p>接下来，我们将应用分解为几个核心模块：</p>\n<ul>\n<li><strong>用户认证模块</strong>：包括用户注册、登录和验证。</li>\n<li><strong>联系人模块</strong>：用户的好友列表，添加和删除联系人。</li>\n<li><strong>聊天模块</strong>：展示消息历史，发送新消息，消息推送。</li>\n<li><strong>设置模块</strong>：用户可以修改个人信息，设置应用选项等。</li>\n</ul>\n<h3 id=\"数据流规划\"><a href=\"#数据流规划\" class=\"headerlink\" title=\"数据流规划\"></a>数据流规划</h3><p>由于聊天应用需要实时的数据更新，我们将使用Combine框架来处理数据的发布和订阅，以确保用户界面能够响应数据的变化。</p>\n<ul>\n<li>使用<code>@Published</code>属性包装器来自动管理数据的发布。</li>\n<li><code>ViewModels</code>将订阅<code>Models</code>的变化，并更新视图状态。</li>\n<li>视图将绑定到视图模型的发布者，以获得数据变更的通知。</li>\n</ul>\n<h3 id=\"安全和隐私\"><a href=\"#安全和隐私\" class=\"headerlink\" title=\"安全和隐私\"></a>安全和隐私</h3><p>聊天应用需要格外注意安全和隐私：</p>\n<ul>\n<li>采用安全的认证机制，如OAuth 2.0。</li>\n<li>传输层加密，确保数据传输的安全。</li>\n<li>数据库加密存储敏感信息。</li>\n</ul>\n<h3 id=\"用户体验（UX）\"><a href=\"#用户体验（UX）\" class=\"headerlink\" title=\"用户体验（UX）\"></a>用户体验（UX）</h3><p>用户体验是聊天应用成功的关键，我们需要确保：</p>\n<ul>\n<li>界面简洁明了，易于导航。</li>\n<li>消息即时传送，无明显延迟。</li>\n<li>有声音和震动的通知反馈。</li>\n</ul>\n<p>通过仔细规</p>\n<p>划应用结构，我们为聊天应用的开发奠定了坚实的基础。后续小节中，我们将深入每个模块，开始具体的设计和编码工作。</p>\n<p><strong>第2小节：用户界面设计</strong></p>\n<p>用户界面（UI）设计是创建聊天应用的重要组成部分。一个直观、易用且美观的UI将极大地提升用户体验。在这一小节，我们将概述聊天应用的用户界面设计过程，包括布局、组件选择、颜色和动画的应用等方面。</p>\n<h3 id=\"UI设计原则\"><a href=\"#UI设计原则\" class=\"headerlink\" title=\"UI设计原则\"></a>UI设计原则</h3><p>在设计界面之前，我们首先确定几个核心设计原则：</p>\n<ul>\n<li><strong>一致性</strong>：整个应用的设计风格保持一致，包括按钮样式、字体、颜色等。</li>\n<li><strong>简洁性</strong>：避免不必要的元素，使用户可以集中于聊天功能。</li>\n<li><strong>直观性</strong>：确保用户能够直观地理解如何使用应用，无需额外学习。</li>\n<li><strong>响应式</strong>：界面应该能够适应不同设备和屏幕大小。</li>\n</ul>\n<h3 id=\"布局设计\"><a href=\"#布局设计\" class=\"headerlink\" title=\"布局设计\"></a>布局设计</h3><p>布局是UI设计的基础，我们将采用如下布局策略：</p>\n<ul>\n<li><strong>导航栏</strong>：位于屏幕顶部，包含用户的状态和导航控件。</li>\n<li><strong>消息列表</strong>：主屏幕显示消息列表，一览无余。</li>\n<li><strong>输入区</strong>：屏幕底部为消息输入区，包括文本输入框和发送按钮。</li>\n<li><strong>设置菜单</strong>：通过导航栏访问，包括个人资料编辑和应用设置。</li>\n</ul>\n<h3 id=\"组件设计\"><a href=\"#组件设计\" class=\"headerlink\" title=\"组件设计\"></a>组件设计</h3><p>我们将使用SwiftUI来构建以下组件：</p>\n<ul>\n<li><strong>CustomButton</strong>：自定义按钮，用于登录、发送消息等。</li>\n<li><strong>ChatBubble</strong>：聊天气泡，区分自己和他人的消息。</li>\n<li><strong>UserAvatar</strong>：用户头像，显示在消息旁边和好友列表中。</li>\n<li><strong>TextField</strong>：自定义文本输入框，支持多行文本输入和表情。</li>\n</ul>\n<h3 id=\"颜色和主题\"><a href=\"#颜色和主题\" class=\"headerlink\" title=\"颜色和主题\"></a>颜色和主题</h3><p>颜色方案将支持暗黑模式和光亮模式，我们将定义一组基础颜色：</p>\n<ul>\n<li><strong>主色调</strong>：定义应用的主题颜色，如蓝色或绿色。</li>\n<li><strong>辅助色</strong>：用于强调按钮或重要信息。</li>\n<li><strong>背景色</strong>：分为深色和浅色变体，适应不同模式。</li>\n<li><strong>文字色</strong>：确保在任何背景色上都清晰可见。</li>\n</ul>\n<h3 id=\"图标和图形\"><a href=\"#图标和图形\" class=\"headerlink\" title=\"图标和图形\"></a>图标和图形</h3><p>应用中的图标和图形将采用矢量图形，以确保在不同分辨率下都能清晰显示。我们将为每个主要功能选择直观的图标。</p>\n<h3 id=\"动画\"><a href=\"#动画\" class=\"headerlink\" title=\"动画\"></a>动画</h3><p>为了提升用户体验，我们将在以下方面应用动画：</p>\n<ul>\n<li><strong>页面切换</strong>：平滑过渡，增强用户操作的连贯感。</li>\n<li><strong>消息发送</strong>：消息框飞入聊天区域的动画。</li>\n<li><strong>加载指示器</strong>：在等待网络响应时提供动态反馈。</li>\n</ul>\n<h3 id=\"响应式设计\"><a href=\"#响应式设计\" class=\"headerlink\" title=\"响应式设计\"></a>响应式设计</h3><p>我们的UI设计将采用响应式方法，以适应不同的设备和屏幕尺寸：</p>\n<ul>\n<li><strong>自适应布局</strong>：使用<code>Stacks</code>、<code>Grids</code>和<code>Flexible Spaces</code>确保组件在不同屏幕上都能正确布局。</li>\n<li><strong>动态字体大小</strong>：支持系统字体大小设置，适应用户的阅读需求。</li>\n</ul>\n<h3 id=\"交互设计\"><a href=\"#交互设计\" class=\"headerlink\" title=\"交互设计\"></a>交互设计</h3><p>最后，交互设计也是我们关注的重点：</p>\n<ul>\n<li><strong>触控反馈</strong>：按钮和可交互元素将提供触觉反馈。</li>\n<li><strong>滑动删除</strong>：在消息列表中轻松</li>\n</ul>\n<p>滑动来删除消息或撤回。</p>\n<p>通过上述设计，我们将创建一个美观、直观且功能强大的聊天应用用户界面。接下来，我们将在小节中进一步详细说明每个组件和功能的实现过程。</p>\n<p><strong>第3小节：应用逻辑实现</strong></p>\n<p>构建一个聊天应用不仅仅是设计外观上的美观与实用，应用的核心在于其逻辑实现。在本小节，我们将探讨如何在SwiftUI框架下实现聊天应用的基本逻辑，包括消息的发送与接收、状态管理以及实时更新等功能。</p>\n<h3 id=\"基础逻辑构建\"><a href=\"#基础逻辑构建\" class=\"headerlink\" title=\"基础逻辑构建\"></a>基础逻辑构建</h3><p>首先，我们需要建立应用的数据模型和业务逻辑层，这通常涉及以下几个关键部分：</p>\n<ul>\n<li><strong>用户模型（User Model）</strong>：定义用户的基本信息，如用户名、头像、状态等。</li>\n<li><strong>消息模型（Message Model）</strong>：定义消息的数据结构，包含发送者、接收者、消息内容、发送时间等。</li>\n<li><strong>会话列表（Conversations List）</strong>：存储用户的聊天会话，每个会话包含多条消息。</li>\n<li><strong>数据管理器（Data Manager）</strong>：负责处理数据的存取、更新以及同步。</li>\n</ul>\n<h3 id=\"消息发送与接收\"><a href=\"#消息发送与接收\" class=\"headerlink\" title=\"消息发送与接收\"></a>消息发送与接收</h3><p>聊天的核心功能是消息的发送与接收，我们将通过以下步骤来实现：</p>\n<ol>\n<li><p><strong>输入与发送</strong>：</p>\n<ul>\n<li>使用<code>TextField</code>或<code>TextView</code>获取用户输入的消息文本。</li>\n<li>当用户点击发送按钮时，通过数据管理器将消息对象保存到会话列表中。</li>\n</ul>\n</li>\n<li><p><strong>消息展示</strong>：</p>\n<ul>\n<li>使用<code>ScrollView</code>和<code>LazyVStack</code>展示消息列表。</li>\n<li>对于每条消息，使用<code>ChatBubble</code>视图来展示，根据发送者是自己还是对方来调整样式和位置。</li>\n</ul>\n</li>\n<li><p><strong>实时更新</strong>：</p>\n<ul>\n<li>通过<code>Combine</code>框架监听数据变化，实现消息的实时更新。</li>\n<li>当有新消息时，更新UI以展示新消息。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"状态管理\"><a href=\"#状态管理\" class=\"headerlink\" title=\"状态管理\"></a>状态管理</h3><p>在SwiftUI中，状态管理是一个重要的概念，它确保UI的正确性和数据的同步。我们将使用<code>@State</code>、<code>@Binding</code>、<code>@ObservedObject</code>等属性包装器来管理状态：</p>\n<ul>\n<li><strong>用户状态</strong>：使用<code>@State</code>管理用户的在线状态，比如在线、离开、忙碌等。</li>\n<li><strong>消息状态</strong>：使用<code>@ObservedObject</code>监控消息的发送和接收状态。</li>\n</ul>\n<h3 id=\"实时更新和同步\"><a href=\"#实时更新和同步\" class=\"headerlink\" title=\"实时更新和同步\"></a>实时更新和同步</h3><p>为了实现聊天应用中的实时互动，我们将使用WebSocket或者Apple的<code>CloudKit</code>来进行网络通信，实现消息的即时推送：</p>\n<ul>\n<li><strong>WebSocket连接</strong>：建立WebSocket连接来监听服务器发来的新消息。</li>\n<li><strong>CloudKit同步</strong>：如果使用<code>CloudKit</code>，则设置相应的记录类型和订阅，以便于新消息到来时可以立即更新。</li>\n</ul>\n<h3 id=\"聊天功能拓展\"><a href=\"#聊天功能拓展\" class=\"headerlink\" title=\"聊天功能拓展\"></a>聊天功能拓展</h3><p>除了基础的文本消息，我们还可以实现以下几个功能：</p>\n<ul>\n<li><strong>图片和视频发送</strong>：允许用户发送媒体文件，并在聊天气泡中预览。</li>\n<li><strong>消息状态标记</strong>：如已读、已发送等状态的标记。</li>\n<li><strong>通知与提醒</strong>：通过本地通知或推送通知，告知用户新消息的到来。</li>\n</ul>\n<h3 id=\"异常处理\"><a href=\"#异常处理\" class=\"headerlink\" title=\"异常处理\"></a>异常处理</h3><p>在实现聊天逻辑时，还需要考虑异常情况的处理：</p>\n<ul>\n<li><strong>网络异常</strong>：当网络不稳定或断开时，给用户适当的反馈，并尝试重新连接。</li>\n<li><strong>数据持久化</strong>：确保消息在本地被保存，即使应用关闭后也能恢复历史消息。</li>\n</ul>\n<h3 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h3><p>开发过程中，持续进行单元测试和集成测试来确保各个功能的可靠性，包括：</p>\n<ul>\n<li><strong>逻辑测试</strong>：对数据管理器和业务逻辑层进行测试。</li>\n<li><strong>UI测试</strong>：确保消息正确显示，</li>\n</ul>\n<p>用户交互按预期工作。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>在本小节中，我们详细探讨了构建聊天应用的应用逻辑实现。从用户界面的交互到后端的数据处理，每一步都是为了提供流畅而可靠的用户体验。通过上述步骤的实现，我们的聊天应用将能够处理实时的消息交流，拥有健壮的逻辑处理能力以及优雅的错误处理机制。接下来的小节，我们将继续深入探讨应用的其他关键功能和实现细节。</p>\n<p><strong>第4小节：数据持久化</strong></p>\n<p>在聊天应用中，数据持久化是保证用户信息、消息历史以及应用状态在不同会话间能够得到保存和恢复的关键技术。不仅仅是为了增强用户体验，数据持久化同样是数据安全和隐私的重要组成部分。在本小节中，我们将讨论在SwiftUI应用中实现数据持久化的策略和技术。</p>\n<h3 id=\"持久化选项\"><a href=\"#持久化选项\" class=\"headerlink\" title=\"持久化选项\"></a>持久化选项</h3><p>SwiftUI应用中，我们可以选择多种方式来实现数据持久化：</p>\n<ol>\n<li><strong>UserDefaults</strong>：适合存储少量的用户偏好设置或简单的应用状态。</li>\n<li><strong>文件系统</strong>：适合存储大量数据，如日志文件或者用户生成的内容。</li>\n<li><strong>SQLite数据库</strong>：适合复杂的数据结构和大量数据的管理。</li>\n<li><strong>Core Data</strong>：苹果推荐的解决方案，集成了SQLite，并提供了丰富的数据管理功能。</li>\n<li><strong>CloudKit</strong>：允许数据在设备间同步，同时保留在iCloud上。</li>\n</ol>\n<h3 id=\"Core-Data集成\"><a href=\"#Core-Data集成\" class=\"headerlink\" title=\"Core Data集成\"></a>Core Data集成</h3><p>我们将以Core Data为例，探讨如何在SwiftUI聊天应用中实现数据持久化。</p>\n<ul>\n<li><strong>设置Core Data堆栈</strong>：这包括了<code>NSPersistentContainer</code>的创建和配置，它将负责管理数据模型和协调数据存储。</li>\n<li><strong>定义数据模型</strong>：在<code>.xcdatamodeld</code>文件中定义实体（Entity），包括<code>User</code>和<code>Message</code>等，并设置好它们的属性和关系。</li>\n<li><strong>管理上下文（Context）</strong>：使用<code>NSManagedObjectContext</code>来管理对象的生命周期，实现数据的增删改查操作。</li>\n</ul>\n<h3 id=\"数据存储和检索\"><a href=\"#数据存储和检索\" class=\"headerlink\" title=\"数据存储和检索\"></a>数据存储和检索</h3><ul>\n<li><strong>存储消息</strong>：当用户发送消息时，创建<code>Message</code>的实例，并通过上下文将其插入到持久化存储中。</li>\n<li><strong>读取会话</strong>：加载聊天会话时，从Core Data中检索相关联的<code>Message</code>实例，根据时间戳排序后显示在界面上。</li>\n</ul>\n<h3 id=\"同步和更新\"><a href=\"#同步和更新\" class=\"headerlink\" title=\"同步和更新\"></a>同步和更新</h3><ul>\n<li><strong>监听数据变化</strong>：利用<code>NSFetchedResultsController</code>监听Core Data模型的变化，当新消息被插入时，自动刷新UI。</li>\n<li><strong>后台更新</strong>：通过<code>performBackgroundTask</code>方法在后台线程上进行数据更新操作，以避免阻塞UI线程。</li>\n</ul>\n<h3 id=\"错误处理\"><a href=\"#错误处理\" class=\"headerlink\" title=\"错误处理\"></a>错误处理</h3><ul>\n<li><strong>处理Core Data错误</strong>：在进行数据操作时，正确处理<code>NSManagedObjectContext</code>的保存（save）操作可能出现的错误。</li>\n<li><strong>数据迁移</strong>：为了应对未来数据模型的变化，实现Core Data的数据迁移策略。</li>\n</ul>\n<h3 id=\"测试与维护\"><a href=\"#测试与维护\" class=\"headerlink\" title=\"测试与维护\"></a>测试与维护</h3><ul>\n<li><strong>单元测试</strong>：为数据模型的创建、更新、删除编写单元测试，确保数据层逻辑的正确性。</li>\n<li><strong>数据清理</strong>：实现数据清理策略，比如删除过旧的消息，避免数据库不断增大。</li>\n</ul>\n<h3 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>数据持久化不仅能提高用户体验，同时对于保证数据的安全性和完整性也至关重要。通过使用Core Data，我们可以为聊天应用提供一个强大、灵活且易于维护的数据存储方案。在聊天应用中实现了数据持久化之后，无论用户何时回到应用，都能够立即接入到他们离开时的状态，保持流畅的聊天体验。在下一小节中，我们将进一步探讨如何将我们的聊天应用与云服务（如CloudKit）整合，实现跨设备的数据同步功能。</p>\n<p><strong>第5小节：网络请求和数据处理</strong></p>\n<p>当我们在构建一个现代的聊天应用时，网络请求成为了一个核心部分，它负责从远程服务器获取数据以及将数据推送到服务器。在本小节中，我们将介绍如何在聊天应用中处理网络请求和数据。</p>\n<h3 id=\"设计API接口\"><a href=\"#设计API接口\" class=\"headerlink\" title=\"设计API接口\"></a>设计API接口</h3><p>在开始编写代码之前，我们需要设计我们聊天应用所需的API接口。这些接口应包括：</p>\n<ul>\n<li>用户注册与登录</li>\n<li>消息发送与接收</li>\n<li>用户状态更新</li>\n<li>好友列表和消息历史获取</li>\n</ul>\n<p>API设计应该遵循RESTful原则或者使用更现代的GraphQL。</p>\n<h3 id=\"使用Swift的网络框架\"><a href=\"#使用Swift的网络框架\" class=\"headerlink\" title=\"使用Swift的网络框架\"></a>使用Swift的网络框架</h3><p>Swift提供了多种网络请求的方法，如<code>URLSession</code>，它是一个强大且灵活的网络通信框架。</p>\n<ul>\n<li><strong>创建网络请求</strong>：使用<code>URLRequest</code>构建请求，包括URL、HTTP方法（如GET、POST）、请求头和请求体。</li>\n<li><strong>发送请求和接收响应</strong>：利用<code>URLSession</code>发起请求，并通过<code>URLSessionDataTask</code>处理回调。</li>\n<li><strong>解析JSON数据</strong>：使用<code>JSONDecoder</code>将服务器返回的JSON数据解析成Swift的结构体。</li>\n</ul>\n<h3 id=\"异步和等待\"><a href=\"#异步和等待\" class=\"headerlink\" title=\"异步和等待\"></a>异步和等待</h3><p>SwiftUI 与 Swift 5.5 引入的 async&#x2F;await 一起，可以大大简化异步网络请求的处理。</p>\n<ul>\n<li><strong>异步函数</strong>：定义异步函数来发起网络请求，使用<code>await</code>关键字等待响应。</li>\n<li><strong>错误处理</strong>：使用<code>do-catch</code>语句捕获并处理网络请求或数据解析中可能发生的错误。</li>\n</ul>\n<h3 id=\"数据模型和解析\"><a href=\"#数据模型和解析\" class=\"headerlink\" title=\"数据模型和解析\"></a>数据模型和解析</h3><p>定义数据模型来对应API返回的数据格式。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">User</span>: <span class=\"hljs-title class_\">Codable</span> &#123;<br>    <span class=\"hljs-keyword\">var</span> id: <span class=\"hljs-type\">String</span><br>    <span class=\"hljs-keyword\">var</span> name: <span class=\"hljs-type\">String</span><br>    <span class=\"hljs-comment\">// ...</span><br>&#125;<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Message</span>: <span class=\"hljs-title class_\">Codable</span> &#123;<br>    <span class=\"hljs-keyword\">var</span> senderId: <span class=\"hljs-type\">String</span><br>    <span class=\"hljs-keyword\">var</span> receiverId: <span class=\"hljs-type\">String</span><br>    <span class=\"hljs-keyword\">var</span> content: <span class=\"hljs-type\">String</span><br>    <span class=\"hljs-keyword\">var</span> timestamp: <span class=\"hljs-type\">Date</span><br>    <span class=\"hljs-comment\">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>使用<code>Codable</code>协议自动将JSON数据和模型进行映射。</p>\n<h3 id=\"实时聊天功能\"><a href=\"#实时聊天功能\" class=\"headerlink\" title=\"实时聊天功能\"></a>实时聊天功能</h3><p>对于聊天应用来说，实时通讯是必不可少的。WebSocket 是一种在单个TCP连接上进行全双工通讯的协议。</p>\n<ul>\n<li><strong>使用WebSocket</strong>：通过<code>URLSessionWebSocketTask</code>来与服务器建立WebSocket连接。</li>\n<li><strong>接收消息</strong>：监听WebSocket的消息事件来实时接收新消息。</li>\n<li><strong>发送消息</strong>：发送消息通过WebSocket实时传递给其他用户。</li>\n</ul>\n<h3 id=\"网络状态监听\"><a href=\"#网络状态监听\" class=\"headerlink\" title=\"网络状态监听\"></a>网络状态监听</h3><p>考虑到网络状态可能时常变化，应用应能响应网络状态的改变。</p>\n<ul>\n<li><strong>使用Reachability</strong>：检测网络连接状态，根据网络状况提示用户或执行重连策略。</li>\n<li><strong>网络指示器</strong>：提供用户界面反馈，例如当应用正在进行网络请求时显示加载指示器。</li>\n</ul>\n<h3 id=\"安全性\"><a href=\"#安全性\" class=\"headerlink\" title=\"安全性\"></a>安全性</h3><p>安全性是聊天应用中一个重要的议题。</p>\n<ul>\n<li><strong>使用HTTPS</strong>：确保所有的网络请求都通过安全的HTTP连接进行。</li>\n<li><strong>身份验证</strong>：使用OAuth、JWT等机制来管理和验证用户身份。</li>\n<li><strong>数据加密</strong>：对敏感数据进行加密，确保即使在传输过程中数据被截获也无法被解读。</li>\n</ul>\n<h3 id=\"测试-1\"><a href=\"#测试-1\" class=\"headerlink\" title=\"测试\"></a>测试</h3><p>网络请求的测试至关重要。</p>\n<ul>\n<li><strong>单元测试</strong>：为网络请求编写单元测试，使用Mock对象来模拟网络响应。</li>\n<li><strong>集成测试</strong>：确保网络请求与应用其他部分的整合运行无误。</li>\n</ul>\n<h3 id=\"总结-2\"><a href=\"#总结-2\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>网络请求和数据处理是构建聊天应用的核心部分。利用Swift的现代编程特性和网络框架，我们可以有效地发送请求、接收响应、处理数据，并保证用户信息的安全性。在下一小节中，我们将讨论如何</p>\n<p>实现跨平台的消息推送通知，这是提升用户体验的另一个关键点。</p>\n<p><strong>第6小节：应用测试和发布准备</strong></p>\n<p>在开发完一个应用后，进行彻底的测试并做好发布前的各种准备工作是至关重要的。这一步骤确保了你的应用能够在广泛发布之前，满足质量标准，减少可能的错误或问题，为最终用户提供良好的体验。</p>\n<h3 id=\"应用测试\"><a href=\"#应用测试\" class=\"headerlink\" title=\"应用测试\"></a>应用测试</h3><p><strong>单元测试</strong>：为应用的每一个独立模块编写单元测试，验证逻辑的正确性。在聊天应用中，需要确保消息处理、用户认证、数据解析等核心功能的准确无误。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">import</span> XCTest<br><span class=\"hljs-keyword\">@testable</span> <span class=\"hljs-keyword\">import</span> ChatApp<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ChatAppTests</span>: <span class=\"hljs-title class_\">XCTestCase</span> &#123;<br>    <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">testMessageParsing</span>() &#123;<br>        <span class=\"hljs-keyword\">let</span> json <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;&#123; <span class=\"hljs-subst\">\\&quot;</span>senderId<span class=\"hljs-subst\">\\&quot;</span>: <span class=\"hljs-subst\">\\&quot;</span>1<span class=\"hljs-subst\">\\&quot;</span>, <span class=\"hljs-subst\">\\&quot;</span>receiverId<span class=\"hljs-subst\">\\&quot;</span>: <span class=\"hljs-subst\">\\&quot;</span>2<span class=\"hljs-subst\">\\&quot;</span>, <span class=\"hljs-subst\">\\&quot;</span>content<span class=\"hljs-subst\">\\&quot;</span>: <span class=\"hljs-subst\">\\&quot;</span>Hello<span class=\"hljs-subst\">\\&quot;</span> &#125;&quot;</span><br>        <span class=\"hljs-keyword\">let</span> data <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">Data</span>(json.utf8)<br>        <span class=\"hljs-keyword\">let</span> message <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">try?</span> <span class=\"hljs-type\">JSONDecoder</span>().decode(<span class=\"hljs-type\">Message</span>.<span class=\"hljs-keyword\">self</span>, from: data)<br>        <span class=\"hljs-type\">XCTAssertNotNil</span>(message)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>集成测试</strong>：检查应用中各个模块之间的交互是否正确。这包括用户界面流程的测试，确保视图控制器和视图模型间的交互按预期工作。</p>\n<p><strong>性能测试</strong>：确保应用的性能达标。例如，消息加载和发送的速度要快，内存消耗要低。</p>\n<p><strong>安全性测试</strong>：验证应用的安全措施，包括数据加密和身份验证流程。</p>\n<h3 id=\"用户界面测试\"><a href=\"#用户界面测试\" class=\"headerlink\" title=\"用户界面测试\"></a>用户界面测试</h3><p><strong>UI测试</strong>：自动化测试用户界面，确保用户的交互行为如点击、滚动、输入等能够产生预期的结果。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">import</span> XCTest<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ChatAppUITests</span>: <span class=\"hljs-title class_\">XCTestCase</span> &#123;<br>    <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">testChatFlow</span>() &#123;<br>        <span class=\"hljs-keyword\">let</span> app <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">XCUIApplication</span>()<br>        app.launch()<br>        <br>        <span class=\"hljs-keyword\">let</span> messageTextField <span class=\"hljs-operator\">=</span> app.textFields[<span class=\"hljs-string\">&quot;messageTextField&quot;</span>]<br>        messageTextField.tap()<br>        messageTextField.typeText(<span class=\"hljs-string\">&quot;Hello, World!&quot;</span>)<br>        <br>        <span class=\"hljs-keyword\">let</span> sendButton <span class=\"hljs-operator\">=</span> app.buttons[<span class=\"hljs-string\">&quot;sendButton&quot;</span>]<br>        sendButton.tap()<br>        <br>        <span class=\"hljs-comment\">// 验证消息是否显示在聊天界面上</span><br>        <span class=\"hljs-keyword\">let</span> chatBubble <span class=\"hljs-operator\">=</span> app.staticTexts[<span class=\"hljs-string\">&quot;Hello, World!&quot;</span>]<br>        <span class=\"hljs-type\">XCTAssertTrue</span>(chatBubble.exists)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>可访问性测试</strong>：确保应用支持VoiceOver等辅助功能，使得所有用户都能使用你的应用。</p>\n<h3 id=\"发布前的准备\"><a href=\"#发布前的准备\" class=\"headerlink\" title=\"发布前的准备\"></a>发布前的准备</h3><p><strong>Beta测试</strong>：通过TestFlight或类似的服务，发布应用的测试版本，邀请用户参与beta测试。</p>\n<p><strong>性能优化</strong>：回顾代码，查找并优化可能的性能瓶颈，如减少不必要的网络请求，优化图片加载。</p>\n<p><strong>本地化</strong>：确保应用支持多语言，包括界面文本和用户内容的适当本地化。</p>\n<p><strong>应用商店优化（ASO）</strong>：为了在应用商店中获得更好的曝光，优化应用的标题、描述、关键字和截图。</p>\n<p><strong>隐私政策和用户协议</strong>：准备并审核应用的隐私政策和用户协议文档，确保符合法律法规和应用商店的要求。</p>\n<p><strong>备份和恢复策略</strong>：确保应用支持数据备份和恢复功能，以便用户更换设备后可以恢复数据。</p>\n<h3 id=\"总结-3\"><a href=\"#总结-3\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>确保你的聊天应用在发布前通过了各种形式的测试，这包括了功能、性能、安全性和用户界面的测试。同时，完成发布前的各项准备工作，确保你的应用在上架后能够吸引用户并且避免法律风险。</p>\n"},{"title":"SwiftUI核心技术第6章数据流与绑定","date":"2023-11-08T00:52:43.000Z","_content":"**第6章：数据流与绑定**\n\n**1. State和Binding**\n\n在SwiftUI中，数据流的管理是构建动态和响应式用户界面的核心。`State`和`Binding`是实现这种数据流动的基本工具，它们使得数据和视图能够保持同步。\n\n**State：拥有数据的真相**\n\n`@State` 是一个属性包装器，用于声明SwiftUI管理的状态。这个状态是私有的，仅在当前视图内部使用。当状态变化时，SwiftUI会自动重新绘制依赖于这个状态的视图部分。\n\n```swift\nstruct ContentView: View {\n    @State private var isToggled = false\n\n    var body: some View {\n        Toggle(\"开关\", isOn: $isToggled)\n    }\n}\n```\n\n在上面的例子中，`isToggled` 是一个布尔状态，与一个开关绑定。当用户切换开关时，`isToggled` 的值会改变，触发视图的更新。\n\n**Binding：连接状态和视图**\n\n`Binding` 提供了对某个状态的读写权限，但不拥有这个状态本身。通过`$`符号，我们可以从一个`@State`变量创建一个`Binding`。\n\n```swift\nstruct ToggleView: View {\n    @Binding var isOn: Bool\n\n    var body: some View {\n        Toggle(\"开关\", isOn: $isOn)\n    }\n}\n```\n\n在这个例子中，`ToggleView` 需要一个`Binding`来控制开关的状态，这个`Binding`可以从父视图的`@State`中派生而来。\n\n**使用State和Binding**\n\n在实际的应用中，`@State`适用于简单的局部状态管理，如界面的某个开关、文本输入框的内容等。当状态改变时，只有使用到该状态的视图会重新渲染，从而优化了性能。\n\n`@Binding`则用于将状态的控制权从一个视图传递到另一个视图。例如，在一个父视图中定义了`@State`，那么就可以将这个状态以`Binding`的形式传递给子视图，让子视图能够读取并修改这个状态。\n\n**State和视图的生命周期**\n\n理解`@State`与视图的生命周期是紧密相关的也很重要。当一个视图被SwiftUI重新绘制时，`@State`所持有的状态会被保留下来。这意味着状态的变更是持久的，即使视图的某些其他部分可能因为不同的原因而重新渲染。\n\n**总结**\n\n`State`和`Binding`是SwiftUI中数据流的基础。`@State`用于创建可变的状态，当状态变化时，视图会响应这些变化。而`Binding`则用于在视图之间共享状态，允许多个视图共同拥有和修改状态。通过恰当地使用这两个工具，我们可以创建出既简洁又高效的响应式用户界面。在接下来的章节中，我们将深入探讨如何在更复杂的应用架构中管理状态和数据流。\n\n\n**2. ObservedObject和EnvironmentObject**\n\n在构建复杂的SwiftUI应用时，我们经常需要处理跨多个视图共享的数据。在这种情况下，仅使用`@State`和`@Binding`可能不够用，因为它们主要用于单个视图或其直接子视图的状态管理。这时，`@ObservedObject`和`@EnvironmentObject`就成为了重要的工具。\n\n**ObservedObject：动态数据的监听者**\n\n`@ObservedObject`用于绑定外部的可观察对象（通常是遵循`ObservableObject`协议的类实例），当可观察对象发出变化通知时，视图会重新渲染以反映新的数据。\n\n这里有一个`ObservableObject`的示例：\n\n```swift\nclass UserData: ObservableObject {\n    @Published var username: String = \"用户\"\n}\n```\n\n`@Published`属性包装器用于标记会发生变化的数据。一旦`username`的值发生变更，就会自动通知所有的观察者。\n\n在视图中使用`@ObservedObject`：\n\n```swift\nstruct UserView: View {\n    @ObservedObject var userData: UserData\n\n    var body: some View {\n        Text(\"用户名: \\(userData.username)\")\n    }\n}\n```\n\n在`UserView`中，`userData`作为一个`@ObservedObject`提供了对`UserData`实例的引用。当`username`更新时，`UserView`也会更新其显示。\n\n**EnvironmentObject：跨层级的数据共享**\n\n`@EnvironmentObject`是一种特殊类型的数据流工具，它可以让数据在视图层级间传递而不需要显式地通过参数传递。它非常适合那些被多个视图访问的全局数据或设置。\n\n首先，你需要在某个父视图中将数据对象添加到环境中：\n\n```swift\n@main\nstruct MyApp: App {\n    var body: some Scene {\n        WindowGroup {\n            ContentView()\n                .environmentObject(UserData())\n        }\n    }\n}\n```\n\n然后，在子视图中，你可以直接通过`@EnvironmentObject`来访问这个数据对象：\n\n```swift\nstruct ProfileView: View {\n    @EnvironmentObject var userData: UserData\n\n    var body: some View {\n        Text(\"欢迎, \\(userData.username)!\")\n    }\n}\n```\n\n不需要显式地从父视图传递`UserData`到`ProfileView`，`ProfileView`可以直接从环境中获取这个对象。\n\n**总结**\n\n`@ObservedObject`和`@EnvironmentObject`为我们提供了强大的数据管理能力，使得数据在视图之间传递变得简单且高效。它们都依赖于`ObservableObject`协议来观察数据模型的变化并响应更新。`@ObservedObject`适用于需要直接引用的情况，而`@EnvironmentObject`更适合于全局或共享数据的情况，尤其是在视图层级较深时。\n\n在接下来的内容中，我们将探讨这些数据流工具如何与SwiftUI的声明式UI框架协同工作，以及如何利用它们来构建响应式和可维护的应用架构。\n\n\n**3. @Published和Combine**\n\n在SwiftUI中，数据的流动和管理是构建应用的核心。为了实现响应式的数据流，SwiftUI密切结合了Combine框架。Combine是一个响应式编程框架，它可以处理所有类型的异步事件。`@Published`是Combine框架中的一个关键特性，它用于创建可观察的对象属性，当这些属性的值发生变化时，它会自动通知系统。\n\n**使用@Published**\n\n使用`@Published`可以很容易地将一个类属性变成响应式的属性。这意味着，当属性的值改变时，所有订阅了这个属性的订阅者都会接收到通知，并且可以响应这些变化。\n\n下面是一个使用`@Published`的例子：\n\n```swift\nimport Combine\n\nclass ProfileViewModel: ObservableObject {\n    @Published var name: String = \"\"\n    @Published var age: Int = 0\n}\n```\n\n在这个例子中，`ProfileViewModel`是一个遵循`ObservableObject`协议的类，它有两个`@Published`属性：`name`和`age`。当这些属性中的任何一个的值改变时，所有的观察者都会得到通知。\n\n**整合Combine**\n\nCombine框架的强大之处在于它可以让你定义复杂的数据处理和变换流程。例如，你可以对输入进行校验、过滤、转换，然后将处理后的数据传递到UI或其他部分。\n\n这里是如何使用Combine订阅`@Published`属性变化的例子：\n\n```swift\nvar cancellables = Set<AnyCancellable>()\n\nlet profileVM = ProfileViewModel()\nprofileVM.$name\n    .sink { name in\n        print(\"Name is now \\(name)\")\n    }\n    .store(in: &cancellables)\n```\n\n在这段代码中，`$name`是对`name`属性的Publisher访问。`.sink`方法会接收一个闭包，这个闭包会在每次`name`属性更新时被调用。`.store(in:)`方法用于管理订阅生命周期，防止早期释放。\n\n**结合SwiftUI视图**\n\n在SwiftUI中，你通常不需要直接处理订阅，因为SwiftUI视图可以直接使用`@ObservedObject`或`@EnvironmentObject`来绑定到可观察的对象。\n\n```swift\nstruct ProfileView: View {\n    @ObservedObject var viewModel: ProfileViewModel\n\n    var body: some View {\n        TextField(\"Name\", text: $viewModel.name)\n        TextField(\"Age\", value: $viewModel.age, formatter: NumberFormatter())\n    }\n}\n```\n\n在`ProfileView`中，每当`viewModel`的`name`或`age`属性变化时，视图会自动更新。\n\n**小结**\n\n`@Published`与Combine框架结合使用，为SwiftUI应用带来了强大的响应式编程能力。这种模式不仅使状态管理变得简洁，还能够创建可维护和可扩展的数据流处理逻辑。随着你深入本书，你将会看到更多关于Combine在实际SwiftUI应用中的强大用例和模式。\n\n\n**4. 数据流的最佳实践**\n\n在构建SwiftUI应用时，高效和可维护的数据流管理是非常重要的。为了达到这个目标，我们需要遵循一些最佳实践来确保我们的应用结构清晰，数据流动合理。以下是在使用SwiftUI时应考虑的数据流最佳实践。\n\n**一、明确数据源的单一真相**\n\n在任何给定的时刻，应用的每个数据点都应该有一个清晰的，可信的来源。这意味着对于任何可变的数据，都应该有一个单一的可信源，而所有视图的状态应反映这个来源。使用`@State`的私有属性用于视图的内部状态，而模型对象中的`@Published`属性用于应用范围的状态。\n\n**二、使用单向数据流**\n\n在SwiftUI中，数据应该从父视图流向子视图（单向数据流）。父视图传递数据到子视图，子视图通过事件传递回父视图，而不是直接修改父视图的状态。这样可以避免复杂的数据依赖和潜在的循环更新问题。\n\n**三、合理使用@State，@Binding，@ObservedObject，和@EnvironmentObject**\n\n- **@State** 应当用于视图的局部状态管理，不应跨越多个视图。\n- **@Binding** 允许子视图与父视图的状态或模型中的数据进行通信。\n- **@ObservedObject** 用于当视图需要响应外部模型对象变化时。\n- **@EnvironmentObject** 适用于多个视图需要访问同一共享数据对象的情况。\n\n**四、谨慎管理生命周期**\n\n识别并管理数据对象的生命周期，尤其是当使用`@ObservedObject`或`@EnvironmentObject`时。避免不必要的重新创建对象，以减少内存使用和性能损耗。\n\n**五、精细控制数据变更**\n\n使用`objectWillChange`手动发送变更通知可以精细控制观察的对象何时更新UI。当需要优化性能或处理复杂的数据变更时这非常有用。\n\n**六、利用Combine进行复杂的数据操作**\n\nCombine框架提供了一套完整的工具，用于处理复杂的数据转换和异步操作。应充分利用这些工具来实现复杂的数据流和事件处理。\n\n**七、避免内存泄漏**\n\n当处理数据流和绑定时，确保正确管理订阅，使用`AnyCancellable`存储返回的订阅，并在不需要时取消订阅，以避免内存泄漏。\n\n**八、编写可测试的代码**\n\n将数据处理逻辑抽象到可单独测试的模型和服务中。避免将业务逻辑放入视图中，这样可以让代码更容易被测试和维护。\n\n**小结**\n\n遵循上述的数据流最佳实践将有助于您构建出高效、稳定且易于维护的SwiftUI应用。确保理解和正确应用每一种属性装饰器和Combine操作符是至关重要的。本书后续章节将会进一步深入这些概念，并结合实例演示如何在真实世界的应用中实践这些最佳实践。","source":"_posts/SwiftUI核心技术第6章数据流与绑定.md","raw":"---\ntitle: SwiftUI核心技术第6章数据流与绑定\ndate: 2023-11-08 08:52:43\ncategories:\n- SwiftUI\ntags:\n---\n**第6章：数据流与绑定**\n\n**1. State和Binding**\n\n在SwiftUI中，数据流的管理是构建动态和响应式用户界面的核心。`State`和`Binding`是实现这种数据流动的基本工具，它们使得数据和视图能够保持同步。\n\n**State：拥有数据的真相**\n\n`@State` 是一个属性包装器，用于声明SwiftUI管理的状态。这个状态是私有的，仅在当前视图内部使用。当状态变化时，SwiftUI会自动重新绘制依赖于这个状态的视图部分。\n\n```swift\nstruct ContentView: View {\n    @State private var isToggled = false\n\n    var body: some View {\n        Toggle(\"开关\", isOn: $isToggled)\n    }\n}\n```\n\n在上面的例子中，`isToggled` 是一个布尔状态，与一个开关绑定。当用户切换开关时，`isToggled` 的值会改变，触发视图的更新。\n\n**Binding：连接状态和视图**\n\n`Binding` 提供了对某个状态的读写权限，但不拥有这个状态本身。通过`$`符号，我们可以从一个`@State`变量创建一个`Binding`。\n\n```swift\nstruct ToggleView: View {\n    @Binding var isOn: Bool\n\n    var body: some View {\n        Toggle(\"开关\", isOn: $isOn)\n    }\n}\n```\n\n在这个例子中，`ToggleView` 需要一个`Binding`来控制开关的状态，这个`Binding`可以从父视图的`@State`中派生而来。\n\n**使用State和Binding**\n\n在实际的应用中，`@State`适用于简单的局部状态管理，如界面的某个开关、文本输入框的内容等。当状态改变时，只有使用到该状态的视图会重新渲染，从而优化了性能。\n\n`@Binding`则用于将状态的控制权从一个视图传递到另一个视图。例如，在一个父视图中定义了`@State`，那么就可以将这个状态以`Binding`的形式传递给子视图，让子视图能够读取并修改这个状态。\n\n**State和视图的生命周期**\n\n理解`@State`与视图的生命周期是紧密相关的也很重要。当一个视图被SwiftUI重新绘制时，`@State`所持有的状态会被保留下来。这意味着状态的变更是持久的，即使视图的某些其他部分可能因为不同的原因而重新渲染。\n\n**总结**\n\n`State`和`Binding`是SwiftUI中数据流的基础。`@State`用于创建可变的状态，当状态变化时，视图会响应这些变化。而`Binding`则用于在视图之间共享状态，允许多个视图共同拥有和修改状态。通过恰当地使用这两个工具，我们可以创建出既简洁又高效的响应式用户界面。在接下来的章节中，我们将深入探讨如何在更复杂的应用架构中管理状态和数据流。\n\n\n**2. ObservedObject和EnvironmentObject**\n\n在构建复杂的SwiftUI应用时，我们经常需要处理跨多个视图共享的数据。在这种情况下，仅使用`@State`和`@Binding`可能不够用，因为它们主要用于单个视图或其直接子视图的状态管理。这时，`@ObservedObject`和`@EnvironmentObject`就成为了重要的工具。\n\n**ObservedObject：动态数据的监听者**\n\n`@ObservedObject`用于绑定外部的可观察对象（通常是遵循`ObservableObject`协议的类实例），当可观察对象发出变化通知时，视图会重新渲染以反映新的数据。\n\n这里有一个`ObservableObject`的示例：\n\n```swift\nclass UserData: ObservableObject {\n    @Published var username: String = \"用户\"\n}\n```\n\n`@Published`属性包装器用于标记会发生变化的数据。一旦`username`的值发生变更，就会自动通知所有的观察者。\n\n在视图中使用`@ObservedObject`：\n\n```swift\nstruct UserView: View {\n    @ObservedObject var userData: UserData\n\n    var body: some View {\n        Text(\"用户名: \\(userData.username)\")\n    }\n}\n```\n\n在`UserView`中，`userData`作为一个`@ObservedObject`提供了对`UserData`实例的引用。当`username`更新时，`UserView`也会更新其显示。\n\n**EnvironmentObject：跨层级的数据共享**\n\n`@EnvironmentObject`是一种特殊类型的数据流工具，它可以让数据在视图层级间传递而不需要显式地通过参数传递。它非常适合那些被多个视图访问的全局数据或设置。\n\n首先，你需要在某个父视图中将数据对象添加到环境中：\n\n```swift\n@main\nstruct MyApp: App {\n    var body: some Scene {\n        WindowGroup {\n            ContentView()\n                .environmentObject(UserData())\n        }\n    }\n}\n```\n\n然后，在子视图中，你可以直接通过`@EnvironmentObject`来访问这个数据对象：\n\n```swift\nstruct ProfileView: View {\n    @EnvironmentObject var userData: UserData\n\n    var body: some View {\n        Text(\"欢迎, \\(userData.username)!\")\n    }\n}\n```\n\n不需要显式地从父视图传递`UserData`到`ProfileView`，`ProfileView`可以直接从环境中获取这个对象。\n\n**总结**\n\n`@ObservedObject`和`@EnvironmentObject`为我们提供了强大的数据管理能力，使得数据在视图之间传递变得简单且高效。它们都依赖于`ObservableObject`协议来观察数据模型的变化并响应更新。`@ObservedObject`适用于需要直接引用的情况，而`@EnvironmentObject`更适合于全局或共享数据的情况，尤其是在视图层级较深时。\n\n在接下来的内容中，我们将探讨这些数据流工具如何与SwiftUI的声明式UI框架协同工作，以及如何利用它们来构建响应式和可维护的应用架构。\n\n\n**3. @Published和Combine**\n\n在SwiftUI中，数据的流动和管理是构建应用的核心。为了实现响应式的数据流，SwiftUI密切结合了Combine框架。Combine是一个响应式编程框架，它可以处理所有类型的异步事件。`@Published`是Combine框架中的一个关键特性，它用于创建可观察的对象属性，当这些属性的值发生变化时，它会自动通知系统。\n\n**使用@Published**\n\n使用`@Published`可以很容易地将一个类属性变成响应式的属性。这意味着，当属性的值改变时，所有订阅了这个属性的订阅者都会接收到通知，并且可以响应这些变化。\n\n下面是一个使用`@Published`的例子：\n\n```swift\nimport Combine\n\nclass ProfileViewModel: ObservableObject {\n    @Published var name: String = \"\"\n    @Published var age: Int = 0\n}\n```\n\n在这个例子中，`ProfileViewModel`是一个遵循`ObservableObject`协议的类，它有两个`@Published`属性：`name`和`age`。当这些属性中的任何一个的值改变时，所有的观察者都会得到通知。\n\n**整合Combine**\n\nCombine框架的强大之处在于它可以让你定义复杂的数据处理和变换流程。例如，你可以对输入进行校验、过滤、转换，然后将处理后的数据传递到UI或其他部分。\n\n这里是如何使用Combine订阅`@Published`属性变化的例子：\n\n```swift\nvar cancellables = Set<AnyCancellable>()\n\nlet profileVM = ProfileViewModel()\nprofileVM.$name\n    .sink { name in\n        print(\"Name is now \\(name)\")\n    }\n    .store(in: &cancellables)\n```\n\n在这段代码中，`$name`是对`name`属性的Publisher访问。`.sink`方法会接收一个闭包，这个闭包会在每次`name`属性更新时被调用。`.store(in:)`方法用于管理订阅生命周期，防止早期释放。\n\n**结合SwiftUI视图**\n\n在SwiftUI中，你通常不需要直接处理订阅，因为SwiftUI视图可以直接使用`@ObservedObject`或`@EnvironmentObject`来绑定到可观察的对象。\n\n```swift\nstruct ProfileView: View {\n    @ObservedObject var viewModel: ProfileViewModel\n\n    var body: some View {\n        TextField(\"Name\", text: $viewModel.name)\n        TextField(\"Age\", value: $viewModel.age, formatter: NumberFormatter())\n    }\n}\n```\n\n在`ProfileView`中，每当`viewModel`的`name`或`age`属性变化时，视图会自动更新。\n\n**小结**\n\n`@Published`与Combine框架结合使用，为SwiftUI应用带来了强大的响应式编程能力。这种模式不仅使状态管理变得简洁，还能够创建可维护和可扩展的数据流处理逻辑。随着你深入本书，你将会看到更多关于Combine在实际SwiftUI应用中的强大用例和模式。\n\n\n**4. 数据流的最佳实践**\n\n在构建SwiftUI应用时，高效和可维护的数据流管理是非常重要的。为了达到这个目标，我们需要遵循一些最佳实践来确保我们的应用结构清晰，数据流动合理。以下是在使用SwiftUI时应考虑的数据流最佳实践。\n\n**一、明确数据源的单一真相**\n\n在任何给定的时刻，应用的每个数据点都应该有一个清晰的，可信的来源。这意味着对于任何可变的数据，都应该有一个单一的可信源，而所有视图的状态应反映这个来源。使用`@State`的私有属性用于视图的内部状态，而模型对象中的`@Published`属性用于应用范围的状态。\n\n**二、使用单向数据流**\n\n在SwiftUI中，数据应该从父视图流向子视图（单向数据流）。父视图传递数据到子视图，子视图通过事件传递回父视图，而不是直接修改父视图的状态。这样可以避免复杂的数据依赖和潜在的循环更新问题。\n\n**三、合理使用@State，@Binding，@ObservedObject，和@EnvironmentObject**\n\n- **@State** 应当用于视图的局部状态管理，不应跨越多个视图。\n- **@Binding** 允许子视图与父视图的状态或模型中的数据进行通信。\n- **@ObservedObject** 用于当视图需要响应外部模型对象变化时。\n- **@EnvironmentObject** 适用于多个视图需要访问同一共享数据对象的情况。\n\n**四、谨慎管理生命周期**\n\n识别并管理数据对象的生命周期，尤其是当使用`@ObservedObject`或`@EnvironmentObject`时。避免不必要的重新创建对象，以减少内存使用和性能损耗。\n\n**五、精细控制数据变更**\n\n使用`objectWillChange`手动发送变更通知可以精细控制观察的对象何时更新UI。当需要优化性能或处理复杂的数据变更时这非常有用。\n\n**六、利用Combine进行复杂的数据操作**\n\nCombine框架提供了一套完整的工具，用于处理复杂的数据转换和异步操作。应充分利用这些工具来实现复杂的数据流和事件处理。\n\n**七、避免内存泄漏**\n\n当处理数据流和绑定时，确保正确管理订阅，使用`AnyCancellable`存储返回的订阅，并在不需要时取消订阅，以避免内存泄漏。\n\n**八、编写可测试的代码**\n\n将数据处理逻辑抽象到可单独测试的模型和服务中。避免将业务逻辑放入视图中，这样可以让代码更容易被测试和维护。\n\n**小结**\n\n遵循上述的数据流最佳实践将有助于您构建出高效、稳定且易于维护的SwiftUI应用。确保理解和正确应用每一种属性装饰器和Combine操作符是至关重要的。本书后续章节将会进一步深入这些概念，并结合实例演示如何在真实世界的应用中实践这些最佳实践。","slug":"SwiftUI核心技术第6章数据流与绑定","published":1,"updated":"2024-03-17T06:11:34.626Z","comments":1,"layout":"post","photos":[],"_id":"clu6up53i002ez6747lj15aya","content":"<p><strong>第6章：数据流与绑定</strong></p>\n<p><strong>1. State和Binding</strong></p>\n<p>在SwiftUI中，数据流的管理是构建动态和响应式用户界面的核心。<code>State</code>和<code>Binding</code>是实现这种数据流动的基本工具，它们使得数据和视图能够保持同步。</p>\n<p><strong>State：拥有数据的真相</strong></p>\n<p><code>@State</code> 是一个属性包装器，用于声明SwiftUI管理的状态。这个状态是私有的，仅在当前视图内部使用。当状态变化时，SwiftUI会自动重新绘制依赖于这个状态的视图部分。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ContentView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> isToggled <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">false</span><br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">Toggle</span>(<span class=\"hljs-string\">&quot;开关&quot;</span>, isOn: <span class=\"hljs-variable\">$isToggled</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在上面的例子中，<code>isToggled</code> 是一个布尔状态，与一个开关绑定。当用户切换开关时，<code>isToggled</code> 的值会改变，触发视图的更新。</p>\n<p><strong>Binding：连接状态和视图</strong></p>\n<p><code>Binding</code> 提供了对某个状态的读写权限，但不拥有这个状态本身。通过<code>$</code>符号，我们可以从一个<code>@State</code>变量创建一个<code>Binding</code>。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ToggleView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@Binding</span> <span class=\"hljs-keyword\">var</span> isOn: <span class=\"hljs-type\">Bool</span><br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">Toggle</span>(<span class=\"hljs-string\">&quot;开关&quot;</span>, isOn: <span class=\"hljs-variable\">$isOn</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在这个例子中，<code>ToggleView</code> 需要一个<code>Binding</code>来控制开关的状态，这个<code>Binding</code>可以从父视图的<code>@State</code>中派生而来。</p>\n<p><strong>使用State和Binding</strong></p>\n<p>在实际的应用中，<code>@State</code>适用于简单的局部状态管理，如界面的某个开关、文本输入框的内容等。当状态改变时，只有使用到该状态的视图会重新渲染，从而优化了性能。</p>\n<p><code>@Binding</code>则用于将状态的控制权从一个视图传递到另一个视图。例如，在一个父视图中定义了<code>@State</code>，那么就可以将这个状态以<code>Binding</code>的形式传递给子视图，让子视图能够读取并修改这个状态。</p>\n<p><strong>State和视图的生命周期</strong></p>\n<p>理解<code>@State</code>与视图的生命周期是紧密相关的也很重要。当一个视图被SwiftUI重新绘制时，<code>@State</code>所持有的状态会被保留下来。这意味着状态的变更是持久的，即使视图的某些其他部分可能因为不同的原因而重新渲染。</p>\n<p><strong>总结</strong></p>\n<p><code>State</code>和<code>Binding</code>是SwiftUI中数据流的基础。<code>@State</code>用于创建可变的状态，当状态变化时，视图会响应这些变化。而<code>Binding</code>则用于在视图之间共享状态，允许多个视图共同拥有和修改状态。通过恰当地使用这两个工具，我们可以创建出既简洁又高效的响应式用户界面。在接下来的章节中，我们将深入探讨如何在更复杂的应用架构中管理状态和数据流。</p>\n<p><strong>2. ObservedObject和EnvironmentObject</strong></p>\n<p>在构建复杂的SwiftUI应用时，我们经常需要处理跨多个视图共享的数据。在这种情况下，仅使用<code>@State</code>和<code>@Binding</code>可能不够用，因为它们主要用于单个视图或其直接子视图的状态管理。这时，<code>@ObservedObject</code>和<code>@EnvironmentObject</code>就成为了重要的工具。</p>\n<p><strong>ObservedObject：动态数据的监听者</strong></p>\n<p><code>@ObservedObject</code>用于绑定外部的可观察对象（通常是遵循<code>ObservableObject</code>协议的类实例），当可观察对象发出变化通知时，视图会重新渲染以反映新的数据。</p>\n<p>这里有一个<code>ObservableObject</code>的示例：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">UserData</span>: <span class=\"hljs-title class_\">ObservableObject</span> &#123;<br>    <span class=\"hljs-meta\">@Published</span> <span class=\"hljs-keyword\">var</span> username: <span class=\"hljs-type\">String</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;用户&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><code>@Published</code>属性包装器用于标记会发生变化的数据。一旦<code>username</code>的值发生变更，就会自动通知所有的观察者。</p>\n<p>在视图中使用<code>@ObservedObject</code>：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">UserView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@ObservedObject</span> <span class=\"hljs-keyword\">var</span> userData: <span class=\"hljs-type\">UserData</span><br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;用户名: <span class=\"hljs-subst\">\\(userData.username)</span>&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在<code>UserView</code>中，<code>userData</code>作为一个<code>@ObservedObject</code>提供了对<code>UserData</code>实例的引用。当<code>username</code>更新时，<code>UserView</code>也会更新其显示。</p>\n<p><strong>EnvironmentObject：跨层级的数据共享</strong></p>\n<p><code>@EnvironmentObject</code>是一种特殊类型的数据流工具，它可以让数据在视图层级间传递而不需要显式地通过参数传递。它非常适合那些被多个视图访问的全局数据或设置。</p>\n<p>首先，你需要在某个父视图中将数据对象添加到环境中：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">@main</span><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">MyApp</span>: <span class=\"hljs-title class_\">App</span> &#123;<br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">Scene</span> &#123;<br>        <span class=\"hljs-type\">WindowGroup</span> &#123;<br>            <span class=\"hljs-type\">ContentView</span>()<br>                .environmentObject(<span class=\"hljs-type\">UserData</span>())<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>然后，在子视图中，你可以直接通过<code>@EnvironmentObject</code>来访问这个数据对象：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ProfileView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@EnvironmentObject</span> <span class=\"hljs-keyword\">var</span> userData: <span class=\"hljs-type\">UserData</span><br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;欢迎, <span class=\"hljs-subst\">\\(userData.username)</span>!&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>不需要显式地从父视图传递<code>UserData</code>到<code>ProfileView</code>，<code>ProfileView</code>可以直接从环境中获取这个对象。</p>\n<p><strong>总结</strong></p>\n<p><code>@ObservedObject</code>和<code>@EnvironmentObject</code>为我们提供了强大的数据管理能力，使得数据在视图之间传递变得简单且高效。它们都依赖于<code>ObservableObject</code>协议来观察数据模型的变化并响应更新。<code>@ObservedObject</code>适用于需要直接引用的情况，而<code>@EnvironmentObject</code>更适合于全局或共享数据的情况，尤其是在视图层级较深时。</p>\n<p>在接下来的内容中，我们将探讨这些数据流工具如何与SwiftUI的声明式UI框架协同工作，以及如何利用它们来构建响应式和可维护的应用架构。</p>\n<p><strong>3. @Published和Combine</strong></p>\n<p>在SwiftUI中，数据的流动和管理是构建应用的核心。为了实现响应式的数据流，SwiftUI密切结合了Combine框架。Combine是一个响应式编程框架，它可以处理所有类型的异步事件。<code>@Published</code>是Combine框架中的一个关键特性，它用于创建可观察的对象属性，当这些属性的值发生变化时，它会自动通知系统。</p>\n<p><strong>使用@Published</strong></p>\n<p>使用<code>@Published</code>可以很容易地将一个类属性变成响应式的属性。这意味着，当属性的值改变时，所有订阅了这个属性的订阅者都会接收到通知，并且可以响应这些变化。</p>\n<p>下面是一个使用<code>@Published</code>的例子：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">import</span> Combine<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ProfileViewModel</span>: <span class=\"hljs-title class_\">ObservableObject</span> &#123;<br>    <span class=\"hljs-meta\">@Published</span> <span class=\"hljs-keyword\">var</span> name: <span class=\"hljs-type\">String</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;&quot;</span><br>    <span class=\"hljs-meta\">@Published</span> <span class=\"hljs-keyword\">var</span> age: <span class=\"hljs-type\">Int</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在这个例子中，<code>ProfileViewModel</code>是一个遵循<code>ObservableObject</code>协议的类，它有两个<code>@Published</code>属性：<code>name</code>和<code>age</code>。当这些属性中的任何一个的值改变时，所有的观察者都会得到通知。</p>\n<p><strong>整合Combine</strong></p>\n<p>Combine框架的强大之处在于它可以让你定义复杂的数据处理和变换流程。例如，你可以对输入进行校验、过滤、转换，然后将处理后的数据传递到UI或其他部分。</p>\n<p>这里是如何使用Combine订阅<code>@Published</code>属性变化的例子：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">var</span> cancellables <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">Set</span>&lt;<span class=\"hljs-type\">AnyCancellable</span>&gt;()<br><br><span class=\"hljs-keyword\">let</span> profileVM <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">ProfileViewModel</span>()<br>profileVM.<span class=\"hljs-variable\">$name</span><br>    .sink &#123; name <span class=\"hljs-keyword\">in</span><br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;Name is now <span class=\"hljs-subst\">\\(name)</span>&quot;</span>)<br>    &#125;<br>    .store(in: <span class=\"hljs-operator\">&amp;</span>cancellables)<br></code></pre></td></tr></table></figure>\n\n<p>在这段代码中，<code>$name</code>是对<code>name</code>属性的Publisher访问。<code>.sink</code>方法会接收一个闭包，这个闭包会在每次<code>name</code>属性更新时被调用。<code>.store(in:)</code>方法用于管理订阅生命周期，防止早期释放。</p>\n<p><strong>结合SwiftUI视图</strong></p>\n<p>在SwiftUI中，你通常不需要直接处理订阅，因为SwiftUI视图可以直接使用<code>@ObservedObject</code>或<code>@EnvironmentObject</code>来绑定到可观察的对象。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ProfileView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@ObservedObject</span> <span class=\"hljs-keyword\">var</span> viewModel: <span class=\"hljs-type\">ProfileViewModel</span><br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">TextField</span>(<span class=\"hljs-string\">&quot;Name&quot;</span>, text: <span class=\"hljs-variable\">$viewModel</span>.name)<br>        <span class=\"hljs-type\">TextField</span>(<span class=\"hljs-string\">&quot;Age&quot;</span>, value: <span class=\"hljs-variable\">$viewModel</span>.age, formatter: <span class=\"hljs-type\">NumberFormatter</span>())<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在<code>ProfileView</code>中，每当<code>viewModel</code>的<code>name</code>或<code>age</code>属性变化时，视图会自动更新。</p>\n<p><strong>小结</strong></p>\n<p><code>@Published</code>与Combine框架结合使用，为SwiftUI应用带来了强大的响应式编程能力。这种模式不仅使状态管理变得简洁，还能够创建可维护和可扩展的数据流处理逻辑。随着你深入本书，你将会看到更多关于Combine在实际SwiftUI应用中的强大用例和模式。</p>\n<p><strong>4. 数据流的最佳实践</strong></p>\n<p>在构建SwiftUI应用时，高效和可维护的数据流管理是非常重要的。为了达到这个目标，我们需要遵循一些最佳实践来确保我们的应用结构清晰，数据流动合理。以下是在使用SwiftUI时应考虑的数据流最佳实践。</p>\n<p><strong>一、明确数据源的单一真相</strong></p>\n<p>在任何给定的时刻，应用的每个数据点都应该有一个清晰的，可信的来源。这意味着对于任何可变的数据，都应该有一个单一的可信源，而所有视图的状态应反映这个来源。使用<code>@State</code>的私有属性用于视图的内部状态，而模型对象中的<code>@Published</code>属性用于应用范围的状态。</p>\n<p><strong>二、使用单向数据流</strong></p>\n<p>在SwiftUI中，数据应该从父视图流向子视图（单向数据流）。父视图传递数据到子视图，子视图通过事件传递回父视图，而不是直接修改父视图的状态。这样可以避免复杂的数据依赖和潜在的循环更新问题。</p>\n<p><strong>三、合理使用@State，@Binding，@ObservedObject，和@EnvironmentObject</strong></p>\n<ul>\n<li><strong>@State</strong> 应当用于视图的局部状态管理，不应跨越多个视图。</li>\n<li><strong>@Binding</strong> 允许子视图与父视图的状态或模型中的数据进行通信。</li>\n<li><strong>@ObservedObject</strong> 用于当视图需要响应外部模型对象变化时。</li>\n<li><strong>@EnvironmentObject</strong> 适用于多个视图需要访问同一共享数据对象的情况。</li>\n</ul>\n<p><strong>四、谨慎管理生命周期</strong></p>\n<p>识别并管理数据对象的生命周期，尤其是当使用<code>@ObservedObject</code>或<code>@EnvironmentObject</code>时。避免不必要的重新创建对象，以减少内存使用和性能损耗。</p>\n<p><strong>五、精细控制数据变更</strong></p>\n<p>使用<code>objectWillChange</code>手动发送变更通知可以精细控制观察的对象何时更新UI。当需要优化性能或处理复杂的数据变更时这非常有用。</p>\n<p><strong>六、利用Combine进行复杂的数据操作</strong></p>\n<p>Combine框架提供了一套完整的工具，用于处理复杂的数据转换和异步操作。应充分利用这些工具来实现复杂的数据流和事件处理。</p>\n<p><strong>七、避免内存泄漏</strong></p>\n<p>当处理数据流和绑定时，确保正确管理订阅，使用<code>AnyCancellable</code>存储返回的订阅，并在不需要时取消订阅，以避免内存泄漏。</p>\n<p><strong>八、编写可测试的代码</strong></p>\n<p>将数据处理逻辑抽象到可单独测试的模型和服务中。避免将业务逻辑放入视图中，这样可以让代码更容易被测试和维护。</p>\n<p><strong>小结</strong></p>\n<p>遵循上述的数据流最佳实践将有助于您构建出高效、稳定且易于维护的SwiftUI应用。确保理解和正确应用每一种属性装饰器和Combine操作符是至关重要的。本书后续章节将会进一步深入这些概念，并结合实例演示如何在真实世界的应用中实践这些最佳实践。</p>\n","excerpt":"","more":"<p><strong>第6章：数据流与绑定</strong></p>\n<p><strong>1. State和Binding</strong></p>\n<p>在SwiftUI中，数据流的管理是构建动态和响应式用户界面的核心。<code>State</code>和<code>Binding</code>是实现这种数据流动的基本工具，它们使得数据和视图能够保持同步。</p>\n<p><strong>State：拥有数据的真相</strong></p>\n<p><code>@State</code> 是一个属性包装器，用于声明SwiftUI管理的状态。这个状态是私有的，仅在当前视图内部使用。当状态变化时，SwiftUI会自动重新绘制依赖于这个状态的视图部分。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ContentView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> isToggled <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">false</span><br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">Toggle</span>(<span class=\"hljs-string\">&quot;开关&quot;</span>, isOn: <span class=\"hljs-variable\">$isToggled</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在上面的例子中，<code>isToggled</code> 是一个布尔状态，与一个开关绑定。当用户切换开关时，<code>isToggled</code> 的值会改变，触发视图的更新。</p>\n<p><strong>Binding：连接状态和视图</strong></p>\n<p><code>Binding</code> 提供了对某个状态的读写权限，但不拥有这个状态本身。通过<code>$</code>符号，我们可以从一个<code>@State</code>变量创建一个<code>Binding</code>。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ToggleView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@Binding</span> <span class=\"hljs-keyword\">var</span> isOn: <span class=\"hljs-type\">Bool</span><br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">Toggle</span>(<span class=\"hljs-string\">&quot;开关&quot;</span>, isOn: <span class=\"hljs-variable\">$isOn</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在这个例子中，<code>ToggleView</code> 需要一个<code>Binding</code>来控制开关的状态，这个<code>Binding</code>可以从父视图的<code>@State</code>中派生而来。</p>\n<p><strong>使用State和Binding</strong></p>\n<p>在实际的应用中，<code>@State</code>适用于简单的局部状态管理，如界面的某个开关、文本输入框的内容等。当状态改变时，只有使用到该状态的视图会重新渲染，从而优化了性能。</p>\n<p><code>@Binding</code>则用于将状态的控制权从一个视图传递到另一个视图。例如，在一个父视图中定义了<code>@State</code>，那么就可以将这个状态以<code>Binding</code>的形式传递给子视图，让子视图能够读取并修改这个状态。</p>\n<p><strong>State和视图的生命周期</strong></p>\n<p>理解<code>@State</code>与视图的生命周期是紧密相关的也很重要。当一个视图被SwiftUI重新绘制时，<code>@State</code>所持有的状态会被保留下来。这意味着状态的变更是持久的，即使视图的某些其他部分可能因为不同的原因而重新渲染。</p>\n<p><strong>总结</strong></p>\n<p><code>State</code>和<code>Binding</code>是SwiftUI中数据流的基础。<code>@State</code>用于创建可变的状态，当状态变化时，视图会响应这些变化。而<code>Binding</code>则用于在视图之间共享状态，允许多个视图共同拥有和修改状态。通过恰当地使用这两个工具，我们可以创建出既简洁又高效的响应式用户界面。在接下来的章节中，我们将深入探讨如何在更复杂的应用架构中管理状态和数据流。</p>\n<p><strong>2. ObservedObject和EnvironmentObject</strong></p>\n<p>在构建复杂的SwiftUI应用时，我们经常需要处理跨多个视图共享的数据。在这种情况下，仅使用<code>@State</code>和<code>@Binding</code>可能不够用，因为它们主要用于单个视图或其直接子视图的状态管理。这时，<code>@ObservedObject</code>和<code>@EnvironmentObject</code>就成为了重要的工具。</p>\n<p><strong>ObservedObject：动态数据的监听者</strong></p>\n<p><code>@ObservedObject</code>用于绑定外部的可观察对象（通常是遵循<code>ObservableObject</code>协议的类实例），当可观察对象发出变化通知时，视图会重新渲染以反映新的数据。</p>\n<p>这里有一个<code>ObservableObject</code>的示例：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">UserData</span>: <span class=\"hljs-title class_\">ObservableObject</span> &#123;<br>    <span class=\"hljs-meta\">@Published</span> <span class=\"hljs-keyword\">var</span> username: <span class=\"hljs-type\">String</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;用户&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><code>@Published</code>属性包装器用于标记会发生变化的数据。一旦<code>username</code>的值发生变更，就会自动通知所有的观察者。</p>\n<p>在视图中使用<code>@ObservedObject</code>：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">UserView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@ObservedObject</span> <span class=\"hljs-keyword\">var</span> userData: <span class=\"hljs-type\">UserData</span><br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;用户名: <span class=\"hljs-subst\">\\(userData.username)</span>&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在<code>UserView</code>中，<code>userData</code>作为一个<code>@ObservedObject</code>提供了对<code>UserData</code>实例的引用。当<code>username</code>更新时，<code>UserView</code>也会更新其显示。</p>\n<p><strong>EnvironmentObject：跨层级的数据共享</strong></p>\n<p><code>@EnvironmentObject</code>是一种特殊类型的数据流工具，它可以让数据在视图层级间传递而不需要显式地通过参数传递。它非常适合那些被多个视图访问的全局数据或设置。</p>\n<p>首先，你需要在某个父视图中将数据对象添加到环境中：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">@main</span><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">MyApp</span>: <span class=\"hljs-title class_\">App</span> &#123;<br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">Scene</span> &#123;<br>        <span class=\"hljs-type\">WindowGroup</span> &#123;<br>            <span class=\"hljs-type\">ContentView</span>()<br>                .environmentObject(<span class=\"hljs-type\">UserData</span>())<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>然后，在子视图中，你可以直接通过<code>@EnvironmentObject</code>来访问这个数据对象：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ProfileView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@EnvironmentObject</span> <span class=\"hljs-keyword\">var</span> userData: <span class=\"hljs-type\">UserData</span><br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;欢迎, <span class=\"hljs-subst\">\\(userData.username)</span>!&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>不需要显式地从父视图传递<code>UserData</code>到<code>ProfileView</code>，<code>ProfileView</code>可以直接从环境中获取这个对象。</p>\n<p><strong>总结</strong></p>\n<p><code>@ObservedObject</code>和<code>@EnvironmentObject</code>为我们提供了强大的数据管理能力，使得数据在视图之间传递变得简单且高效。它们都依赖于<code>ObservableObject</code>协议来观察数据模型的变化并响应更新。<code>@ObservedObject</code>适用于需要直接引用的情况，而<code>@EnvironmentObject</code>更适合于全局或共享数据的情况，尤其是在视图层级较深时。</p>\n<p>在接下来的内容中，我们将探讨这些数据流工具如何与SwiftUI的声明式UI框架协同工作，以及如何利用它们来构建响应式和可维护的应用架构。</p>\n<p><strong>3. @Published和Combine</strong></p>\n<p>在SwiftUI中，数据的流动和管理是构建应用的核心。为了实现响应式的数据流，SwiftUI密切结合了Combine框架。Combine是一个响应式编程框架，它可以处理所有类型的异步事件。<code>@Published</code>是Combine框架中的一个关键特性，它用于创建可观察的对象属性，当这些属性的值发生变化时，它会自动通知系统。</p>\n<p><strong>使用@Published</strong></p>\n<p>使用<code>@Published</code>可以很容易地将一个类属性变成响应式的属性。这意味着，当属性的值改变时，所有订阅了这个属性的订阅者都会接收到通知，并且可以响应这些变化。</p>\n<p>下面是一个使用<code>@Published</code>的例子：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">import</span> Combine<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ProfileViewModel</span>: <span class=\"hljs-title class_\">ObservableObject</span> &#123;<br>    <span class=\"hljs-meta\">@Published</span> <span class=\"hljs-keyword\">var</span> name: <span class=\"hljs-type\">String</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;&quot;</span><br>    <span class=\"hljs-meta\">@Published</span> <span class=\"hljs-keyword\">var</span> age: <span class=\"hljs-type\">Int</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在这个例子中，<code>ProfileViewModel</code>是一个遵循<code>ObservableObject</code>协议的类，它有两个<code>@Published</code>属性：<code>name</code>和<code>age</code>。当这些属性中的任何一个的值改变时，所有的观察者都会得到通知。</p>\n<p><strong>整合Combine</strong></p>\n<p>Combine框架的强大之处在于它可以让你定义复杂的数据处理和变换流程。例如，你可以对输入进行校验、过滤、转换，然后将处理后的数据传递到UI或其他部分。</p>\n<p>这里是如何使用Combine订阅<code>@Published</code>属性变化的例子：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">var</span> cancellables <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">Set</span>&lt;<span class=\"hljs-type\">AnyCancellable</span>&gt;()<br><br><span class=\"hljs-keyword\">let</span> profileVM <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">ProfileViewModel</span>()<br>profileVM.<span class=\"hljs-variable\">$name</span><br>    .sink &#123; name <span class=\"hljs-keyword\">in</span><br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;Name is now <span class=\"hljs-subst\">\\(name)</span>&quot;</span>)<br>    &#125;<br>    .store(in: <span class=\"hljs-operator\">&amp;</span>cancellables)<br></code></pre></td></tr></table></figure>\n\n<p>在这段代码中，<code>$name</code>是对<code>name</code>属性的Publisher访问。<code>.sink</code>方法会接收一个闭包，这个闭包会在每次<code>name</code>属性更新时被调用。<code>.store(in:)</code>方法用于管理订阅生命周期，防止早期释放。</p>\n<p><strong>结合SwiftUI视图</strong></p>\n<p>在SwiftUI中，你通常不需要直接处理订阅，因为SwiftUI视图可以直接使用<code>@ObservedObject</code>或<code>@EnvironmentObject</code>来绑定到可观察的对象。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ProfileView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@ObservedObject</span> <span class=\"hljs-keyword\">var</span> viewModel: <span class=\"hljs-type\">ProfileViewModel</span><br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">TextField</span>(<span class=\"hljs-string\">&quot;Name&quot;</span>, text: <span class=\"hljs-variable\">$viewModel</span>.name)<br>        <span class=\"hljs-type\">TextField</span>(<span class=\"hljs-string\">&quot;Age&quot;</span>, value: <span class=\"hljs-variable\">$viewModel</span>.age, formatter: <span class=\"hljs-type\">NumberFormatter</span>())<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在<code>ProfileView</code>中，每当<code>viewModel</code>的<code>name</code>或<code>age</code>属性变化时，视图会自动更新。</p>\n<p><strong>小结</strong></p>\n<p><code>@Published</code>与Combine框架结合使用，为SwiftUI应用带来了强大的响应式编程能力。这种模式不仅使状态管理变得简洁，还能够创建可维护和可扩展的数据流处理逻辑。随着你深入本书，你将会看到更多关于Combine在实际SwiftUI应用中的强大用例和模式。</p>\n<p><strong>4. 数据流的最佳实践</strong></p>\n<p>在构建SwiftUI应用时，高效和可维护的数据流管理是非常重要的。为了达到这个目标，我们需要遵循一些最佳实践来确保我们的应用结构清晰，数据流动合理。以下是在使用SwiftUI时应考虑的数据流最佳实践。</p>\n<p><strong>一、明确数据源的单一真相</strong></p>\n<p>在任何给定的时刻，应用的每个数据点都应该有一个清晰的，可信的来源。这意味着对于任何可变的数据，都应该有一个单一的可信源，而所有视图的状态应反映这个来源。使用<code>@State</code>的私有属性用于视图的内部状态，而模型对象中的<code>@Published</code>属性用于应用范围的状态。</p>\n<p><strong>二、使用单向数据流</strong></p>\n<p>在SwiftUI中，数据应该从父视图流向子视图（单向数据流）。父视图传递数据到子视图，子视图通过事件传递回父视图，而不是直接修改父视图的状态。这样可以避免复杂的数据依赖和潜在的循环更新问题。</p>\n<p><strong>三、合理使用@State，@Binding，@ObservedObject，和@EnvironmentObject</strong></p>\n<ul>\n<li><strong>@State</strong> 应当用于视图的局部状态管理，不应跨越多个视图。</li>\n<li><strong>@Binding</strong> 允许子视图与父视图的状态或模型中的数据进行通信。</li>\n<li><strong>@ObservedObject</strong> 用于当视图需要响应外部模型对象变化时。</li>\n<li><strong>@EnvironmentObject</strong> 适用于多个视图需要访问同一共享数据对象的情况。</li>\n</ul>\n<p><strong>四、谨慎管理生命周期</strong></p>\n<p>识别并管理数据对象的生命周期，尤其是当使用<code>@ObservedObject</code>或<code>@EnvironmentObject</code>时。避免不必要的重新创建对象，以减少内存使用和性能损耗。</p>\n<p><strong>五、精细控制数据变更</strong></p>\n<p>使用<code>objectWillChange</code>手动发送变更通知可以精细控制观察的对象何时更新UI。当需要优化性能或处理复杂的数据变更时这非常有用。</p>\n<p><strong>六、利用Combine进行复杂的数据操作</strong></p>\n<p>Combine框架提供了一套完整的工具，用于处理复杂的数据转换和异步操作。应充分利用这些工具来实现复杂的数据流和事件处理。</p>\n<p><strong>七、避免内存泄漏</strong></p>\n<p>当处理数据流和绑定时，确保正确管理订阅，使用<code>AnyCancellable</code>存储返回的订阅，并在不需要时取消订阅，以避免内存泄漏。</p>\n<p><strong>八、编写可测试的代码</strong></p>\n<p>将数据处理逻辑抽象到可单独测试的模型和服务中。避免将业务逻辑放入视图中，这样可以让代码更容易被测试和维护。</p>\n<p><strong>小结</strong></p>\n<p>遵循上述的数据流最佳实践将有助于您构建出高效、稳定且易于维护的SwiftUI应用。确保理解和正确应用每一种属性装饰器和Combine操作符是至关重要的。本书后续章节将会进一步深入这些概念，并结合实例演示如何在真实世界的应用中实践这些最佳实践。</p>\n"},{"title":"SwiftUI核心技术第5章布局管理","date":"2023-11-08T00:47:49.000Z","_content":"**第5章：布局管理**\n\n**1. 堆（Stacks）**\n\n在SwiftUI中，布局是通过组合不同的视图和使用布局容器来实现的，其中最基础和最常用的布局容器是堆（Stack）。Stacks在SwiftUI中主要有三种类型：`HStack`、`VStack`和`ZStack`，它们分别代表水平堆、垂直堆和覆盖堆。通过这三种Stack，可以构建出复杂的布局结构。\n\n**理解堆的工作方式**\n\n- `HStack`（水平堆）将其子视图沿着水平轴排列。\n- `VStack`（垂直堆）将子视图沿着垂直轴排列。\n- `ZStack`（覆盖堆）则将子视图按照代码中的顺序覆盖排列，即先声明的视图会被后声明的视图覆盖。\n\n**使用HStack和VStack管理布局**\n\n```swift\nVStack(alignment: .leading, spacing: 10) {\n    Text(\"第一行\")\n    HStack {\n        Text(\"左侧\")\n        Spacer() // Spacer会推动旁边的视图尽可能远的距离\n        Text(\"右侧\")\n    }\n    Text(\"第二行\")\n}\n.padding() // 对VStack添加内边距\n```\n\n在上面的代码示例中，我们首先创建了一个`VStack`，其子视图之间有10点的间距，并且它们在水平方向上左对齐。在这个垂直堆中，我们有两行文本和一个`HStack`。在`HStack`中，两个文本视图被一个`Spacer`隔开，这会推动这些文本视图到`HStack`的两侧。\n\n**ZStack的层叠效果**\n\n```swift\nZStack {\n    Image(\"background\")\n        .resizable()\n        .aspectRatio(contentMode: .fill)\n    VStack {\n        Text(\"层叠的顶部文本\")\n            .font(.largeTitle)\n            .foregroundColor(.white)\n        Spacer()\n    }\n}\n.frame(height: 300) // 设置ZStack的高度\n.clipped() // 保证图片不会超出ZStack的边界\n```\n\n在这个例子中，`ZStack`用于创建层叠效果。它首先放置了一张背景图片，然后在图片上层放置了一个`VStack`，其中包含了一行文本。\n\n**使用堆的布局行为**\n\n- `Stacks`默认会尽可能地占据父视图提供的空间，除非使用`frame`、`edgesIgnoringSafeArea`、`fixedSize`等修饰符进行限制。\n- `alignment`参数控制子视图在交叉轴上的对齐方式（对于`HStack`是垂直对齐，对于`VStack`是水平对齐）。\n- `spacing`参数决定子视图之间的间距。\n\n**对齐和分布**\n\nStacks的另一个关键特性是对齐。开发者可以非常细致地控制如何对齐子视图：\n\n```swift\nHStack(alignment: .top) {\n    Text(\"顶部对齐\")\n    Divider()\n    Text(\"还是顶部对齐\")\n}\n```\n\n在这个`HStack`中，所有的子视图都会在顶部对齐，即使它们的高度不同。\n\n**总结**\n\n通过理解和利用Stacks，你可以构建出直观且灵活的布局。Stacks的简单性和强大的组合能力，使得它们成为SwiftUI布局的核心工具。它们可以嵌套使用，也可以与其他布局视图和控件配合，以创建出复杂且响应式的用户界面。随着你\n\n对这些基础布局工具的熟悉和运用，你将能够更加精准地操控空间，为你的应用提供坚实的视觉基础。\n\n\n**2. 对齐与帧（Alignment and Frames）**\n\n布局的精髓在于如何控制视图的大小和位置。在SwiftUI中，`对齐`和`帧`是两个基本但强大的概念，它们定义了视图在父视图中的具体摆放方式。\n\n**理解对齐**\n\n对齐在SwiftUI中是通过对齐指南来实现的，它定义了视图如何根据父视图或兄弟视图的对齐线来定位自己。例如，在一个`VStack`中，你可以通过`alignment`参数设置子视图在水平方向上的对齐方式，而在`HStack`中，这会影响子视图在垂直方向上的对齐。\n\n```swift\nHStack(alignment: .bottom) {\n    Text(\"底部对齐\")\n    Image(systemName: \"star\")\n        .alignmentGuide(.bottom) { d in d[.top] }\n    Text(\"这个星星将对齐顶部\")\n}\n```\n\n在这个例子中，我们通过`.alignmentGuide`修饰符来改变图像视图的默认对齐行为，使其按照顶部对齐而不是底部。\n\n**使用帧控制视图大小**\n\n帧（frame）允许你为视图设置一个明确的大小或者提供一个理想的大小范围。`frame`修饰符可以指定宽度（`width`）、高度（`height`）、最小宽度（`minWidth`）、最大宽度（`maxWidth`）、最小高度（`minHeight`）、和最大高度（`maxHeight`）。\n\n```swift\nText(\"固定大小的文本框\")\n    .frame(width: 100, height: 100)\n    .border(Color.red)\n```\n\n上述代码将文本框的宽度和高度都固定在了100点，无论内容大小如何，文本框都不会改变尺寸。\n\n**对齐和帧的组合使用**\n\n对齐和帧可以组合使用，以创建更复杂的布局效果。例如，你可能想要创建一个宽度固定，但高度根据内容动态调整的文本视图，同时在其内部文本垂直居中对齐。\n\n```swift\nText(\"垂直居中的文本\")\n    .frame(minHeight: 0, maxHeight: .infinity)\n    .frame(width: 200)\n    .background(Color.gray)\n    .alignmentGuide(.vertical) { d in\n        d[VerticalAlignment.center]\n    }\n```\n\n这里我们使用了两个`frame`修饰符：第一个`frame`确保文本在垂直方向上可以扩展到可用的全部空间，第二个`frame`则设置了文本的固定宽度。通过`alignmentGuide`，文本在其框架内垂直居中。\n\n**总结**\n\n对齐和帧是布局时的两个非常重要的概念。通过精确的对齐控制，你可以确保界面元素以一种一致和预期的方式排列。同时，使用帧可以限制和指定视图的大小，无论是固定的还是灵活的。掌握了这些工具，你将能够设计出外观精确且布局合理的界面，即便是面对各种屏幕尺寸和设备方向，你的应用界面也能保持其应有的布局和结构。\n\n\n**3. Spacer和Divider**\n\n在构建用户界面时，除了直接操纵视图的尺寸和对齐，SwiftUI还提供了用于控制视图间隔的工具：Spacer和Divider。这些工具在进行视图布局时是不可或缺的，它们可以帮助我们创建出更为优雅和灵活的用户界面。\n\n**Spacer: 创建灵活的空间**\n\nSpacer是一个会尽可能占用多余空间的视图。在一个Stack中，Spacer可以推动相邻的视图，使其与Stack的边缘或其他视图保持距离。Spacer本身没有可见的内容，但它可以控制布局的间距。\n\n```swift\nHStack {\n    Text(\"左边\")\n    Spacer() // 占据所有可用空间\n    Text(\"右边\")\n}\n```\n\n在上述例子中，Spacer位于两个文本视图之间，并推动它们分别靠近水平Stack的左右边缘。\n\nSpacer的另一个常用场景是在其前后添加修饰符，以控制其最小空间尺寸。\n\n```swift\nHStack {\n    Text(\"左边\")\n    Spacer()\n        .frame(minWidth: 20)\n    Text(\"右边\")\n}\n```\n\n此时，Spacer至少会创建20点的空间，即使在更大的容器中，它也会扩展以填满额外的空间。\n\n**Divider: 分隔视图**\n\nDivider是一个用于分隔内容的细线，通常在视觉上表示不同部分的内容。它可以在列表、VStack或HStack中作为清晰分界线使用。\n\n```swift\nVStack {\n    Text(\"第一部分\")\n    Divider()\n    Text(\"第二部分\")\n}\n```\n\nDivider会自动采用垂直或水平方向，取决于它所在的Stack类型。在VStack中，它是水平的；而在HStack中，则是垂直的。\n\n**自定义Spacer和Divider**\n\n虽然Spacer和Divider是很好的布局工具，但有时你可能需要更多的自定义。例如，你可以使用背景和框架修饰符来自定义Divider的样式。\n\n```swift\nDivider()\n    .background(Color.blue)\n    .frame(height: 1)\n```\n\n在这个例子中，我们自定义了Divider的颜色和高度，创建了一个蓝色的分隔线。\n\n同样，你也可以对Spacer进行类似的自定义。\n\n**总结**\n\nSpacer和Divider是在SwiftUI中创建和维护视图间隙的简单而强大的工具。它们支持布局的灵活性，同时为内容的视觉分隔提供方便。在理解了如何利用Spacer来控制视图的扩展和收缩，以及如何使用Divider来清晰地区分内容之后，你将能够创建出既美观又实用的布局设计。\n\n\n**4. 布局优先级**\n\n当我们在SwiftUI中构建复杂的界面时，经常会遇到多个视图争抢空间的情况。布局优先级（Layout Priority）是一个高级的概念，它允许我们微调视图如何在父视图中分配额外的空间。理解并正确使用布局优先级，可以帮助我们创建更加精确和高度定制的用户界面。\n\n**基本概念**\n\n在SwiftUI中，所有视图默认具有相同的布局优先级，值为0。当空间不足以满足所有子视图的理想尺寸时，系统会根据布局优先级来决定哪个视图可以首先满足其尺寸需求。\n\n```swift\nHStack {\n    Text(\"非常非常长的文本\").layoutPriority(1)\n    Spacer()\n    Text(\"短文本\")\n}\n```\n\n在这个例子中，第一个`Text`视图的布局优先级被设置为1，这意味着它在空间分配时会被优先考虑。即使在有限的空间中，它也会尽可能地显示完整的内容，而`Spacer`和第二个`Text`视图会相应地压缩。\n\n**布局优先级的使用**\n\n布局优先级的值可以是任意的正浮点数。数值越大，获取额外空间的优先级就越高。\n\n```swift\nHStack {\n    Text(\"需要更多空间的文本\").layoutPriority(2)\n    Text(\"不那么重要的文本\").layoutPriority(1)\n    Text(\"普通文本\")\n}\n```\n\n在上面的代码中，第一个文本视图被赋予了最高的优先级（2），其次是第二个文本视图（1），最后是没有显式设置优先级的文本视图（默认为0）。因此，当空间有限时，第一个文本视图会尽量显示更多的内容。\n\n**布局优先级的策略**\n\n布局优先级通常用于解决视图间的竞争关系，但是它并不是解决所有布局问题的万能钥匙。合理使用布局优先级需要策略，过度依赖可能会导致布局变得难以预测和管理。在设置优先级时，你应当始终考虑内容的重要性以及用户体验。\n\n一个良好的策略是尽量保持简单，只在确实需要时调整布局优先级。并且，始终牢记布局的整体目标是创造既满足设计需求又对用户友好的界面。\n\n**结合其他布局工具**\n\n布局优先级并不孤立工作，它应该与其他布局工具一起使用，例如`frame`、`alignment`、`Spacer`等。在实际开发中，你会发现布局优先级是与其他布局概念协同工作的，比如使用`fixedSize`来防止视图被压缩，或者与`flexible`结合来调整视图的压缩和扩展行为。\n\n**总结**\n\n掌握了布局优先级的概念和使用方法后，我们就能更加精细地控制SwiftUI布局的行为。正确的布局优先级设置能够确保重要的内容得到展示，辅助视图适应剩余空间，从而创造出既直观又富有层次的用户界面。在设计复杂的布局时，优先级的细微调整可以带来显著的视觉和体验改善。","source":"_posts/SwiftUI核心技术第5章布局管理.md","raw":"---\ntitle: SwiftUI核心技术第5章布局管理\ndate: 2023-11-08 08:47:49\ncategories:\n- SwiftUI\ntags:\n---\n**第5章：布局管理**\n\n**1. 堆（Stacks）**\n\n在SwiftUI中，布局是通过组合不同的视图和使用布局容器来实现的，其中最基础和最常用的布局容器是堆（Stack）。Stacks在SwiftUI中主要有三种类型：`HStack`、`VStack`和`ZStack`，它们分别代表水平堆、垂直堆和覆盖堆。通过这三种Stack，可以构建出复杂的布局结构。\n\n**理解堆的工作方式**\n\n- `HStack`（水平堆）将其子视图沿着水平轴排列。\n- `VStack`（垂直堆）将子视图沿着垂直轴排列。\n- `ZStack`（覆盖堆）则将子视图按照代码中的顺序覆盖排列，即先声明的视图会被后声明的视图覆盖。\n\n**使用HStack和VStack管理布局**\n\n```swift\nVStack(alignment: .leading, spacing: 10) {\n    Text(\"第一行\")\n    HStack {\n        Text(\"左侧\")\n        Spacer() // Spacer会推动旁边的视图尽可能远的距离\n        Text(\"右侧\")\n    }\n    Text(\"第二行\")\n}\n.padding() // 对VStack添加内边距\n```\n\n在上面的代码示例中，我们首先创建了一个`VStack`，其子视图之间有10点的间距，并且它们在水平方向上左对齐。在这个垂直堆中，我们有两行文本和一个`HStack`。在`HStack`中，两个文本视图被一个`Spacer`隔开，这会推动这些文本视图到`HStack`的两侧。\n\n**ZStack的层叠效果**\n\n```swift\nZStack {\n    Image(\"background\")\n        .resizable()\n        .aspectRatio(contentMode: .fill)\n    VStack {\n        Text(\"层叠的顶部文本\")\n            .font(.largeTitle)\n            .foregroundColor(.white)\n        Spacer()\n    }\n}\n.frame(height: 300) // 设置ZStack的高度\n.clipped() // 保证图片不会超出ZStack的边界\n```\n\n在这个例子中，`ZStack`用于创建层叠效果。它首先放置了一张背景图片，然后在图片上层放置了一个`VStack`，其中包含了一行文本。\n\n**使用堆的布局行为**\n\n- `Stacks`默认会尽可能地占据父视图提供的空间，除非使用`frame`、`edgesIgnoringSafeArea`、`fixedSize`等修饰符进行限制。\n- `alignment`参数控制子视图在交叉轴上的对齐方式（对于`HStack`是垂直对齐，对于`VStack`是水平对齐）。\n- `spacing`参数决定子视图之间的间距。\n\n**对齐和分布**\n\nStacks的另一个关键特性是对齐。开发者可以非常细致地控制如何对齐子视图：\n\n```swift\nHStack(alignment: .top) {\n    Text(\"顶部对齐\")\n    Divider()\n    Text(\"还是顶部对齐\")\n}\n```\n\n在这个`HStack`中，所有的子视图都会在顶部对齐，即使它们的高度不同。\n\n**总结**\n\n通过理解和利用Stacks，你可以构建出直观且灵活的布局。Stacks的简单性和强大的组合能力，使得它们成为SwiftUI布局的核心工具。它们可以嵌套使用，也可以与其他布局视图和控件配合，以创建出复杂且响应式的用户界面。随着你\n\n对这些基础布局工具的熟悉和运用，你将能够更加精准地操控空间，为你的应用提供坚实的视觉基础。\n\n\n**2. 对齐与帧（Alignment and Frames）**\n\n布局的精髓在于如何控制视图的大小和位置。在SwiftUI中，`对齐`和`帧`是两个基本但强大的概念，它们定义了视图在父视图中的具体摆放方式。\n\n**理解对齐**\n\n对齐在SwiftUI中是通过对齐指南来实现的，它定义了视图如何根据父视图或兄弟视图的对齐线来定位自己。例如，在一个`VStack`中，你可以通过`alignment`参数设置子视图在水平方向上的对齐方式，而在`HStack`中，这会影响子视图在垂直方向上的对齐。\n\n```swift\nHStack(alignment: .bottom) {\n    Text(\"底部对齐\")\n    Image(systemName: \"star\")\n        .alignmentGuide(.bottom) { d in d[.top] }\n    Text(\"这个星星将对齐顶部\")\n}\n```\n\n在这个例子中，我们通过`.alignmentGuide`修饰符来改变图像视图的默认对齐行为，使其按照顶部对齐而不是底部。\n\n**使用帧控制视图大小**\n\n帧（frame）允许你为视图设置一个明确的大小或者提供一个理想的大小范围。`frame`修饰符可以指定宽度（`width`）、高度（`height`）、最小宽度（`minWidth`）、最大宽度（`maxWidth`）、最小高度（`minHeight`）、和最大高度（`maxHeight`）。\n\n```swift\nText(\"固定大小的文本框\")\n    .frame(width: 100, height: 100)\n    .border(Color.red)\n```\n\n上述代码将文本框的宽度和高度都固定在了100点，无论内容大小如何，文本框都不会改变尺寸。\n\n**对齐和帧的组合使用**\n\n对齐和帧可以组合使用，以创建更复杂的布局效果。例如，你可能想要创建一个宽度固定，但高度根据内容动态调整的文本视图，同时在其内部文本垂直居中对齐。\n\n```swift\nText(\"垂直居中的文本\")\n    .frame(minHeight: 0, maxHeight: .infinity)\n    .frame(width: 200)\n    .background(Color.gray)\n    .alignmentGuide(.vertical) { d in\n        d[VerticalAlignment.center]\n    }\n```\n\n这里我们使用了两个`frame`修饰符：第一个`frame`确保文本在垂直方向上可以扩展到可用的全部空间，第二个`frame`则设置了文本的固定宽度。通过`alignmentGuide`，文本在其框架内垂直居中。\n\n**总结**\n\n对齐和帧是布局时的两个非常重要的概念。通过精确的对齐控制，你可以确保界面元素以一种一致和预期的方式排列。同时，使用帧可以限制和指定视图的大小，无论是固定的还是灵活的。掌握了这些工具，你将能够设计出外观精确且布局合理的界面，即便是面对各种屏幕尺寸和设备方向，你的应用界面也能保持其应有的布局和结构。\n\n\n**3. Spacer和Divider**\n\n在构建用户界面时，除了直接操纵视图的尺寸和对齐，SwiftUI还提供了用于控制视图间隔的工具：Spacer和Divider。这些工具在进行视图布局时是不可或缺的，它们可以帮助我们创建出更为优雅和灵活的用户界面。\n\n**Spacer: 创建灵活的空间**\n\nSpacer是一个会尽可能占用多余空间的视图。在一个Stack中，Spacer可以推动相邻的视图，使其与Stack的边缘或其他视图保持距离。Spacer本身没有可见的内容，但它可以控制布局的间距。\n\n```swift\nHStack {\n    Text(\"左边\")\n    Spacer() // 占据所有可用空间\n    Text(\"右边\")\n}\n```\n\n在上述例子中，Spacer位于两个文本视图之间，并推动它们分别靠近水平Stack的左右边缘。\n\nSpacer的另一个常用场景是在其前后添加修饰符，以控制其最小空间尺寸。\n\n```swift\nHStack {\n    Text(\"左边\")\n    Spacer()\n        .frame(minWidth: 20)\n    Text(\"右边\")\n}\n```\n\n此时，Spacer至少会创建20点的空间，即使在更大的容器中，它也会扩展以填满额外的空间。\n\n**Divider: 分隔视图**\n\nDivider是一个用于分隔内容的细线，通常在视觉上表示不同部分的内容。它可以在列表、VStack或HStack中作为清晰分界线使用。\n\n```swift\nVStack {\n    Text(\"第一部分\")\n    Divider()\n    Text(\"第二部分\")\n}\n```\n\nDivider会自动采用垂直或水平方向，取决于它所在的Stack类型。在VStack中，它是水平的；而在HStack中，则是垂直的。\n\n**自定义Spacer和Divider**\n\n虽然Spacer和Divider是很好的布局工具，但有时你可能需要更多的自定义。例如，你可以使用背景和框架修饰符来自定义Divider的样式。\n\n```swift\nDivider()\n    .background(Color.blue)\n    .frame(height: 1)\n```\n\n在这个例子中，我们自定义了Divider的颜色和高度，创建了一个蓝色的分隔线。\n\n同样，你也可以对Spacer进行类似的自定义。\n\n**总结**\n\nSpacer和Divider是在SwiftUI中创建和维护视图间隙的简单而强大的工具。它们支持布局的灵活性，同时为内容的视觉分隔提供方便。在理解了如何利用Spacer来控制视图的扩展和收缩，以及如何使用Divider来清晰地区分内容之后，你将能够创建出既美观又实用的布局设计。\n\n\n**4. 布局优先级**\n\n当我们在SwiftUI中构建复杂的界面时，经常会遇到多个视图争抢空间的情况。布局优先级（Layout Priority）是一个高级的概念，它允许我们微调视图如何在父视图中分配额外的空间。理解并正确使用布局优先级，可以帮助我们创建更加精确和高度定制的用户界面。\n\n**基本概念**\n\n在SwiftUI中，所有视图默认具有相同的布局优先级，值为0。当空间不足以满足所有子视图的理想尺寸时，系统会根据布局优先级来决定哪个视图可以首先满足其尺寸需求。\n\n```swift\nHStack {\n    Text(\"非常非常长的文本\").layoutPriority(1)\n    Spacer()\n    Text(\"短文本\")\n}\n```\n\n在这个例子中，第一个`Text`视图的布局优先级被设置为1，这意味着它在空间分配时会被优先考虑。即使在有限的空间中，它也会尽可能地显示完整的内容，而`Spacer`和第二个`Text`视图会相应地压缩。\n\n**布局优先级的使用**\n\n布局优先级的值可以是任意的正浮点数。数值越大，获取额外空间的优先级就越高。\n\n```swift\nHStack {\n    Text(\"需要更多空间的文本\").layoutPriority(2)\n    Text(\"不那么重要的文本\").layoutPriority(1)\n    Text(\"普通文本\")\n}\n```\n\n在上面的代码中，第一个文本视图被赋予了最高的优先级（2），其次是第二个文本视图（1），最后是没有显式设置优先级的文本视图（默认为0）。因此，当空间有限时，第一个文本视图会尽量显示更多的内容。\n\n**布局优先级的策略**\n\n布局优先级通常用于解决视图间的竞争关系，但是它并不是解决所有布局问题的万能钥匙。合理使用布局优先级需要策略，过度依赖可能会导致布局变得难以预测和管理。在设置优先级时，你应当始终考虑内容的重要性以及用户体验。\n\n一个良好的策略是尽量保持简单，只在确实需要时调整布局优先级。并且，始终牢记布局的整体目标是创造既满足设计需求又对用户友好的界面。\n\n**结合其他布局工具**\n\n布局优先级并不孤立工作，它应该与其他布局工具一起使用，例如`frame`、`alignment`、`Spacer`等。在实际开发中，你会发现布局优先级是与其他布局概念协同工作的，比如使用`fixedSize`来防止视图被压缩，或者与`flexible`结合来调整视图的压缩和扩展行为。\n\n**总结**\n\n掌握了布局优先级的概念和使用方法后，我们就能更加精细地控制SwiftUI布局的行为。正确的布局优先级设置能够确保重要的内容得到展示，辅助视图适应剩余空间，从而创造出既直观又富有层次的用户界面。在设计复杂的布局时，优先级的细微调整可以带来显著的视觉和体验改善。","slug":"SwiftUI核心技术第5章布局管理","published":1,"updated":"2024-03-17T06:11:17.149Z","comments":1,"layout":"post","photos":[],"_id":"clu6up53i002gz6746t60gn93","content":"<p><strong>第5章：布局管理</strong></p>\n<p><strong>1. 堆（Stacks）</strong></p>\n<p>在SwiftUI中，布局是通过组合不同的视图和使用布局容器来实现的，其中最基础和最常用的布局容器是堆（Stack）。Stacks在SwiftUI中主要有三种类型：<code>HStack</code>、<code>VStack</code>和<code>ZStack</code>，它们分别代表水平堆、垂直堆和覆盖堆。通过这三种Stack，可以构建出复杂的布局结构。</p>\n<p><strong>理解堆的工作方式</strong></p>\n<ul>\n<li><code>HStack</code>（水平堆）将其子视图沿着水平轴排列。</li>\n<li><code>VStack</code>（垂直堆）将子视图沿着垂直轴排列。</li>\n<li><code>ZStack</code>（覆盖堆）则将子视图按照代码中的顺序覆盖排列，即先声明的视图会被后声明的视图覆盖。</li>\n</ul>\n<p><strong>使用HStack和VStack管理布局</strong></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">VStack</span>(alignment: .leading, spacing: <span class=\"hljs-number\">10</span>) &#123;<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;第一行&quot;</span>)<br>    <span class=\"hljs-type\">HStack</span> &#123;<br>        <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;左侧&quot;</span>)<br>        <span class=\"hljs-type\">Spacer</span>() <span class=\"hljs-comment\">// Spacer会推动旁边的视图尽可能远的距离</span><br>        <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;右侧&quot;</span>)<br>    &#125;<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;第二行&quot;</span>)<br>&#125;<br>.padding() <span class=\"hljs-comment\">// 对VStack添加内边距</span><br></code></pre></td></tr></table></figure>\n\n<p>在上面的代码示例中，我们首先创建了一个<code>VStack</code>，其子视图之间有10点的间距，并且它们在水平方向上左对齐。在这个垂直堆中，我们有两行文本和一个<code>HStack</code>。在<code>HStack</code>中，两个文本视图被一个<code>Spacer</code>隔开，这会推动这些文本视图到<code>HStack</code>的两侧。</p>\n<p><strong>ZStack的层叠效果</strong></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">ZStack</span> &#123;<br>    <span class=\"hljs-type\">Image</span>(<span class=\"hljs-string\">&quot;background&quot;</span>)<br>        .resizable()<br>        .aspectRatio(contentMode: .fill)<br>    <span class=\"hljs-type\">VStack</span> &#123;<br>        <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;层叠的顶部文本&quot;</span>)<br>            .font(.largeTitle)<br>            .foregroundColor(.white)<br>        <span class=\"hljs-type\">Spacer</span>()<br>    &#125;<br>&#125;<br>.frame(height: <span class=\"hljs-number\">300</span>) <span class=\"hljs-comment\">// 设置ZStack的高度</span><br>.clipped() <span class=\"hljs-comment\">// 保证图片不会超出ZStack的边界</span><br></code></pre></td></tr></table></figure>\n\n<p>在这个例子中，<code>ZStack</code>用于创建层叠效果。它首先放置了一张背景图片，然后在图片上层放置了一个<code>VStack</code>，其中包含了一行文本。</p>\n<p><strong>使用堆的布局行为</strong></p>\n<ul>\n<li><code>Stacks</code>默认会尽可能地占据父视图提供的空间，除非使用<code>frame</code>、<code>edgesIgnoringSafeArea</code>、<code>fixedSize</code>等修饰符进行限制。</li>\n<li><code>alignment</code>参数控制子视图在交叉轴上的对齐方式（对于<code>HStack</code>是垂直对齐，对于<code>VStack</code>是水平对齐）。</li>\n<li><code>spacing</code>参数决定子视图之间的间距。</li>\n</ul>\n<p><strong>对齐和分布</strong></p>\n<p>Stacks的另一个关键特性是对齐。开发者可以非常细致地控制如何对齐子视图：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">HStack</span>(alignment: .top) &#123;<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;顶部对齐&quot;</span>)<br>    <span class=\"hljs-type\">Divider</span>()<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;还是顶部对齐&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在这个<code>HStack</code>中，所有的子视图都会在顶部对齐，即使它们的高度不同。</p>\n<p><strong>总结</strong></p>\n<p>通过理解和利用Stacks，你可以构建出直观且灵活的布局。Stacks的简单性和强大的组合能力，使得它们成为SwiftUI布局的核心工具。它们可以嵌套使用，也可以与其他布局视图和控件配合，以创建出复杂且响应式的用户界面。随着你</p>\n<p>对这些基础布局工具的熟悉和运用，你将能够更加精准地操控空间，为你的应用提供坚实的视觉基础。</p>\n<p><strong>2. 对齐与帧（Alignment and Frames）</strong></p>\n<p>布局的精髓在于如何控制视图的大小和位置。在SwiftUI中，<code>对齐</code>和<code>帧</code>是两个基本但强大的概念，它们定义了视图在父视图中的具体摆放方式。</p>\n<p><strong>理解对齐</strong></p>\n<p>对齐在SwiftUI中是通过对齐指南来实现的，它定义了视图如何根据父视图或兄弟视图的对齐线来定位自己。例如，在一个<code>VStack</code>中，你可以通过<code>alignment</code>参数设置子视图在水平方向上的对齐方式，而在<code>HStack</code>中，这会影响子视图在垂直方向上的对齐。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">HStack</span>(alignment: .bottom) &#123;<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;底部对齐&quot;</span>)<br>    <span class=\"hljs-type\">Image</span>(systemName: <span class=\"hljs-string\">&quot;star&quot;</span>)<br>        .alignmentGuide(.bottom) &#123; d <span class=\"hljs-keyword\">in</span> d[.top] &#125;<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;这个星星将对齐顶部&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在这个例子中，我们通过<code>.alignmentGuide</code>修饰符来改变图像视图的默认对齐行为，使其按照顶部对齐而不是底部。</p>\n<p><strong>使用帧控制视图大小</strong></p>\n<p>帧（frame）允许你为视图设置一个明确的大小或者提供一个理想的大小范围。<code>frame</code>修饰符可以指定宽度（<code>width</code>）、高度（<code>height</code>）、最小宽度（<code>minWidth</code>）、最大宽度（<code>maxWidth</code>）、最小高度（<code>minHeight</code>）、和最大高度（<code>maxHeight</code>）。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;固定大小的文本框&quot;</span>)<br>    .frame(width: <span class=\"hljs-number\">100</span>, height: <span class=\"hljs-number\">100</span>)<br>    .border(<span class=\"hljs-type\">Color</span>.red)<br></code></pre></td></tr></table></figure>\n\n<p>上述代码将文本框的宽度和高度都固定在了100点，无论内容大小如何，文本框都不会改变尺寸。</p>\n<p><strong>对齐和帧的组合使用</strong></p>\n<p>对齐和帧可以组合使用，以创建更复杂的布局效果。例如，你可能想要创建一个宽度固定，但高度根据内容动态调整的文本视图，同时在其内部文本垂直居中对齐。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;垂直居中的文本&quot;</span>)<br>    .frame(minHeight: <span class=\"hljs-number\">0</span>, maxHeight: .infinity)<br>    .frame(width: <span class=\"hljs-number\">200</span>)<br>    .background(<span class=\"hljs-type\">Color</span>.gray)<br>    .alignmentGuide(.vertical) &#123; d <span class=\"hljs-keyword\">in</span><br>        d[<span class=\"hljs-type\">VerticalAlignment</span>.center]<br>    &#125;<br></code></pre></td></tr></table></figure>\n\n<p>这里我们使用了两个<code>frame</code>修饰符：第一个<code>frame</code>确保文本在垂直方向上可以扩展到可用的全部空间，第二个<code>frame</code>则设置了文本的固定宽度。通过<code>alignmentGuide</code>，文本在其框架内垂直居中。</p>\n<p><strong>总结</strong></p>\n<p>对齐和帧是布局时的两个非常重要的概念。通过精确的对齐控制，你可以确保界面元素以一种一致和预期的方式排列。同时，使用帧可以限制和指定视图的大小，无论是固定的还是灵活的。掌握了这些工具，你将能够设计出外观精确且布局合理的界面，即便是面对各种屏幕尺寸和设备方向，你的应用界面也能保持其应有的布局和结构。</p>\n<p><strong>3. Spacer和Divider</strong></p>\n<p>在构建用户界面时，除了直接操纵视图的尺寸和对齐，SwiftUI还提供了用于控制视图间隔的工具：Spacer和Divider。这些工具在进行视图布局时是不可或缺的，它们可以帮助我们创建出更为优雅和灵活的用户界面。</p>\n<p><strong>Spacer: 创建灵活的空间</strong></p>\n<p>Spacer是一个会尽可能占用多余空间的视图。在一个Stack中，Spacer可以推动相邻的视图，使其与Stack的边缘或其他视图保持距离。Spacer本身没有可见的内容，但它可以控制布局的间距。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">HStack</span> &#123;<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;左边&quot;</span>)<br>    <span class=\"hljs-type\">Spacer</span>() <span class=\"hljs-comment\">// 占据所有可用空间</span><br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;右边&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在上述例子中，Spacer位于两个文本视图之间，并推动它们分别靠近水平Stack的左右边缘。</p>\n<p>Spacer的另一个常用场景是在其前后添加修饰符，以控制其最小空间尺寸。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">HStack</span> &#123;<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;左边&quot;</span>)<br>    <span class=\"hljs-type\">Spacer</span>()<br>        .frame(minWidth: <span class=\"hljs-number\">20</span>)<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;右边&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>此时，Spacer至少会创建20点的空间，即使在更大的容器中，它也会扩展以填满额外的空间。</p>\n<p><strong>Divider: 分隔视图</strong></p>\n<p>Divider是一个用于分隔内容的细线，通常在视觉上表示不同部分的内容。它可以在列表、VStack或HStack中作为清晰分界线使用。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">VStack</span> &#123;<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;第一部分&quot;</span>)<br>    <span class=\"hljs-type\">Divider</span>()<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;第二部分&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>Divider会自动采用垂直或水平方向，取决于它所在的Stack类型。在VStack中，它是水平的；而在HStack中，则是垂直的。</p>\n<p><strong>自定义Spacer和Divider</strong></p>\n<p>虽然Spacer和Divider是很好的布局工具，但有时你可能需要更多的自定义。例如，你可以使用背景和框架修饰符来自定义Divider的样式。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Divider</span>()<br>    .background(<span class=\"hljs-type\">Color</span>.blue)<br>    .frame(height: <span class=\"hljs-number\">1</span>)<br></code></pre></td></tr></table></figure>\n\n<p>在这个例子中，我们自定义了Divider的颜色和高度，创建了一个蓝色的分隔线。</p>\n<p>同样，你也可以对Spacer进行类似的自定义。</p>\n<p><strong>总结</strong></p>\n<p>Spacer和Divider是在SwiftUI中创建和维护视图间隙的简单而强大的工具。它们支持布局的灵活性，同时为内容的视觉分隔提供方便。在理解了如何利用Spacer来控制视图的扩展和收缩，以及如何使用Divider来清晰地区分内容之后，你将能够创建出既美观又实用的布局设计。</p>\n<p><strong>4. 布局优先级</strong></p>\n<p>当我们在SwiftUI中构建复杂的界面时，经常会遇到多个视图争抢空间的情况。布局优先级（Layout Priority）是一个高级的概念，它允许我们微调视图如何在父视图中分配额外的空间。理解并正确使用布局优先级，可以帮助我们创建更加精确和高度定制的用户界面。</p>\n<p><strong>基本概念</strong></p>\n<p>在SwiftUI中，所有视图默认具有相同的布局优先级，值为0。当空间不足以满足所有子视图的理想尺寸时，系统会根据布局优先级来决定哪个视图可以首先满足其尺寸需求。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">HStack</span> &#123;<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;非常非常长的文本&quot;</span>).layoutPriority(<span class=\"hljs-number\">1</span>)<br>    <span class=\"hljs-type\">Spacer</span>()<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;短文本&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在这个例子中，第一个<code>Text</code>视图的布局优先级被设置为1，这意味着它在空间分配时会被优先考虑。即使在有限的空间中，它也会尽可能地显示完整的内容，而<code>Spacer</code>和第二个<code>Text</code>视图会相应地压缩。</p>\n<p><strong>布局优先级的使用</strong></p>\n<p>布局优先级的值可以是任意的正浮点数。数值越大，获取额外空间的优先级就越高。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">HStack</span> &#123;<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;需要更多空间的文本&quot;</span>).layoutPriority(<span class=\"hljs-number\">2</span>)<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;不那么重要的文本&quot;</span>).layoutPriority(<span class=\"hljs-number\">1</span>)<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;普通文本&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在上面的代码中，第一个文本视图被赋予了最高的优先级（2），其次是第二个文本视图（1），最后是没有显式设置优先级的文本视图（默认为0）。因此，当空间有限时，第一个文本视图会尽量显示更多的内容。</p>\n<p><strong>布局优先级的策略</strong></p>\n<p>布局优先级通常用于解决视图间的竞争关系，但是它并不是解决所有布局问题的万能钥匙。合理使用布局优先级需要策略，过度依赖可能会导致布局变得难以预测和管理。在设置优先级时，你应当始终考虑内容的重要性以及用户体验。</p>\n<p>一个良好的策略是尽量保持简单，只在确实需要时调整布局优先级。并且，始终牢记布局的整体目标是创造既满足设计需求又对用户友好的界面。</p>\n<p><strong>结合其他布局工具</strong></p>\n<p>布局优先级并不孤立工作，它应该与其他布局工具一起使用，例如<code>frame</code>、<code>alignment</code>、<code>Spacer</code>等。在实际开发中，你会发现布局优先级是与其他布局概念协同工作的，比如使用<code>fixedSize</code>来防止视图被压缩，或者与<code>flexible</code>结合来调整视图的压缩和扩展行为。</p>\n<p><strong>总结</strong></p>\n<p>掌握了布局优先级的概念和使用方法后，我们就能更加精细地控制SwiftUI布局的行为。正确的布局优先级设置能够确保重要的内容得到展示，辅助视图适应剩余空间，从而创造出既直观又富有层次的用户界面。在设计复杂的布局时，优先级的细微调整可以带来显著的视觉和体验改善。</p>\n","excerpt":"","more":"<p><strong>第5章：布局管理</strong></p>\n<p><strong>1. 堆（Stacks）</strong></p>\n<p>在SwiftUI中，布局是通过组合不同的视图和使用布局容器来实现的，其中最基础和最常用的布局容器是堆（Stack）。Stacks在SwiftUI中主要有三种类型：<code>HStack</code>、<code>VStack</code>和<code>ZStack</code>，它们分别代表水平堆、垂直堆和覆盖堆。通过这三种Stack，可以构建出复杂的布局结构。</p>\n<p><strong>理解堆的工作方式</strong></p>\n<ul>\n<li><code>HStack</code>（水平堆）将其子视图沿着水平轴排列。</li>\n<li><code>VStack</code>（垂直堆）将子视图沿着垂直轴排列。</li>\n<li><code>ZStack</code>（覆盖堆）则将子视图按照代码中的顺序覆盖排列，即先声明的视图会被后声明的视图覆盖。</li>\n</ul>\n<p><strong>使用HStack和VStack管理布局</strong></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">VStack</span>(alignment: .leading, spacing: <span class=\"hljs-number\">10</span>) &#123;<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;第一行&quot;</span>)<br>    <span class=\"hljs-type\">HStack</span> &#123;<br>        <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;左侧&quot;</span>)<br>        <span class=\"hljs-type\">Spacer</span>() <span class=\"hljs-comment\">// Spacer会推动旁边的视图尽可能远的距离</span><br>        <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;右侧&quot;</span>)<br>    &#125;<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;第二行&quot;</span>)<br>&#125;<br>.padding() <span class=\"hljs-comment\">// 对VStack添加内边距</span><br></code></pre></td></tr></table></figure>\n\n<p>在上面的代码示例中，我们首先创建了一个<code>VStack</code>，其子视图之间有10点的间距，并且它们在水平方向上左对齐。在这个垂直堆中，我们有两行文本和一个<code>HStack</code>。在<code>HStack</code>中，两个文本视图被一个<code>Spacer</code>隔开，这会推动这些文本视图到<code>HStack</code>的两侧。</p>\n<p><strong>ZStack的层叠效果</strong></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">ZStack</span> &#123;<br>    <span class=\"hljs-type\">Image</span>(<span class=\"hljs-string\">&quot;background&quot;</span>)<br>        .resizable()<br>        .aspectRatio(contentMode: .fill)<br>    <span class=\"hljs-type\">VStack</span> &#123;<br>        <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;层叠的顶部文本&quot;</span>)<br>            .font(.largeTitle)<br>            .foregroundColor(.white)<br>        <span class=\"hljs-type\">Spacer</span>()<br>    &#125;<br>&#125;<br>.frame(height: <span class=\"hljs-number\">300</span>) <span class=\"hljs-comment\">// 设置ZStack的高度</span><br>.clipped() <span class=\"hljs-comment\">// 保证图片不会超出ZStack的边界</span><br></code></pre></td></tr></table></figure>\n\n<p>在这个例子中，<code>ZStack</code>用于创建层叠效果。它首先放置了一张背景图片，然后在图片上层放置了一个<code>VStack</code>，其中包含了一行文本。</p>\n<p><strong>使用堆的布局行为</strong></p>\n<ul>\n<li><code>Stacks</code>默认会尽可能地占据父视图提供的空间，除非使用<code>frame</code>、<code>edgesIgnoringSafeArea</code>、<code>fixedSize</code>等修饰符进行限制。</li>\n<li><code>alignment</code>参数控制子视图在交叉轴上的对齐方式（对于<code>HStack</code>是垂直对齐，对于<code>VStack</code>是水平对齐）。</li>\n<li><code>spacing</code>参数决定子视图之间的间距。</li>\n</ul>\n<p><strong>对齐和分布</strong></p>\n<p>Stacks的另一个关键特性是对齐。开发者可以非常细致地控制如何对齐子视图：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">HStack</span>(alignment: .top) &#123;<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;顶部对齐&quot;</span>)<br>    <span class=\"hljs-type\">Divider</span>()<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;还是顶部对齐&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在这个<code>HStack</code>中，所有的子视图都会在顶部对齐，即使它们的高度不同。</p>\n<p><strong>总结</strong></p>\n<p>通过理解和利用Stacks，你可以构建出直观且灵活的布局。Stacks的简单性和强大的组合能力，使得它们成为SwiftUI布局的核心工具。它们可以嵌套使用，也可以与其他布局视图和控件配合，以创建出复杂且响应式的用户界面。随着你</p>\n<p>对这些基础布局工具的熟悉和运用，你将能够更加精准地操控空间，为你的应用提供坚实的视觉基础。</p>\n<p><strong>2. 对齐与帧（Alignment and Frames）</strong></p>\n<p>布局的精髓在于如何控制视图的大小和位置。在SwiftUI中，<code>对齐</code>和<code>帧</code>是两个基本但强大的概念，它们定义了视图在父视图中的具体摆放方式。</p>\n<p><strong>理解对齐</strong></p>\n<p>对齐在SwiftUI中是通过对齐指南来实现的，它定义了视图如何根据父视图或兄弟视图的对齐线来定位自己。例如，在一个<code>VStack</code>中，你可以通过<code>alignment</code>参数设置子视图在水平方向上的对齐方式，而在<code>HStack</code>中，这会影响子视图在垂直方向上的对齐。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">HStack</span>(alignment: .bottom) &#123;<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;底部对齐&quot;</span>)<br>    <span class=\"hljs-type\">Image</span>(systemName: <span class=\"hljs-string\">&quot;star&quot;</span>)<br>        .alignmentGuide(.bottom) &#123; d <span class=\"hljs-keyword\">in</span> d[.top] &#125;<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;这个星星将对齐顶部&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在这个例子中，我们通过<code>.alignmentGuide</code>修饰符来改变图像视图的默认对齐行为，使其按照顶部对齐而不是底部。</p>\n<p><strong>使用帧控制视图大小</strong></p>\n<p>帧（frame）允许你为视图设置一个明确的大小或者提供一个理想的大小范围。<code>frame</code>修饰符可以指定宽度（<code>width</code>）、高度（<code>height</code>）、最小宽度（<code>minWidth</code>）、最大宽度（<code>maxWidth</code>）、最小高度（<code>minHeight</code>）、和最大高度（<code>maxHeight</code>）。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;固定大小的文本框&quot;</span>)<br>    .frame(width: <span class=\"hljs-number\">100</span>, height: <span class=\"hljs-number\">100</span>)<br>    .border(<span class=\"hljs-type\">Color</span>.red)<br></code></pre></td></tr></table></figure>\n\n<p>上述代码将文本框的宽度和高度都固定在了100点，无论内容大小如何，文本框都不会改变尺寸。</p>\n<p><strong>对齐和帧的组合使用</strong></p>\n<p>对齐和帧可以组合使用，以创建更复杂的布局效果。例如，你可能想要创建一个宽度固定，但高度根据内容动态调整的文本视图，同时在其内部文本垂直居中对齐。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;垂直居中的文本&quot;</span>)<br>    .frame(minHeight: <span class=\"hljs-number\">0</span>, maxHeight: .infinity)<br>    .frame(width: <span class=\"hljs-number\">200</span>)<br>    .background(<span class=\"hljs-type\">Color</span>.gray)<br>    .alignmentGuide(.vertical) &#123; d <span class=\"hljs-keyword\">in</span><br>        d[<span class=\"hljs-type\">VerticalAlignment</span>.center]<br>    &#125;<br></code></pre></td></tr></table></figure>\n\n<p>这里我们使用了两个<code>frame</code>修饰符：第一个<code>frame</code>确保文本在垂直方向上可以扩展到可用的全部空间，第二个<code>frame</code>则设置了文本的固定宽度。通过<code>alignmentGuide</code>，文本在其框架内垂直居中。</p>\n<p><strong>总结</strong></p>\n<p>对齐和帧是布局时的两个非常重要的概念。通过精确的对齐控制，你可以确保界面元素以一种一致和预期的方式排列。同时，使用帧可以限制和指定视图的大小，无论是固定的还是灵活的。掌握了这些工具，你将能够设计出外观精确且布局合理的界面，即便是面对各种屏幕尺寸和设备方向，你的应用界面也能保持其应有的布局和结构。</p>\n<p><strong>3. Spacer和Divider</strong></p>\n<p>在构建用户界面时，除了直接操纵视图的尺寸和对齐，SwiftUI还提供了用于控制视图间隔的工具：Spacer和Divider。这些工具在进行视图布局时是不可或缺的，它们可以帮助我们创建出更为优雅和灵活的用户界面。</p>\n<p><strong>Spacer: 创建灵活的空间</strong></p>\n<p>Spacer是一个会尽可能占用多余空间的视图。在一个Stack中，Spacer可以推动相邻的视图，使其与Stack的边缘或其他视图保持距离。Spacer本身没有可见的内容，但它可以控制布局的间距。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">HStack</span> &#123;<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;左边&quot;</span>)<br>    <span class=\"hljs-type\">Spacer</span>() <span class=\"hljs-comment\">// 占据所有可用空间</span><br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;右边&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在上述例子中，Spacer位于两个文本视图之间，并推动它们分别靠近水平Stack的左右边缘。</p>\n<p>Spacer的另一个常用场景是在其前后添加修饰符，以控制其最小空间尺寸。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">HStack</span> &#123;<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;左边&quot;</span>)<br>    <span class=\"hljs-type\">Spacer</span>()<br>        .frame(minWidth: <span class=\"hljs-number\">20</span>)<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;右边&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>此时，Spacer至少会创建20点的空间，即使在更大的容器中，它也会扩展以填满额外的空间。</p>\n<p><strong>Divider: 分隔视图</strong></p>\n<p>Divider是一个用于分隔内容的细线，通常在视觉上表示不同部分的内容。它可以在列表、VStack或HStack中作为清晰分界线使用。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">VStack</span> &#123;<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;第一部分&quot;</span>)<br>    <span class=\"hljs-type\">Divider</span>()<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;第二部分&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>Divider会自动采用垂直或水平方向，取决于它所在的Stack类型。在VStack中，它是水平的；而在HStack中，则是垂直的。</p>\n<p><strong>自定义Spacer和Divider</strong></p>\n<p>虽然Spacer和Divider是很好的布局工具，但有时你可能需要更多的自定义。例如，你可以使用背景和框架修饰符来自定义Divider的样式。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Divider</span>()<br>    .background(<span class=\"hljs-type\">Color</span>.blue)<br>    .frame(height: <span class=\"hljs-number\">1</span>)<br></code></pre></td></tr></table></figure>\n\n<p>在这个例子中，我们自定义了Divider的颜色和高度，创建了一个蓝色的分隔线。</p>\n<p>同样，你也可以对Spacer进行类似的自定义。</p>\n<p><strong>总结</strong></p>\n<p>Spacer和Divider是在SwiftUI中创建和维护视图间隙的简单而强大的工具。它们支持布局的灵活性，同时为内容的视觉分隔提供方便。在理解了如何利用Spacer来控制视图的扩展和收缩，以及如何使用Divider来清晰地区分内容之后，你将能够创建出既美观又实用的布局设计。</p>\n<p><strong>4. 布局优先级</strong></p>\n<p>当我们在SwiftUI中构建复杂的界面时，经常会遇到多个视图争抢空间的情况。布局优先级（Layout Priority）是一个高级的概念，它允许我们微调视图如何在父视图中分配额外的空间。理解并正确使用布局优先级，可以帮助我们创建更加精确和高度定制的用户界面。</p>\n<p><strong>基本概念</strong></p>\n<p>在SwiftUI中，所有视图默认具有相同的布局优先级，值为0。当空间不足以满足所有子视图的理想尺寸时，系统会根据布局优先级来决定哪个视图可以首先满足其尺寸需求。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">HStack</span> &#123;<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;非常非常长的文本&quot;</span>).layoutPriority(<span class=\"hljs-number\">1</span>)<br>    <span class=\"hljs-type\">Spacer</span>()<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;短文本&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在这个例子中，第一个<code>Text</code>视图的布局优先级被设置为1，这意味着它在空间分配时会被优先考虑。即使在有限的空间中，它也会尽可能地显示完整的内容，而<code>Spacer</code>和第二个<code>Text</code>视图会相应地压缩。</p>\n<p><strong>布局优先级的使用</strong></p>\n<p>布局优先级的值可以是任意的正浮点数。数值越大，获取额外空间的优先级就越高。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">HStack</span> &#123;<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;需要更多空间的文本&quot;</span>).layoutPriority(<span class=\"hljs-number\">2</span>)<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;不那么重要的文本&quot;</span>).layoutPriority(<span class=\"hljs-number\">1</span>)<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;普通文本&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在上面的代码中，第一个文本视图被赋予了最高的优先级（2），其次是第二个文本视图（1），最后是没有显式设置优先级的文本视图（默认为0）。因此，当空间有限时，第一个文本视图会尽量显示更多的内容。</p>\n<p><strong>布局优先级的策略</strong></p>\n<p>布局优先级通常用于解决视图间的竞争关系，但是它并不是解决所有布局问题的万能钥匙。合理使用布局优先级需要策略，过度依赖可能会导致布局变得难以预测和管理。在设置优先级时，你应当始终考虑内容的重要性以及用户体验。</p>\n<p>一个良好的策略是尽量保持简单，只在确实需要时调整布局优先级。并且，始终牢记布局的整体目标是创造既满足设计需求又对用户友好的界面。</p>\n<p><strong>结合其他布局工具</strong></p>\n<p>布局优先级并不孤立工作，它应该与其他布局工具一起使用，例如<code>frame</code>、<code>alignment</code>、<code>Spacer</code>等。在实际开发中，你会发现布局优先级是与其他布局概念协同工作的，比如使用<code>fixedSize</code>来防止视图被压缩，或者与<code>flexible</code>结合来调整视图的压缩和扩展行为。</p>\n<p><strong>总结</strong></p>\n<p>掌握了布局优先级的概念和使用方法后，我们就能更加精细地控制SwiftUI布局的行为。正确的布局优先级设置能够确保重要的内容得到展示，辅助视图适应剩余空间，从而创造出既直观又富有层次的用户界面。在设计复杂的布局时，优先级的细微调整可以带来显著的视觉和体验改善。</p>\n"},{"title":"SwiftUI核心技术第7章导航与呈现","date":"2023-11-08T01:09:18.000Z","_content":"**第7章：导航与呈现**\n\n**1. NavigationView和NavigationViewLink**\n\n在SwiftUI中，`NavigationView`和`NavigationLink`组合起来使用，提供了一个强大的导航框架，让我们可以构建具有层次结构的页面间跳转。它们的设计遵循了SwiftUI的声明式语法，使得页面跳转和数据传递变得直观和易于管理。\n\n**NavigationView**\n\n`NavigationView`是一个容器视图，它承载着你的视图层次结构，并提供了展示这些视图的空间。你可以把它看作是页面导航的起点。通常，一个`NavigationView`包含一个或多个`View`，这些`View`可以通过`NavigationLink`来进行跳转。\n\n```swift\nNavigationView {\n    List(selection: $selectedItem) {\n        NavigationLink(destination: DetailView(item: item)) {\n            Text(item.title)\n        }\n    }\n    .navigationBarTitle(Text(\"Items\"))\n}\n```\n\n在这个例子中，`NavigationView`包含了一个列表，列表中的每一项都绑定了一个`NavigationLink`，点击时将展示`DetailView`。\n\n**NavigationLink**\n\n`NavigationLink`负责在`NavigationView`中触发页面跳转。它有多个初始化方法，可以根据需求选择使用。最基本的用法是提供一个目标视图和触发跳转的内容。\n\n```swift\nNavigationLink(destination: DetailView(item: item)) {\n    Text(item.title)\n}\n```\n\n这里`NavigationLink`的目的地是`DetailView`，用户点击列表项上的`Text`时会触发导航到`DetailView`。\n\n**激活和反激活链接**\n\n`NavigationLink`可以与SwiftUI的状态绑定，以编程方式激活或反激活导航。通过在`NavigationLink`初始化时传递一个布尔型的绑定，你可以控制导航的行为。\n\n```swift\n@State private var isLinkActive = false\n\nvar body: some View {\n    NavigationView {\n        NavigationLink(destination: DetailView(), isActive: $isLinkActive) {\n            Button(\"Go to Details\") {\n                self.isLinkActive = true\n            }\n        }\n    }\n}\n```\n\n在这个例子中，一个按钮被用来激活`NavigationLink`。当用户点击按钮，`isLinkActive`状态变为`true`，触发导航到`DetailView`。\n\n**传递数据**\n\n在导航过程中，你可能需要向目的地视图传递数据。`NavigationLink`的`destination`参数让你可以轻松做到这一点。\n\n```swift\nNavigationLink(destination: DetailView(item: item)) {\n    ItemRow(item: item)\n}\n```\n\n在这里，每个`ItemRow`是一个列表中的行，它带有一个与之关联的`item`数据模型。点击`ItemRow`时，`item`将被传递到`DetailView`。\n\n**小结**\n\n`NavigationView`和`NavigationLink`构成了SwiftUI中页面导航的基石。它们的使用方式灵活而强大，支持各种复杂的导航模式。通过声明式语法，我们可以更专注于视图的内容和业务逻辑，而不是导航的细节。本章节的后续部分将探讨更高级的导航模式，如使用`TabView`和`modal`呈现，以及如何处理数据传递和状态管理。\n\n\n**2. TabView**\n\n在构建一个用户界面时，底部的标签栏是一种常见的设计，允许用户轻松切换不同的视图或功能模块。在SwiftUI中，这可以通过`TabView`来实现。`TabView`为应用提供了一个选项卡式的界面，每个选项卡都代表了一个视图。\n\n**基本用法**\n\n`TabView`的基本用法涉及到声明式地列出每一个选项卡，并使用`tabItem`修饰符来定义每个标签的外观，通常包括图标和文本。\n\n```swift\nTabView {\n    Text(\"首页\")\n        .tabItem {\n            Image(systemName: \"house\")\n            Text(\"Home\")\n        }\n    \n    Text(\"设置\")\n        .tabItem {\n            Image(systemName: \"gear\")\n            Text(\"Settings\")\n        }\n}\n```\n\n在这个简单的例子中，`TabView`包含了两个选项卡：“首页”和“设置”，每个选项卡都是用`Text`视图表示的，并且有对应的系统图标。\n\n**选项卡状态管理**\n\n`TabView`可以与`@State`变量绑定，从而允许你编程方式控制当前激活的选项卡。\n\n```swift\n@State private var selectedTab = 0\n\nvar body: some View {\n    TabView(selection: $selectedTab) {\n        HomeView()\n            .tabItem {\n                Image(systemName: \"house\")\n                Text(\"Home\")\n            }\n            .tag(0)\n        \n        SettingsView()\n            .tabItem {\n                Image(systemName: \"gear\")\n                Text(\"Settings\")\n            }\n            .tag(1)\n    }\n}\n```\n\n在上述代码中，`selectedTab`绑定到`TabView`的`selection`参数。通过改变`selectedTab`的值，你可以改变当前选中的标签页。\n\n**自定义外观**\n\n`TabView`的外观可以通过多种方式进行自定义。例如，可以使用`.accentColor`来改变选中标签的颜色。\n\n```swift\nTabView {\n    // ... 你的选项卡\n}\n.accentColor(.green)\n```\n\n**结合NavigationView使用**\n\n在`TabView`内部，你可能还会嵌入`NavigationView`，以在选项卡内部提供导航堆栈。\n\n```swift\nTabView {\n    NavigationView {\n        HomeView()\n    }\n    .tabItem {\n        Image(systemName: \"house\")\n        Text(\"Home\")\n    }\n    // ... 其他选项卡\n}\n```\n\n这样做可以确保每个选项卡都能拥有独立的导航历史，这对于用户体验非常重要。\n\n**使用场景**\n\n`TabView`在很多类型的应用中都非常有用。它是构建具有多个独立部分的应用的理想选择，例如社交网络应用、具有个人中心、消息、设置等的应用。\n\n**小结**\n\n通过本节的介绍，我们了解了如何使用`TabView`创建具有多个交互式选项卡的界面。`TabView`不仅提供了高度的可定制性，还能够很好地与其他视图和数据流模式协同工作。在接下来的小节中，我们将继续探索更多关于SwiftUI中视图呈现和数据流管理的先进概念。\n\n\n**3. Sheets和Alerts**\n\n在构建应用时，弹出视图和警告框（Alerts）是与用户交互的重要方式。在SwiftUI中，这通常通过使用`Sheet`和`Alert`视图完成。\n\n**Sheets**\n\nSheet是一种覆盖在当前内容上的卡片样式视图，通常用于导航流程之外的辅助任务，比如表单填写、设置选项等。\n\n**创建Sheet**\n\n要创建一个Sheet，你需要使用`.sheet`修饰符，并为其提供一个绑定的布尔值，这个布尔值决定Sheet是否可见。\n\n```swift\n@State private var showingSheet = false\n\nvar body: some View {\n    Button(\"Show Sheet\") {\n        showingSheet.toggle()\n    }\n    .sheet(isPresented: $showingSheet) {\n        // Sheet的内容\n        Text(\"Here's the Sheet\")\n    }\n}\n```\n\n**自定义Sheet**\n\nSheet的内容可以是任意视图。例如，你可以创建一个包含表单的`NavigationView`。\n\n```swift\n.sheet(isPresented: $showingSheet) {\n    NavigationView {\n        Form {\n            // 表单内容\n        }\n        .navigationBarTitle(\"Settings\", displayMode: .inline)\n        .navigationBarItems(trailing: Button(\"Done\") {\n            showingSheet = false\n        })\n    }\n}\n```\n\n**使用Sheet实现细节**\n\n在内部，Sheet会自动管理自己的显示和隐藏。你可以将`showingSheet`绑定到视图的某个状态或者对象的属性上，当这个属性变化时，对应的Sheet会自动显示或隐藏。\n\n**Alerts**\n\nAlerts用于显示重要信息，并可以提供一个或多个操作选项。\n\n**创建Alert**\n\n和Sheet类似，Alert也使用绑定的布尔值来控制显示状态。不过，创建Alert时，通常还会指定标题、消息和按钮。\n\n```swift\n@State private var showingAlert = false\n\nvar body: some View {\n    Button(\"Show Alert\") {\n        showingAlert = true\n    }\n    .alert(isPresented: $showingAlert) {\n        Alert(\n            title: Text(\"Warning\"),\n            message: Text(\"Are you sure?\"),\n            primaryButton: .destructive(Text(\"Delete\")) {\n                // 删除操作\n            },\n            secondaryButton: .cancel()\n        )\n    }\n}\n```\n\n**Alert的样式**\n\nAlert可以有多种样式，从简单的带有单一按钮的Alert到复杂的带有多个按钮和自定义操作的Alert。\n\n**小结**\n\nSheet和Alert都是在SwiftUI中管理临时视图和用户交互的重要工具。通过合理使用这两种视图，你可以创建出既直观又有效的用户体验。正如我们所见，SwiftUI提供的`.sheet`和`.alert`修饰符让这两种视图的展示和管理变得十分简单。在接下来的章节中，我们将深入探讨如何利用SwiftUI的高级特性来构建更为复杂的用户交互界面。\n\n\n**4. Navigation的高级用法**\n\nSwiftUI的导航系统提供了一种直观且声明式的方法来处理视图间的转换。除了基础的`NavigationView`和`NavigationLink`之外，我们还可以采用更高级的用法来增强用户体验和视图的灵活性。\n\n**程序化导航**\n\n在某些情况下，你可能需要从视图模型或响应某个事件时进行导航。这可以通过绑定到视图模型中的属性并使用`NavigationLink`的`isActive`参数实现。\n\n```swift\nclass ViewModel: ObservableObject {\n    @Published var isDetailViewActive = false\n}\n\nstruct ContentView: View {\n    @StateObject var viewModel = ViewModel()\n\n    var body: some View {\n        NavigationView {\n            NavigationLink(destination: DetailView(), isActive: $viewModel.isDetailViewActive) { \n                EmptyView()\n            }\n            Button(\"Go to Details\") {\n                viewModel.isDetailViewActive = true\n            }\n        }\n    }\n}\n```\n\n**隐藏和显示导航栏**\n\n在用户界面中，有时候我们需要隐藏导航栏来提供沉浸式体验，或者我们需要在特定的视图中改变导航栏的显示方式。\n\n```swift\nstruct DetailView: View {\n    var body: some View {\n        // 隐藏导航栏\n        .navigationBarHidden(true)\n        // 在视图即将出现时设置导航栏样式\n        .onAppear {\n            // 设置导航栏样式\n        }\n    }\n}\n```\n\n**自定义后退按钮行为**\n\n有时默认的后退按钮行为并不符合我们的需要。在SwiftUI中，我们可以通过添加一个自定义的按钮并绑定其行为来覆盖默认的后退按钮。\n\n```swift\nstruct CustomBackButtonView: View {\n    @Environment(\\.presentationMode) var presentationMode\n\n    var body: some View {\n        Button(action: {\n            // 执行自定义后退操作\n            presentationMode.wrappedValue.dismiss()\n        }) {\n            HStack {\n                Image(systemName: \"arrow.left\")\n                Text(\"Back\")\n            }\n        }\n    }\n}\n```\n\n**深度链接**\n\n深度链接是指直接导航到应用内部的某个特定页面的链接。在SwiftUI中，我们可以监听来自URL的深度链接，并根据链接的内容导航到相应的视图。\n\n```swift\n.onOpenURL { url in\n    // 解析URL并进行导航\n}\n```\n\n**嵌套导航**\n\n在构建复杂的界面时，我们可能会需要嵌套多个`NavigationView`。虽然这在用户界面上并不常见，但在特定的设计中可能是必要的。嵌套导航需要细心处理，以确保导航栈的正确和流畅的用户体验。\n\n```swift\nNavigationView {\n    // 主界面\n    NavigationView {\n        // 嵌套的子界面\n    }\n}\n```\n\n**小结**\n\n通过上述高级导航功能，开发者可以在SwiftUI中创建复杂且具有出色用户体验的导航流。这些高级技巧的掌握可以帮助你更好地管理视图层级和导航逻辑，让应用的导航更加直观和响应用户操作。在后续章节中，我们将探索如何将这些高级导航技巧与应用的其它部分相结合，以构建完整且功能丰富的应用程序。","source":"_posts/SwiftUI核心技术第7章导航与呈现.md","raw":"---\ntitle: SwiftUI核心技术第7章导航与呈现\ndate: 2023-11-08 09:09:18\ncategories:\n- SwiftUI\ntags:\n---\n**第7章：导航与呈现**\n\n**1. NavigationView和NavigationViewLink**\n\n在SwiftUI中，`NavigationView`和`NavigationLink`组合起来使用，提供了一个强大的导航框架，让我们可以构建具有层次结构的页面间跳转。它们的设计遵循了SwiftUI的声明式语法，使得页面跳转和数据传递变得直观和易于管理。\n\n**NavigationView**\n\n`NavigationView`是一个容器视图，它承载着你的视图层次结构，并提供了展示这些视图的空间。你可以把它看作是页面导航的起点。通常，一个`NavigationView`包含一个或多个`View`，这些`View`可以通过`NavigationLink`来进行跳转。\n\n```swift\nNavigationView {\n    List(selection: $selectedItem) {\n        NavigationLink(destination: DetailView(item: item)) {\n            Text(item.title)\n        }\n    }\n    .navigationBarTitle(Text(\"Items\"))\n}\n```\n\n在这个例子中，`NavigationView`包含了一个列表，列表中的每一项都绑定了一个`NavigationLink`，点击时将展示`DetailView`。\n\n**NavigationLink**\n\n`NavigationLink`负责在`NavigationView`中触发页面跳转。它有多个初始化方法，可以根据需求选择使用。最基本的用法是提供一个目标视图和触发跳转的内容。\n\n```swift\nNavigationLink(destination: DetailView(item: item)) {\n    Text(item.title)\n}\n```\n\n这里`NavigationLink`的目的地是`DetailView`，用户点击列表项上的`Text`时会触发导航到`DetailView`。\n\n**激活和反激活链接**\n\n`NavigationLink`可以与SwiftUI的状态绑定，以编程方式激活或反激活导航。通过在`NavigationLink`初始化时传递一个布尔型的绑定，你可以控制导航的行为。\n\n```swift\n@State private var isLinkActive = false\n\nvar body: some View {\n    NavigationView {\n        NavigationLink(destination: DetailView(), isActive: $isLinkActive) {\n            Button(\"Go to Details\") {\n                self.isLinkActive = true\n            }\n        }\n    }\n}\n```\n\n在这个例子中，一个按钮被用来激活`NavigationLink`。当用户点击按钮，`isLinkActive`状态变为`true`，触发导航到`DetailView`。\n\n**传递数据**\n\n在导航过程中，你可能需要向目的地视图传递数据。`NavigationLink`的`destination`参数让你可以轻松做到这一点。\n\n```swift\nNavigationLink(destination: DetailView(item: item)) {\n    ItemRow(item: item)\n}\n```\n\n在这里，每个`ItemRow`是一个列表中的行，它带有一个与之关联的`item`数据模型。点击`ItemRow`时，`item`将被传递到`DetailView`。\n\n**小结**\n\n`NavigationView`和`NavigationLink`构成了SwiftUI中页面导航的基石。它们的使用方式灵活而强大，支持各种复杂的导航模式。通过声明式语法，我们可以更专注于视图的内容和业务逻辑，而不是导航的细节。本章节的后续部分将探讨更高级的导航模式，如使用`TabView`和`modal`呈现，以及如何处理数据传递和状态管理。\n\n\n**2. TabView**\n\n在构建一个用户界面时，底部的标签栏是一种常见的设计，允许用户轻松切换不同的视图或功能模块。在SwiftUI中，这可以通过`TabView`来实现。`TabView`为应用提供了一个选项卡式的界面，每个选项卡都代表了一个视图。\n\n**基本用法**\n\n`TabView`的基本用法涉及到声明式地列出每一个选项卡，并使用`tabItem`修饰符来定义每个标签的外观，通常包括图标和文本。\n\n```swift\nTabView {\n    Text(\"首页\")\n        .tabItem {\n            Image(systemName: \"house\")\n            Text(\"Home\")\n        }\n    \n    Text(\"设置\")\n        .tabItem {\n            Image(systemName: \"gear\")\n            Text(\"Settings\")\n        }\n}\n```\n\n在这个简单的例子中，`TabView`包含了两个选项卡：“首页”和“设置”，每个选项卡都是用`Text`视图表示的，并且有对应的系统图标。\n\n**选项卡状态管理**\n\n`TabView`可以与`@State`变量绑定，从而允许你编程方式控制当前激活的选项卡。\n\n```swift\n@State private var selectedTab = 0\n\nvar body: some View {\n    TabView(selection: $selectedTab) {\n        HomeView()\n            .tabItem {\n                Image(systemName: \"house\")\n                Text(\"Home\")\n            }\n            .tag(0)\n        \n        SettingsView()\n            .tabItem {\n                Image(systemName: \"gear\")\n                Text(\"Settings\")\n            }\n            .tag(1)\n    }\n}\n```\n\n在上述代码中，`selectedTab`绑定到`TabView`的`selection`参数。通过改变`selectedTab`的值，你可以改变当前选中的标签页。\n\n**自定义外观**\n\n`TabView`的外观可以通过多种方式进行自定义。例如，可以使用`.accentColor`来改变选中标签的颜色。\n\n```swift\nTabView {\n    // ... 你的选项卡\n}\n.accentColor(.green)\n```\n\n**结合NavigationView使用**\n\n在`TabView`内部，你可能还会嵌入`NavigationView`，以在选项卡内部提供导航堆栈。\n\n```swift\nTabView {\n    NavigationView {\n        HomeView()\n    }\n    .tabItem {\n        Image(systemName: \"house\")\n        Text(\"Home\")\n    }\n    // ... 其他选项卡\n}\n```\n\n这样做可以确保每个选项卡都能拥有独立的导航历史，这对于用户体验非常重要。\n\n**使用场景**\n\n`TabView`在很多类型的应用中都非常有用。它是构建具有多个独立部分的应用的理想选择，例如社交网络应用、具有个人中心、消息、设置等的应用。\n\n**小结**\n\n通过本节的介绍，我们了解了如何使用`TabView`创建具有多个交互式选项卡的界面。`TabView`不仅提供了高度的可定制性，还能够很好地与其他视图和数据流模式协同工作。在接下来的小节中，我们将继续探索更多关于SwiftUI中视图呈现和数据流管理的先进概念。\n\n\n**3. Sheets和Alerts**\n\n在构建应用时，弹出视图和警告框（Alerts）是与用户交互的重要方式。在SwiftUI中，这通常通过使用`Sheet`和`Alert`视图完成。\n\n**Sheets**\n\nSheet是一种覆盖在当前内容上的卡片样式视图，通常用于导航流程之外的辅助任务，比如表单填写、设置选项等。\n\n**创建Sheet**\n\n要创建一个Sheet，你需要使用`.sheet`修饰符，并为其提供一个绑定的布尔值，这个布尔值决定Sheet是否可见。\n\n```swift\n@State private var showingSheet = false\n\nvar body: some View {\n    Button(\"Show Sheet\") {\n        showingSheet.toggle()\n    }\n    .sheet(isPresented: $showingSheet) {\n        // Sheet的内容\n        Text(\"Here's the Sheet\")\n    }\n}\n```\n\n**自定义Sheet**\n\nSheet的内容可以是任意视图。例如，你可以创建一个包含表单的`NavigationView`。\n\n```swift\n.sheet(isPresented: $showingSheet) {\n    NavigationView {\n        Form {\n            // 表单内容\n        }\n        .navigationBarTitle(\"Settings\", displayMode: .inline)\n        .navigationBarItems(trailing: Button(\"Done\") {\n            showingSheet = false\n        })\n    }\n}\n```\n\n**使用Sheet实现细节**\n\n在内部，Sheet会自动管理自己的显示和隐藏。你可以将`showingSheet`绑定到视图的某个状态或者对象的属性上，当这个属性变化时，对应的Sheet会自动显示或隐藏。\n\n**Alerts**\n\nAlerts用于显示重要信息，并可以提供一个或多个操作选项。\n\n**创建Alert**\n\n和Sheet类似，Alert也使用绑定的布尔值来控制显示状态。不过，创建Alert时，通常还会指定标题、消息和按钮。\n\n```swift\n@State private var showingAlert = false\n\nvar body: some View {\n    Button(\"Show Alert\") {\n        showingAlert = true\n    }\n    .alert(isPresented: $showingAlert) {\n        Alert(\n            title: Text(\"Warning\"),\n            message: Text(\"Are you sure?\"),\n            primaryButton: .destructive(Text(\"Delete\")) {\n                // 删除操作\n            },\n            secondaryButton: .cancel()\n        )\n    }\n}\n```\n\n**Alert的样式**\n\nAlert可以有多种样式，从简单的带有单一按钮的Alert到复杂的带有多个按钮和自定义操作的Alert。\n\n**小结**\n\nSheet和Alert都是在SwiftUI中管理临时视图和用户交互的重要工具。通过合理使用这两种视图，你可以创建出既直观又有效的用户体验。正如我们所见，SwiftUI提供的`.sheet`和`.alert`修饰符让这两种视图的展示和管理变得十分简单。在接下来的章节中，我们将深入探讨如何利用SwiftUI的高级特性来构建更为复杂的用户交互界面。\n\n\n**4. Navigation的高级用法**\n\nSwiftUI的导航系统提供了一种直观且声明式的方法来处理视图间的转换。除了基础的`NavigationView`和`NavigationLink`之外，我们还可以采用更高级的用法来增强用户体验和视图的灵活性。\n\n**程序化导航**\n\n在某些情况下，你可能需要从视图模型或响应某个事件时进行导航。这可以通过绑定到视图模型中的属性并使用`NavigationLink`的`isActive`参数实现。\n\n```swift\nclass ViewModel: ObservableObject {\n    @Published var isDetailViewActive = false\n}\n\nstruct ContentView: View {\n    @StateObject var viewModel = ViewModel()\n\n    var body: some View {\n        NavigationView {\n            NavigationLink(destination: DetailView(), isActive: $viewModel.isDetailViewActive) { \n                EmptyView()\n            }\n            Button(\"Go to Details\") {\n                viewModel.isDetailViewActive = true\n            }\n        }\n    }\n}\n```\n\n**隐藏和显示导航栏**\n\n在用户界面中，有时候我们需要隐藏导航栏来提供沉浸式体验，或者我们需要在特定的视图中改变导航栏的显示方式。\n\n```swift\nstruct DetailView: View {\n    var body: some View {\n        // 隐藏导航栏\n        .navigationBarHidden(true)\n        // 在视图即将出现时设置导航栏样式\n        .onAppear {\n            // 设置导航栏样式\n        }\n    }\n}\n```\n\n**自定义后退按钮行为**\n\n有时默认的后退按钮行为并不符合我们的需要。在SwiftUI中，我们可以通过添加一个自定义的按钮并绑定其行为来覆盖默认的后退按钮。\n\n```swift\nstruct CustomBackButtonView: View {\n    @Environment(\\.presentationMode) var presentationMode\n\n    var body: some View {\n        Button(action: {\n            // 执行自定义后退操作\n            presentationMode.wrappedValue.dismiss()\n        }) {\n            HStack {\n                Image(systemName: \"arrow.left\")\n                Text(\"Back\")\n            }\n        }\n    }\n}\n```\n\n**深度链接**\n\n深度链接是指直接导航到应用内部的某个特定页面的链接。在SwiftUI中，我们可以监听来自URL的深度链接，并根据链接的内容导航到相应的视图。\n\n```swift\n.onOpenURL { url in\n    // 解析URL并进行导航\n}\n```\n\n**嵌套导航**\n\n在构建复杂的界面时，我们可能会需要嵌套多个`NavigationView`。虽然这在用户界面上并不常见，但在特定的设计中可能是必要的。嵌套导航需要细心处理，以确保导航栈的正确和流畅的用户体验。\n\n```swift\nNavigationView {\n    // 主界面\n    NavigationView {\n        // 嵌套的子界面\n    }\n}\n```\n\n**小结**\n\n通过上述高级导航功能，开发者可以在SwiftUI中创建复杂且具有出色用户体验的导航流。这些高级技巧的掌握可以帮助你更好地管理视图层级和导航逻辑，让应用的导航更加直观和响应用户操作。在后续章节中，我们将探索如何将这些高级导航技巧与应用的其它部分相结合，以构建完整且功能丰富的应用程序。","slug":"SwiftUI核心技术第7章导航与呈现","published":1,"updated":"2024-03-17T06:11:38.648Z","comments":1,"layout":"post","photos":[],"_id":"clu6up53j002iz674hgqse1h1","content":"<p><strong>第7章：导航与呈现</strong></p>\n<p><strong>1. NavigationView和NavigationViewLink</strong></p>\n<p>在SwiftUI中，<code>NavigationView</code>和<code>NavigationLink</code>组合起来使用，提供了一个强大的导航框架，让我们可以构建具有层次结构的页面间跳转。它们的设计遵循了SwiftUI的声明式语法，使得页面跳转和数据传递变得直观和易于管理。</p>\n<p><strong>NavigationView</strong></p>\n<p><code>NavigationView</code>是一个容器视图，它承载着你的视图层次结构，并提供了展示这些视图的空间。你可以把它看作是页面导航的起点。通常，一个<code>NavigationView</code>包含一个或多个<code>View</code>，这些<code>View</code>可以通过<code>NavigationLink</code>来进行跳转。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">NavigationView</span> &#123;<br>    <span class=\"hljs-type\">List</span>(selection: <span class=\"hljs-variable\">$selectedItem</span>) &#123;<br>        <span class=\"hljs-type\">NavigationLink</span>(destination: <span class=\"hljs-type\">DetailView</span>(item: item)) &#123;<br>            <span class=\"hljs-type\">Text</span>(item.title)<br>        &#125;<br>    &#125;<br>    .navigationBarTitle(<span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Items&quot;</span>))<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在这个例子中，<code>NavigationView</code>包含了一个列表，列表中的每一项都绑定了一个<code>NavigationLink</code>，点击时将展示<code>DetailView</code>。</p>\n<p><strong>NavigationLink</strong></p>\n<p><code>NavigationLink</code>负责在<code>NavigationView</code>中触发页面跳转。它有多个初始化方法，可以根据需求选择使用。最基本的用法是提供一个目标视图和触发跳转的内容。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">NavigationLink</span>(destination: <span class=\"hljs-type\">DetailView</span>(item: item)) &#123;<br>    <span class=\"hljs-type\">Text</span>(item.title)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这里<code>NavigationLink</code>的目的地是<code>DetailView</code>，用户点击列表项上的<code>Text</code>时会触发导航到<code>DetailView</code>。</p>\n<p><strong>激活和反激活链接</strong></p>\n<p><code>NavigationLink</code>可以与SwiftUI的状态绑定，以编程方式激活或反激活导航。通过在<code>NavigationLink</code>初始化时传递一个布尔型的绑定，你可以控制导航的行为。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> isLinkActive <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">false</span><br><br><span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>    <span class=\"hljs-type\">NavigationView</span> &#123;<br>        <span class=\"hljs-type\">NavigationLink</span>(destination: <span class=\"hljs-type\">DetailView</span>(), isActive: <span class=\"hljs-variable\">$isLinkActive</span>) &#123;<br>            <span class=\"hljs-type\">Button</span>(<span class=\"hljs-string\">&quot;Go to Details&quot;</span>) &#123;<br>                <span class=\"hljs-keyword\">self</span>.isLinkActive <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">true</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在这个例子中，一个按钮被用来激活<code>NavigationLink</code>。当用户点击按钮，<code>isLinkActive</code>状态变为<code>true</code>，触发导航到<code>DetailView</code>。</p>\n<p><strong>传递数据</strong></p>\n<p>在导航过程中，你可能需要向目的地视图传递数据。<code>NavigationLink</code>的<code>destination</code>参数让你可以轻松做到这一点。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">NavigationLink</span>(destination: <span class=\"hljs-type\">DetailView</span>(item: item)) &#123;<br>    <span class=\"hljs-type\">ItemRow</span>(item: item)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在这里，每个<code>ItemRow</code>是一个列表中的行，它带有一个与之关联的<code>item</code>数据模型。点击<code>ItemRow</code>时，<code>item</code>将被传递到<code>DetailView</code>。</p>\n<p><strong>小结</strong></p>\n<p><code>NavigationView</code>和<code>NavigationLink</code>构成了SwiftUI中页面导航的基石。它们的使用方式灵活而强大，支持各种复杂的导航模式。通过声明式语法，我们可以更专注于视图的内容和业务逻辑，而不是导航的细节。本章节的后续部分将探讨更高级的导航模式，如使用<code>TabView</code>和<code>modal</code>呈现，以及如何处理数据传递和状态管理。</p>\n<p><strong>2. TabView</strong></p>\n<p>在构建一个用户界面时，底部的标签栏是一种常见的设计，允许用户轻松切换不同的视图或功能模块。在SwiftUI中，这可以通过<code>TabView</code>来实现。<code>TabView</code>为应用提供了一个选项卡式的界面，每个选项卡都代表了一个视图。</p>\n<p><strong>基本用法</strong></p>\n<p><code>TabView</code>的基本用法涉及到声明式地列出每一个选项卡，并使用<code>tabItem</code>修饰符来定义每个标签的外观，通常包括图标和文本。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">TabView</span> &#123;<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;首页&quot;</span>)<br>        .tabItem &#123;<br>            <span class=\"hljs-type\">Image</span>(systemName: <span class=\"hljs-string\">&quot;house&quot;</span>)<br>            <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Home&quot;</span>)<br>        &#125;<br>    <br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;设置&quot;</span>)<br>        .tabItem &#123;<br>            <span class=\"hljs-type\">Image</span>(systemName: <span class=\"hljs-string\">&quot;gear&quot;</span>)<br>            <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Settings&quot;</span>)<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在这个简单的例子中，<code>TabView</code>包含了两个选项卡：“首页”和“设置”，每个选项卡都是用<code>Text</code>视图表示的，并且有对应的系统图标。</p>\n<p><strong>选项卡状态管理</strong></p>\n<p><code>TabView</code>可以与<code>@State</code>变量绑定，从而允许你编程方式控制当前激活的选项卡。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> selectedTab <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span><br><br><span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>    <span class=\"hljs-type\">TabView</span>(selection: <span class=\"hljs-variable\">$selectedTab</span>) &#123;<br>        <span class=\"hljs-type\">HomeView</span>()<br>            .tabItem &#123;<br>                <span class=\"hljs-type\">Image</span>(systemName: <span class=\"hljs-string\">&quot;house&quot;</span>)<br>                <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Home&quot;</span>)<br>            &#125;<br>            .tag(<span class=\"hljs-number\">0</span>)<br>        <br>        <span class=\"hljs-type\">SettingsView</span>()<br>            .tabItem &#123;<br>                <span class=\"hljs-type\">Image</span>(systemName: <span class=\"hljs-string\">&quot;gear&quot;</span>)<br>                <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Settings&quot;</span>)<br>            &#125;<br>            .tag(<span class=\"hljs-number\">1</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在上述代码中，<code>selectedTab</code>绑定到<code>TabView</code>的<code>selection</code>参数。通过改变<code>selectedTab</code>的值，你可以改变当前选中的标签页。</p>\n<p><strong>自定义外观</strong></p>\n<p><code>TabView</code>的外观可以通过多种方式进行自定义。例如，可以使用<code>.accentColor</code>来改变选中标签的颜色。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">TabView</span> &#123;<br>    <span class=\"hljs-comment\">// ... 你的选项卡</span><br>&#125;<br>.accentColor(.green)<br></code></pre></td></tr></table></figure>\n\n<p><strong>结合NavigationView使用</strong></p>\n<p>在<code>TabView</code>内部，你可能还会嵌入<code>NavigationView</code>，以在选项卡内部提供导航堆栈。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">TabView</span> &#123;<br>    <span class=\"hljs-type\">NavigationView</span> &#123;<br>        <span class=\"hljs-type\">HomeView</span>()<br>    &#125;<br>    .tabItem &#123;<br>        <span class=\"hljs-type\">Image</span>(systemName: <span class=\"hljs-string\">&quot;house&quot;</span>)<br>        <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Home&quot;</span>)<br>    &#125;<br>    <span class=\"hljs-comment\">// ... 其他选项卡</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这样做可以确保每个选项卡都能拥有独立的导航历史，这对于用户体验非常重要。</p>\n<p><strong>使用场景</strong></p>\n<p><code>TabView</code>在很多类型的应用中都非常有用。它是构建具有多个独立部分的应用的理想选择，例如社交网络应用、具有个人中心、消息、设置等的应用。</p>\n<p><strong>小结</strong></p>\n<p>通过本节的介绍，我们了解了如何使用<code>TabView</code>创建具有多个交互式选项卡的界面。<code>TabView</code>不仅提供了高度的可定制性，还能够很好地与其他视图和数据流模式协同工作。在接下来的小节中，我们将继续探索更多关于SwiftUI中视图呈现和数据流管理的先进概念。</p>\n<p><strong>3. Sheets和Alerts</strong></p>\n<p>在构建应用时，弹出视图和警告框（Alerts）是与用户交互的重要方式。在SwiftUI中，这通常通过使用<code>Sheet</code>和<code>Alert</code>视图完成。</p>\n<p><strong>Sheets</strong></p>\n<p>Sheet是一种覆盖在当前内容上的卡片样式视图，通常用于导航流程之外的辅助任务，比如表单填写、设置选项等。</p>\n<p><strong>创建Sheet</strong></p>\n<p>要创建一个Sheet，你需要使用<code>.sheet</code>修饰符，并为其提供一个绑定的布尔值，这个布尔值决定Sheet是否可见。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> showingSheet <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">false</span><br><br><span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>    <span class=\"hljs-type\">Button</span>(<span class=\"hljs-string\">&quot;Show Sheet&quot;</span>) &#123;<br>        showingSheet.toggle()<br>    &#125;<br>    .sheet(isPresented: <span class=\"hljs-variable\">$showingSheet</span>) &#123;<br>        <span class=\"hljs-comment\">// Sheet的内容</span><br>        <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Here&#x27;s the Sheet&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>自定义Sheet</strong></p>\n<p>Sheet的内容可以是任意视图。例如，你可以创建一个包含表单的<code>NavigationView</code>。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\">.sheet(isPresented: <span class=\"hljs-variable\">$showingSheet</span>) &#123;<br>    <span class=\"hljs-type\">NavigationView</span> &#123;<br>        <span class=\"hljs-type\">Form</span> &#123;<br>            <span class=\"hljs-comment\">// 表单内容</span><br>        &#125;<br>        .navigationBarTitle(<span class=\"hljs-string\">&quot;Settings&quot;</span>, displayMode: .inline)<br>        .navigationBarItems(trailing: <span class=\"hljs-type\">Button</span>(<span class=\"hljs-string\">&quot;Done&quot;</span>) &#123;<br>            showingSheet <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">false</span><br>        &#125;)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>使用Sheet实现细节</strong></p>\n<p>在内部，Sheet会自动管理自己的显示和隐藏。你可以将<code>showingSheet</code>绑定到视图的某个状态或者对象的属性上，当这个属性变化时，对应的Sheet会自动显示或隐藏。</p>\n<p><strong>Alerts</strong></p>\n<p>Alerts用于显示重要信息，并可以提供一个或多个操作选项。</p>\n<p><strong>创建Alert</strong></p>\n<p>和Sheet类似，Alert也使用绑定的布尔值来控制显示状态。不过，创建Alert时，通常还会指定标题、消息和按钮。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> showingAlert <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">false</span><br><br><span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>    <span class=\"hljs-type\">Button</span>(<span class=\"hljs-string\">&quot;Show Alert&quot;</span>) &#123;<br>        showingAlert <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">true</span><br>    &#125;<br>    .alert(isPresented: <span class=\"hljs-variable\">$showingAlert</span>) &#123;<br>        <span class=\"hljs-type\">Alert</span>(<br>            title: <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Warning&quot;</span>),<br>            message: <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Are you sure?&quot;</span>),<br>            primaryButton: .destructive(<span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Delete&quot;</span>)) &#123;<br>                <span class=\"hljs-comment\">// 删除操作</span><br>            &#125;,<br>            secondaryButton: .cancel()<br>        )<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>Alert的样式</strong></p>\n<p>Alert可以有多种样式，从简单的带有单一按钮的Alert到复杂的带有多个按钮和自定义操作的Alert。</p>\n<p><strong>小结</strong></p>\n<p>Sheet和Alert都是在SwiftUI中管理临时视图和用户交互的重要工具。通过合理使用这两种视图，你可以创建出既直观又有效的用户体验。正如我们所见，SwiftUI提供的<code>.sheet</code>和<code>.alert</code>修饰符让这两种视图的展示和管理变得十分简单。在接下来的章节中，我们将深入探讨如何利用SwiftUI的高级特性来构建更为复杂的用户交互界面。</p>\n<p><strong>4. Navigation的高级用法</strong></p>\n<p>SwiftUI的导航系统提供了一种直观且声明式的方法来处理视图间的转换。除了基础的<code>NavigationView</code>和<code>NavigationLink</code>之外，我们还可以采用更高级的用法来增强用户体验和视图的灵活性。</p>\n<p><strong>程序化导航</strong></p>\n<p>在某些情况下，你可能需要从视图模型或响应某个事件时进行导航。这可以通过绑定到视图模型中的属性并使用<code>NavigationLink</code>的<code>isActive</code>参数实现。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ViewModel</span>: <span class=\"hljs-title class_\">ObservableObject</span> &#123;<br>    <span class=\"hljs-meta\">@Published</span> <span class=\"hljs-keyword\">var</span> isDetailViewActive <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">false</span><br>&#125;<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ContentView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@StateObject</span> <span class=\"hljs-keyword\">var</span> viewModel <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">ViewModel</span>()<br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">NavigationView</span> &#123;<br>            <span class=\"hljs-type\">NavigationLink</span>(destination: <span class=\"hljs-type\">DetailView</span>(), isActive: <span class=\"hljs-variable\">$viewModel</span>.isDetailViewActive) &#123; <br>                <span class=\"hljs-type\">EmptyView</span>()<br>            &#125;<br>            <span class=\"hljs-type\">Button</span>(<span class=\"hljs-string\">&quot;Go to Details&quot;</span>) &#123;<br>                viewModel.isDetailViewActive <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">true</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>隐藏和显示导航栏</strong></p>\n<p>在用户界面中，有时候我们需要隐藏导航栏来提供沉浸式体验，或者我们需要在特定的视图中改变导航栏的显示方式。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">DetailView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-comment\">// 隐藏导航栏</span><br>        .navigationBarHidden(<span class=\"hljs-literal\">true</span>)<br>        <span class=\"hljs-comment\">// 在视图即将出现时设置导航栏样式</span><br>        .onAppear &#123;<br>            <span class=\"hljs-comment\">// 设置导航栏样式</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>自定义后退按钮行为</strong></p>\n<p>有时默认的后退按钮行为并不符合我们的需要。在SwiftUI中，我们可以通过添加一个自定义的按钮并绑定其行为来覆盖默认的后退按钮。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">CustomBackButtonView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@Environment</span>(\\.presentationMode) <span class=\"hljs-keyword\">var</span> presentationMode<br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">Button</span>(action: &#123;<br>            <span class=\"hljs-comment\">// 执行自定义后退操作</span><br>            presentationMode.wrappedValue.dismiss()<br>        &#125;) &#123;<br>            <span class=\"hljs-type\">HStack</span> &#123;<br>                <span class=\"hljs-type\">Image</span>(systemName: <span class=\"hljs-string\">&quot;arrow.left&quot;</span>)<br>                <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Back&quot;</span>)<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>深度链接</strong></p>\n<p>深度链接是指直接导航到应用内部的某个特定页面的链接。在SwiftUI中，我们可以监听来自URL的深度链接，并根据链接的内容导航到相应的视图。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\">.onOpenURL &#123; url <span class=\"hljs-keyword\">in</span><br>    <span class=\"hljs-comment\">// 解析URL并进行导航</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>嵌套导航</strong></p>\n<p>在构建复杂的界面时，我们可能会需要嵌套多个<code>NavigationView</code>。虽然这在用户界面上并不常见，但在特定的设计中可能是必要的。嵌套导航需要细心处理，以确保导航栈的正确和流畅的用户体验。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">NavigationView</span> &#123;<br>    <span class=\"hljs-comment\">// 主界面</span><br>    <span class=\"hljs-type\">NavigationView</span> &#123;<br>        <span class=\"hljs-comment\">// 嵌套的子界面</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>小结</strong></p>\n<p>通过上述高级导航功能，开发者可以在SwiftUI中创建复杂且具有出色用户体验的导航流。这些高级技巧的掌握可以帮助你更好地管理视图层级和导航逻辑，让应用的导航更加直观和响应用户操作。在后续章节中，我们将探索如何将这些高级导航技巧与应用的其它部分相结合，以构建完整且功能丰富的应用程序。</p>\n","excerpt":"","more":"<p><strong>第7章：导航与呈现</strong></p>\n<p><strong>1. NavigationView和NavigationViewLink</strong></p>\n<p>在SwiftUI中，<code>NavigationView</code>和<code>NavigationLink</code>组合起来使用，提供了一个强大的导航框架，让我们可以构建具有层次结构的页面间跳转。它们的设计遵循了SwiftUI的声明式语法，使得页面跳转和数据传递变得直观和易于管理。</p>\n<p><strong>NavigationView</strong></p>\n<p><code>NavigationView</code>是一个容器视图，它承载着你的视图层次结构，并提供了展示这些视图的空间。你可以把它看作是页面导航的起点。通常，一个<code>NavigationView</code>包含一个或多个<code>View</code>，这些<code>View</code>可以通过<code>NavigationLink</code>来进行跳转。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">NavigationView</span> &#123;<br>    <span class=\"hljs-type\">List</span>(selection: <span class=\"hljs-variable\">$selectedItem</span>) &#123;<br>        <span class=\"hljs-type\">NavigationLink</span>(destination: <span class=\"hljs-type\">DetailView</span>(item: item)) &#123;<br>            <span class=\"hljs-type\">Text</span>(item.title)<br>        &#125;<br>    &#125;<br>    .navigationBarTitle(<span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Items&quot;</span>))<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在这个例子中，<code>NavigationView</code>包含了一个列表，列表中的每一项都绑定了一个<code>NavigationLink</code>，点击时将展示<code>DetailView</code>。</p>\n<p><strong>NavigationLink</strong></p>\n<p><code>NavigationLink</code>负责在<code>NavigationView</code>中触发页面跳转。它有多个初始化方法，可以根据需求选择使用。最基本的用法是提供一个目标视图和触发跳转的内容。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">NavigationLink</span>(destination: <span class=\"hljs-type\">DetailView</span>(item: item)) &#123;<br>    <span class=\"hljs-type\">Text</span>(item.title)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这里<code>NavigationLink</code>的目的地是<code>DetailView</code>，用户点击列表项上的<code>Text</code>时会触发导航到<code>DetailView</code>。</p>\n<p><strong>激活和反激活链接</strong></p>\n<p><code>NavigationLink</code>可以与SwiftUI的状态绑定，以编程方式激活或反激活导航。通过在<code>NavigationLink</code>初始化时传递一个布尔型的绑定，你可以控制导航的行为。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> isLinkActive <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">false</span><br><br><span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>    <span class=\"hljs-type\">NavigationView</span> &#123;<br>        <span class=\"hljs-type\">NavigationLink</span>(destination: <span class=\"hljs-type\">DetailView</span>(), isActive: <span class=\"hljs-variable\">$isLinkActive</span>) &#123;<br>            <span class=\"hljs-type\">Button</span>(<span class=\"hljs-string\">&quot;Go to Details&quot;</span>) &#123;<br>                <span class=\"hljs-keyword\">self</span>.isLinkActive <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">true</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在这个例子中，一个按钮被用来激活<code>NavigationLink</code>。当用户点击按钮，<code>isLinkActive</code>状态变为<code>true</code>，触发导航到<code>DetailView</code>。</p>\n<p><strong>传递数据</strong></p>\n<p>在导航过程中，你可能需要向目的地视图传递数据。<code>NavigationLink</code>的<code>destination</code>参数让你可以轻松做到这一点。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">NavigationLink</span>(destination: <span class=\"hljs-type\">DetailView</span>(item: item)) &#123;<br>    <span class=\"hljs-type\">ItemRow</span>(item: item)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在这里，每个<code>ItemRow</code>是一个列表中的行，它带有一个与之关联的<code>item</code>数据模型。点击<code>ItemRow</code>时，<code>item</code>将被传递到<code>DetailView</code>。</p>\n<p><strong>小结</strong></p>\n<p><code>NavigationView</code>和<code>NavigationLink</code>构成了SwiftUI中页面导航的基石。它们的使用方式灵活而强大，支持各种复杂的导航模式。通过声明式语法，我们可以更专注于视图的内容和业务逻辑，而不是导航的细节。本章节的后续部分将探讨更高级的导航模式，如使用<code>TabView</code>和<code>modal</code>呈现，以及如何处理数据传递和状态管理。</p>\n<p><strong>2. TabView</strong></p>\n<p>在构建一个用户界面时，底部的标签栏是一种常见的设计，允许用户轻松切换不同的视图或功能模块。在SwiftUI中，这可以通过<code>TabView</code>来实现。<code>TabView</code>为应用提供了一个选项卡式的界面，每个选项卡都代表了一个视图。</p>\n<p><strong>基本用法</strong></p>\n<p><code>TabView</code>的基本用法涉及到声明式地列出每一个选项卡，并使用<code>tabItem</code>修饰符来定义每个标签的外观，通常包括图标和文本。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">TabView</span> &#123;<br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;首页&quot;</span>)<br>        .tabItem &#123;<br>            <span class=\"hljs-type\">Image</span>(systemName: <span class=\"hljs-string\">&quot;house&quot;</span>)<br>            <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Home&quot;</span>)<br>        &#125;<br>    <br>    <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;设置&quot;</span>)<br>        .tabItem &#123;<br>            <span class=\"hljs-type\">Image</span>(systemName: <span class=\"hljs-string\">&quot;gear&quot;</span>)<br>            <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Settings&quot;</span>)<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在这个简单的例子中，<code>TabView</code>包含了两个选项卡：“首页”和“设置”，每个选项卡都是用<code>Text</code>视图表示的，并且有对应的系统图标。</p>\n<p><strong>选项卡状态管理</strong></p>\n<p><code>TabView</code>可以与<code>@State</code>变量绑定，从而允许你编程方式控制当前激活的选项卡。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> selectedTab <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span><br><br><span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>    <span class=\"hljs-type\">TabView</span>(selection: <span class=\"hljs-variable\">$selectedTab</span>) &#123;<br>        <span class=\"hljs-type\">HomeView</span>()<br>            .tabItem &#123;<br>                <span class=\"hljs-type\">Image</span>(systemName: <span class=\"hljs-string\">&quot;house&quot;</span>)<br>                <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Home&quot;</span>)<br>            &#125;<br>            .tag(<span class=\"hljs-number\">0</span>)<br>        <br>        <span class=\"hljs-type\">SettingsView</span>()<br>            .tabItem &#123;<br>                <span class=\"hljs-type\">Image</span>(systemName: <span class=\"hljs-string\">&quot;gear&quot;</span>)<br>                <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Settings&quot;</span>)<br>            &#125;<br>            .tag(<span class=\"hljs-number\">1</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在上述代码中，<code>selectedTab</code>绑定到<code>TabView</code>的<code>selection</code>参数。通过改变<code>selectedTab</code>的值，你可以改变当前选中的标签页。</p>\n<p><strong>自定义外观</strong></p>\n<p><code>TabView</code>的外观可以通过多种方式进行自定义。例如，可以使用<code>.accentColor</code>来改变选中标签的颜色。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">TabView</span> &#123;<br>    <span class=\"hljs-comment\">// ... 你的选项卡</span><br>&#125;<br>.accentColor(.green)<br></code></pre></td></tr></table></figure>\n\n<p><strong>结合NavigationView使用</strong></p>\n<p>在<code>TabView</code>内部，你可能还会嵌入<code>NavigationView</code>，以在选项卡内部提供导航堆栈。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">TabView</span> &#123;<br>    <span class=\"hljs-type\">NavigationView</span> &#123;<br>        <span class=\"hljs-type\">HomeView</span>()<br>    &#125;<br>    .tabItem &#123;<br>        <span class=\"hljs-type\">Image</span>(systemName: <span class=\"hljs-string\">&quot;house&quot;</span>)<br>        <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Home&quot;</span>)<br>    &#125;<br>    <span class=\"hljs-comment\">// ... 其他选项卡</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这样做可以确保每个选项卡都能拥有独立的导航历史，这对于用户体验非常重要。</p>\n<p><strong>使用场景</strong></p>\n<p><code>TabView</code>在很多类型的应用中都非常有用。它是构建具有多个独立部分的应用的理想选择，例如社交网络应用、具有个人中心、消息、设置等的应用。</p>\n<p><strong>小结</strong></p>\n<p>通过本节的介绍，我们了解了如何使用<code>TabView</code>创建具有多个交互式选项卡的界面。<code>TabView</code>不仅提供了高度的可定制性，还能够很好地与其他视图和数据流模式协同工作。在接下来的小节中，我们将继续探索更多关于SwiftUI中视图呈现和数据流管理的先进概念。</p>\n<p><strong>3. Sheets和Alerts</strong></p>\n<p>在构建应用时，弹出视图和警告框（Alerts）是与用户交互的重要方式。在SwiftUI中，这通常通过使用<code>Sheet</code>和<code>Alert</code>视图完成。</p>\n<p><strong>Sheets</strong></p>\n<p>Sheet是一种覆盖在当前内容上的卡片样式视图，通常用于导航流程之外的辅助任务，比如表单填写、设置选项等。</p>\n<p><strong>创建Sheet</strong></p>\n<p>要创建一个Sheet，你需要使用<code>.sheet</code>修饰符，并为其提供一个绑定的布尔值，这个布尔值决定Sheet是否可见。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> showingSheet <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">false</span><br><br><span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>    <span class=\"hljs-type\">Button</span>(<span class=\"hljs-string\">&quot;Show Sheet&quot;</span>) &#123;<br>        showingSheet.toggle()<br>    &#125;<br>    .sheet(isPresented: <span class=\"hljs-variable\">$showingSheet</span>) &#123;<br>        <span class=\"hljs-comment\">// Sheet的内容</span><br>        <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Here&#x27;s the Sheet&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>自定义Sheet</strong></p>\n<p>Sheet的内容可以是任意视图。例如，你可以创建一个包含表单的<code>NavigationView</code>。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\">.sheet(isPresented: <span class=\"hljs-variable\">$showingSheet</span>) &#123;<br>    <span class=\"hljs-type\">NavigationView</span> &#123;<br>        <span class=\"hljs-type\">Form</span> &#123;<br>            <span class=\"hljs-comment\">// 表单内容</span><br>        &#125;<br>        .navigationBarTitle(<span class=\"hljs-string\">&quot;Settings&quot;</span>, displayMode: .inline)<br>        .navigationBarItems(trailing: <span class=\"hljs-type\">Button</span>(<span class=\"hljs-string\">&quot;Done&quot;</span>) &#123;<br>            showingSheet <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">false</span><br>        &#125;)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>使用Sheet实现细节</strong></p>\n<p>在内部，Sheet会自动管理自己的显示和隐藏。你可以将<code>showingSheet</code>绑定到视图的某个状态或者对象的属性上，当这个属性变化时，对应的Sheet会自动显示或隐藏。</p>\n<p><strong>Alerts</strong></p>\n<p>Alerts用于显示重要信息，并可以提供一个或多个操作选项。</p>\n<p><strong>创建Alert</strong></p>\n<p>和Sheet类似，Alert也使用绑定的布尔值来控制显示状态。不过，创建Alert时，通常还会指定标题、消息和按钮。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> showingAlert <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">false</span><br><br><span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>    <span class=\"hljs-type\">Button</span>(<span class=\"hljs-string\">&quot;Show Alert&quot;</span>) &#123;<br>        showingAlert <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">true</span><br>    &#125;<br>    .alert(isPresented: <span class=\"hljs-variable\">$showingAlert</span>) &#123;<br>        <span class=\"hljs-type\">Alert</span>(<br>            title: <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Warning&quot;</span>),<br>            message: <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Are you sure?&quot;</span>),<br>            primaryButton: .destructive(<span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Delete&quot;</span>)) &#123;<br>                <span class=\"hljs-comment\">// 删除操作</span><br>            &#125;,<br>            secondaryButton: .cancel()<br>        )<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>Alert的样式</strong></p>\n<p>Alert可以有多种样式，从简单的带有单一按钮的Alert到复杂的带有多个按钮和自定义操作的Alert。</p>\n<p><strong>小结</strong></p>\n<p>Sheet和Alert都是在SwiftUI中管理临时视图和用户交互的重要工具。通过合理使用这两种视图，你可以创建出既直观又有效的用户体验。正如我们所见，SwiftUI提供的<code>.sheet</code>和<code>.alert</code>修饰符让这两种视图的展示和管理变得十分简单。在接下来的章节中，我们将深入探讨如何利用SwiftUI的高级特性来构建更为复杂的用户交互界面。</p>\n<p><strong>4. Navigation的高级用法</strong></p>\n<p>SwiftUI的导航系统提供了一种直观且声明式的方法来处理视图间的转换。除了基础的<code>NavigationView</code>和<code>NavigationLink</code>之外，我们还可以采用更高级的用法来增强用户体验和视图的灵活性。</p>\n<p><strong>程序化导航</strong></p>\n<p>在某些情况下，你可能需要从视图模型或响应某个事件时进行导航。这可以通过绑定到视图模型中的属性并使用<code>NavigationLink</code>的<code>isActive</code>参数实现。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ViewModel</span>: <span class=\"hljs-title class_\">ObservableObject</span> &#123;<br>    <span class=\"hljs-meta\">@Published</span> <span class=\"hljs-keyword\">var</span> isDetailViewActive <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">false</span><br>&#125;<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ContentView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@StateObject</span> <span class=\"hljs-keyword\">var</span> viewModel <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">ViewModel</span>()<br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">NavigationView</span> &#123;<br>            <span class=\"hljs-type\">NavigationLink</span>(destination: <span class=\"hljs-type\">DetailView</span>(), isActive: <span class=\"hljs-variable\">$viewModel</span>.isDetailViewActive) &#123; <br>                <span class=\"hljs-type\">EmptyView</span>()<br>            &#125;<br>            <span class=\"hljs-type\">Button</span>(<span class=\"hljs-string\">&quot;Go to Details&quot;</span>) &#123;<br>                viewModel.isDetailViewActive <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">true</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>隐藏和显示导航栏</strong></p>\n<p>在用户界面中，有时候我们需要隐藏导航栏来提供沉浸式体验，或者我们需要在特定的视图中改变导航栏的显示方式。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">DetailView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-comment\">// 隐藏导航栏</span><br>        .navigationBarHidden(<span class=\"hljs-literal\">true</span>)<br>        <span class=\"hljs-comment\">// 在视图即将出现时设置导航栏样式</span><br>        .onAppear &#123;<br>            <span class=\"hljs-comment\">// 设置导航栏样式</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>自定义后退按钮行为</strong></p>\n<p>有时默认的后退按钮行为并不符合我们的需要。在SwiftUI中，我们可以通过添加一个自定义的按钮并绑定其行为来覆盖默认的后退按钮。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">CustomBackButtonView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@Environment</span>(\\.presentationMode) <span class=\"hljs-keyword\">var</span> presentationMode<br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">Button</span>(action: &#123;<br>            <span class=\"hljs-comment\">// 执行自定义后退操作</span><br>            presentationMode.wrappedValue.dismiss()<br>        &#125;) &#123;<br>            <span class=\"hljs-type\">HStack</span> &#123;<br>                <span class=\"hljs-type\">Image</span>(systemName: <span class=\"hljs-string\">&quot;arrow.left&quot;</span>)<br>                <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Back&quot;</span>)<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>深度链接</strong></p>\n<p>深度链接是指直接导航到应用内部的某个特定页面的链接。在SwiftUI中，我们可以监听来自URL的深度链接，并根据链接的内容导航到相应的视图。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\">.onOpenURL &#123; url <span class=\"hljs-keyword\">in</span><br>    <span class=\"hljs-comment\">// 解析URL并进行导航</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>嵌套导航</strong></p>\n<p>在构建复杂的界面时，我们可能会需要嵌套多个<code>NavigationView</code>。虽然这在用户界面上并不常见，但在特定的设计中可能是必要的。嵌套导航需要细心处理，以确保导航栈的正确和流畅的用户体验。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">NavigationView</span> &#123;<br>    <span class=\"hljs-comment\">// 主界面</span><br>    <span class=\"hljs-type\">NavigationView</span> &#123;<br>        <span class=\"hljs-comment\">// 嵌套的子界面</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>小结</strong></p>\n<p>通过上述高级导航功能，开发者可以在SwiftUI中创建复杂且具有出色用户体验的导航流。这些高级技巧的掌握可以帮助你更好地管理视图层级和导航逻辑，让应用的导航更加直观和响应用户操作。在后续章节中，我们将探索如何将这些高级导航技巧与应用的其它部分相结合，以构建完整且功能丰富的应用程序。</p>\n"},{"title":"SwiftUI核心技术第13章性能优化","date":"2023-11-08T01:43:56.000Z","_content":"**第13章：性能优化**\n\n**第1小节：诊断和解决性能问题**\n\n性能优化是软件开发中的关键步骤，特别是对于那些要求快速响应和流畅体验的应用。性能问题可能是由许多因素造成的，包括但不限于内存泄漏、过度渲染、网络延迟或者不高效的数据结构和算法。有效的性能优化往往从准确诊断问题开始。\n\n### 1. 性能评估\n\n在深入代码优化之前，首先要进行一个全面的性能评估。使用Xcode自带的Instrument工具可以帮助检测应用的CPU使用率、内存泄漏、能耗和网络性能等。\n\n### 2. 识别瓶颈\n\n在性能评估之后，需要确定应用中的性能瓶颈。通过分析Instruments的报告，可以识别出CPU和内存的高消耗区域。对于图形密集型的应用，可能还需要检查GPU的使用情况。\n\n### 3. 代码分析与调优\n\n一旦确定了瓶颈，就可以开始针对性的代码优化了。这可能包括：\n\n- **优化算法和数据结构**：改进或替换那些复杂度高的算法和数据结构。\n- **减少计算量**：避免不必要的计算，特别是在渲染和布局的过程中。\n- **异步执行**：使用异步编程模式来避免UI线程阻塞。\n- **资源优化**：优化图像和资源的加载，确保它们是压缩的且以正确的尺寸使用。\n\n### 4. 内存管理\n\n内存问题，尤其是内存泄漏，是性能问题的常见原因。使用ARC（自动引用计数）应该是管理内存的首选方法，但开发者仍需避免循环引用，及时释放不再使用的对象。\n\n### 5. 网络优化\n\n应用的响应时间很大程度上受网络状况的影响。通过优化API调用，使用缓存和数据预加载技术，可以显著提高性能。\n\n### 6. 测试与监控\n\n- **单元测试**：编写单元测试来确保代码的效率。\n- **性能测试**：模拟高负载情况下应用的表现。\n- **监控**：发布应用后，继续监控其性能，并根据用户反馈和数据进行调整。\n\n### 7. 优化策略\n\n- **延迟加载**：只有当需要时才加载数据或执行计算。\n- **预计算和缓存**：预计算重复计算的结果并进行缓存。\n- **复用和回收**：在可能的情况下复用对象和视图。\n\n### 8. 持续优化\n\n性能优化不是一次性的任务，而是一个持续的过程。随着应用的发展和用户基础的增长，应持续关注性能指标，并进行相应的优化。\n\n通过遵循上述步骤，开发者可以诊断出性能问题的根本原因，并采取相应的措施来解决问题。从用户体验的角度出发，提升应用的性能将直接影响到应用的成功与否。\n\n\n**第2小节：延迟加载和内存管理**\n\n在移动应用开发中，高效的内存使用是至关重要的。用户设备的内存资源有限，如果应用消耗过多内存，会影响用户体验，并可能导致应用被系统终止。延迟加载（Lazy Loading）和精心的内存管理是优化应用性能的关键策略。\n\n### 延迟加载（Lazy Loading）\n\n延迟加载是一种在需要时才加载数据或对象到内存的策略。这种方法可以减少应用的启动时间，降低内存消耗，提高整体性能。\n\n#### 实施延迟加载的策略：\n\n1. **按需实例化**：仅当确实需要显示或处理某个对象时，才创建该对象的实例。\n2. **视图渲染优化**：对于列表和滚动视图，可以使用如SwiftUI的`LazyVStack`和`LazyHStack`，这些组件能确保只有那些在屏幕上的视图才会被加载和渲染。\n3. **数据获取**：对于网络请求，可以实现预加载和按页面分段加载数据，避免一次性加载大量数据。\n4. **资源管理**：对图像和视频等大型文件进行按需加载，并考虑实现缓存机制。\n\n### 内存管理\n\n良好的内存管理可以避免内存泄漏和过度消耗，从而提高应用性能。\n\n#### 内存管理的关键点：\n\n1. **自动引用计数（ARC）**：理解并正确使用ARC是必要的，避免循环引用和内存泄漏。\n2. **弱引用和无主引用**：在闭包和委托模式中使用`weak`和`unowned`关键字来避免强引用循环。\n3. **资源释放**：及时释放不再需要的对象，特别是在处理大型对象和文件时。\n4. **内存警告处理**：正确处理内存警告，释放可以释放的资源，避免应用被系统终止。\n5. **内存分析工具**：使用Xcode的Memory Graph Debugger和Leaks工具定期检查内存问题。\n\n#### 实施内存管理的技术：\n\n- **使用`deinit`进行清理**：当对象被销毁时，确保释放它持有的资源。\n- **缓存策略**：智能地实施缓存策略，既要提高数据访问的效率，又要避免过度消耗内存。\n- **内存池**：对于频繁创建和销毁的小对象，可以使用内存池来管理。\n- **对象复用**：例如，在UITableView中复用cell，而不是每次都创建新的cell。\n\n通过延迟加载和内存管理，开发者可以显著提高应用的性能和用户体验。理解和正确实现这些概念将使应用在不同设备和操作系统上更加稳定和流畅。\n\n\n**第3小节：视图更新效率优化**\n\n在现代移动应用中，保持流畅的用户界面至关重要。在SwiftUI中，视图更新的效率直接影响到用户体验。这一小节将探讨如何优化视图更新的效率。\n\n### 理解视图更新机制\n\n首先，我们需要理解SwiftUI是如何处理视图更新的。SwiftUI视图是声明式的，这意味着你定义的是视图的期望状态，而非状态变化的过程。当视图的状态发生变化时，SwiftUI会重新计算视图的body属性。\n\n#### 管理状态变化\n\n- **最小化状态变化**：确保只有真正需要更新的视图状态时才进行更改。\n- **精确的观察**：使用`@State`、`@Binding`、`@ObservedObject`和`@EnvironmentObject`智能地观察模型的变化。\n\n### 避免不必要的视图更新\n\n不必要的视图重建会浪费资源并降低性能。\n\n#### 实现策略：\n\n1. **合理使用`Equatable`**：对于自定义视图，实现`Equatable`协议并在`shouldUpdate`中提供差异对比，以避免相同状态时的重建。\n2. **条件式视图更新**：通过逻辑判断确保只有当状态确实改变时才更新视图。\n3. **局部更新**：使用`.id()`修饰符或其他方式来提示SwiftUI哪些部分的视图是稳定的，不需要重建。\n\n### 高效的数据流\n\n数据流向视图的方式也影响更新效率。\n\n#### 优化数据流的方法：\n\n- **使用`@State`进行本地状态管理**：对于视图私有的状态，使用`@State`来进行本地化管理。\n- **利用`@ObservedObject`和`@EnvironmentObject`共享状态**：对于需要在多个视图间共享的状态，可以使用这些属性包装器。\n\n### 性能分析工具\n\n使用Xcode提供的性能分析工具来查找性能瓶颈。\n\n#### 分析方法：\n\n1. **时间分析器**：利用Xcode的时间分析器查看哪些部分的代码耗时最多。\n2. **SwiftUI预览性能检查**：在SwiftUI预览中测试视图更新，观察是否有延迟。\n\n### 最佳实践\n\n- **延迟复杂计算**：对于复杂的视图计算，可以考虑将其推迟到视图显示之后的背景线程。\n- **异步图片加载**：对于图片和其他媒体资源，使用异步加载以避免阻塞UI线程。\n- **智能组件分割**：将复杂视图拆分成更小的、可以独立更新的组件。\n\n通过以上策略，可以确保SwiftUI应用中的视图更新是高效的，从而提供流畅的用户体验。记住，性能调优是一个持续的过程，定期的性能评测和分析是非常必要的。","source":"_posts/SwiftUI核心技术第13章性能优化.md","raw":"---\ntitle: SwiftUI核心技术第13章性能优化\ndate: 2023-11-08 09:43:56\ncategories:\n- SwiftUI\ntags:\n---\n**第13章：性能优化**\n\n**第1小节：诊断和解决性能问题**\n\n性能优化是软件开发中的关键步骤，特别是对于那些要求快速响应和流畅体验的应用。性能问题可能是由许多因素造成的，包括但不限于内存泄漏、过度渲染、网络延迟或者不高效的数据结构和算法。有效的性能优化往往从准确诊断问题开始。\n\n### 1. 性能评估\n\n在深入代码优化之前，首先要进行一个全面的性能评估。使用Xcode自带的Instrument工具可以帮助检测应用的CPU使用率、内存泄漏、能耗和网络性能等。\n\n### 2. 识别瓶颈\n\n在性能评估之后，需要确定应用中的性能瓶颈。通过分析Instruments的报告，可以识别出CPU和内存的高消耗区域。对于图形密集型的应用，可能还需要检查GPU的使用情况。\n\n### 3. 代码分析与调优\n\n一旦确定了瓶颈，就可以开始针对性的代码优化了。这可能包括：\n\n- **优化算法和数据结构**：改进或替换那些复杂度高的算法和数据结构。\n- **减少计算量**：避免不必要的计算，特别是在渲染和布局的过程中。\n- **异步执行**：使用异步编程模式来避免UI线程阻塞。\n- **资源优化**：优化图像和资源的加载，确保它们是压缩的且以正确的尺寸使用。\n\n### 4. 内存管理\n\n内存问题，尤其是内存泄漏，是性能问题的常见原因。使用ARC（自动引用计数）应该是管理内存的首选方法，但开发者仍需避免循环引用，及时释放不再使用的对象。\n\n### 5. 网络优化\n\n应用的响应时间很大程度上受网络状况的影响。通过优化API调用，使用缓存和数据预加载技术，可以显著提高性能。\n\n### 6. 测试与监控\n\n- **单元测试**：编写单元测试来确保代码的效率。\n- **性能测试**：模拟高负载情况下应用的表现。\n- **监控**：发布应用后，继续监控其性能，并根据用户反馈和数据进行调整。\n\n### 7. 优化策略\n\n- **延迟加载**：只有当需要时才加载数据或执行计算。\n- **预计算和缓存**：预计算重复计算的结果并进行缓存。\n- **复用和回收**：在可能的情况下复用对象和视图。\n\n### 8. 持续优化\n\n性能优化不是一次性的任务，而是一个持续的过程。随着应用的发展和用户基础的增长，应持续关注性能指标，并进行相应的优化。\n\n通过遵循上述步骤，开发者可以诊断出性能问题的根本原因，并采取相应的措施来解决问题。从用户体验的角度出发，提升应用的性能将直接影响到应用的成功与否。\n\n\n**第2小节：延迟加载和内存管理**\n\n在移动应用开发中，高效的内存使用是至关重要的。用户设备的内存资源有限，如果应用消耗过多内存，会影响用户体验，并可能导致应用被系统终止。延迟加载（Lazy Loading）和精心的内存管理是优化应用性能的关键策略。\n\n### 延迟加载（Lazy Loading）\n\n延迟加载是一种在需要时才加载数据或对象到内存的策略。这种方法可以减少应用的启动时间，降低内存消耗，提高整体性能。\n\n#### 实施延迟加载的策略：\n\n1. **按需实例化**：仅当确实需要显示或处理某个对象时，才创建该对象的实例。\n2. **视图渲染优化**：对于列表和滚动视图，可以使用如SwiftUI的`LazyVStack`和`LazyHStack`，这些组件能确保只有那些在屏幕上的视图才会被加载和渲染。\n3. **数据获取**：对于网络请求，可以实现预加载和按页面分段加载数据，避免一次性加载大量数据。\n4. **资源管理**：对图像和视频等大型文件进行按需加载，并考虑实现缓存机制。\n\n### 内存管理\n\n良好的内存管理可以避免内存泄漏和过度消耗，从而提高应用性能。\n\n#### 内存管理的关键点：\n\n1. **自动引用计数（ARC）**：理解并正确使用ARC是必要的，避免循环引用和内存泄漏。\n2. **弱引用和无主引用**：在闭包和委托模式中使用`weak`和`unowned`关键字来避免强引用循环。\n3. **资源释放**：及时释放不再需要的对象，特别是在处理大型对象和文件时。\n4. **内存警告处理**：正确处理内存警告，释放可以释放的资源，避免应用被系统终止。\n5. **内存分析工具**：使用Xcode的Memory Graph Debugger和Leaks工具定期检查内存问题。\n\n#### 实施内存管理的技术：\n\n- **使用`deinit`进行清理**：当对象被销毁时，确保释放它持有的资源。\n- **缓存策略**：智能地实施缓存策略，既要提高数据访问的效率，又要避免过度消耗内存。\n- **内存池**：对于频繁创建和销毁的小对象，可以使用内存池来管理。\n- **对象复用**：例如，在UITableView中复用cell，而不是每次都创建新的cell。\n\n通过延迟加载和内存管理，开发者可以显著提高应用的性能和用户体验。理解和正确实现这些概念将使应用在不同设备和操作系统上更加稳定和流畅。\n\n\n**第3小节：视图更新效率优化**\n\n在现代移动应用中，保持流畅的用户界面至关重要。在SwiftUI中，视图更新的效率直接影响到用户体验。这一小节将探讨如何优化视图更新的效率。\n\n### 理解视图更新机制\n\n首先，我们需要理解SwiftUI是如何处理视图更新的。SwiftUI视图是声明式的，这意味着你定义的是视图的期望状态，而非状态变化的过程。当视图的状态发生变化时，SwiftUI会重新计算视图的body属性。\n\n#### 管理状态变化\n\n- **最小化状态变化**：确保只有真正需要更新的视图状态时才进行更改。\n- **精确的观察**：使用`@State`、`@Binding`、`@ObservedObject`和`@EnvironmentObject`智能地观察模型的变化。\n\n### 避免不必要的视图更新\n\n不必要的视图重建会浪费资源并降低性能。\n\n#### 实现策略：\n\n1. **合理使用`Equatable`**：对于自定义视图，实现`Equatable`协议并在`shouldUpdate`中提供差异对比，以避免相同状态时的重建。\n2. **条件式视图更新**：通过逻辑判断确保只有当状态确实改变时才更新视图。\n3. **局部更新**：使用`.id()`修饰符或其他方式来提示SwiftUI哪些部分的视图是稳定的，不需要重建。\n\n### 高效的数据流\n\n数据流向视图的方式也影响更新效率。\n\n#### 优化数据流的方法：\n\n- **使用`@State`进行本地状态管理**：对于视图私有的状态，使用`@State`来进行本地化管理。\n- **利用`@ObservedObject`和`@EnvironmentObject`共享状态**：对于需要在多个视图间共享的状态，可以使用这些属性包装器。\n\n### 性能分析工具\n\n使用Xcode提供的性能分析工具来查找性能瓶颈。\n\n#### 分析方法：\n\n1. **时间分析器**：利用Xcode的时间分析器查看哪些部分的代码耗时最多。\n2. **SwiftUI预览性能检查**：在SwiftUI预览中测试视图更新，观察是否有延迟。\n\n### 最佳实践\n\n- **延迟复杂计算**：对于复杂的视图计算，可以考虑将其推迟到视图显示之后的背景线程。\n- **异步图片加载**：对于图片和其他媒体资源，使用异步加载以避免阻塞UI线程。\n- **智能组件分割**：将复杂视图拆分成更小的、可以独立更新的组件。\n\n通过以上策略，可以确保SwiftUI应用中的视图更新是高效的，从而提供流畅的用户体验。记住，性能调优是一个持续的过程，定期的性能评测和分析是非常必要的。","slug":"SwiftUI核心技术第13章性能优化","published":1,"updated":"2024-03-17T06:11:58.265Z","comments":1,"layout":"post","photos":[],"_id":"clu6up53j002kz674hmee6gix","content":"<p><strong>第13章：性能优化</strong></p>\n<p><strong>第1小节：诊断和解决性能问题</strong></p>\n<p>性能优化是软件开发中的关键步骤，特别是对于那些要求快速响应和流畅体验的应用。性能问题可能是由许多因素造成的，包括但不限于内存泄漏、过度渲染、网络延迟或者不高效的数据结构和算法。有效的性能优化往往从准确诊断问题开始。</p>\n<h3 id=\"1-性能评估\"><a href=\"#1-性能评估\" class=\"headerlink\" title=\"1. 性能评估\"></a>1. 性能评估</h3><p>在深入代码优化之前，首先要进行一个全面的性能评估。使用Xcode自带的Instrument工具可以帮助检测应用的CPU使用率、内存泄漏、能耗和网络性能等。</p>\n<h3 id=\"2-识别瓶颈\"><a href=\"#2-识别瓶颈\" class=\"headerlink\" title=\"2. 识别瓶颈\"></a>2. 识别瓶颈</h3><p>在性能评估之后，需要确定应用中的性能瓶颈。通过分析Instruments的报告，可以识别出CPU和内存的高消耗区域。对于图形密集型的应用，可能还需要检查GPU的使用情况。</p>\n<h3 id=\"3-代码分析与调优\"><a href=\"#3-代码分析与调优\" class=\"headerlink\" title=\"3. 代码分析与调优\"></a>3. 代码分析与调优</h3><p>一旦确定了瓶颈，就可以开始针对性的代码优化了。这可能包括：</p>\n<ul>\n<li><strong>优化算法和数据结构</strong>：改进或替换那些复杂度高的算法和数据结构。</li>\n<li><strong>减少计算量</strong>：避免不必要的计算，特别是在渲染和布局的过程中。</li>\n<li><strong>异步执行</strong>：使用异步编程模式来避免UI线程阻塞。</li>\n<li><strong>资源优化</strong>：优化图像和资源的加载，确保它们是压缩的且以正确的尺寸使用。</li>\n</ul>\n<h3 id=\"4-内存管理\"><a href=\"#4-内存管理\" class=\"headerlink\" title=\"4. 内存管理\"></a>4. 内存管理</h3><p>内存问题，尤其是内存泄漏，是性能问题的常见原因。使用ARC（自动引用计数）应该是管理内存的首选方法，但开发者仍需避免循环引用，及时释放不再使用的对象。</p>\n<h3 id=\"5-网络优化\"><a href=\"#5-网络优化\" class=\"headerlink\" title=\"5. 网络优化\"></a>5. 网络优化</h3><p>应用的响应时间很大程度上受网络状况的影响。通过优化API调用，使用缓存和数据预加载技术，可以显著提高性能。</p>\n<h3 id=\"6-测试与监控\"><a href=\"#6-测试与监控\" class=\"headerlink\" title=\"6. 测试与监控\"></a>6. 测试与监控</h3><ul>\n<li><strong>单元测试</strong>：编写单元测试来确保代码的效率。</li>\n<li><strong>性能测试</strong>：模拟高负载情况下应用的表现。</li>\n<li><strong>监控</strong>：发布应用后，继续监控其性能，并根据用户反馈和数据进行调整。</li>\n</ul>\n<h3 id=\"7-优化策略\"><a href=\"#7-优化策略\" class=\"headerlink\" title=\"7. 优化策略\"></a>7. 优化策略</h3><ul>\n<li><strong>延迟加载</strong>：只有当需要时才加载数据或执行计算。</li>\n<li><strong>预计算和缓存</strong>：预计算重复计算的结果并进行缓存。</li>\n<li><strong>复用和回收</strong>：在可能的情况下复用对象和视图。</li>\n</ul>\n<h3 id=\"8-持续优化\"><a href=\"#8-持续优化\" class=\"headerlink\" title=\"8. 持续优化\"></a>8. 持续优化</h3><p>性能优化不是一次性的任务，而是一个持续的过程。随着应用的发展和用户基础的增长，应持续关注性能指标，并进行相应的优化。</p>\n<p>通过遵循上述步骤，开发者可以诊断出性能问题的根本原因，并采取相应的措施来解决问题。从用户体验的角度出发，提升应用的性能将直接影响到应用的成功与否。</p>\n<p><strong>第2小节：延迟加载和内存管理</strong></p>\n<p>在移动应用开发中，高效的内存使用是至关重要的。用户设备的内存资源有限，如果应用消耗过多内存，会影响用户体验，并可能导致应用被系统终止。延迟加载（Lazy Loading）和精心的内存管理是优化应用性能的关键策略。</p>\n<h3 id=\"延迟加载（Lazy-Loading）\"><a href=\"#延迟加载（Lazy-Loading）\" class=\"headerlink\" title=\"延迟加载（Lazy Loading）\"></a>延迟加载（Lazy Loading）</h3><p>延迟加载是一种在需要时才加载数据或对象到内存的策略。这种方法可以减少应用的启动时间，降低内存消耗，提高整体性能。</p>\n<h4 id=\"实施延迟加载的策略：\"><a href=\"#实施延迟加载的策略：\" class=\"headerlink\" title=\"实施延迟加载的策略：\"></a>实施延迟加载的策略：</h4><ol>\n<li><strong>按需实例化</strong>：仅当确实需要显示或处理某个对象时，才创建该对象的实例。</li>\n<li><strong>视图渲染优化</strong>：对于列表和滚动视图，可以使用如SwiftUI的<code>LazyVStack</code>和<code>LazyHStack</code>，这些组件能确保只有那些在屏幕上的视图才会被加载和渲染。</li>\n<li><strong>数据获取</strong>：对于网络请求，可以实现预加载和按页面分段加载数据，避免一次性加载大量数据。</li>\n<li><strong>资源管理</strong>：对图像和视频等大型文件进行按需加载，并考虑实现缓存机制。</li>\n</ol>\n<h3 id=\"内存管理\"><a href=\"#内存管理\" class=\"headerlink\" title=\"内存管理\"></a>内存管理</h3><p>良好的内存管理可以避免内存泄漏和过度消耗，从而提高应用性能。</p>\n<h4 id=\"内存管理的关键点：\"><a href=\"#内存管理的关键点：\" class=\"headerlink\" title=\"内存管理的关键点：\"></a>内存管理的关键点：</h4><ol>\n<li><strong>自动引用计数（ARC）</strong>：理解并正确使用ARC是必要的，避免循环引用和内存泄漏。</li>\n<li><strong>弱引用和无主引用</strong>：在闭包和委托模式中使用<code>weak</code>和<code>unowned</code>关键字来避免强引用循环。</li>\n<li><strong>资源释放</strong>：及时释放不再需要的对象，特别是在处理大型对象和文件时。</li>\n<li><strong>内存警告处理</strong>：正确处理内存警告，释放可以释放的资源，避免应用被系统终止。</li>\n<li><strong>内存分析工具</strong>：使用Xcode的Memory Graph Debugger和Leaks工具定期检查内存问题。</li>\n</ol>\n<h4 id=\"实施内存管理的技术：\"><a href=\"#实施内存管理的技术：\" class=\"headerlink\" title=\"实施内存管理的技术：\"></a>实施内存管理的技术：</h4><ul>\n<li><strong>使用<code>deinit</code>进行清理</strong>：当对象被销毁时，确保释放它持有的资源。</li>\n<li><strong>缓存策略</strong>：智能地实施缓存策略，既要提高数据访问的效率，又要避免过度消耗内存。</li>\n<li><strong>内存池</strong>：对于频繁创建和销毁的小对象，可以使用内存池来管理。</li>\n<li><strong>对象复用</strong>：例如，在UITableView中复用cell，而不是每次都创建新的cell。</li>\n</ul>\n<p>通过延迟加载和内存管理，开发者可以显著提高应用的性能和用户体验。理解和正确实现这些概念将使应用在不同设备和操作系统上更加稳定和流畅。</p>\n<p><strong>第3小节：视图更新效率优化</strong></p>\n<p>在现代移动应用中，保持流畅的用户界面至关重要。在SwiftUI中，视图更新的效率直接影响到用户体验。这一小节将探讨如何优化视图更新的效率。</p>\n<h3 id=\"理解视图更新机制\"><a href=\"#理解视图更新机制\" class=\"headerlink\" title=\"理解视图更新机制\"></a>理解视图更新机制</h3><p>首先，我们需要理解SwiftUI是如何处理视图更新的。SwiftUI视图是声明式的，这意味着你定义的是视图的期望状态，而非状态变化的过程。当视图的状态发生变化时，SwiftUI会重新计算视图的body属性。</p>\n<h4 id=\"管理状态变化\"><a href=\"#管理状态变化\" class=\"headerlink\" title=\"管理状态变化\"></a>管理状态变化</h4><ul>\n<li><strong>最小化状态变化</strong>：确保只有真正需要更新的视图状态时才进行更改。</li>\n<li><strong>精确的观察</strong>：使用<code>@State</code>、<code>@Binding</code>、<code>@ObservedObject</code>和<code>@EnvironmentObject</code>智能地观察模型的变化。</li>\n</ul>\n<h3 id=\"避免不必要的视图更新\"><a href=\"#避免不必要的视图更新\" class=\"headerlink\" title=\"避免不必要的视图更新\"></a>避免不必要的视图更新</h3><p>不必要的视图重建会浪费资源并降低性能。</p>\n<h4 id=\"实现策略：\"><a href=\"#实现策略：\" class=\"headerlink\" title=\"实现策略：\"></a>实现策略：</h4><ol>\n<li>**合理使用<code>Equatable</code>**：对于自定义视图，实现<code>Equatable</code>协议并在<code>shouldUpdate</code>中提供差异对比，以避免相同状态时的重建。</li>\n<li><strong>条件式视图更新</strong>：通过逻辑判断确保只有当状态确实改变时才更新视图。</li>\n<li><strong>局部更新</strong>：使用<code>.id()</code>修饰符或其他方式来提示SwiftUI哪些部分的视图是稳定的，不需要重建。</li>\n</ol>\n<h3 id=\"高效的数据流\"><a href=\"#高效的数据流\" class=\"headerlink\" title=\"高效的数据流\"></a>高效的数据流</h3><p>数据流向视图的方式也影响更新效率。</p>\n<h4 id=\"优化数据流的方法：\"><a href=\"#优化数据流的方法：\" class=\"headerlink\" title=\"优化数据流的方法：\"></a>优化数据流的方法：</h4><ul>\n<li><strong>使用<code>@State</code>进行本地状态管理</strong>：对于视图私有的状态，使用<code>@State</code>来进行本地化管理。</li>\n<li><strong>利用<code>@ObservedObject</code>和<code>@EnvironmentObject</code>共享状态</strong>：对于需要在多个视图间共享的状态，可以使用这些属性包装器。</li>\n</ul>\n<h3 id=\"性能分析工具\"><a href=\"#性能分析工具\" class=\"headerlink\" title=\"性能分析工具\"></a>性能分析工具</h3><p>使用Xcode提供的性能分析工具来查找性能瓶颈。</p>\n<h4 id=\"分析方法：\"><a href=\"#分析方法：\" class=\"headerlink\" title=\"分析方法：\"></a>分析方法：</h4><ol>\n<li><strong>时间分析器</strong>：利用Xcode的时间分析器查看哪些部分的代码耗时最多。</li>\n<li><strong>SwiftUI预览性能检查</strong>：在SwiftUI预览中测试视图更新，观察是否有延迟。</li>\n</ol>\n<h3 id=\"最佳实践\"><a href=\"#最佳实践\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h3><ul>\n<li><strong>延迟复杂计算</strong>：对于复杂的视图计算，可以考虑将其推迟到视图显示之后的背景线程。</li>\n<li><strong>异步图片加载</strong>：对于图片和其他媒体资源，使用异步加载以避免阻塞UI线程。</li>\n<li><strong>智能组件分割</strong>：将复杂视图拆分成更小的、可以独立更新的组件。</li>\n</ul>\n<p>通过以上策略，可以确保SwiftUI应用中的视图更新是高效的，从而提供流畅的用户体验。记住，性能调优是一个持续的过程，定期的性能评测和分析是非常必要的。</p>\n","excerpt":"","more":"<p><strong>第13章：性能优化</strong></p>\n<p><strong>第1小节：诊断和解决性能问题</strong></p>\n<p>性能优化是软件开发中的关键步骤，特别是对于那些要求快速响应和流畅体验的应用。性能问题可能是由许多因素造成的，包括但不限于内存泄漏、过度渲染、网络延迟或者不高效的数据结构和算法。有效的性能优化往往从准确诊断问题开始。</p>\n<h3 id=\"1-性能评估\"><a href=\"#1-性能评估\" class=\"headerlink\" title=\"1. 性能评估\"></a>1. 性能评估</h3><p>在深入代码优化之前，首先要进行一个全面的性能评估。使用Xcode自带的Instrument工具可以帮助检测应用的CPU使用率、内存泄漏、能耗和网络性能等。</p>\n<h3 id=\"2-识别瓶颈\"><a href=\"#2-识别瓶颈\" class=\"headerlink\" title=\"2. 识别瓶颈\"></a>2. 识别瓶颈</h3><p>在性能评估之后，需要确定应用中的性能瓶颈。通过分析Instruments的报告，可以识别出CPU和内存的高消耗区域。对于图形密集型的应用，可能还需要检查GPU的使用情况。</p>\n<h3 id=\"3-代码分析与调优\"><a href=\"#3-代码分析与调优\" class=\"headerlink\" title=\"3. 代码分析与调优\"></a>3. 代码分析与调优</h3><p>一旦确定了瓶颈，就可以开始针对性的代码优化了。这可能包括：</p>\n<ul>\n<li><strong>优化算法和数据结构</strong>：改进或替换那些复杂度高的算法和数据结构。</li>\n<li><strong>减少计算量</strong>：避免不必要的计算，特别是在渲染和布局的过程中。</li>\n<li><strong>异步执行</strong>：使用异步编程模式来避免UI线程阻塞。</li>\n<li><strong>资源优化</strong>：优化图像和资源的加载，确保它们是压缩的且以正确的尺寸使用。</li>\n</ul>\n<h3 id=\"4-内存管理\"><a href=\"#4-内存管理\" class=\"headerlink\" title=\"4. 内存管理\"></a>4. 内存管理</h3><p>内存问题，尤其是内存泄漏，是性能问题的常见原因。使用ARC（自动引用计数）应该是管理内存的首选方法，但开发者仍需避免循环引用，及时释放不再使用的对象。</p>\n<h3 id=\"5-网络优化\"><a href=\"#5-网络优化\" class=\"headerlink\" title=\"5. 网络优化\"></a>5. 网络优化</h3><p>应用的响应时间很大程度上受网络状况的影响。通过优化API调用，使用缓存和数据预加载技术，可以显著提高性能。</p>\n<h3 id=\"6-测试与监控\"><a href=\"#6-测试与监控\" class=\"headerlink\" title=\"6. 测试与监控\"></a>6. 测试与监控</h3><ul>\n<li><strong>单元测试</strong>：编写单元测试来确保代码的效率。</li>\n<li><strong>性能测试</strong>：模拟高负载情况下应用的表现。</li>\n<li><strong>监控</strong>：发布应用后，继续监控其性能，并根据用户反馈和数据进行调整。</li>\n</ul>\n<h3 id=\"7-优化策略\"><a href=\"#7-优化策略\" class=\"headerlink\" title=\"7. 优化策略\"></a>7. 优化策略</h3><ul>\n<li><strong>延迟加载</strong>：只有当需要时才加载数据或执行计算。</li>\n<li><strong>预计算和缓存</strong>：预计算重复计算的结果并进行缓存。</li>\n<li><strong>复用和回收</strong>：在可能的情况下复用对象和视图。</li>\n</ul>\n<h3 id=\"8-持续优化\"><a href=\"#8-持续优化\" class=\"headerlink\" title=\"8. 持续优化\"></a>8. 持续优化</h3><p>性能优化不是一次性的任务，而是一个持续的过程。随着应用的发展和用户基础的增长，应持续关注性能指标，并进行相应的优化。</p>\n<p>通过遵循上述步骤，开发者可以诊断出性能问题的根本原因，并采取相应的措施来解决问题。从用户体验的角度出发，提升应用的性能将直接影响到应用的成功与否。</p>\n<p><strong>第2小节：延迟加载和内存管理</strong></p>\n<p>在移动应用开发中，高效的内存使用是至关重要的。用户设备的内存资源有限，如果应用消耗过多内存，会影响用户体验，并可能导致应用被系统终止。延迟加载（Lazy Loading）和精心的内存管理是优化应用性能的关键策略。</p>\n<h3 id=\"延迟加载（Lazy-Loading）\"><a href=\"#延迟加载（Lazy-Loading）\" class=\"headerlink\" title=\"延迟加载（Lazy Loading）\"></a>延迟加载（Lazy Loading）</h3><p>延迟加载是一种在需要时才加载数据或对象到内存的策略。这种方法可以减少应用的启动时间，降低内存消耗，提高整体性能。</p>\n<h4 id=\"实施延迟加载的策略：\"><a href=\"#实施延迟加载的策略：\" class=\"headerlink\" title=\"实施延迟加载的策略：\"></a>实施延迟加载的策略：</h4><ol>\n<li><strong>按需实例化</strong>：仅当确实需要显示或处理某个对象时，才创建该对象的实例。</li>\n<li><strong>视图渲染优化</strong>：对于列表和滚动视图，可以使用如SwiftUI的<code>LazyVStack</code>和<code>LazyHStack</code>，这些组件能确保只有那些在屏幕上的视图才会被加载和渲染。</li>\n<li><strong>数据获取</strong>：对于网络请求，可以实现预加载和按页面分段加载数据，避免一次性加载大量数据。</li>\n<li><strong>资源管理</strong>：对图像和视频等大型文件进行按需加载，并考虑实现缓存机制。</li>\n</ol>\n<h3 id=\"内存管理\"><a href=\"#内存管理\" class=\"headerlink\" title=\"内存管理\"></a>内存管理</h3><p>良好的内存管理可以避免内存泄漏和过度消耗，从而提高应用性能。</p>\n<h4 id=\"内存管理的关键点：\"><a href=\"#内存管理的关键点：\" class=\"headerlink\" title=\"内存管理的关键点：\"></a>内存管理的关键点：</h4><ol>\n<li><strong>自动引用计数（ARC）</strong>：理解并正确使用ARC是必要的，避免循环引用和内存泄漏。</li>\n<li><strong>弱引用和无主引用</strong>：在闭包和委托模式中使用<code>weak</code>和<code>unowned</code>关键字来避免强引用循环。</li>\n<li><strong>资源释放</strong>：及时释放不再需要的对象，特别是在处理大型对象和文件时。</li>\n<li><strong>内存警告处理</strong>：正确处理内存警告，释放可以释放的资源，避免应用被系统终止。</li>\n<li><strong>内存分析工具</strong>：使用Xcode的Memory Graph Debugger和Leaks工具定期检查内存问题。</li>\n</ol>\n<h4 id=\"实施内存管理的技术：\"><a href=\"#实施内存管理的技术：\" class=\"headerlink\" title=\"实施内存管理的技术：\"></a>实施内存管理的技术：</h4><ul>\n<li><strong>使用<code>deinit</code>进行清理</strong>：当对象被销毁时，确保释放它持有的资源。</li>\n<li><strong>缓存策略</strong>：智能地实施缓存策略，既要提高数据访问的效率，又要避免过度消耗内存。</li>\n<li><strong>内存池</strong>：对于频繁创建和销毁的小对象，可以使用内存池来管理。</li>\n<li><strong>对象复用</strong>：例如，在UITableView中复用cell，而不是每次都创建新的cell。</li>\n</ul>\n<p>通过延迟加载和内存管理，开发者可以显著提高应用的性能和用户体验。理解和正确实现这些概念将使应用在不同设备和操作系统上更加稳定和流畅。</p>\n<p><strong>第3小节：视图更新效率优化</strong></p>\n<p>在现代移动应用中，保持流畅的用户界面至关重要。在SwiftUI中，视图更新的效率直接影响到用户体验。这一小节将探讨如何优化视图更新的效率。</p>\n<h3 id=\"理解视图更新机制\"><a href=\"#理解视图更新机制\" class=\"headerlink\" title=\"理解视图更新机制\"></a>理解视图更新机制</h3><p>首先，我们需要理解SwiftUI是如何处理视图更新的。SwiftUI视图是声明式的，这意味着你定义的是视图的期望状态，而非状态变化的过程。当视图的状态发生变化时，SwiftUI会重新计算视图的body属性。</p>\n<h4 id=\"管理状态变化\"><a href=\"#管理状态变化\" class=\"headerlink\" title=\"管理状态变化\"></a>管理状态变化</h4><ul>\n<li><strong>最小化状态变化</strong>：确保只有真正需要更新的视图状态时才进行更改。</li>\n<li><strong>精确的观察</strong>：使用<code>@State</code>、<code>@Binding</code>、<code>@ObservedObject</code>和<code>@EnvironmentObject</code>智能地观察模型的变化。</li>\n</ul>\n<h3 id=\"避免不必要的视图更新\"><a href=\"#避免不必要的视图更新\" class=\"headerlink\" title=\"避免不必要的视图更新\"></a>避免不必要的视图更新</h3><p>不必要的视图重建会浪费资源并降低性能。</p>\n<h4 id=\"实现策略：\"><a href=\"#实现策略：\" class=\"headerlink\" title=\"实现策略：\"></a>实现策略：</h4><ol>\n<li>**合理使用<code>Equatable</code>**：对于自定义视图，实现<code>Equatable</code>协议并在<code>shouldUpdate</code>中提供差异对比，以避免相同状态时的重建。</li>\n<li><strong>条件式视图更新</strong>：通过逻辑判断确保只有当状态确实改变时才更新视图。</li>\n<li><strong>局部更新</strong>：使用<code>.id()</code>修饰符或其他方式来提示SwiftUI哪些部分的视图是稳定的，不需要重建。</li>\n</ol>\n<h3 id=\"高效的数据流\"><a href=\"#高效的数据流\" class=\"headerlink\" title=\"高效的数据流\"></a>高效的数据流</h3><p>数据流向视图的方式也影响更新效率。</p>\n<h4 id=\"优化数据流的方法：\"><a href=\"#优化数据流的方法：\" class=\"headerlink\" title=\"优化数据流的方法：\"></a>优化数据流的方法：</h4><ul>\n<li><strong>使用<code>@State</code>进行本地状态管理</strong>：对于视图私有的状态，使用<code>@State</code>来进行本地化管理。</li>\n<li><strong>利用<code>@ObservedObject</code>和<code>@EnvironmentObject</code>共享状态</strong>：对于需要在多个视图间共享的状态，可以使用这些属性包装器。</li>\n</ul>\n<h3 id=\"性能分析工具\"><a href=\"#性能分析工具\" class=\"headerlink\" title=\"性能分析工具\"></a>性能分析工具</h3><p>使用Xcode提供的性能分析工具来查找性能瓶颈。</p>\n<h4 id=\"分析方法：\"><a href=\"#分析方法：\" class=\"headerlink\" title=\"分析方法：\"></a>分析方法：</h4><ol>\n<li><strong>时间分析器</strong>：利用Xcode的时间分析器查看哪些部分的代码耗时最多。</li>\n<li><strong>SwiftUI预览性能检查</strong>：在SwiftUI预览中测试视图更新，观察是否有延迟。</li>\n</ol>\n<h3 id=\"最佳实践\"><a href=\"#最佳实践\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h3><ul>\n<li><strong>延迟复杂计算</strong>：对于复杂的视图计算，可以考虑将其推迟到视图显示之后的背景线程。</li>\n<li><strong>异步图片加载</strong>：对于图片和其他媒体资源，使用异步加载以避免阻塞UI线程。</li>\n<li><strong>智能组件分割</strong>：将复杂视图拆分成更小的、可以独立更新的组件。</li>\n</ul>\n<p>通过以上策略，可以确保SwiftUI应用中的视图更新是高效的，从而提供流畅的用户体验。记住，性能调优是一个持续的过程，定期的性能评测和分析是非常必要的。</p>\n"},{"title":"SwiftUI核心技术第8章动画与转场","date":"2023-11-08T01:13:02.000Z","_content":"**第8章：动画与转场**\n\n**第1小节：基础动画**\n\n在SwiftUI中，动画是用来增强用户体验的一种手段，它可以提供平滑的视觉过渡和引人注目的交互。通过使用SwiftUI强大的动画API，你可以轻松地为界面元素添加动画效果。\n\n**动画的类型**\n\n在SwiftUI中，动画主要可以分为隐式动画和显式动画两大类。\n\n1. **隐式动画**：最简单的动画形式，仅需要使用`.animation()`修饰符，并为其提供一个动画样式。\n2. **显式动画**：使用`withAnimation`函数来明确开始动画的时间点，并提供一个动画样式。\n\n**创建一个简单的隐式动画**\n\n你可以通过在视图的某个状态改变时附加`.animation()`修饰符，让这个状态改变带有动画效果。\n\n```swift\nstruct SimpleAnimationView: View {\n    @State private var scale: CGFloat = 1\n\n    var body: some View {\n        Circle()\n            .scaleEffect(scale)\n            .animation(.easeInOut, value: scale)\n            .onTapGesture {\n                scale += 1\n            }\n    }\n}\n```\n\n在上面的例子中，每当用户点击圆形，`scale`状态变量就会增加，而圆形的尺寸变化将以渐进渐出的方式动画显示。\n\n**使用`withAnimation`进行显式动画**\n\n如果你想控制动画的触发时机，而不是依赖于状态的改变，你可以使用`withAnimation`来显式地执行动画。\n\n```swift\nButton(\"Tap Me\") {\n    withAnimation(.spring(response: 0.5, dampingFraction: 0.5, blendDuration: 1)) {\n        scale += 1\n    }\n}\n```\n\n在这个例子中，当按钮被点击时，不管`scale`的值如何变化，动画都会被执行。\n\n**动画的组合**\n\n你可以将不同的动画效果组合在一起，创建复杂的动画序列。这通过在`.animation()`修饰符中使用`Animation`的静态方法来实现。\n\n```swift\n.animation(\n    Animation.easeInOut(duration: 2).repeatForever(autoreverses: true)\n)\n```\n\n此代码会创建一个无限重复并自动反向的渐进渐出动画。\n\n**动画参数**\n\nSwiftUI提供了许多可以调整动画行为的参数：\n\n- `duration`：动画的时长。\n- `delay`：动画开始前的等待时间。\n- `repeatCount`：动画重复的次数。\n- `autoreverses`：动画是否在完成后自动反向。\n\n**小结**\n\n基础动画是SwiftUI中最容易实现的动画类型，它们可以快速为你的应用添加视觉吸引力和反馈。通过使用隐式动画或显式动画，你可以控制动画的触发方式和行为。此外，SwiftUI的动画系统是高度可组合的，允许你通过组合和定制动画参数来创建复杂的动画效果。\n\n在本书的后续章节中，我们将深入探讨如何使用SwiftUI的高级动画功能，比如路径动画、自定义时间曲线以及动画的联动效果，来创建更具表现力和创造力的用户界面。\n\n\n**第2小节：自定义动画**\n\n在SwiftUI中，除了内置的动画类型，开发者还可以通过自定义动画来进一步个性化UI交互。自定义动画允许开发者控制动画的具体行为和时间曲线，实现独特的动态效果。\n\n**动画时间曲线**\n\n时间曲线描述了动画状态值随时间的变化方式。SwiftUI提供了几种内置的时间曲线，例如`easeIn`、`easeOut`和`easeInOut`。要自定义这些曲线，你可以使用`timingCurve(_:_:_:_:)`方法。\n\n```swift\n.animation(.timingCurve(0.2, 0.8, 0.2, 1, duration: 0.5))\n```\n\n这个方法接受四个表示贝塞尔曲线控制点的参数，可以非常精细地控制动画的加速和减速过程。\n\n**使用`interpolatingSpring`自定义弹簧动画**\n\n如果你需要一个物理弹性效果，可以使用`interpolatingSpring(stiffness:damping:)`函数来自定义一个弹簧动画。\n\n```swift\n.animation(.interpolatingSpring(stiffness: 50, damping: 5))\n```\n\n调整`stiffness`（刚度）和`damping`（阻尼）参数可以模拟不同的弹簧物理特性。\n\n**使用`Animation`的`delay(_: )`和`speed(_: )`自定义动画速度和延迟**\n\n```swift\n.animation(.easeInOut(duration: 2).delay(0.5).speed(2))\n```\n\n这里，动画会在半秒延迟后开始，并且以原始时长的两倍速度播放。\n\n**自定义动画路径**\n\nSwiftUI动画不仅限于简单的开始和结束状态之间的过渡。使用`GeometryEffect`，你可以创建完全自定义的动画路径。\n\n```swift\nstruct CustomAnimationView: View {\n    @State private var isAnimated = false\n\n    var body: some View {\n        Circle()\n            .frame(width: 100, height: 100)\n            .modifier(CustomPathModifier(isAnimated: $isAnimated))\n            .onTapGesture {\n                withAnimation {\n                    isAnimated.toggle()\n                }\n            }\n    }\n}\n\nstruct CustomPathModifier: GeometryEffect {\n    @Binding var isAnimated: Bool\n\n    func effectValue(size: CGSize) -> ProjectionTransform {\n        let path = UIBezierPath()\n        path.move(to: CGPoint(x: 0, y: isAnimated ? size.height : 0))\n        // Your custom path here\n        return ProjectionTransform(CGAffineTransform(translationX: path.currentPoint.x, y: path.currentPoint.y))\n    }\n}\n```\n\n通过创建一个遵循`GeometryEffect`协议的自定义修饰符，你可以定义一个复杂的动画路径，这个路径由一个点沿着给定路径移动的动画组成。\n\n**自定义动画的应用场景**\n\n- 当内置动画不能满足你的设计需求时。\n- 当你想要创建一个与众不同的动态交互体验。\n- 在需要精确控制动画行为，如游戏或特定动画教程中。\n\n**小结**\n\n自定义动画是SwiftUI动画功能的深入使用。通过控制时间曲线、弹簧动画参数和自定义动画路径，你可以创造出个性化和专业级别的动态效果。自定义动画能提升应用的专业感和用户的交互体验，使你的应用在众多相似应用中脱颖而出。\n\n接下来，我们将探讨转场动画，它们可以为视图的呈现和消失提供引人注目的视觉效果。\n\n\n**第3小节：交互式和响应式动画**\n\n在构建现代的用户界面时，我们不仅希望动画能够提供视觉上的引导和反馈，还希望它们能够与用户的交互紧密结合，创造流畅的体验。这就是交互式和响应式动画发挥作用的地方。在SwiftUI中，你可以根据用户的输入或其他事件，实时地调整动画，从而创建出高度交互的UI元素。\n\n**交互式动画**\n\n交互式动画是指随着用户的操作实时变化的动画。例如，拖动滑块时的动态变化或者通过手势控制的动画。\n\n**实现交互式动画的方法**\n\n你可以通过以下方式为你的应用添加交互式动画：\n\n1. **使用Gesture**\n\n   绑定手势到视图，然后在手势变化时更新视图的状态。\n\n   ```swift\n   struct InteractiveView: View {\n       @GestureState private var dragState = CGSize.zero\n\n       var body: some View {\n           Rectangle()\n               .fill(Color.blue)\n               .frame(width: 100, height: 100)\n               .offset(dragState)\n               .gesture(\n                   DragGesture()\n                       .updating($dragState) { value, state, _ in\n                           state = value.translation\n                       }\n               )\n       }\n   }\n   ```\n\n   在这个例子中，`DragGesture`跟踪手指的拖动，并实时更新`Rectangle`的偏移。\n\n2. **与动画状态链接**\n\n   将动画和状态变量结合起来，实现随状态改变而动画的效果。\n\n   ```swift\n   struct ResponsiveView: View {\n       @State private var position = CGPoint.zero\n\n       var body: some View {\n           Circle()\n               .position(position)\n               .onTapGesture {\n                   withAnimation {\n                       position = CGPoint(x: position.x + 100, y: position.y + 100)\n                   }\n               }\n       }\n   }\n   ```\n\n   这里，每次点击都会使圆形移动，并伴随平滑的过渡动画。\n\n**响应式动画**\n\n响应式动画则是指根据外部事件或数据的变化而自动触发的动画。例如，当接收到新消息时，提示符以动画的形式出现。\n\n**实现响应式动画的方法**\n\n1. **数据绑定**\n\n   通过观察对象中的`@Published`属性变化来驱动动画。\n\n   ```swift\n   class AnimationViewModel: ObservableObject {\n       @Published var isLoading = false\n   }\n\n   struct LoadingView: View {\n       @ObservedObject var viewModel = AnimationViewModel()\n\n       var body: some View {\n           Circle()\n               .frame(width: 50, height: 50)\n               .rotationEffect(Angle(degrees: viewModel.isLoading ? 360 : 0))\n               .animation(Animation.linear(duration: 1).repeatForever(autoreverses: false), value: viewModel.isLoading)\n               .onAppear {\n                   viewModel.isLoading = true\n               }\n       }\n   }\n   ```\n\n   当`isLoading`变为`true`时，圆形会开始无限旋转，模拟加载指示器的效果。\n\n2. **环境变量**\n\n   利用`@EnvironmentObject`或其他环境属性，在多个视图之间共享动画状态。\n\n   ```swift\n   struct ContentView: View {\n       @EnvironmentObject var userSettings: UserSettings\n\n       var body: some View {\n           Text(userSettings.username)\n               .scaleEffect(userSettings.isLoggedOut ? 0 : 1)\n               .animation(.spring(), value: userSettings.isLoggedOut)\n       }\n   }\n   ```\n\n   当用户注销时，用户名的文本会通过缩放动画消失。\n\n**小结**\n\n交互式和响应式动画在提高应用的用户体验方面起着至关重要的作用。在SwiftUI中，你可以轻松地将动画与用户的交互以及应用的数据状态相结合。\n\n\n**第4小节：转场动画**\n\n转场动画是用户界面的一部分，它们在视图的呈现和消失时创造连贯的视觉效果。在SwiftUI中，转场是以声明的方式定义的，允许开发者指定添加或删除视图时的动画类型。利用转场，开发者可以提供一种流畅的视觉体验，减少用户界面变化对用户认知的干扰。\n\n**基础转场**\n\nSwiftUI提供了几种内置的转场类型，例如`.opacity`、`.slide`和`.scale`。\n\n```swift\nstruct ContentView: View {\n    @State private var isPresented = false\n\n    var body: some View {\n        VStack {\n            if isPresented {\n                Text(\"Hello, World!\")\n                    .transition(.slide)\n            }\n            Button(\"Toggle View\") {\n                withAnimation {\n                    isPresented.toggle()\n                }\n            }\n        }\n    }\n}\n```\n\n在这个示例中，当`isPresented`状态变化时，`Text`视图会滑入或滑出。\n\n**组合转场**\n\n你还可以组合多个转场来创建独特的效果：\n\n```swift\n.transition(.asymmetric(insertion: .scale, removal: .opacity))\n```\n\n在这里，视图出现时使用缩放效果，消失时使用渐隐效果。\n\n**自定义转场**\n\nSwiftUI还允许创建自定义转场。这通常是通过定义视图的两种状态并描述它们之间的动画过渡来实现的。\n\n```swift\nextension AnyTransition {\n    static var pivot: AnyTransition {\n        .modifier(\n            active: CornerRotateModifier(amount: -90),\n            identity: CornerRotateModifier(amount: 0)\n        )\n    }\n}\n\nstruct CornerRotateModifier: ViewModifier {\n    let amount: Double\n    func body(content: Content) -> some View {\n        content.rotationEffect(Angle(degrees: amount), anchor: .topLeading)\n    }\n}\n```\n\n在这个自定义转场中，`pivot`通过旋转视图的顶部锚点实现转动效果。\n\n**使用转场动画**\n\n转场可以与`withAnimation`闭包结合使用，来实现视图状态变化时的平滑过渡。\n\n```swift\nButton(\"Toggle View\") {\n    withAnimation(.spring()) {\n        isPresented.toggle()\n    }\n}\n```\n\n这将创建一个在点击按钮时视图呈现和消失时有弹簧动效的交互。\n\n**小结**\n\n转场动画在SwiftUI中为开发者提供了一个高效的方法来处理视图的呈现和消失，使用户界面更加生动和有趣。内置的转场类型适用于多数情况，而自定义转场则为特殊需求提供了无限的可能性。通过恰当使用转场，可以大大提升应用的质感和用户满意度。","source":"_posts/SwiftUI核心技术第8章动画与转场.md","raw":"---\ntitle: SwiftUI核心技术第8章动画与转场\ndate: 2023-11-08 09:13:02\ncategories:\n- SwiftUI\ntags:\n---\n**第8章：动画与转场**\n\n**第1小节：基础动画**\n\n在SwiftUI中，动画是用来增强用户体验的一种手段，它可以提供平滑的视觉过渡和引人注目的交互。通过使用SwiftUI强大的动画API，你可以轻松地为界面元素添加动画效果。\n\n**动画的类型**\n\n在SwiftUI中，动画主要可以分为隐式动画和显式动画两大类。\n\n1. **隐式动画**：最简单的动画形式，仅需要使用`.animation()`修饰符，并为其提供一个动画样式。\n2. **显式动画**：使用`withAnimation`函数来明确开始动画的时间点，并提供一个动画样式。\n\n**创建一个简单的隐式动画**\n\n你可以通过在视图的某个状态改变时附加`.animation()`修饰符，让这个状态改变带有动画效果。\n\n```swift\nstruct SimpleAnimationView: View {\n    @State private var scale: CGFloat = 1\n\n    var body: some View {\n        Circle()\n            .scaleEffect(scale)\n            .animation(.easeInOut, value: scale)\n            .onTapGesture {\n                scale += 1\n            }\n    }\n}\n```\n\n在上面的例子中，每当用户点击圆形，`scale`状态变量就会增加，而圆形的尺寸变化将以渐进渐出的方式动画显示。\n\n**使用`withAnimation`进行显式动画**\n\n如果你想控制动画的触发时机，而不是依赖于状态的改变，你可以使用`withAnimation`来显式地执行动画。\n\n```swift\nButton(\"Tap Me\") {\n    withAnimation(.spring(response: 0.5, dampingFraction: 0.5, blendDuration: 1)) {\n        scale += 1\n    }\n}\n```\n\n在这个例子中，当按钮被点击时，不管`scale`的值如何变化，动画都会被执行。\n\n**动画的组合**\n\n你可以将不同的动画效果组合在一起，创建复杂的动画序列。这通过在`.animation()`修饰符中使用`Animation`的静态方法来实现。\n\n```swift\n.animation(\n    Animation.easeInOut(duration: 2).repeatForever(autoreverses: true)\n)\n```\n\n此代码会创建一个无限重复并自动反向的渐进渐出动画。\n\n**动画参数**\n\nSwiftUI提供了许多可以调整动画行为的参数：\n\n- `duration`：动画的时长。\n- `delay`：动画开始前的等待时间。\n- `repeatCount`：动画重复的次数。\n- `autoreverses`：动画是否在完成后自动反向。\n\n**小结**\n\n基础动画是SwiftUI中最容易实现的动画类型，它们可以快速为你的应用添加视觉吸引力和反馈。通过使用隐式动画或显式动画，你可以控制动画的触发方式和行为。此外，SwiftUI的动画系统是高度可组合的，允许你通过组合和定制动画参数来创建复杂的动画效果。\n\n在本书的后续章节中，我们将深入探讨如何使用SwiftUI的高级动画功能，比如路径动画、自定义时间曲线以及动画的联动效果，来创建更具表现力和创造力的用户界面。\n\n\n**第2小节：自定义动画**\n\n在SwiftUI中，除了内置的动画类型，开发者还可以通过自定义动画来进一步个性化UI交互。自定义动画允许开发者控制动画的具体行为和时间曲线，实现独特的动态效果。\n\n**动画时间曲线**\n\n时间曲线描述了动画状态值随时间的变化方式。SwiftUI提供了几种内置的时间曲线，例如`easeIn`、`easeOut`和`easeInOut`。要自定义这些曲线，你可以使用`timingCurve(_:_:_:_:)`方法。\n\n```swift\n.animation(.timingCurve(0.2, 0.8, 0.2, 1, duration: 0.5))\n```\n\n这个方法接受四个表示贝塞尔曲线控制点的参数，可以非常精细地控制动画的加速和减速过程。\n\n**使用`interpolatingSpring`自定义弹簧动画**\n\n如果你需要一个物理弹性效果，可以使用`interpolatingSpring(stiffness:damping:)`函数来自定义一个弹簧动画。\n\n```swift\n.animation(.interpolatingSpring(stiffness: 50, damping: 5))\n```\n\n调整`stiffness`（刚度）和`damping`（阻尼）参数可以模拟不同的弹簧物理特性。\n\n**使用`Animation`的`delay(_: )`和`speed(_: )`自定义动画速度和延迟**\n\n```swift\n.animation(.easeInOut(duration: 2).delay(0.5).speed(2))\n```\n\n这里，动画会在半秒延迟后开始，并且以原始时长的两倍速度播放。\n\n**自定义动画路径**\n\nSwiftUI动画不仅限于简单的开始和结束状态之间的过渡。使用`GeometryEffect`，你可以创建完全自定义的动画路径。\n\n```swift\nstruct CustomAnimationView: View {\n    @State private var isAnimated = false\n\n    var body: some View {\n        Circle()\n            .frame(width: 100, height: 100)\n            .modifier(CustomPathModifier(isAnimated: $isAnimated))\n            .onTapGesture {\n                withAnimation {\n                    isAnimated.toggle()\n                }\n            }\n    }\n}\n\nstruct CustomPathModifier: GeometryEffect {\n    @Binding var isAnimated: Bool\n\n    func effectValue(size: CGSize) -> ProjectionTransform {\n        let path = UIBezierPath()\n        path.move(to: CGPoint(x: 0, y: isAnimated ? size.height : 0))\n        // Your custom path here\n        return ProjectionTransform(CGAffineTransform(translationX: path.currentPoint.x, y: path.currentPoint.y))\n    }\n}\n```\n\n通过创建一个遵循`GeometryEffect`协议的自定义修饰符，你可以定义一个复杂的动画路径，这个路径由一个点沿着给定路径移动的动画组成。\n\n**自定义动画的应用场景**\n\n- 当内置动画不能满足你的设计需求时。\n- 当你想要创建一个与众不同的动态交互体验。\n- 在需要精确控制动画行为，如游戏或特定动画教程中。\n\n**小结**\n\n自定义动画是SwiftUI动画功能的深入使用。通过控制时间曲线、弹簧动画参数和自定义动画路径，你可以创造出个性化和专业级别的动态效果。自定义动画能提升应用的专业感和用户的交互体验，使你的应用在众多相似应用中脱颖而出。\n\n接下来，我们将探讨转场动画，它们可以为视图的呈现和消失提供引人注目的视觉效果。\n\n\n**第3小节：交互式和响应式动画**\n\n在构建现代的用户界面时，我们不仅希望动画能够提供视觉上的引导和反馈，还希望它们能够与用户的交互紧密结合，创造流畅的体验。这就是交互式和响应式动画发挥作用的地方。在SwiftUI中，你可以根据用户的输入或其他事件，实时地调整动画，从而创建出高度交互的UI元素。\n\n**交互式动画**\n\n交互式动画是指随着用户的操作实时变化的动画。例如，拖动滑块时的动态变化或者通过手势控制的动画。\n\n**实现交互式动画的方法**\n\n你可以通过以下方式为你的应用添加交互式动画：\n\n1. **使用Gesture**\n\n   绑定手势到视图，然后在手势变化时更新视图的状态。\n\n   ```swift\n   struct InteractiveView: View {\n       @GestureState private var dragState = CGSize.zero\n\n       var body: some View {\n           Rectangle()\n               .fill(Color.blue)\n               .frame(width: 100, height: 100)\n               .offset(dragState)\n               .gesture(\n                   DragGesture()\n                       .updating($dragState) { value, state, _ in\n                           state = value.translation\n                       }\n               )\n       }\n   }\n   ```\n\n   在这个例子中，`DragGesture`跟踪手指的拖动，并实时更新`Rectangle`的偏移。\n\n2. **与动画状态链接**\n\n   将动画和状态变量结合起来，实现随状态改变而动画的效果。\n\n   ```swift\n   struct ResponsiveView: View {\n       @State private var position = CGPoint.zero\n\n       var body: some View {\n           Circle()\n               .position(position)\n               .onTapGesture {\n                   withAnimation {\n                       position = CGPoint(x: position.x + 100, y: position.y + 100)\n                   }\n               }\n       }\n   }\n   ```\n\n   这里，每次点击都会使圆形移动，并伴随平滑的过渡动画。\n\n**响应式动画**\n\n响应式动画则是指根据外部事件或数据的变化而自动触发的动画。例如，当接收到新消息时，提示符以动画的形式出现。\n\n**实现响应式动画的方法**\n\n1. **数据绑定**\n\n   通过观察对象中的`@Published`属性变化来驱动动画。\n\n   ```swift\n   class AnimationViewModel: ObservableObject {\n       @Published var isLoading = false\n   }\n\n   struct LoadingView: View {\n       @ObservedObject var viewModel = AnimationViewModel()\n\n       var body: some View {\n           Circle()\n               .frame(width: 50, height: 50)\n               .rotationEffect(Angle(degrees: viewModel.isLoading ? 360 : 0))\n               .animation(Animation.linear(duration: 1).repeatForever(autoreverses: false), value: viewModel.isLoading)\n               .onAppear {\n                   viewModel.isLoading = true\n               }\n       }\n   }\n   ```\n\n   当`isLoading`变为`true`时，圆形会开始无限旋转，模拟加载指示器的效果。\n\n2. **环境变量**\n\n   利用`@EnvironmentObject`或其他环境属性，在多个视图之间共享动画状态。\n\n   ```swift\n   struct ContentView: View {\n       @EnvironmentObject var userSettings: UserSettings\n\n       var body: some View {\n           Text(userSettings.username)\n               .scaleEffect(userSettings.isLoggedOut ? 0 : 1)\n               .animation(.spring(), value: userSettings.isLoggedOut)\n       }\n   }\n   ```\n\n   当用户注销时，用户名的文本会通过缩放动画消失。\n\n**小结**\n\n交互式和响应式动画在提高应用的用户体验方面起着至关重要的作用。在SwiftUI中，你可以轻松地将动画与用户的交互以及应用的数据状态相结合。\n\n\n**第4小节：转场动画**\n\n转场动画是用户界面的一部分，它们在视图的呈现和消失时创造连贯的视觉效果。在SwiftUI中，转场是以声明的方式定义的，允许开发者指定添加或删除视图时的动画类型。利用转场，开发者可以提供一种流畅的视觉体验，减少用户界面变化对用户认知的干扰。\n\n**基础转场**\n\nSwiftUI提供了几种内置的转场类型，例如`.opacity`、`.slide`和`.scale`。\n\n```swift\nstruct ContentView: View {\n    @State private var isPresented = false\n\n    var body: some View {\n        VStack {\n            if isPresented {\n                Text(\"Hello, World!\")\n                    .transition(.slide)\n            }\n            Button(\"Toggle View\") {\n                withAnimation {\n                    isPresented.toggle()\n                }\n            }\n        }\n    }\n}\n```\n\n在这个示例中，当`isPresented`状态变化时，`Text`视图会滑入或滑出。\n\n**组合转场**\n\n你还可以组合多个转场来创建独特的效果：\n\n```swift\n.transition(.asymmetric(insertion: .scale, removal: .opacity))\n```\n\n在这里，视图出现时使用缩放效果，消失时使用渐隐效果。\n\n**自定义转场**\n\nSwiftUI还允许创建自定义转场。这通常是通过定义视图的两种状态并描述它们之间的动画过渡来实现的。\n\n```swift\nextension AnyTransition {\n    static var pivot: AnyTransition {\n        .modifier(\n            active: CornerRotateModifier(amount: -90),\n            identity: CornerRotateModifier(amount: 0)\n        )\n    }\n}\n\nstruct CornerRotateModifier: ViewModifier {\n    let amount: Double\n    func body(content: Content) -> some View {\n        content.rotationEffect(Angle(degrees: amount), anchor: .topLeading)\n    }\n}\n```\n\n在这个自定义转场中，`pivot`通过旋转视图的顶部锚点实现转动效果。\n\n**使用转场动画**\n\n转场可以与`withAnimation`闭包结合使用，来实现视图状态变化时的平滑过渡。\n\n```swift\nButton(\"Toggle View\") {\n    withAnimation(.spring()) {\n        isPresented.toggle()\n    }\n}\n```\n\n这将创建一个在点击按钮时视图呈现和消失时有弹簧动效的交互。\n\n**小结**\n\n转场动画在SwiftUI中为开发者提供了一个高效的方法来处理视图的呈现和消失，使用户界面更加生动和有趣。内置的转场类型适用于多数情况，而自定义转场则为特殊需求提供了无限的可能性。通过恰当使用转场，可以大大提升应用的质感和用户满意度。","slug":"SwiftUI核心技术第8章动画与转场","published":1,"updated":"2024-03-17T06:11:41.709Z","comments":1,"layout":"post","photos":[],"_id":"clu6up53j002mz6744s97grs6","content":"<p><strong>第8章：动画与转场</strong></p>\n<p><strong>第1小节：基础动画</strong></p>\n<p>在SwiftUI中，动画是用来增强用户体验的一种手段，它可以提供平滑的视觉过渡和引人注目的交互。通过使用SwiftUI强大的动画API，你可以轻松地为界面元素添加动画效果。</p>\n<p><strong>动画的类型</strong></p>\n<p>在SwiftUI中，动画主要可以分为隐式动画和显式动画两大类。</p>\n<ol>\n<li><strong>隐式动画</strong>：最简单的动画形式，仅需要使用<code>.animation()</code>修饰符，并为其提供一个动画样式。</li>\n<li><strong>显式动画</strong>：使用<code>withAnimation</code>函数来明确开始动画的时间点，并提供一个动画样式。</li>\n</ol>\n<p><strong>创建一个简单的隐式动画</strong></p>\n<p>你可以通过在视图的某个状态改变时附加<code>.animation()</code>修饰符，让这个状态改变带有动画效果。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">SimpleAnimationView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> scale: <span class=\"hljs-type\">CGFloat</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1</span><br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">Circle</span>()<br>            .scaleEffect(scale)<br>            .animation(.easeInOut, value: scale)<br>            .onTapGesture &#123;<br>                scale <span class=\"hljs-operator\">+=</span> <span class=\"hljs-number\">1</span><br>            &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在上面的例子中，每当用户点击圆形，<code>scale</code>状态变量就会增加，而圆形的尺寸变化将以渐进渐出的方式动画显示。</p>\n<p><strong>使用<code>withAnimation</code>进行显式动画</strong></p>\n<p>如果你想控制动画的触发时机，而不是依赖于状态的改变，你可以使用<code>withAnimation</code>来显式地执行动画。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Button</span>(<span class=\"hljs-string\">&quot;Tap Me&quot;</span>) &#123;<br>    withAnimation(.spring(response: <span class=\"hljs-number\">0.5</span>, dampingFraction: <span class=\"hljs-number\">0.5</span>, blendDuration: <span class=\"hljs-number\">1</span>)) &#123;<br>        scale <span class=\"hljs-operator\">+=</span> <span class=\"hljs-number\">1</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在这个例子中，当按钮被点击时，不管<code>scale</code>的值如何变化，动画都会被执行。</p>\n<p><strong>动画的组合</strong></p>\n<p>你可以将不同的动画效果组合在一起，创建复杂的动画序列。这通过在<code>.animation()</code>修饰符中使用<code>Animation</code>的静态方法来实现。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\">.animation(<br>    <span class=\"hljs-type\">Animation</span>.easeInOut(duration: <span class=\"hljs-number\">2</span>).repeatForever(autoreverses: <span class=\"hljs-literal\">true</span>)<br>)<br></code></pre></td></tr></table></figure>\n\n<p>此代码会创建一个无限重复并自动反向的渐进渐出动画。</p>\n<p><strong>动画参数</strong></p>\n<p>SwiftUI提供了许多可以调整动画行为的参数：</p>\n<ul>\n<li><code>duration</code>：动画的时长。</li>\n<li><code>delay</code>：动画开始前的等待时间。</li>\n<li><code>repeatCount</code>：动画重复的次数。</li>\n<li><code>autoreverses</code>：动画是否在完成后自动反向。</li>\n</ul>\n<p><strong>小结</strong></p>\n<p>基础动画是SwiftUI中最容易实现的动画类型，它们可以快速为你的应用添加视觉吸引力和反馈。通过使用隐式动画或显式动画，你可以控制动画的触发方式和行为。此外，SwiftUI的动画系统是高度可组合的，允许你通过组合和定制动画参数来创建复杂的动画效果。</p>\n<p>在本书的后续章节中，我们将深入探讨如何使用SwiftUI的高级动画功能，比如路径动画、自定义时间曲线以及动画的联动效果，来创建更具表现力和创造力的用户界面。</p>\n<p><strong>第2小节：自定义动画</strong></p>\n<p>在SwiftUI中，除了内置的动画类型，开发者还可以通过自定义动画来进一步个性化UI交互。自定义动画允许开发者控制动画的具体行为和时间曲线，实现独特的动态效果。</p>\n<p><strong>动画时间曲线</strong></p>\n<p>时间曲线描述了动画状态值随时间的变化方式。SwiftUI提供了几种内置的时间曲线，例如<code>easeIn</code>、<code>easeOut</code>和<code>easeInOut</code>。要自定义这些曲线，你可以使用<code>timingCurve(_:_:_:_:)</code>方法。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\">.animation(.timingCurve(<span class=\"hljs-number\">0.2</span>, <span class=\"hljs-number\">0.8</span>, <span class=\"hljs-number\">0.2</span>, <span class=\"hljs-number\">1</span>, duration: <span class=\"hljs-number\">0.5</span>))<br></code></pre></td></tr></table></figure>\n\n<p>这个方法接受四个表示贝塞尔曲线控制点的参数，可以非常精细地控制动画的加速和减速过程。</p>\n<p><strong>使用<code>interpolatingSpring</code>自定义弹簧动画</strong></p>\n<p>如果你需要一个物理弹性效果，可以使用<code>interpolatingSpring(stiffness:damping:)</code>函数来自定义一个弹簧动画。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\">.animation(.interpolatingSpring(stiffness: <span class=\"hljs-number\">50</span>, damping: <span class=\"hljs-number\">5</span>))<br></code></pre></td></tr></table></figure>\n\n<p>调整<code>stiffness</code>（刚度）和<code>damping</code>（阻尼）参数可以模拟不同的弹簧物理特性。</p>\n<p><strong>使用<code>Animation</code>的<code>delay(_: )</code>和<code>speed(_: )</code>自定义动画速度和延迟</strong></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\">.animation(.easeInOut(duration: <span class=\"hljs-number\">2</span>).delay(<span class=\"hljs-number\">0.5</span>).speed(<span class=\"hljs-number\">2</span>))<br></code></pre></td></tr></table></figure>\n\n<p>这里，动画会在半秒延迟后开始，并且以原始时长的两倍速度播放。</p>\n<p><strong>自定义动画路径</strong></p>\n<p>SwiftUI动画不仅限于简单的开始和结束状态之间的过渡。使用<code>GeometryEffect</code>，你可以创建完全自定义的动画路径。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">CustomAnimationView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> isAnimated <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">false</span><br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">Circle</span>()<br>            .frame(width: <span class=\"hljs-number\">100</span>, height: <span class=\"hljs-number\">100</span>)<br>            .modifier(<span class=\"hljs-type\">CustomPathModifier</span>(isAnimated: <span class=\"hljs-variable\">$isAnimated</span>))<br>            .onTapGesture &#123;<br>                withAnimation &#123;<br>                    isAnimated.toggle()<br>                &#125;<br>            &#125;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">CustomPathModifier</span>: <span class=\"hljs-title class_\">GeometryEffect</span> &#123;<br>    <span class=\"hljs-meta\">@Binding</span> <span class=\"hljs-keyword\">var</span> isAnimated: <span class=\"hljs-type\">Bool</span><br><br>    <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">effectValue</span>(<span class=\"hljs-params\">size</span>: <span class=\"hljs-type\">CGSize</span>) -&gt; <span class=\"hljs-type\">ProjectionTransform</span> &#123;<br>        <span class=\"hljs-keyword\">let</span> path <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">UIBezierPath</span>()<br>        path.move(to: <span class=\"hljs-type\">CGPoint</span>(x: <span class=\"hljs-number\">0</span>, y: isAnimated <span class=\"hljs-operator\">?</span> size.height : <span class=\"hljs-number\">0</span>))<br>        <span class=\"hljs-comment\">// Your custom path here</span><br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-type\">ProjectionTransform</span>(<span class=\"hljs-type\">CGAffineTransform</span>(translationX: path.currentPoint.x, y: path.currentPoint.y))<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>通过创建一个遵循<code>GeometryEffect</code>协议的自定义修饰符，你可以定义一个复杂的动画路径，这个路径由一个点沿着给定路径移动的动画组成。</p>\n<p><strong>自定义动画的应用场景</strong></p>\n<ul>\n<li>当内置动画不能满足你的设计需求时。</li>\n<li>当你想要创建一个与众不同的动态交互体验。</li>\n<li>在需要精确控制动画行为，如游戏或特定动画教程中。</li>\n</ul>\n<p><strong>小结</strong></p>\n<p>自定义动画是SwiftUI动画功能的深入使用。通过控制时间曲线、弹簧动画参数和自定义动画路径，你可以创造出个性化和专业级别的动态效果。自定义动画能提升应用的专业感和用户的交互体验，使你的应用在众多相似应用中脱颖而出。</p>\n<p>接下来，我们将探讨转场动画，它们可以为视图的呈现和消失提供引人注目的视觉效果。</p>\n<p><strong>第3小节：交互式和响应式动画</strong></p>\n<p>在构建现代的用户界面时，我们不仅希望动画能够提供视觉上的引导和反馈，还希望它们能够与用户的交互紧密结合，创造流畅的体验。这就是交互式和响应式动画发挥作用的地方。在SwiftUI中，你可以根据用户的输入或其他事件，实时地调整动画，从而创建出高度交互的UI元素。</p>\n<p><strong>交互式动画</strong></p>\n<p>交互式动画是指随着用户的操作实时变化的动画。例如，拖动滑块时的动态变化或者通过手势控制的动画。</p>\n<p><strong>实现交互式动画的方法</strong></p>\n<p>你可以通过以下方式为你的应用添加交互式动画：</p>\n<ol>\n<li><p><strong>使用Gesture</strong></p>\n<p>绑定手势到视图，然后在手势变化时更新视图的状态。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">InteractiveView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@GestureState</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> dragState <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">CGSize</span>.zero<br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">Rectangle</span>()<br>            .fill(<span class=\"hljs-type\">Color</span>.blue)<br>            .frame(width: <span class=\"hljs-number\">100</span>, height: <span class=\"hljs-number\">100</span>)<br>            .offset(dragState)<br>            .gesture(<br>                <span class=\"hljs-type\">DragGesture</span>()<br>                    .updating(<span class=\"hljs-variable\">$dragState</span>) &#123; value, state, <span class=\"hljs-keyword\">_</span> <span class=\"hljs-keyword\">in</span><br>                        state <span class=\"hljs-operator\">=</span> value.translation<br>                    &#125;<br>            )<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在这个例子中，<code>DragGesture</code>跟踪手指的拖动，并实时更新<code>Rectangle</code>的偏移。</p>\n</li>\n<li><p><strong>与动画状态链接</strong></p>\n<p>将动画和状态变量结合起来，实现随状态改变而动画的效果。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ResponsiveView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> position <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">CGPoint</span>.zero<br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">Circle</span>()<br>            .position(position)<br>            .onTapGesture &#123;<br>                withAnimation &#123;<br>                    position <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">CGPoint</span>(x: position.x <span class=\"hljs-operator\">+</span> <span class=\"hljs-number\">100</span>, y: position.y <span class=\"hljs-operator\">+</span> <span class=\"hljs-number\">100</span>)<br>                &#125;<br>            &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这里，每次点击都会使圆形移动，并伴随平滑的过渡动画。</p>\n</li>\n</ol>\n<p><strong>响应式动画</strong></p>\n<p>响应式动画则是指根据外部事件或数据的变化而自动触发的动画。例如，当接收到新消息时，提示符以动画的形式出现。</p>\n<p><strong>实现响应式动画的方法</strong></p>\n<ol>\n<li><p><strong>数据绑定</strong></p>\n<p>通过观察对象中的<code>@Published</code>属性变化来驱动动画。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">AnimationViewModel</span>: <span class=\"hljs-title class_\">ObservableObject</span> &#123;<br>    <span class=\"hljs-meta\">@Published</span> <span class=\"hljs-keyword\">var</span> isLoading <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">false</span><br>&#125;<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">LoadingView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@ObservedObject</span> <span class=\"hljs-keyword\">var</span> viewModel <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">AnimationViewModel</span>()<br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">Circle</span>()<br>            .frame(width: <span class=\"hljs-number\">50</span>, height: <span class=\"hljs-number\">50</span>)<br>            .rotationEffect(<span class=\"hljs-type\">Angle</span>(degrees: viewModel.isLoading <span class=\"hljs-operator\">?</span> <span class=\"hljs-number\">360</span> : <span class=\"hljs-number\">0</span>))<br>            .animation(<span class=\"hljs-type\">Animation</span>.linear(duration: <span class=\"hljs-number\">1</span>).repeatForever(autoreverses: <span class=\"hljs-literal\">false</span>), value: viewModel.isLoading)<br>            .onAppear &#123;<br>                viewModel.isLoading <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">true</span><br>            &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>当<code>isLoading</code>变为<code>true</code>时，圆形会开始无限旋转，模拟加载指示器的效果。</p>\n</li>\n<li><p><strong>环境变量</strong></p>\n<p>利用<code>@EnvironmentObject</code>或其他环境属性，在多个视图之间共享动画状态。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ContentView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@EnvironmentObject</span> <span class=\"hljs-keyword\">var</span> userSettings: <span class=\"hljs-type\">UserSettings</span><br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">Text</span>(userSettings.username)<br>            .scaleEffect(userSettings.isLoggedOut <span class=\"hljs-operator\">?</span> <span class=\"hljs-number\">0</span> : <span class=\"hljs-number\">1</span>)<br>            .animation(.spring(), value: userSettings.isLoggedOut)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>当用户注销时，用户名的文本会通过缩放动画消失。</p>\n</li>\n</ol>\n<p><strong>小结</strong></p>\n<p>交互式和响应式动画在提高应用的用户体验方面起着至关重要的作用。在SwiftUI中，你可以轻松地将动画与用户的交互以及应用的数据状态相结合。</p>\n<p><strong>第4小节：转场动画</strong></p>\n<p>转场动画是用户界面的一部分，它们在视图的呈现和消失时创造连贯的视觉效果。在SwiftUI中，转场是以声明的方式定义的，允许开发者指定添加或删除视图时的动画类型。利用转场，开发者可以提供一种流畅的视觉体验，减少用户界面变化对用户认知的干扰。</p>\n<p><strong>基础转场</strong></p>\n<p>SwiftUI提供了几种内置的转场类型，例如<code>.opacity</code>、<code>.slide</code>和<code>.scale</code>。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ContentView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> isPresented <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">false</span><br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">VStack</span> &#123;<br>            <span class=\"hljs-keyword\">if</span> isPresented &#123;<br>                <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Hello, World!&quot;</span>)<br>                    .transition(.slide)<br>            &#125;<br>            <span class=\"hljs-type\">Button</span>(<span class=\"hljs-string\">&quot;Toggle View&quot;</span>) &#123;<br>                withAnimation &#123;<br>                    isPresented.toggle()<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在这个示例中，当<code>isPresented</code>状态变化时，<code>Text</code>视图会滑入或滑出。</p>\n<p><strong>组合转场</strong></p>\n<p>你还可以组合多个转场来创建独特的效果：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\">.transition(.asymmetric(insertion: .scale, removal: .opacity))<br></code></pre></td></tr></table></figure>\n\n<p>在这里，视图出现时使用缩放效果，消失时使用渐隐效果。</p>\n<p><strong>自定义转场</strong></p>\n<p>SwiftUI还允许创建自定义转场。这通常是通过定义视图的两种状态并描述它们之间的动画过渡来实现的。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">extension</span> <span class=\"hljs-title class_\">AnyTransition</span> &#123;<br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">var</span> pivot: <span class=\"hljs-type\">AnyTransition</span> &#123;<br>        .modifier(<br>            active: <span class=\"hljs-type\">CornerRotateModifier</span>(amount: <span class=\"hljs-operator\">-</span><span class=\"hljs-number\">90</span>),<br>            identity: <span class=\"hljs-type\">CornerRotateModifier</span>(amount: <span class=\"hljs-number\">0</span>)<br>        )<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">CornerRotateModifier</span>: <span class=\"hljs-title class_\">ViewModifier</span> &#123;<br>    <span class=\"hljs-keyword\">let</span> amount: <span class=\"hljs-type\">Double</span><br>    <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">body</span>(<span class=\"hljs-params\">content</span>: <span class=\"hljs-type\">Content</span>) -&gt; <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        content.rotationEffect(<span class=\"hljs-type\">Angle</span>(degrees: amount), anchor: .topLeading)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在这个自定义转场中，<code>pivot</code>通过旋转视图的顶部锚点实现转动效果。</p>\n<p><strong>使用转场动画</strong></p>\n<p>转场可以与<code>withAnimation</code>闭包结合使用，来实现视图状态变化时的平滑过渡。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Button</span>(<span class=\"hljs-string\">&quot;Toggle View&quot;</span>) &#123;<br>    withAnimation(.spring()) &#123;<br>        isPresented.toggle()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这将创建一个在点击按钮时视图呈现和消失时有弹簧动效的交互。</p>\n<p><strong>小结</strong></p>\n<p>转场动画在SwiftUI中为开发者提供了一个高效的方法来处理视图的呈现和消失，使用户界面更加生动和有趣。内置的转场类型适用于多数情况，而自定义转场则为特殊需求提供了无限的可能性。通过恰当使用转场，可以大大提升应用的质感和用户满意度。</p>\n","excerpt":"","more":"<p><strong>第8章：动画与转场</strong></p>\n<p><strong>第1小节：基础动画</strong></p>\n<p>在SwiftUI中，动画是用来增强用户体验的一种手段，它可以提供平滑的视觉过渡和引人注目的交互。通过使用SwiftUI强大的动画API，你可以轻松地为界面元素添加动画效果。</p>\n<p><strong>动画的类型</strong></p>\n<p>在SwiftUI中，动画主要可以分为隐式动画和显式动画两大类。</p>\n<ol>\n<li><strong>隐式动画</strong>：最简单的动画形式，仅需要使用<code>.animation()</code>修饰符，并为其提供一个动画样式。</li>\n<li><strong>显式动画</strong>：使用<code>withAnimation</code>函数来明确开始动画的时间点，并提供一个动画样式。</li>\n</ol>\n<p><strong>创建一个简单的隐式动画</strong></p>\n<p>你可以通过在视图的某个状态改变时附加<code>.animation()</code>修饰符，让这个状态改变带有动画效果。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">SimpleAnimationView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> scale: <span class=\"hljs-type\">CGFloat</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1</span><br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">Circle</span>()<br>            .scaleEffect(scale)<br>            .animation(.easeInOut, value: scale)<br>            .onTapGesture &#123;<br>                scale <span class=\"hljs-operator\">+=</span> <span class=\"hljs-number\">1</span><br>            &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在上面的例子中，每当用户点击圆形，<code>scale</code>状态变量就会增加，而圆形的尺寸变化将以渐进渐出的方式动画显示。</p>\n<p><strong>使用<code>withAnimation</code>进行显式动画</strong></p>\n<p>如果你想控制动画的触发时机，而不是依赖于状态的改变，你可以使用<code>withAnimation</code>来显式地执行动画。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Button</span>(<span class=\"hljs-string\">&quot;Tap Me&quot;</span>) &#123;<br>    withAnimation(.spring(response: <span class=\"hljs-number\">0.5</span>, dampingFraction: <span class=\"hljs-number\">0.5</span>, blendDuration: <span class=\"hljs-number\">1</span>)) &#123;<br>        scale <span class=\"hljs-operator\">+=</span> <span class=\"hljs-number\">1</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在这个例子中，当按钮被点击时，不管<code>scale</code>的值如何变化，动画都会被执行。</p>\n<p><strong>动画的组合</strong></p>\n<p>你可以将不同的动画效果组合在一起，创建复杂的动画序列。这通过在<code>.animation()</code>修饰符中使用<code>Animation</code>的静态方法来实现。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\">.animation(<br>    <span class=\"hljs-type\">Animation</span>.easeInOut(duration: <span class=\"hljs-number\">2</span>).repeatForever(autoreverses: <span class=\"hljs-literal\">true</span>)<br>)<br></code></pre></td></tr></table></figure>\n\n<p>此代码会创建一个无限重复并自动反向的渐进渐出动画。</p>\n<p><strong>动画参数</strong></p>\n<p>SwiftUI提供了许多可以调整动画行为的参数：</p>\n<ul>\n<li><code>duration</code>：动画的时长。</li>\n<li><code>delay</code>：动画开始前的等待时间。</li>\n<li><code>repeatCount</code>：动画重复的次数。</li>\n<li><code>autoreverses</code>：动画是否在完成后自动反向。</li>\n</ul>\n<p><strong>小结</strong></p>\n<p>基础动画是SwiftUI中最容易实现的动画类型，它们可以快速为你的应用添加视觉吸引力和反馈。通过使用隐式动画或显式动画，你可以控制动画的触发方式和行为。此外，SwiftUI的动画系统是高度可组合的，允许你通过组合和定制动画参数来创建复杂的动画效果。</p>\n<p>在本书的后续章节中，我们将深入探讨如何使用SwiftUI的高级动画功能，比如路径动画、自定义时间曲线以及动画的联动效果，来创建更具表现力和创造力的用户界面。</p>\n<p><strong>第2小节：自定义动画</strong></p>\n<p>在SwiftUI中，除了内置的动画类型，开发者还可以通过自定义动画来进一步个性化UI交互。自定义动画允许开发者控制动画的具体行为和时间曲线，实现独特的动态效果。</p>\n<p><strong>动画时间曲线</strong></p>\n<p>时间曲线描述了动画状态值随时间的变化方式。SwiftUI提供了几种内置的时间曲线，例如<code>easeIn</code>、<code>easeOut</code>和<code>easeInOut</code>。要自定义这些曲线，你可以使用<code>timingCurve(_:_:_:_:)</code>方法。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\">.animation(.timingCurve(<span class=\"hljs-number\">0.2</span>, <span class=\"hljs-number\">0.8</span>, <span class=\"hljs-number\">0.2</span>, <span class=\"hljs-number\">1</span>, duration: <span class=\"hljs-number\">0.5</span>))<br></code></pre></td></tr></table></figure>\n\n<p>这个方法接受四个表示贝塞尔曲线控制点的参数，可以非常精细地控制动画的加速和减速过程。</p>\n<p><strong>使用<code>interpolatingSpring</code>自定义弹簧动画</strong></p>\n<p>如果你需要一个物理弹性效果，可以使用<code>interpolatingSpring(stiffness:damping:)</code>函数来自定义一个弹簧动画。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\">.animation(.interpolatingSpring(stiffness: <span class=\"hljs-number\">50</span>, damping: <span class=\"hljs-number\">5</span>))<br></code></pre></td></tr></table></figure>\n\n<p>调整<code>stiffness</code>（刚度）和<code>damping</code>（阻尼）参数可以模拟不同的弹簧物理特性。</p>\n<p><strong>使用<code>Animation</code>的<code>delay(_: )</code>和<code>speed(_: )</code>自定义动画速度和延迟</strong></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\">.animation(.easeInOut(duration: <span class=\"hljs-number\">2</span>).delay(<span class=\"hljs-number\">0.5</span>).speed(<span class=\"hljs-number\">2</span>))<br></code></pre></td></tr></table></figure>\n\n<p>这里，动画会在半秒延迟后开始，并且以原始时长的两倍速度播放。</p>\n<p><strong>自定义动画路径</strong></p>\n<p>SwiftUI动画不仅限于简单的开始和结束状态之间的过渡。使用<code>GeometryEffect</code>，你可以创建完全自定义的动画路径。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">CustomAnimationView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> isAnimated <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">false</span><br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">Circle</span>()<br>            .frame(width: <span class=\"hljs-number\">100</span>, height: <span class=\"hljs-number\">100</span>)<br>            .modifier(<span class=\"hljs-type\">CustomPathModifier</span>(isAnimated: <span class=\"hljs-variable\">$isAnimated</span>))<br>            .onTapGesture &#123;<br>                withAnimation &#123;<br>                    isAnimated.toggle()<br>                &#125;<br>            &#125;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">CustomPathModifier</span>: <span class=\"hljs-title class_\">GeometryEffect</span> &#123;<br>    <span class=\"hljs-meta\">@Binding</span> <span class=\"hljs-keyword\">var</span> isAnimated: <span class=\"hljs-type\">Bool</span><br><br>    <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">effectValue</span>(<span class=\"hljs-params\">size</span>: <span class=\"hljs-type\">CGSize</span>) -&gt; <span class=\"hljs-type\">ProjectionTransform</span> &#123;<br>        <span class=\"hljs-keyword\">let</span> path <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">UIBezierPath</span>()<br>        path.move(to: <span class=\"hljs-type\">CGPoint</span>(x: <span class=\"hljs-number\">0</span>, y: isAnimated <span class=\"hljs-operator\">?</span> size.height : <span class=\"hljs-number\">0</span>))<br>        <span class=\"hljs-comment\">// Your custom path here</span><br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-type\">ProjectionTransform</span>(<span class=\"hljs-type\">CGAffineTransform</span>(translationX: path.currentPoint.x, y: path.currentPoint.y))<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>通过创建一个遵循<code>GeometryEffect</code>协议的自定义修饰符，你可以定义一个复杂的动画路径，这个路径由一个点沿着给定路径移动的动画组成。</p>\n<p><strong>自定义动画的应用场景</strong></p>\n<ul>\n<li>当内置动画不能满足你的设计需求时。</li>\n<li>当你想要创建一个与众不同的动态交互体验。</li>\n<li>在需要精确控制动画行为，如游戏或特定动画教程中。</li>\n</ul>\n<p><strong>小结</strong></p>\n<p>自定义动画是SwiftUI动画功能的深入使用。通过控制时间曲线、弹簧动画参数和自定义动画路径，你可以创造出个性化和专业级别的动态效果。自定义动画能提升应用的专业感和用户的交互体验，使你的应用在众多相似应用中脱颖而出。</p>\n<p>接下来，我们将探讨转场动画，它们可以为视图的呈现和消失提供引人注目的视觉效果。</p>\n<p><strong>第3小节：交互式和响应式动画</strong></p>\n<p>在构建现代的用户界面时，我们不仅希望动画能够提供视觉上的引导和反馈，还希望它们能够与用户的交互紧密结合，创造流畅的体验。这就是交互式和响应式动画发挥作用的地方。在SwiftUI中，你可以根据用户的输入或其他事件，实时地调整动画，从而创建出高度交互的UI元素。</p>\n<p><strong>交互式动画</strong></p>\n<p>交互式动画是指随着用户的操作实时变化的动画。例如，拖动滑块时的动态变化或者通过手势控制的动画。</p>\n<p><strong>实现交互式动画的方法</strong></p>\n<p>你可以通过以下方式为你的应用添加交互式动画：</p>\n<ol>\n<li><p><strong>使用Gesture</strong></p>\n<p>绑定手势到视图，然后在手势变化时更新视图的状态。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">InteractiveView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@GestureState</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> dragState <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">CGSize</span>.zero<br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">Rectangle</span>()<br>            .fill(<span class=\"hljs-type\">Color</span>.blue)<br>            .frame(width: <span class=\"hljs-number\">100</span>, height: <span class=\"hljs-number\">100</span>)<br>            .offset(dragState)<br>            .gesture(<br>                <span class=\"hljs-type\">DragGesture</span>()<br>                    .updating(<span class=\"hljs-variable\">$dragState</span>) &#123; value, state, <span class=\"hljs-keyword\">_</span> <span class=\"hljs-keyword\">in</span><br>                        state <span class=\"hljs-operator\">=</span> value.translation<br>                    &#125;<br>            )<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在这个例子中，<code>DragGesture</code>跟踪手指的拖动，并实时更新<code>Rectangle</code>的偏移。</p>\n</li>\n<li><p><strong>与动画状态链接</strong></p>\n<p>将动画和状态变量结合起来，实现随状态改变而动画的效果。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ResponsiveView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> position <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">CGPoint</span>.zero<br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">Circle</span>()<br>            .position(position)<br>            .onTapGesture &#123;<br>                withAnimation &#123;<br>                    position <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">CGPoint</span>(x: position.x <span class=\"hljs-operator\">+</span> <span class=\"hljs-number\">100</span>, y: position.y <span class=\"hljs-operator\">+</span> <span class=\"hljs-number\">100</span>)<br>                &#125;<br>            &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这里，每次点击都会使圆形移动，并伴随平滑的过渡动画。</p>\n</li>\n</ol>\n<p><strong>响应式动画</strong></p>\n<p>响应式动画则是指根据外部事件或数据的变化而自动触发的动画。例如，当接收到新消息时，提示符以动画的形式出现。</p>\n<p><strong>实现响应式动画的方法</strong></p>\n<ol>\n<li><p><strong>数据绑定</strong></p>\n<p>通过观察对象中的<code>@Published</code>属性变化来驱动动画。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">AnimationViewModel</span>: <span class=\"hljs-title class_\">ObservableObject</span> &#123;<br>    <span class=\"hljs-meta\">@Published</span> <span class=\"hljs-keyword\">var</span> isLoading <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">false</span><br>&#125;<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">LoadingView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@ObservedObject</span> <span class=\"hljs-keyword\">var</span> viewModel <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">AnimationViewModel</span>()<br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">Circle</span>()<br>            .frame(width: <span class=\"hljs-number\">50</span>, height: <span class=\"hljs-number\">50</span>)<br>            .rotationEffect(<span class=\"hljs-type\">Angle</span>(degrees: viewModel.isLoading <span class=\"hljs-operator\">?</span> <span class=\"hljs-number\">360</span> : <span class=\"hljs-number\">0</span>))<br>            .animation(<span class=\"hljs-type\">Animation</span>.linear(duration: <span class=\"hljs-number\">1</span>).repeatForever(autoreverses: <span class=\"hljs-literal\">false</span>), value: viewModel.isLoading)<br>            .onAppear &#123;<br>                viewModel.isLoading <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">true</span><br>            &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>当<code>isLoading</code>变为<code>true</code>时，圆形会开始无限旋转，模拟加载指示器的效果。</p>\n</li>\n<li><p><strong>环境变量</strong></p>\n<p>利用<code>@EnvironmentObject</code>或其他环境属性，在多个视图之间共享动画状态。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ContentView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@EnvironmentObject</span> <span class=\"hljs-keyword\">var</span> userSettings: <span class=\"hljs-type\">UserSettings</span><br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">Text</span>(userSettings.username)<br>            .scaleEffect(userSettings.isLoggedOut <span class=\"hljs-operator\">?</span> <span class=\"hljs-number\">0</span> : <span class=\"hljs-number\">1</span>)<br>            .animation(.spring(), value: userSettings.isLoggedOut)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>当用户注销时，用户名的文本会通过缩放动画消失。</p>\n</li>\n</ol>\n<p><strong>小结</strong></p>\n<p>交互式和响应式动画在提高应用的用户体验方面起着至关重要的作用。在SwiftUI中，你可以轻松地将动画与用户的交互以及应用的数据状态相结合。</p>\n<p><strong>第4小节：转场动画</strong></p>\n<p>转场动画是用户界面的一部分，它们在视图的呈现和消失时创造连贯的视觉效果。在SwiftUI中，转场是以声明的方式定义的，允许开发者指定添加或删除视图时的动画类型。利用转场，开发者可以提供一种流畅的视觉体验，减少用户界面变化对用户认知的干扰。</p>\n<p><strong>基础转场</strong></p>\n<p>SwiftUI提供了几种内置的转场类型，例如<code>.opacity</code>、<code>.slide</code>和<code>.scale</code>。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ContentView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> isPresented <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">false</span><br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">VStack</span> &#123;<br>            <span class=\"hljs-keyword\">if</span> isPresented &#123;<br>                <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Hello, World!&quot;</span>)<br>                    .transition(.slide)<br>            &#125;<br>            <span class=\"hljs-type\">Button</span>(<span class=\"hljs-string\">&quot;Toggle View&quot;</span>) &#123;<br>                withAnimation &#123;<br>                    isPresented.toggle()<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在这个示例中，当<code>isPresented</code>状态变化时，<code>Text</code>视图会滑入或滑出。</p>\n<p><strong>组合转场</strong></p>\n<p>你还可以组合多个转场来创建独特的效果：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\">.transition(.asymmetric(insertion: .scale, removal: .opacity))<br></code></pre></td></tr></table></figure>\n\n<p>在这里，视图出现时使用缩放效果，消失时使用渐隐效果。</p>\n<p><strong>自定义转场</strong></p>\n<p>SwiftUI还允许创建自定义转场。这通常是通过定义视图的两种状态并描述它们之间的动画过渡来实现的。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">extension</span> <span class=\"hljs-title class_\">AnyTransition</span> &#123;<br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">var</span> pivot: <span class=\"hljs-type\">AnyTransition</span> &#123;<br>        .modifier(<br>            active: <span class=\"hljs-type\">CornerRotateModifier</span>(amount: <span class=\"hljs-operator\">-</span><span class=\"hljs-number\">90</span>),<br>            identity: <span class=\"hljs-type\">CornerRotateModifier</span>(amount: <span class=\"hljs-number\">0</span>)<br>        )<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">CornerRotateModifier</span>: <span class=\"hljs-title class_\">ViewModifier</span> &#123;<br>    <span class=\"hljs-keyword\">let</span> amount: <span class=\"hljs-type\">Double</span><br>    <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">body</span>(<span class=\"hljs-params\">content</span>: <span class=\"hljs-type\">Content</span>) -&gt; <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        content.rotationEffect(<span class=\"hljs-type\">Angle</span>(degrees: amount), anchor: .topLeading)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在这个自定义转场中，<code>pivot</code>通过旋转视图的顶部锚点实现转动效果。</p>\n<p><strong>使用转场动画</strong></p>\n<p>转场可以与<code>withAnimation</code>闭包结合使用，来实现视图状态变化时的平滑过渡。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Button</span>(<span class=\"hljs-string\">&quot;Toggle View&quot;</span>) &#123;<br>    withAnimation(.spring()) &#123;<br>        isPresented.toggle()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这将创建一个在点击按钮时视图呈现和消失时有弹簧动效的交互。</p>\n<p><strong>小结</strong></p>\n<p>转场动画在SwiftUI中为开发者提供了一个高效的方法来处理视图的呈现和消失，使用户界面更加生动和有趣。内置的转场类型适用于多数情况，而自定义转场则为特殊需求提供了无限的可能性。通过恰当使用转场，可以大大提升应用的质感和用户满意度。</p>\n"},{"title":"SwiftUI核心技术第9章复合视图与可复用性","date":"2023-11-08T01:18:34.000Z","_content":"**第9章：复合视图与可复用性**\n\n**第1小节：组合现有视图**\n\n在构建复杂的用户界面时，有效的视图复用和组合是提高代码可维护性和减少重复的关键。SwiftUI以其声明式语法和数据驱动的方法论，为视图的复合提供了极佳的支持。\n\n**视图复合的概念**\n\n视图复合是指将多个较小的视图组合成一个复杂的视图的过程。这是软件工程中“组合优于继承”原则的直接体现，允许开发者通过构建并组合简单的视图块来创建复杂的用户界面。\n\n**基本视图组合**\n\n在SwiftUI中，最基本的视图组合可以通过使用Stacks、Groups等容器视图来完成。例如，一个简单的登录表单可以通过组合TextFields和Button视图来创建：\n\n```swift\nstruct LoginForm: View {\n    @State private var username: String = \"\"\n    @State private var password: String = \"\"\n\n    var body: some View {\n        VStack {\n            TextField(\"Username\", text: $username)\n                .textFieldStyle(RoundedBorderTextFieldStyle())\n            SecureField(\"Password\", text: $password)\n                .textFieldStyle(RoundedBorderTextFieldStyle())\n            Button(\"Log In\") {\n                // Handle login action\n            }\n            .padding()\n        }\n    }\n}\n```\n\n在这个例子中，我们创建了一个自定义的`LoginForm`视图，它将两个文本字段和一个按钮组合在一起。\n\n**视图抽象**\n\nSwiftUI的另一个强大功能是能够创建可复用的自定义视图。例如，如果我们发现在不同的地方多次使用相同的文本样式，可以将其抽象为一个可复用的视图：\n\n```swift\nstruct TitleText: View {\n    var text: String\n\n    var body: some View {\n        Text(text)\n            .font(.largeTitle)\n            .foregroundColor(.blue)\n    }\n}\n```\n\n使用`TitleText`视图可以确保文本样式的一致性，并且在更新样式时，只需修改`TitleText`视图的定义即可。\n\n**利用视图修饰符**\n\n除了创建完整的自定义视图外，开发者也可以定义视图修饰符来封装常用的修改器组合。这可以进一步简化视图定义并增强可读性：\n\n```swift\nstruct CardStyle: ViewModifier {\n    func body(content: Content) -> some View {\n        content\n            .padding()\n            .background(Color.white)\n            .cornerRadius(10)\n            .shadow(radius: 5)\n    }\n}\n\nextension View {\n    func cardStyle() -> some View {\n        self.modifier(CardStyle())\n    }\n}\n```\n\n现在，任何视图都可以轻松地应用这个“卡片”样式：\n\n```swift\nText(\"Hello World\")\n    .cardStyle()\n```\n\n**小结**\n\n通过组合现有视图，开发者可以在SwiftUI中高效地构建复杂的用户界面。这种方法的核心优势是它提高了代码的可维护性、减少了重复，并且通过自定义视图和视图修饰符，能够轻松实现视图的一致性和可复用性。这种模块化的构建方式非常适合快速迭代和扩展，是构建复杂UI时的推荐方法。\n\n\n**第2小节：创建可复用的视图库**\n\n在构建复杂的SwiftUI应用时，开发者会逐渐积累起一组可复用的视图和视图修饰符。将这些元素组织成一个内部视图库，不仅可以提升开发效率，还可以确保UI的一致性。在这一节中，我们将探讨如何创建和维护一个可复用的视图库。\n\n**可复用视图库的优点**\n\n1. **一致性**：统一的视图库可以确保整个应用的视觉元素保持一致。\n2. **效率**：通过重用视图组件，可以避免重复劳动，加快开发速度。\n3. **可维护性**：需要调整设计时，只需要更新视图库中的组件即可影响整个应用。\n\n**设计可复用视图**\n\n当设计一个可复用视图时，考虑以下几个方面：\n\n- **通用性**：视图应该足够通用，能够适应不同的使用场景。\n- **可配置性**：提供合理的接口来调整视图的外观和行为。\n- **独立性**：视图应该是自包含的，不依赖于外部状态。\n\n**视图库结构**\n\n一个好的视图库应该具有清晰的结构，通常包含以下几个层次：\n\n1. **基础视图**：最基本的视图组件，如按钮、标签、输入框等。\n2. **视图修饰符**：用于修饰视图的通用样式，如阴影、边框、字体样式等。\n3. **复合视图**：由多个基础视图或其他复合视图组合而成的复杂视图。\n4. **布局**：用于组织视图在容器中的位置和排列的布局组件。\n\n**实施示例**\n\n让我们来定义一个基础的可复用视图库的组件：\n\n```swift\n// 基础视图\nstruct PrimaryButton: View {\n    var title: String\n    var action: () -> Void\n\n    var body: some View {\n        Button(action: action) {\n            Text(title)\n                .fontWeight(.bold)\n                .frame(minWidth: 0, maxWidth: .infinity)\n                .padding()\n                .background(Color.blue)\n                .foregroundColor(.white)\n                .cornerRadius(10)\n        }\n    }\n}\n\n// 视图修饰符\nstruct ShadowModifier: ViewModifier {\n    func body(content: Content) -> some View {\n        content\n            .shadow(color: .gray, radius: 5, x: 0, y: 2)\n    }\n}\n\nextension View {\n    func applyShadow() -> some View {\n        modifier(ShadowModifier())\n    }\n}\n\n// 复合视图\nstruct UserInfoCard: View {\n    var username: String\n    var email: String\n\n    var body: some View {\n        VStack(alignment: .leading) {\n            Text(username)\n                .font(.headline)\n                .applyShadow()\n            Text(email)\n                .font(.subheadline)\n        }\n        .padding()\n        .background(Color.white)\n        .cornerRadius(10)\n        .applyShadow()\n    }\n}\n```\n\n**视图库的维护**\n\n- **文档**：为每个组件编写详细的文档，说明其用法和配置选项。\n- **示例应用**：创建一个示例应用，演示视图库中每个组件的用法。\n- **版本控制**：当更新视图库时，使用版本控制来管理变更。\n\n**小结**\n\n创建和维护一个可复用的视图库是提高SwiftUI应用开发效率和质量的有效方法。通过精心设计和文档化，视图库不仅能够确保UI的一致性，还能极大地简化应用的迭代和扩展。\n\n\n**第3小节：自定义Modifier**\n\n在SwiftUI中，`Modifier`允许开发者封装一系列的视图修改操作，并可复用于不同的视图。通过创建自定义的`Modifier`，可以极大地提高代码的可维护性和清晰度，同时也使得UI组件的风格和布局保持一致。本小节将详细介绍如何定义和使用自定义Modifier。\n\n**理解Modifier**\n\nModifier是一种遵循`ViewModifier`协议的结构体，它通过改变视图的渲染和布局属性来修改视图的外观和行为。每当对视图应用Modifier时，SwiftUI都会在背后创建一个新的视图结构，而不是修改旧的视图。这使得视图修改操作既安全又易于管理。\n\n**创建自定义Modifier**\n\n1. **定义Modifier结构体**：首先，需要定义一个结构体并遵循`ViewModifier`协议。\n2. **实现`body`属性**：在结构体中实现必需的`body`计算属性，它接收一个`Content`参数，并返回一个新的视图。\n3. **添加修改操作**：在`body`属性中，对传入的`Content`进行修改，如添加边框、改变字体、设置背景等。\n\n**示例：自定义圆角和阴影Modifier**\n\n```swift\nstruct RoundedShadowModifier: ViewModifier {\n    var radius: CGFloat\n    var shadowRadius: CGFloat\n\n    func body(content: Content) -> some View {\n        content\n            .cornerRadius(radius)\n            .shadow(radius: shadowRadius)\n    }\n}\n\nextension View {\n    func roundedShadow(radius: CGFloat, shadowRadius: CGFloat) -> some View {\n        modifier(RoundedShadowModifier(radius: radius, shadowRadius: shadowRadius))\n    }\n}\n```\n\n在上述示例中，我们定义了一个名为`RoundedShadowModifier`的自定义Modifier，它将圆角和阴影效果应用于任何视图。通过`extension`扩展`View`，我们为所有视图添加了一个名为`roundedShadow`的新方法，它使得应用圆角和阴影更加便捷。\n\n**使用自定义Modifier**\n\n一旦定义了自定义Modifier，就可以在任何视图上像使用内置Modifier一样使用它：\n\n```swift\nText(\"Hello, SwiftUI!\")\n    .roundedShadow(radius: 10, shadowRadius: 5)\n```\n\n**优化Modifier**\n\n- **链式调用**：Modifier可以链式调用，使得视图修改更加灵活。\n- **条件修改**：可以使用条件语句动态地应用Modifier。\n- **性能考虑**：尽量避免创建过于复杂的Modifier，以免影响性能。\n\n**总结**\n\n自定义Modifier在SwiftUI开发中是一项强大的工具，它不仅可以提高代码的复用性和清晰度，还可以帮助维护应用的视觉一致性。通过创建合适的自定义Modifier，可以简化视图的构建过程，并提升开发效率。","source":"_posts/SwiftUI核心技术第9章复合视图与可复用性.md","raw":"---\ntitle: SwiftUI核心技术第9章复合视图与可复用性\ndate: 2023-11-08 09:18:34\ncategories:\n- SwiftUI\ntags:\n---\n**第9章：复合视图与可复用性**\n\n**第1小节：组合现有视图**\n\n在构建复杂的用户界面时，有效的视图复用和组合是提高代码可维护性和减少重复的关键。SwiftUI以其声明式语法和数据驱动的方法论，为视图的复合提供了极佳的支持。\n\n**视图复合的概念**\n\n视图复合是指将多个较小的视图组合成一个复杂的视图的过程。这是软件工程中“组合优于继承”原则的直接体现，允许开发者通过构建并组合简单的视图块来创建复杂的用户界面。\n\n**基本视图组合**\n\n在SwiftUI中，最基本的视图组合可以通过使用Stacks、Groups等容器视图来完成。例如，一个简单的登录表单可以通过组合TextFields和Button视图来创建：\n\n```swift\nstruct LoginForm: View {\n    @State private var username: String = \"\"\n    @State private var password: String = \"\"\n\n    var body: some View {\n        VStack {\n            TextField(\"Username\", text: $username)\n                .textFieldStyle(RoundedBorderTextFieldStyle())\n            SecureField(\"Password\", text: $password)\n                .textFieldStyle(RoundedBorderTextFieldStyle())\n            Button(\"Log In\") {\n                // Handle login action\n            }\n            .padding()\n        }\n    }\n}\n```\n\n在这个例子中，我们创建了一个自定义的`LoginForm`视图，它将两个文本字段和一个按钮组合在一起。\n\n**视图抽象**\n\nSwiftUI的另一个强大功能是能够创建可复用的自定义视图。例如，如果我们发现在不同的地方多次使用相同的文本样式，可以将其抽象为一个可复用的视图：\n\n```swift\nstruct TitleText: View {\n    var text: String\n\n    var body: some View {\n        Text(text)\n            .font(.largeTitle)\n            .foregroundColor(.blue)\n    }\n}\n```\n\n使用`TitleText`视图可以确保文本样式的一致性，并且在更新样式时，只需修改`TitleText`视图的定义即可。\n\n**利用视图修饰符**\n\n除了创建完整的自定义视图外，开发者也可以定义视图修饰符来封装常用的修改器组合。这可以进一步简化视图定义并增强可读性：\n\n```swift\nstruct CardStyle: ViewModifier {\n    func body(content: Content) -> some View {\n        content\n            .padding()\n            .background(Color.white)\n            .cornerRadius(10)\n            .shadow(radius: 5)\n    }\n}\n\nextension View {\n    func cardStyle() -> some View {\n        self.modifier(CardStyle())\n    }\n}\n```\n\n现在，任何视图都可以轻松地应用这个“卡片”样式：\n\n```swift\nText(\"Hello World\")\n    .cardStyle()\n```\n\n**小结**\n\n通过组合现有视图，开发者可以在SwiftUI中高效地构建复杂的用户界面。这种方法的核心优势是它提高了代码的可维护性、减少了重复，并且通过自定义视图和视图修饰符，能够轻松实现视图的一致性和可复用性。这种模块化的构建方式非常适合快速迭代和扩展，是构建复杂UI时的推荐方法。\n\n\n**第2小节：创建可复用的视图库**\n\n在构建复杂的SwiftUI应用时，开发者会逐渐积累起一组可复用的视图和视图修饰符。将这些元素组织成一个内部视图库，不仅可以提升开发效率，还可以确保UI的一致性。在这一节中，我们将探讨如何创建和维护一个可复用的视图库。\n\n**可复用视图库的优点**\n\n1. **一致性**：统一的视图库可以确保整个应用的视觉元素保持一致。\n2. **效率**：通过重用视图组件，可以避免重复劳动，加快开发速度。\n3. **可维护性**：需要调整设计时，只需要更新视图库中的组件即可影响整个应用。\n\n**设计可复用视图**\n\n当设计一个可复用视图时，考虑以下几个方面：\n\n- **通用性**：视图应该足够通用，能够适应不同的使用场景。\n- **可配置性**：提供合理的接口来调整视图的外观和行为。\n- **独立性**：视图应该是自包含的，不依赖于外部状态。\n\n**视图库结构**\n\n一个好的视图库应该具有清晰的结构，通常包含以下几个层次：\n\n1. **基础视图**：最基本的视图组件，如按钮、标签、输入框等。\n2. **视图修饰符**：用于修饰视图的通用样式，如阴影、边框、字体样式等。\n3. **复合视图**：由多个基础视图或其他复合视图组合而成的复杂视图。\n4. **布局**：用于组织视图在容器中的位置和排列的布局组件。\n\n**实施示例**\n\n让我们来定义一个基础的可复用视图库的组件：\n\n```swift\n// 基础视图\nstruct PrimaryButton: View {\n    var title: String\n    var action: () -> Void\n\n    var body: some View {\n        Button(action: action) {\n            Text(title)\n                .fontWeight(.bold)\n                .frame(minWidth: 0, maxWidth: .infinity)\n                .padding()\n                .background(Color.blue)\n                .foregroundColor(.white)\n                .cornerRadius(10)\n        }\n    }\n}\n\n// 视图修饰符\nstruct ShadowModifier: ViewModifier {\n    func body(content: Content) -> some View {\n        content\n            .shadow(color: .gray, radius: 5, x: 0, y: 2)\n    }\n}\n\nextension View {\n    func applyShadow() -> some View {\n        modifier(ShadowModifier())\n    }\n}\n\n// 复合视图\nstruct UserInfoCard: View {\n    var username: String\n    var email: String\n\n    var body: some View {\n        VStack(alignment: .leading) {\n            Text(username)\n                .font(.headline)\n                .applyShadow()\n            Text(email)\n                .font(.subheadline)\n        }\n        .padding()\n        .background(Color.white)\n        .cornerRadius(10)\n        .applyShadow()\n    }\n}\n```\n\n**视图库的维护**\n\n- **文档**：为每个组件编写详细的文档，说明其用法和配置选项。\n- **示例应用**：创建一个示例应用，演示视图库中每个组件的用法。\n- **版本控制**：当更新视图库时，使用版本控制来管理变更。\n\n**小结**\n\n创建和维护一个可复用的视图库是提高SwiftUI应用开发效率和质量的有效方法。通过精心设计和文档化，视图库不仅能够确保UI的一致性，还能极大地简化应用的迭代和扩展。\n\n\n**第3小节：自定义Modifier**\n\n在SwiftUI中，`Modifier`允许开发者封装一系列的视图修改操作，并可复用于不同的视图。通过创建自定义的`Modifier`，可以极大地提高代码的可维护性和清晰度，同时也使得UI组件的风格和布局保持一致。本小节将详细介绍如何定义和使用自定义Modifier。\n\n**理解Modifier**\n\nModifier是一种遵循`ViewModifier`协议的结构体，它通过改变视图的渲染和布局属性来修改视图的外观和行为。每当对视图应用Modifier时，SwiftUI都会在背后创建一个新的视图结构，而不是修改旧的视图。这使得视图修改操作既安全又易于管理。\n\n**创建自定义Modifier**\n\n1. **定义Modifier结构体**：首先，需要定义一个结构体并遵循`ViewModifier`协议。\n2. **实现`body`属性**：在结构体中实现必需的`body`计算属性，它接收一个`Content`参数，并返回一个新的视图。\n3. **添加修改操作**：在`body`属性中，对传入的`Content`进行修改，如添加边框、改变字体、设置背景等。\n\n**示例：自定义圆角和阴影Modifier**\n\n```swift\nstruct RoundedShadowModifier: ViewModifier {\n    var radius: CGFloat\n    var shadowRadius: CGFloat\n\n    func body(content: Content) -> some View {\n        content\n            .cornerRadius(radius)\n            .shadow(radius: shadowRadius)\n    }\n}\n\nextension View {\n    func roundedShadow(radius: CGFloat, shadowRadius: CGFloat) -> some View {\n        modifier(RoundedShadowModifier(radius: radius, shadowRadius: shadowRadius))\n    }\n}\n```\n\n在上述示例中，我们定义了一个名为`RoundedShadowModifier`的自定义Modifier，它将圆角和阴影效果应用于任何视图。通过`extension`扩展`View`，我们为所有视图添加了一个名为`roundedShadow`的新方法，它使得应用圆角和阴影更加便捷。\n\n**使用自定义Modifier**\n\n一旦定义了自定义Modifier，就可以在任何视图上像使用内置Modifier一样使用它：\n\n```swift\nText(\"Hello, SwiftUI!\")\n    .roundedShadow(radius: 10, shadowRadius: 5)\n```\n\n**优化Modifier**\n\n- **链式调用**：Modifier可以链式调用，使得视图修改更加灵活。\n- **条件修改**：可以使用条件语句动态地应用Modifier。\n- **性能考虑**：尽量避免创建过于复杂的Modifier，以免影响性能。\n\n**总结**\n\n自定义Modifier在SwiftUI开发中是一项强大的工具，它不仅可以提高代码的复用性和清晰度，还可以帮助维护应用的视觉一致性。通过创建合适的自定义Modifier，可以简化视图的构建过程，并提升开发效率。","slug":"SwiftUI核心技术第9章复合视图与可复用性","published":1,"updated":"2024-03-17T06:11:44.777Z","comments":1,"layout":"post","photos":[],"_id":"clu6up53j002oz6746xs3h0u3","content":"<p><strong>第9章：复合视图与可复用性</strong></p>\n<p><strong>第1小节：组合现有视图</strong></p>\n<p>在构建复杂的用户界面时，有效的视图复用和组合是提高代码可维护性和减少重复的关键。SwiftUI以其声明式语法和数据驱动的方法论，为视图的复合提供了极佳的支持。</p>\n<p><strong>视图复合的概念</strong></p>\n<p>视图复合是指将多个较小的视图组合成一个复杂的视图的过程。这是软件工程中“组合优于继承”原则的直接体现，允许开发者通过构建并组合简单的视图块来创建复杂的用户界面。</p>\n<p><strong>基本视图组合</strong></p>\n<p>在SwiftUI中，最基本的视图组合可以通过使用Stacks、Groups等容器视图来完成。例如，一个简单的登录表单可以通过组合TextFields和Button视图来创建：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">LoginForm</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> username: <span class=\"hljs-type\">String</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;&quot;</span><br>    <span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> password: <span class=\"hljs-type\">String</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;&quot;</span><br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">VStack</span> &#123;<br>            <span class=\"hljs-type\">TextField</span>(<span class=\"hljs-string\">&quot;Username&quot;</span>, text: <span class=\"hljs-variable\">$username</span>)<br>                .textFieldStyle(<span class=\"hljs-type\">RoundedBorderTextFieldStyle</span>())<br>            <span class=\"hljs-type\">SecureField</span>(<span class=\"hljs-string\">&quot;Password&quot;</span>, text: <span class=\"hljs-variable\">$password</span>)<br>                .textFieldStyle(<span class=\"hljs-type\">RoundedBorderTextFieldStyle</span>())<br>            <span class=\"hljs-type\">Button</span>(<span class=\"hljs-string\">&quot;Log In&quot;</span>) &#123;<br>                <span class=\"hljs-comment\">// Handle login action</span><br>            &#125;<br>            .padding()<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在这个例子中，我们创建了一个自定义的<code>LoginForm</code>视图，它将两个文本字段和一个按钮组合在一起。</p>\n<p><strong>视图抽象</strong></p>\n<p>SwiftUI的另一个强大功能是能够创建可复用的自定义视图。例如，如果我们发现在不同的地方多次使用相同的文本样式，可以将其抽象为一个可复用的视图：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">TitleText</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-keyword\">var</span> text: <span class=\"hljs-type\">String</span><br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">Text</span>(text)<br>            .font(.largeTitle)<br>            .foregroundColor(.blue)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>使用<code>TitleText</code>视图可以确保文本样式的一致性，并且在更新样式时，只需修改<code>TitleText</code>视图的定义即可。</p>\n<p><strong>利用视图修饰符</strong></p>\n<p>除了创建完整的自定义视图外，开发者也可以定义视图修饰符来封装常用的修改器组合。这可以进一步简化视图定义并增强可读性：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">CardStyle</span>: <span class=\"hljs-title class_\">ViewModifier</span> &#123;<br>    <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">body</span>(<span class=\"hljs-params\">content</span>: <span class=\"hljs-type\">Content</span>) -&gt; <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        content<br>            .padding()<br>            .background(<span class=\"hljs-type\">Color</span>.white)<br>            .cornerRadius(<span class=\"hljs-number\">10</span>)<br>            .shadow(radius: <span class=\"hljs-number\">5</span>)<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">extension</span> <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">cardStyle</span>() -&gt; <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-keyword\">self</span>.modifier(<span class=\"hljs-type\">CardStyle</span>())<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>现在，任何视图都可以轻松地应用这个“卡片”样式：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Hello World&quot;</span>)<br>    .cardStyle()<br></code></pre></td></tr></table></figure>\n\n<p><strong>小结</strong></p>\n<p>通过组合现有视图，开发者可以在SwiftUI中高效地构建复杂的用户界面。这种方法的核心优势是它提高了代码的可维护性、减少了重复，并且通过自定义视图和视图修饰符，能够轻松实现视图的一致性和可复用性。这种模块化的构建方式非常适合快速迭代和扩展，是构建复杂UI时的推荐方法。</p>\n<p><strong>第2小节：创建可复用的视图库</strong></p>\n<p>在构建复杂的SwiftUI应用时，开发者会逐渐积累起一组可复用的视图和视图修饰符。将这些元素组织成一个内部视图库，不仅可以提升开发效率，还可以确保UI的一致性。在这一节中，我们将探讨如何创建和维护一个可复用的视图库。</p>\n<p><strong>可复用视图库的优点</strong></p>\n<ol>\n<li><strong>一致性</strong>：统一的视图库可以确保整个应用的视觉元素保持一致。</li>\n<li><strong>效率</strong>：通过重用视图组件，可以避免重复劳动，加快开发速度。</li>\n<li><strong>可维护性</strong>：需要调整设计时，只需要更新视图库中的组件即可影响整个应用。</li>\n</ol>\n<p><strong>设计可复用视图</strong></p>\n<p>当设计一个可复用视图时，考虑以下几个方面：</p>\n<ul>\n<li><strong>通用性</strong>：视图应该足够通用，能够适应不同的使用场景。</li>\n<li><strong>可配置性</strong>：提供合理的接口来调整视图的外观和行为。</li>\n<li><strong>独立性</strong>：视图应该是自包含的，不依赖于外部状态。</li>\n</ul>\n<p><strong>视图库结构</strong></p>\n<p>一个好的视图库应该具有清晰的结构，通常包含以下几个层次：</p>\n<ol>\n<li><strong>基础视图</strong>：最基本的视图组件，如按钮、标签、输入框等。</li>\n<li><strong>视图修饰符</strong>：用于修饰视图的通用样式，如阴影、边框、字体样式等。</li>\n<li><strong>复合视图</strong>：由多个基础视图或其他复合视图组合而成的复杂视图。</li>\n<li><strong>布局</strong>：用于组织视图在容器中的位置和排列的布局组件。</li>\n</ol>\n<p><strong>实施示例</strong></p>\n<p>让我们来定义一个基础的可复用视图库的组件：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-comment\">// 基础视图</span><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">PrimaryButton</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-keyword\">var</span> title: <span class=\"hljs-type\">String</span><br>    <span class=\"hljs-keyword\">var</span> action: () -&gt; <span class=\"hljs-type\">Void</span><br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">Button</span>(action: action) &#123;<br>            <span class=\"hljs-type\">Text</span>(title)<br>                .fontWeight(.bold)<br>                .frame(minWidth: <span class=\"hljs-number\">0</span>, maxWidth: .infinity)<br>                .padding()<br>                .background(<span class=\"hljs-type\">Color</span>.blue)<br>                .foregroundColor(.white)<br>                .cornerRadius(<span class=\"hljs-number\">10</span>)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\">// 视图修饰符</span><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ShadowModifier</span>: <span class=\"hljs-title class_\">ViewModifier</span> &#123;<br>    <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">body</span>(<span class=\"hljs-params\">content</span>: <span class=\"hljs-type\">Content</span>) -&gt; <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        content<br>            .shadow(color: .gray, radius: <span class=\"hljs-number\">5</span>, x: <span class=\"hljs-number\">0</span>, y: <span class=\"hljs-number\">2</span>)<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">extension</span> <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">applyShadow</span>() -&gt; <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        modifier(<span class=\"hljs-type\">ShadowModifier</span>())<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\">// 复合视图</span><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">UserInfoCard</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-keyword\">var</span> username: <span class=\"hljs-type\">String</span><br>    <span class=\"hljs-keyword\">var</span> email: <span class=\"hljs-type\">String</span><br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">VStack</span>(alignment: .leading) &#123;<br>            <span class=\"hljs-type\">Text</span>(username)<br>                .font(.headline)<br>                .applyShadow()<br>            <span class=\"hljs-type\">Text</span>(email)<br>                .font(.subheadline)<br>        &#125;<br>        .padding()<br>        .background(<span class=\"hljs-type\">Color</span>.white)<br>        .cornerRadius(<span class=\"hljs-number\">10</span>)<br>        .applyShadow()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>视图库的维护</strong></p>\n<ul>\n<li><strong>文档</strong>：为每个组件编写详细的文档，说明其用法和配置选项。</li>\n<li><strong>示例应用</strong>：创建一个示例应用，演示视图库中每个组件的用法。</li>\n<li><strong>版本控制</strong>：当更新视图库时，使用版本控制来管理变更。</li>\n</ul>\n<p><strong>小结</strong></p>\n<p>创建和维护一个可复用的视图库是提高SwiftUI应用开发效率和质量的有效方法。通过精心设计和文档化，视图库不仅能够确保UI的一致性，还能极大地简化应用的迭代和扩展。</p>\n<p><strong>第3小节：自定义Modifier</strong></p>\n<p>在SwiftUI中，<code>Modifier</code>允许开发者封装一系列的视图修改操作，并可复用于不同的视图。通过创建自定义的<code>Modifier</code>，可以极大地提高代码的可维护性和清晰度，同时也使得UI组件的风格和布局保持一致。本小节将详细介绍如何定义和使用自定义Modifier。</p>\n<p><strong>理解Modifier</strong></p>\n<p>Modifier是一种遵循<code>ViewModifier</code>协议的结构体，它通过改变视图的渲染和布局属性来修改视图的外观和行为。每当对视图应用Modifier时，SwiftUI都会在背后创建一个新的视图结构，而不是修改旧的视图。这使得视图修改操作既安全又易于管理。</p>\n<p><strong>创建自定义Modifier</strong></p>\n<ol>\n<li><strong>定义Modifier结构体</strong>：首先，需要定义一个结构体并遵循<code>ViewModifier</code>协议。</li>\n<li><strong>实现<code>body</code>属性</strong>：在结构体中实现必需的<code>body</code>计算属性，它接收一个<code>Content</code>参数，并返回一个新的视图。</li>\n<li><strong>添加修改操作</strong>：在<code>body</code>属性中，对传入的<code>Content</code>进行修改，如添加边框、改变字体、设置背景等。</li>\n</ol>\n<p><strong>示例：自定义圆角和阴影Modifier</strong></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">RoundedShadowModifier</span>: <span class=\"hljs-title class_\">ViewModifier</span> &#123;<br>    <span class=\"hljs-keyword\">var</span> radius: <span class=\"hljs-type\">CGFloat</span><br>    <span class=\"hljs-keyword\">var</span> shadowRadius: <span class=\"hljs-type\">CGFloat</span><br><br>    <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">body</span>(<span class=\"hljs-params\">content</span>: <span class=\"hljs-type\">Content</span>) -&gt; <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        content<br>            .cornerRadius(radius)<br>            .shadow(radius: shadowRadius)<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">extension</span> <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">roundedShadow</span>(<span class=\"hljs-params\">radius</span>: <span class=\"hljs-type\">CGFloat</span>, <span class=\"hljs-params\">shadowRadius</span>: <span class=\"hljs-type\">CGFloat</span>) -&gt; <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        modifier(<span class=\"hljs-type\">RoundedShadowModifier</span>(radius: radius, shadowRadius: shadowRadius))<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在上述示例中，我们定义了一个名为<code>RoundedShadowModifier</code>的自定义Modifier，它将圆角和阴影效果应用于任何视图。通过<code>extension</code>扩展<code>View</code>，我们为所有视图添加了一个名为<code>roundedShadow</code>的新方法，它使得应用圆角和阴影更加便捷。</p>\n<p><strong>使用自定义Modifier</strong></p>\n<p>一旦定义了自定义Modifier，就可以在任何视图上像使用内置Modifier一样使用它：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Hello, SwiftUI!&quot;</span>)<br>    .roundedShadow(radius: <span class=\"hljs-number\">10</span>, shadowRadius: <span class=\"hljs-number\">5</span>)<br></code></pre></td></tr></table></figure>\n\n<p><strong>优化Modifier</strong></p>\n<ul>\n<li><strong>链式调用</strong>：Modifier可以链式调用，使得视图修改更加灵活。</li>\n<li><strong>条件修改</strong>：可以使用条件语句动态地应用Modifier。</li>\n<li><strong>性能考虑</strong>：尽量避免创建过于复杂的Modifier，以免影响性能。</li>\n</ul>\n<p><strong>总结</strong></p>\n<p>自定义Modifier在SwiftUI开发中是一项强大的工具，它不仅可以提高代码的复用性和清晰度，还可以帮助维护应用的视觉一致性。通过创建合适的自定义Modifier，可以简化视图的构建过程，并提升开发效率。</p>\n","excerpt":"","more":"<p><strong>第9章：复合视图与可复用性</strong></p>\n<p><strong>第1小节：组合现有视图</strong></p>\n<p>在构建复杂的用户界面时，有效的视图复用和组合是提高代码可维护性和减少重复的关键。SwiftUI以其声明式语法和数据驱动的方法论，为视图的复合提供了极佳的支持。</p>\n<p><strong>视图复合的概念</strong></p>\n<p>视图复合是指将多个较小的视图组合成一个复杂的视图的过程。这是软件工程中“组合优于继承”原则的直接体现，允许开发者通过构建并组合简单的视图块来创建复杂的用户界面。</p>\n<p><strong>基本视图组合</strong></p>\n<p>在SwiftUI中，最基本的视图组合可以通过使用Stacks、Groups等容器视图来完成。例如，一个简单的登录表单可以通过组合TextFields和Button视图来创建：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">LoginForm</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> username: <span class=\"hljs-type\">String</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;&quot;</span><br>    <span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> password: <span class=\"hljs-type\">String</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;&quot;</span><br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">VStack</span> &#123;<br>            <span class=\"hljs-type\">TextField</span>(<span class=\"hljs-string\">&quot;Username&quot;</span>, text: <span class=\"hljs-variable\">$username</span>)<br>                .textFieldStyle(<span class=\"hljs-type\">RoundedBorderTextFieldStyle</span>())<br>            <span class=\"hljs-type\">SecureField</span>(<span class=\"hljs-string\">&quot;Password&quot;</span>, text: <span class=\"hljs-variable\">$password</span>)<br>                .textFieldStyle(<span class=\"hljs-type\">RoundedBorderTextFieldStyle</span>())<br>            <span class=\"hljs-type\">Button</span>(<span class=\"hljs-string\">&quot;Log In&quot;</span>) &#123;<br>                <span class=\"hljs-comment\">// Handle login action</span><br>            &#125;<br>            .padding()<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在这个例子中，我们创建了一个自定义的<code>LoginForm</code>视图，它将两个文本字段和一个按钮组合在一起。</p>\n<p><strong>视图抽象</strong></p>\n<p>SwiftUI的另一个强大功能是能够创建可复用的自定义视图。例如，如果我们发现在不同的地方多次使用相同的文本样式，可以将其抽象为一个可复用的视图：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">TitleText</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-keyword\">var</span> text: <span class=\"hljs-type\">String</span><br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">Text</span>(text)<br>            .font(.largeTitle)<br>            .foregroundColor(.blue)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>使用<code>TitleText</code>视图可以确保文本样式的一致性，并且在更新样式时，只需修改<code>TitleText</code>视图的定义即可。</p>\n<p><strong>利用视图修饰符</strong></p>\n<p>除了创建完整的自定义视图外，开发者也可以定义视图修饰符来封装常用的修改器组合。这可以进一步简化视图定义并增强可读性：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">CardStyle</span>: <span class=\"hljs-title class_\">ViewModifier</span> &#123;<br>    <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">body</span>(<span class=\"hljs-params\">content</span>: <span class=\"hljs-type\">Content</span>) -&gt; <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        content<br>            .padding()<br>            .background(<span class=\"hljs-type\">Color</span>.white)<br>            .cornerRadius(<span class=\"hljs-number\">10</span>)<br>            .shadow(radius: <span class=\"hljs-number\">5</span>)<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">extension</span> <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">cardStyle</span>() -&gt; <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-keyword\">self</span>.modifier(<span class=\"hljs-type\">CardStyle</span>())<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>现在，任何视图都可以轻松地应用这个“卡片”样式：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Hello World&quot;</span>)<br>    .cardStyle()<br></code></pre></td></tr></table></figure>\n\n<p><strong>小结</strong></p>\n<p>通过组合现有视图，开发者可以在SwiftUI中高效地构建复杂的用户界面。这种方法的核心优势是它提高了代码的可维护性、减少了重复，并且通过自定义视图和视图修饰符，能够轻松实现视图的一致性和可复用性。这种模块化的构建方式非常适合快速迭代和扩展，是构建复杂UI时的推荐方法。</p>\n<p><strong>第2小节：创建可复用的视图库</strong></p>\n<p>在构建复杂的SwiftUI应用时，开发者会逐渐积累起一组可复用的视图和视图修饰符。将这些元素组织成一个内部视图库，不仅可以提升开发效率，还可以确保UI的一致性。在这一节中，我们将探讨如何创建和维护一个可复用的视图库。</p>\n<p><strong>可复用视图库的优点</strong></p>\n<ol>\n<li><strong>一致性</strong>：统一的视图库可以确保整个应用的视觉元素保持一致。</li>\n<li><strong>效率</strong>：通过重用视图组件，可以避免重复劳动，加快开发速度。</li>\n<li><strong>可维护性</strong>：需要调整设计时，只需要更新视图库中的组件即可影响整个应用。</li>\n</ol>\n<p><strong>设计可复用视图</strong></p>\n<p>当设计一个可复用视图时，考虑以下几个方面：</p>\n<ul>\n<li><strong>通用性</strong>：视图应该足够通用，能够适应不同的使用场景。</li>\n<li><strong>可配置性</strong>：提供合理的接口来调整视图的外观和行为。</li>\n<li><strong>独立性</strong>：视图应该是自包含的，不依赖于外部状态。</li>\n</ul>\n<p><strong>视图库结构</strong></p>\n<p>一个好的视图库应该具有清晰的结构，通常包含以下几个层次：</p>\n<ol>\n<li><strong>基础视图</strong>：最基本的视图组件，如按钮、标签、输入框等。</li>\n<li><strong>视图修饰符</strong>：用于修饰视图的通用样式，如阴影、边框、字体样式等。</li>\n<li><strong>复合视图</strong>：由多个基础视图或其他复合视图组合而成的复杂视图。</li>\n<li><strong>布局</strong>：用于组织视图在容器中的位置和排列的布局组件。</li>\n</ol>\n<p><strong>实施示例</strong></p>\n<p>让我们来定义一个基础的可复用视图库的组件：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-comment\">// 基础视图</span><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">PrimaryButton</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-keyword\">var</span> title: <span class=\"hljs-type\">String</span><br>    <span class=\"hljs-keyword\">var</span> action: () -&gt; <span class=\"hljs-type\">Void</span><br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">Button</span>(action: action) &#123;<br>            <span class=\"hljs-type\">Text</span>(title)<br>                .fontWeight(.bold)<br>                .frame(minWidth: <span class=\"hljs-number\">0</span>, maxWidth: .infinity)<br>                .padding()<br>                .background(<span class=\"hljs-type\">Color</span>.blue)<br>                .foregroundColor(.white)<br>                .cornerRadius(<span class=\"hljs-number\">10</span>)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\">// 视图修饰符</span><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ShadowModifier</span>: <span class=\"hljs-title class_\">ViewModifier</span> &#123;<br>    <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">body</span>(<span class=\"hljs-params\">content</span>: <span class=\"hljs-type\">Content</span>) -&gt; <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        content<br>            .shadow(color: .gray, radius: <span class=\"hljs-number\">5</span>, x: <span class=\"hljs-number\">0</span>, y: <span class=\"hljs-number\">2</span>)<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">extension</span> <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">applyShadow</span>() -&gt; <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        modifier(<span class=\"hljs-type\">ShadowModifier</span>())<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\">// 复合视图</span><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">UserInfoCard</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-keyword\">var</span> username: <span class=\"hljs-type\">String</span><br>    <span class=\"hljs-keyword\">var</span> email: <span class=\"hljs-type\">String</span><br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">VStack</span>(alignment: .leading) &#123;<br>            <span class=\"hljs-type\">Text</span>(username)<br>                .font(.headline)<br>                .applyShadow()<br>            <span class=\"hljs-type\">Text</span>(email)<br>                .font(.subheadline)<br>        &#125;<br>        .padding()<br>        .background(<span class=\"hljs-type\">Color</span>.white)<br>        .cornerRadius(<span class=\"hljs-number\">10</span>)<br>        .applyShadow()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>视图库的维护</strong></p>\n<ul>\n<li><strong>文档</strong>：为每个组件编写详细的文档，说明其用法和配置选项。</li>\n<li><strong>示例应用</strong>：创建一个示例应用，演示视图库中每个组件的用法。</li>\n<li><strong>版本控制</strong>：当更新视图库时，使用版本控制来管理变更。</li>\n</ul>\n<p><strong>小结</strong></p>\n<p>创建和维护一个可复用的视图库是提高SwiftUI应用开发效率和质量的有效方法。通过精心设计和文档化，视图库不仅能够确保UI的一致性，还能极大地简化应用的迭代和扩展。</p>\n<p><strong>第3小节：自定义Modifier</strong></p>\n<p>在SwiftUI中，<code>Modifier</code>允许开发者封装一系列的视图修改操作，并可复用于不同的视图。通过创建自定义的<code>Modifier</code>，可以极大地提高代码的可维护性和清晰度，同时也使得UI组件的风格和布局保持一致。本小节将详细介绍如何定义和使用自定义Modifier。</p>\n<p><strong>理解Modifier</strong></p>\n<p>Modifier是一种遵循<code>ViewModifier</code>协议的结构体，它通过改变视图的渲染和布局属性来修改视图的外观和行为。每当对视图应用Modifier时，SwiftUI都会在背后创建一个新的视图结构，而不是修改旧的视图。这使得视图修改操作既安全又易于管理。</p>\n<p><strong>创建自定义Modifier</strong></p>\n<ol>\n<li><strong>定义Modifier结构体</strong>：首先，需要定义一个结构体并遵循<code>ViewModifier</code>协议。</li>\n<li><strong>实现<code>body</code>属性</strong>：在结构体中实现必需的<code>body</code>计算属性，它接收一个<code>Content</code>参数，并返回一个新的视图。</li>\n<li><strong>添加修改操作</strong>：在<code>body</code>属性中，对传入的<code>Content</code>进行修改，如添加边框、改变字体、设置背景等。</li>\n</ol>\n<p><strong>示例：自定义圆角和阴影Modifier</strong></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">RoundedShadowModifier</span>: <span class=\"hljs-title class_\">ViewModifier</span> &#123;<br>    <span class=\"hljs-keyword\">var</span> radius: <span class=\"hljs-type\">CGFloat</span><br>    <span class=\"hljs-keyword\">var</span> shadowRadius: <span class=\"hljs-type\">CGFloat</span><br><br>    <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">body</span>(<span class=\"hljs-params\">content</span>: <span class=\"hljs-type\">Content</span>) -&gt; <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        content<br>            .cornerRadius(radius)<br>            .shadow(radius: shadowRadius)<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">extension</span> <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">roundedShadow</span>(<span class=\"hljs-params\">radius</span>: <span class=\"hljs-type\">CGFloat</span>, <span class=\"hljs-params\">shadowRadius</span>: <span class=\"hljs-type\">CGFloat</span>) -&gt; <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        modifier(<span class=\"hljs-type\">RoundedShadowModifier</span>(radius: radius, shadowRadius: shadowRadius))<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在上述示例中，我们定义了一个名为<code>RoundedShadowModifier</code>的自定义Modifier，它将圆角和阴影效果应用于任何视图。通过<code>extension</code>扩展<code>View</code>，我们为所有视图添加了一个名为<code>roundedShadow</code>的新方法，它使得应用圆角和阴影更加便捷。</p>\n<p><strong>使用自定义Modifier</strong></p>\n<p>一旦定义了自定义Modifier，就可以在任何视图上像使用内置Modifier一样使用它：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Hello, SwiftUI!&quot;</span>)<br>    .roundedShadow(radius: <span class=\"hljs-number\">10</span>, shadowRadius: <span class=\"hljs-number\">5</span>)<br></code></pre></td></tr></table></figure>\n\n<p><strong>优化Modifier</strong></p>\n<ul>\n<li><strong>链式调用</strong>：Modifier可以链式调用，使得视图修改更加灵活。</li>\n<li><strong>条件修改</strong>：可以使用条件语句动态地应用Modifier。</li>\n<li><strong>性能考虑</strong>：尽量避免创建过于复杂的Modifier，以免影响性能。</li>\n</ul>\n<p><strong>总结</strong></p>\n<p>自定义Modifier在SwiftUI开发中是一项强大的工具，它不仅可以提高代码的复用性和清晰度，还可以帮助维护应用的视觉一致性。通过创建合适的自定义Modifier，可以简化视图的构建过程，并提升开发效率。</p>\n"},{"title":"SwiftUI简介","date":"2023-11-07T07:13:57.000Z","_content":"SwiftUI是苹果在2019年WWDC大会上推出的一个用于在苹果生态系统中构建用户界面的框架。它可以用来为iOS、macOS、watchOS和tvOS开发应用程序。SwiftUI的设计目标是提供一种更简洁、更声明式的编程方法来构建用户界面。\n\n以下是SwiftUI的一些关键特点：\n\n1. **声明式语法**：SwiftUI使用声明式语法，让开发者可以用简洁的代码描述界面应该呈现的样子，而不是编写实现这个界面的步骤。这种方法提高了代码的可读性和可维护性。\n\n2. **跨平台**：SwiftUI代码可以在所有苹果平台上运行，这意味着你可以一次性编写代码，然后将其部署到不同的设备上。\n\n3. **实时预览**：与Xcode集成的SwiftUI提供了实时预览功能。你可以边修改代码边看到界面的变化，这极大地提高了开发的效率。\n\n4. **数据驱动**：SwiftUI紧密结合了Swift语言的其他功能，比如Combine框架，提供了数据驱动的视图更新。这意味着当数据变化时，UI会自动更新。\n\n5. **易于集成**：可以在现有的UIKit应用中使用SwiftUI构建部分界面，这让现有项目可以逐步迁移而无需全部重写。\n\n6. **强大的动画和过渡支持**：SwiftUI让添加动画变得非常容易，简单的修改状态即可自动获得平滑的过渡效果。\n\n7. **组件化**：SwiftUI鼓励开发者将UI分解为小的、可重用的组件，这样不仅可以提升代码复用性，也使得界面的各个部分更容易管理和维护。\n\n8. **无需记忆性**：SwiftUI界面的状态是无需记忆的，它通过绑定数据来直接驱动界面，这样可以避免传统的UI编程中常见的状态不一致问题。\n\n9. **访问性和国际化**：SwiftUI使得添加访问性支持更为容易，并且它的设计天然支持国际化和本地化。\n\n10. **Swift语言的集成**：SwiftUI紧密集成了Swift编程语言的特性，比如类型安全、函数式编程元素和其他现代编程范式。\n\nSwiftUI的学习曲线相对平缓，尤其对于熟悉Swift语言的开发者来说，它提供了一个更加直观和快速的方式来构建美观且高性能的用户界面。随着SwiftUI不断的迭代和改进，它正在成为苹果开发生态中越来越重要的一部分。\n","source":"_posts/SwiftUI简介.md","raw":"---\ntitle: SwiftUI简介\ndate: 2023-11-07 15:13:57\ncategories:\n- SwiftUI\ntags:\n---\nSwiftUI是苹果在2019年WWDC大会上推出的一个用于在苹果生态系统中构建用户界面的框架。它可以用来为iOS、macOS、watchOS和tvOS开发应用程序。SwiftUI的设计目标是提供一种更简洁、更声明式的编程方法来构建用户界面。\n\n以下是SwiftUI的一些关键特点：\n\n1. **声明式语法**：SwiftUI使用声明式语法，让开发者可以用简洁的代码描述界面应该呈现的样子，而不是编写实现这个界面的步骤。这种方法提高了代码的可读性和可维护性。\n\n2. **跨平台**：SwiftUI代码可以在所有苹果平台上运行，这意味着你可以一次性编写代码，然后将其部署到不同的设备上。\n\n3. **实时预览**：与Xcode集成的SwiftUI提供了实时预览功能。你可以边修改代码边看到界面的变化，这极大地提高了开发的效率。\n\n4. **数据驱动**：SwiftUI紧密结合了Swift语言的其他功能，比如Combine框架，提供了数据驱动的视图更新。这意味着当数据变化时，UI会自动更新。\n\n5. **易于集成**：可以在现有的UIKit应用中使用SwiftUI构建部分界面，这让现有项目可以逐步迁移而无需全部重写。\n\n6. **强大的动画和过渡支持**：SwiftUI让添加动画变得非常容易，简单的修改状态即可自动获得平滑的过渡效果。\n\n7. **组件化**：SwiftUI鼓励开发者将UI分解为小的、可重用的组件，这样不仅可以提升代码复用性，也使得界面的各个部分更容易管理和维护。\n\n8. **无需记忆性**：SwiftUI界面的状态是无需记忆的，它通过绑定数据来直接驱动界面，这样可以避免传统的UI编程中常见的状态不一致问题。\n\n9. **访问性和国际化**：SwiftUI使得添加访问性支持更为容易，并且它的设计天然支持国际化和本地化。\n\n10. **Swift语言的集成**：SwiftUI紧密集成了Swift编程语言的特性，比如类型安全、函数式编程元素和其他现代编程范式。\n\nSwiftUI的学习曲线相对平缓，尤其对于熟悉Swift语言的开发者来说，它提供了一个更加直观和快速的方式来构建美观且高性能的用户界面。随着SwiftUI不断的迭代和改进，它正在成为苹果开发生态中越来越重要的一部分。\n","slug":"SwiftUI简介","published":1,"updated":"2024-03-17T06:12:07.973Z","comments":1,"layout":"post","photos":[],"_id":"clu6up53j002qz6746blmg71v","content":"<p>SwiftUI是苹果在2019年WWDC大会上推出的一个用于在苹果生态系统中构建用户界面的框架。它可以用来为iOS、macOS、watchOS和tvOS开发应用程序。SwiftUI的设计目标是提供一种更简洁、更声明式的编程方法来构建用户界面。</p>\n<p>以下是SwiftUI的一些关键特点：</p>\n<ol>\n<li><p><strong>声明式语法</strong>：SwiftUI使用声明式语法，让开发者可以用简洁的代码描述界面应该呈现的样子，而不是编写实现这个界面的步骤。这种方法提高了代码的可读性和可维护性。</p>\n</li>\n<li><p><strong>跨平台</strong>：SwiftUI代码可以在所有苹果平台上运行，这意味着你可以一次性编写代码，然后将其部署到不同的设备上。</p>\n</li>\n<li><p><strong>实时预览</strong>：与Xcode集成的SwiftUI提供了实时预览功能。你可以边修改代码边看到界面的变化，这极大地提高了开发的效率。</p>\n</li>\n<li><p><strong>数据驱动</strong>：SwiftUI紧密结合了Swift语言的其他功能，比如Combine框架，提供了数据驱动的视图更新。这意味着当数据变化时，UI会自动更新。</p>\n</li>\n<li><p><strong>易于集成</strong>：可以在现有的UIKit应用中使用SwiftUI构建部分界面，这让现有项目可以逐步迁移而无需全部重写。</p>\n</li>\n<li><p><strong>强大的动画和过渡支持</strong>：SwiftUI让添加动画变得非常容易，简单的修改状态即可自动获得平滑的过渡效果。</p>\n</li>\n<li><p><strong>组件化</strong>：SwiftUI鼓励开发者将UI分解为小的、可重用的组件，这样不仅可以提升代码复用性，也使得界面的各个部分更容易管理和维护。</p>\n</li>\n<li><p><strong>无需记忆性</strong>：SwiftUI界面的状态是无需记忆的，它通过绑定数据来直接驱动界面，这样可以避免传统的UI编程中常见的状态不一致问题。</p>\n</li>\n<li><p><strong>访问性和国际化</strong>：SwiftUI使得添加访问性支持更为容易，并且它的设计天然支持国际化和本地化。</p>\n</li>\n<li><p><strong>Swift语言的集成</strong>：SwiftUI紧密集成了Swift编程语言的特性，比如类型安全、函数式编程元素和其他现代编程范式。</p>\n</li>\n</ol>\n<p>SwiftUI的学习曲线相对平缓，尤其对于熟悉Swift语言的开发者来说，它提供了一个更加直观和快速的方式来构建美观且高性能的用户界面。随着SwiftUI不断的迭代和改进，它正在成为苹果开发生态中越来越重要的一部分。</p>\n","excerpt":"","more":"<p>SwiftUI是苹果在2019年WWDC大会上推出的一个用于在苹果生态系统中构建用户界面的框架。它可以用来为iOS、macOS、watchOS和tvOS开发应用程序。SwiftUI的设计目标是提供一种更简洁、更声明式的编程方法来构建用户界面。</p>\n<p>以下是SwiftUI的一些关键特点：</p>\n<ol>\n<li><p><strong>声明式语法</strong>：SwiftUI使用声明式语法，让开发者可以用简洁的代码描述界面应该呈现的样子，而不是编写实现这个界面的步骤。这种方法提高了代码的可读性和可维护性。</p>\n</li>\n<li><p><strong>跨平台</strong>：SwiftUI代码可以在所有苹果平台上运行，这意味着你可以一次性编写代码，然后将其部署到不同的设备上。</p>\n</li>\n<li><p><strong>实时预览</strong>：与Xcode集成的SwiftUI提供了实时预览功能。你可以边修改代码边看到界面的变化，这极大地提高了开发的效率。</p>\n</li>\n<li><p><strong>数据驱动</strong>：SwiftUI紧密结合了Swift语言的其他功能，比如Combine框架，提供了数据驱动的视图更新。这意味着当数据变化时，UI会自动更新。</p>\n</li>\n<li><p><strong>易于集成</strong>：可以在现有的UIKit应用中使用SwiftUI构建部分界面，这让现有项目可以逐步迁移而无需全部重写。</p>\n</li>\n<li><p><strong>强大的动画和过渡支持</strong>：SwiftUI让添加动画变得非常容易，简单的修改状态即可自动获得平滑的过渡效果。</p>\n</li>\n<li><p><strong>组件化</strong>：SwiftUI鼓励开发者将UI分解为小的、可重用的组件，这样不仅可以提升代码复用性，也使得界面的各个部分更容易管理和维护。</p>\n</li>\n<li><p><strong>无需记忆性</strong>：SwiftUI界面的状态是无需记忆的，它通过绑定数据来直接驱动界面，这样可以避免传统的UI编程中常见的状态不一致问题。</p>\n</li>\n<li><p><strong>访问性和国际化</strong>：SwiftUI使得添加访问性支持更为容易，并且它的设计天然支持国际化和本地化。</p>\n</li>\n<li><p><strong>Swift语言的集成</strong>：SwiftUI紧密集成了Swift编程语言的特性，比如类型安全、函数式编程元素和其他现代编程范式。</p>\n</li>\n</ol>\n<p>SwiftUI的学习曲线相对平缓，尤其对于熟悉Swift语言的开发者来说，它提供了一个更加直观和快速的方式来构建美观且高性能的用户界面。随着SwiftUI不断的迭代和改进，它正在成为苹果开发生态中越来越重要的一部分。</p>\n"},{"title":"SwiftUI设计思想","date":"2023-11-07T07:49:49.000Z","_content":"SwiftUI的设计思想体现了现代UI框架的若干核心理念：\n\n### 声明式语法\nSwiftUI采用声明式语法，开发者只需要声明UI应该如何根据不同的状态显示，而不是编写代码来控制UI的每一个变化过程。这种方式简化了代码结构，使得UI逻辑更清晰易懂，也更易于维护。\n\n### 组件化和复用\nSwiftUI鼓励将UI划分为小的、可复用的组件。每个组件管理自己的状态和表现，这促进了代码的模块化和重用，并使得开发者能够构建出高度复杂且易于维护的UI系统。\n\n### 数据驱动的UI\nSwiftUI的设计充分利用了Swift语言的特性，如结构体、属性观察器等，实现了数据和UI的紧密绑定。当数据发生变化时，UI会自动响应更新，大大简化了同步UI和数据状态的工作。\n\n### 单一数据流\n通过使用单一数据流，SwiftUI确保了数据的一致性和可预测性。状态（State）和绑定（Binding）的概念帮助开发者明确数据流向，并易于跟踪和调试。\n\n### 跨平台兼容性\nSwiftUI从设计之初就考虑到了跨平台的需求。相同的SwiftUI代码可以运行在iOS、macOS、watchOS和tvOS上，这降低了为不同平台开发和维护UI的工作量和复杂度。\n\n### 与Swift语言的一致性\nSwiftUI紧密集成了Swift语言的功能，例如泛型、协议和函数式编程概念。这种集成确保了SwiftUI的API设计既自然又符合Swift语言的特性和风格。\n\n### 现代化和简化的API\nSwiftUI致力于提供一个简洁的API，用最少的代码完成最多的工作。例如，通过链式调用修饰符（Modifier）可以轻松地定制组件的样式和行为。\n\n### 强调性能和效率\nSwiftUI的设计充分考虑了性能。它利用了差异化更新（只更新UI的变更部分）以及懒加载视图等机制，以确保高效的内存和资源使用。\n\n通过这些设计理念，SwiftUI旨在实现快速、高效且更少出错的UI开发流程，适应现代应用开发的需求。随着Swift和SwiftUI的不断发展，它将进一步融合和优化，以提供更好的开发体验。","source":"_posts/SwiftUI设计思想.md","raw":"---\ntitle: SwiftUI设计思想\ndate: 2023-11-07 15:49:49\ncategories:\n- SwiftUI\ntags:\n---\nSwiftUI的设计思想体现了现代UI框架的若干核心理念：\n\n### 声明式语法\nSwiftUI采用声明式语法，开发者只需要声明UI应该如何根据不同的状态显示，而不是编写代码来控制UI的每一个变化过程。这种方式简化了代码结构，使得UI逻辑更清晰易懂，也更易于维护。\n\n### 组件化和复用\nSwiftUI鼓励将UI划分为小的、可复用的组件。每个组件管理自己的状态和表现，这促进了代码的模块化和重用，并使得开发者能够构建出高度复杂且易于维护的UI系统。\n\n### 数据驱动的UI\nSwiftUI的设计充分利用了Swift语言的特性，如结构体、属性观察器等，实现了数据和UI的紧密绑定。当数据发生变化时，UI会自动响应更新，大大简化了同步UI和数据状态的工作。\n\n### 单一数据流\n通过使用单一数据流，SwiftUI确保了数据的一致性和可预测性。状态（State）和绑定（Binding）的概念帮助开发者明确数据流向，并易于跟踪和调试。\n\n### 跨平台兼容性\nSwiftUI从设计之初就考虑到了跨平台的需求。相同的SwiftUI代码可以运行在iOS、macOS、watchOS和tvOS上，这降低了为不同平台开发和维护UI的工作量和复杂度。\n\n### 与Swift语言的一致性\nSwiftUI紧密集成了Swift语言的功能，例如泛型、协议和函数式编程概念。这种集成确保了SwiftUI的API设计既自然又符合Swift语言的特性和风格。\n\n### 现代化和简化的API\nSwiftUI致力于提供一个简洁的API，用最少的代码完成最多的工作。例如，通过链式调用修饰符（Modifier）可以轻松地定制组件的样式和行为。\n\n### 强调性能和效率\nSwiftUI的设计充分考虑了性能。它利用了差异化更新（只更新UI的变更部分）以及懒加载视图等机制，以确保高效的内存和资源使用。\n\n通过这些设计理念，SwiftUI旨在实现快速、高效且更少出错的UI开发流程，适应现代应用开发的需求。随着Swift和SwiftUI的不断发展，它将进一步融合和优化，以提供更好的开发体验。","slug":"SwiftUI设计思想","published":1,"updated":"2024-03-17T06:12:12.016Z","comments":1,"layout":"post","photos":[],"_id":"clu6up53k002sz6746dsfdixq","content":"<p>SwiftUI的设计思想体现了现代UI框架的若干核心理念：</p>\n<h3 id=\"声明式语法\"><a href=\"#声明式语法\" class=\"headerlink\" title=\"声明式语法\"></a>声明式语法</h3><p>SwiftUI采用声明式语法，开发者只需要声明UI应该如何根据不同的状态显示，而不是编写代码来控制UI的每一个变化过程。这种方式简化了代码结构，使得UI逻辑更清晰易懂，也更易于维护。</p>\n<h3 id=\"组件化和复用\"><a href=\"#组件化和复用\" class=\"headerlink\" title=\"组件化和复用\"></a>组件化和复用</h3><p>SwiftUI鼓励将UI划分为小的、可复用的组件。每个组件管理自己的状态和表现，这促进了代码的模块化和重用，并使得开发者能够构建出高度复杂且易于维护的UI系统。</p>\n<h3 id=\"数据驱动的UI\"><a href=\"#数据驱动的UI\" class=\"headerlink\" title=\"数据驱动的UI\"></a>数据驱动的UI</h3><p>SwiftUI的设计充分利用了Swift语言的特性，如结构体、属性观察器等，实现了数据和UI的紧密绑定。当数据发生变化时，UI会自动响应更新，大大简化了同步UI和数据状态的工作。</p>\n<h3 id=\"单一数据流\"><a href=\"#单一数据流\" class=\"headerlink\" title=\"单一数据流\"></a>单一数据流</h3><p>通过使用单一数据流，SwiftUI确保了数据的一致性和可预测性。状态（State）和绑定（Binding）的概念帮助开发者明确数据流向，并易于跟踪和调试。</p>\n<h3 id=\"跨平台兼容性\"><a href=\"#跨平台兼容性\" class=\"headerlink\" title=\"跨平台兼容性\"></a>跨平台兼容性</h3><p>SwiftUI从设计之初就考虑到了跨平台的需求。相同的SwiftUI代码可以运行在iOS、macOS、watchOS和tvOS上，这降低了为不同平台开发和维护UI的工作量和复杂度。</p>\n<h3 id=\"与Swift语言的一致性\"><a href=\"#与Swift语言的一致性\" class=\"headerlink\" title=\"与Swift语言的一致性\"></a>与Swift语言的一致性</h3><p>SwiftUI紧密集成了Swift语言的功能，例如泛型、协议和函数式编程概念。这种集成确保了SwiftUI的API设计既自然又符合Swift语言的特性和风格。</p>\n<h3 id=\"现代化和简化的API\"><a href=\"#现代化和简化的API\" class=\"headerlink\" title=\"现代化和简化的API\"></a>现代化和简化的API</h3><p>SwiftUI致力于提供一个简洁的API，用最少的代码完成最多的工作。例如，通过链式调用修饰符（Modifier）可以轻松地定制组件的样式和行为。</p>\n<h3 id=\"强调性能和效率\"><a href=\"#强调性能和效率\" class=\"headerlink\" title=\"强调性能和效率\"></a>强调性能和效率</h3><p>SwiftUI的设计充分考虑了性能。它利用了差异化更新（只更新UI的变更部分）以及懒加载视图等机制，以确保高效的内存和资源使用。</p>\n<p>通过这些设计理念，SwiftUI旨在实现快速、高效且更少出错的UI开发流程，适应现代应用开发的需求。随着Swift和SwiftUI的不断发展，它将进一步融合和优化，以提供更好的开发体验。</p>\n","excerpt":"","more":"<p>SwiftUI的设计思想体现了现代UI框架的若干核心理念：</p>\n<h3 id=\"声明式语法\"><a href=\"#声明式语法\" class=\"headerlink\" title=\"声明式语法\"></a>声明式语法</h3><p>SwiftUI采用声明式语法，开发者只需要声明UI应该如何根据不同的状态显示，而不是编写代码来控制UI的每一个变化过程。这种方式简化了代码结构，使得UI逻辑更清晰易懂，也更易于维护。</p>\n<h3 id=\"组件化和复用\"><a href=\"#组件化和复用\" class=\"headerlink\" title=\"组件化和复用\"></a>组件化和复用</h3><p>SwiftUI鼓励将UI划分为小的、可复用的组件。每个组件管理自己的状态和表现，这促进了代码的模块化和重用，并使得开发者能够构建出高度复杂且易于维护的UI系统。</p>\n<h3 id=\"数据驱动的UI\"><a href=\"#数据驱动的UI\" class=\"headerlink\" title=\"数据驱动的UI\"></a>数据驱动的UI</h3><p>SwiftUI的设计充分利用了Swift语言的特性，如结构体、属性观察器等，实现了数据和UI的紧密绑定。当数据发生变化时，UI会自动响应更新，大大简化了同步UI和数据状态的工作。</p>\n<h3 id=\"单一数据流\"><a href=\"#单一数据流\" class=\"headerlink\" title=\"单一数据流\"></a>单一数据流</h3><p>通过使用单一数据流，SwiftUI确保了数据的一致性和可预测性。状态（State）和绑定（Binding）的概念帮助开发者明确数据流向，并易于跟踪和调试。</p>\n<h3 id=\"跨平台兼容性\"><a href=\"#跨平台兼容性\" class=\"headerlink\" title=\"跨平台兼容性\"></a>跨平台兼容性</h3><p>SwiftUI从设计之初就考虑到了跨平台的需求。相同的SwiftUI代码可以运行在iOS、macOS、watchOS和tvOS上，这降低了为不同平台开发和维护UI的工作量和复杂度。</p>\n<h3 id=\"与Swift语言的一致性\"><a href=\"#与Swift语言的一致性\" class=\"headerlink\" title=\"与Swift语言的一致性\"></a>与Swift语言的一致性</h3><p>SwiftUI紧密集成了Swift语言的功能，例如泛型、协议和函数式编程概念。这种集成确保了SwiftUI的API设计既自然又符合Swift语言的特性和风格。</p>\n<h3 id=\"现代化和简化的API\"><a href=\"#现代化和简化的API\" class=\"headerlink\" title=\"现代化和简化的API\"></a>现代化和简化的API</h3><p>SwiftUI致力于提供一个简洁的API，用最少的代码完成最多的工作。例如，通过链式调用修饰符（Modifier）可以轻松地定制组件的样式和行为。</p>\n<h3 id=\"强调性能和效率\"><a href=\"#强调性能和效率\" class=\"headerlink\" title=\"强调性能和效率\"></a>强调性能和效率</h3><p>SwiftUI的设计充分考虑了性能。它利用了差异化更新（只更新UI的变更部分）以及懒加载视图等机制，以确保高效的内存和资源使用。</p>\n<p>通过这些设计理念，SwiftUI旨在实现快速、高效且更少出错的UI开发流程，适应现代应用开发的需求。随着Swift和SwiftUI的不断发展，它将进一步融合和优化，以提供更好的开发体验。</p>\n"},{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"date":"2023-11-06T01:14:03.574Z","updated":"2023-11-06T01:14:03.574Z","comments":1,"layout":"post","photos":[],"_id":"clu6up53k002uz674d5ic0on5","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo new <span class=\"hljs-string\">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo server<br></code></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo generate<br></code></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo deploy<br></code></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo new <span class=\"hljs-string\">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo server<br></code></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo generate<br></code></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo deploy<br></code></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"},{"title":"macOS查看环境变量","date":"2024-03-22T07:30:58.000Z","_content":"\n在macOS中，您可以通过终端查看和设置环境变量。以下是查看环境变量的方法：\n\n打开终端。\n\n输入 echo $PATH 来查看PATH变量，它通常包含执行的程序的路径。\n\n要查看所有环境变量，可以使用 env 命令。\n\n如果您想查看特定的环境变量，可以直接输入变量名，例如 echo $HOME 将显示当前用户的主目录。\n\n以下是实际的命令示例：\n\n# 查看PATH变量\n```shell\necho $PATH\n```\n# 查看所有环境变量\n```shell\nenv\n ```\n# 查看特定的环境变量，例如HOME目录\n```shell\necho $HOME\n```\n\n这些命令将在终端中输出相应的环境变量信息。","source":"_posts/macOS查看环境变量.md","raw":"---\ntitle: macOS查看环境变量\ndate: 2024-03-22 15:30:58\ntags:\n---\n\n在macOS中，您可以通过终端查看和设置环境变量。以下是查看环境变量的方法：\n\n打开终端。\n\n输入 echo $PATH 来查看PATH变量，它通常包含执行的程序的路径。\n\n要查看所有环境变量，可以使用 env 命令。\n\n如果您想查看特定的环境变量，可以直接输入变量名，例如 echo $HOME 将显示当前用户的主目录。\n\n以下是实际的命令示例：\n\n# 查看PATH变量\n```shell\necho $PATH\n```\n# 查看所有环境变量\n```shell\nenv\n ```\n# 查看特定的环境变量，例如HOME目录\n```shell\necho $HOME\n```\n\n这些命令将在终端中输出相应的环境变量信息。","slug":"macOS查看环境变量","published":1,"updated":"2024-03-22T07:31:45.933Z","comments":1,"layout":"post","photos":[],"_id":"clu6up53k002wz674enfu5k70","content":"<p>在macOS中，您可以通过终端查看和设置环境变量。以下是查看环境变量的方法：</p>\n<p>打开终端。</p>\n<p>输入 echo $PATH 来查看PATH变量，它通常包含执行的程序的路径。</p>\n<p>要查看所有环境变量，可以使用 env 命令。</p>\n<p>如果您想查看特定的环境变量，可以直接输入变量名，例如 echo $HOME 将显示当前用户的主目录。</p>\n<p>以下是实际的命令示例：</p>\n<h1 id=\"查看PATH变量\"><a href=\"#查看PATH变量\" class=\"headerlink\" title=\"查看PATH变量\"></a>查看PATH变量</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">echo $PATH<br></code></pre></td></tr></table></figure>\n<h1 id=\"查看所有环境变量\"><a href=\"#查看所有环境变量\" class=\"headerlink\" title=\"查看所有环境变量\"></a>查看所有环境变量</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">env<br></code></pre></td></tr></table></figure>\n<h1 id=\"查看特定的环境变量，例如HOME目录\"><a href=\"#查看特定的环境变量，例如HOME目录\" class=\"headerlink\" title=\"查看特定的环境变量，例如HOME目录\"></a>查看特定的环境变量，例如HOME目录</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">echo $HOME<br></code></pre></td></tr></table></figure>\n\n<p>这些命令将在终端中输出相应的环境变量信息。</p>\n","excerpt":"","more":"<p>在macOS中，您可以通过终端查看和设置环境变量。以下是查看环境变量的方法：</p>\n<p>打开终端。</p>\n<p>输入 echo $PATH 来查看PATH变量，它通常包含执行的程序的路径。</p>\n<p>要查看所有环境变量，可以使用 env 命令。</p>\n<p>如果您想查看特定的环境变量，可以直接输入变量名，例如 echo $HOME 将显示当前用户的主目录。</p>\n<p>以下是实际的命令示例：</p>\n<h1 id=\"查看PATH变量\"><a href=\"#查看PATH变量\" class=\"headerlink\" title=\"查看PATH变量\"></a>查看PATH变量</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">echo $PATH<br></code></pre></td></tr></table></figure>\n<h1 id=\"查看所有环境变量\"><a href=\"#查看所有环境变量\" class=\"headerlink\" title=\"查看所有环境变量\"></a>查看所有环境变量</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">env<br></code></pre></td></tr></table></figure>\n<h1 id=\"查看特定的环境变量，例如HOME目录\"><a href=\"#查看特定的环境变量，例如HOME目录\" class=\"headerlink\" title=\"查看特定的环境变量，例如HOME目录\"></a>查看特定的环境变量，例如HOME目录</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">echo $HOME<br></code></pre></td></tr></table></figure>\n\n<p>这些命令将在终端中输出相应的环境变量信息。</p>\n"},{"title":"使用JavaNIO编写一个HelloWorld程序","date":"2024-03-17T02:52:45.000Z","_content":"\n以下是一个简单的 Java NIO 客户端和服务端的 \"Hello World\" 程序：\n\n**服务端程序（Server.java）：**\n\n```java\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\n\npublic class Server {\n    public static void main(String[] args) {\n        try {\n            // 创建 ServerSocketChannel\n            ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();\n            \n            // 绑定端口\n            serverSocketChannel.bind(new InetSocketAddress(9999));\n            System.out.println(\"Server started, listening on port 9999...\");\n            \n            while (true) {\n                // 接受客户端连接\n                SocketChannel socketChannel = serverSocketChannel.accept();\n                \n                // 读取数据\n                ByteBuffer buffer = ByteBuffer.allocate(1024);\n                socketChannel.read(buffer);\n                buffer.flip();\n                System.out.println(\"Received message from client: \" + new String(buffer.array()).trim());\n                \n                // 发送响应\n                String response = \"Hello Client!\";\n                ByteBuffer responseBuffer = ByteBuffer.wrap(response.getBytes());\n                socketChannel.write(responseBuffer);\n                \n                // 关闭连接\n                socketChannel.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n**客户端程序（Client.java）：**\n\n```java\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SocketChannel;\n\npublic class Client {\n    public static void main(String[] args) {\n        try {\n            // 创建 SocketChannel\n            SocketChannel socketChannel = SocketChannel.open();\n            \n            // 连接到服务器\n            socketChannel.connect(new InetSocketAddress(\"localhost\", 9999));\n            System.out.println(\"Connected to server...\");\n            \n            // 发送数据\n            String message = \"Hello Server!\";\n            ByteBuffer buffer = ByteBuffer.wrap(message.getBytes());\n            socketChannel.write(buffer);\n            \n            // 接收响应\n            ByteBuffer responseBuffer = ByteBuffer.allocate(1024);\n            socketChannel.read(responseBuffer);\n            responseBuffer.flip();\n            System.out.println(\"Received response from server: \" + new String(responseBuffer.array()).trim());\n            \n            // 关闭连接\n            socketChannel.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n这个程序包括一个简单的客户端和服务器端。服务器监听端口9999，并在接收到客户端消息后，返回 \"Hello Client!\"。客户端连接到服务器，发送消息 \"Hello Server!\"，并打印出从服务器接收到的响应。","source":"_posts/使用JavaNIO编写一个HelloWorld程序.md","raw":"---\ntitle: 使用JavaNIO编写一个HelloWorld程序\ndate: 2024-03-17 10:52:45\ntags:\n---\n\n以下是一个简单的 Java NIO 客户端和服务端的 \"Hello World\" 程序：\n\n**服务端程序（Server.java）：**\n\n```java\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\n\npublic class Server {\n    public static void main(String[] args) {\n        try {\n            // 创建 ServerSocketChannel\n            ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();\n            \n            // 绑定端口\n            serverSocketChannel.bind(new InetSocketAddress(9999));\n            System.out.println(\"Server started, listening on port 9999...\");\n            \n            while (true) {\n                // 接受客户端连接\n                SocketChannel socketChannel = serverSocketChannel.accept();\n                \n                // 读取数据\n                ByteBuffer buffer = ByteBuffer.allocate(1024);\n                socketChannel.read(buffer);\n                buffer.flip();\n                System.out.println(\"Received message from client: \" + new String(buffer.array()).trim());\n                \n                // 发送响应\n                String response = \"Hello Client!\";\n                ByteBuffer responseBuffer = ByteBuffer.wrap(response.getBytes());\n                socketChannel.write(responseBuffer);\n                \n                // 关闭连接\n                socketChannel.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n**客户端程序（Client.java）：**\n\n```java\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SocketChannel;\n\npublic class Client {\n    public static void main(String[] args) {\n        try {\n            // 创建 SocketChannel\n            SocketChannel socketChannel = SocketChannel.open();\n            \n            // 连接到服务器\n            socketChannel.connect(new InetSocketAddress(\"localhost\", 9999));\n            System.out.println(\"Connected to server...\");\n            \n            // 发送数据\n            String message = \"Hello Server!\";\n            ByteBuffer buffer = ByteBuffer.wrap(message.getBytes());\n            socketChannel.write(buffer);\n            \n            // 接收响应\n            ByteBuffer responseBuffer = ByteBuffer.allocate(1024);\n            socketChannel.read(responseBuffer);\n            responseBuffer.flip();\n            System.out.println(\"Received response from server: \" + new String(responseBuffer.array()).trim());\n            \n            // 关闭连接\n            socketChannel.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n这个程序包括一个简单的客户端和服务器端。服务器监听端口9999，并在接收到客户端消息后，返回 \"Hello Client!\"。客户端连接到服务器，发送消息 \"Hello Server!\"，并打印出从服务器接收到的响应。","slug":"使用JavaNIO编写一个HelloWorld程序","published":1,"updated":"2024-03-17T02:53:00.142Z","comments":1,"layout":"post","photos":[],"_id":"clu6up53k002yz674685pcjrm","content":"<p>以下是一个简单的 Java NIO 客户端和服务端的 “Hello World” 程序：</p>\n<p><strong>服务端程序（Server.java）：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">import</span> java.io.IOException;<br><span class=\"hljs-keyword\">import</span> java.net.InetSocketAddress;<br><span class=\"hljs-keyword\">import</span> java.nio.ByteBuffer;<br><span class=\"hljs-keyword\">import</span> java.nio.channels.ServerSocketChannel;<br><span class=\"hljs-keyword\">import</span> java.nio.channels.SocketChannel;<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Server</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        <span class=\"hljs-keyword\">try</span> &#123;<br>            <span class=\"hljs-comment\">// 创建 ServerSocketChannel</span><br>            <span class=\"hljs-type\">ServerSocketChannel</span> <span class=\"hljs-variable\">serverSocketChannel</span> <span class=\"hljs-operator\">=</span> ServerSocketChannel.open();<br>            <br>            <span class=\"hljs-comment\">// 绑定端口</span><br>            serverSocketChannel.bind(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">InetSocketAddress</span>(<span class=\"hljs-number\">9999</span>));<br>            System.out.println(<span class=\"hljs-string\">&quot;Server started, listening on port 9999...&quot;</span>);<br>            <br>            <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>) &#123;<br>                <span class=\"hljs-comment\">// 接受客户端连接</span><br>                <span class=\"hljs-type\">SocketChannel</span> <span class=\"hljs-variable\">socketChannel</span> <span class=\"hljs-operator\">=</span> serverSocketChannel.accept();<br>                <br>                <span class=\"hljs-comment\">// 读取数据</span><br>                <span class=\"hljs-type\">ByteBuffer</span> <span class=\"hljs-variable\">buffer</span> <span class=\"hljs-operator\">=</span> ByteBuffer.allocate(<span class=\"hljs-number\">1024</span>);<br>                socketChannel.read(buffer);<br>                buffer.flip();<br>                System.out.println(<span class=\"hljs-string\">&quot;Received message from client: &quot;</span> + <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">String</span>(buffer.array()).trim());<br>                <br>                <span class=\"hljs-comment\">// 发送响应</span><br>                <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">response</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;Hello Client!&quot;</span>;<br>                <span class=\"hljs-type\">ByteBuffer</span> <span class=\"hljs-variable\">responseBuffer</span> <span class=\"hljs-operator\">=</span> ByteBuffer.wrap(response.getBytes());<br>                socketChannel.write(responseBuffer);<br>                <br>                <span class=\"hljs-comment\">// 关闭连接</span><br>                socketChannel.close();<br>            &#125;<br>        &#125; <span class=\"hljs-keyword\">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>客户端程序（Client.java）：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">import</span> java.io.IOException;<br><span class=\"hljs-keyword\">import</span> java.net.InetSocketAddress;<br><span class=\"hljs-keyword\">import</span> java.nio.ByteBuffer;<br><span class=\"hljs-keyword\">import</span> java.nio.channels.SocketChannel;<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Client</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        <span class=\"hljs-keyword\">try</span> &#123;<br>            <span class=\"hljs-comment\">// 创建 SocketChannel</span><br>            <span class=\"hljs-type\">SocketChannel</span> <span class=\"hljs-variable\">socketChannel</span> <span class=\"hljs-operator\">=</span> SocketChannel.open();<br>            <br>            <span class=\"hljs-comment\">// 连接到服务器</span><br>            socketChannel.connect(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">InetSocketAddress</span>(<span class=\"hljs-string\">&quot;localhost&quot;</span>, <span class=\"hljs-number\">9999</span>));<br>            System.out.println(<span class=\"hljs-string\">&quot;Connected to server...&quot;</span>);<br>            <br>            <span class=\"hljs-comment\">// 发送数据</span><br>            <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">message</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;Hello Server!&quot;</span>;<br>            <span class=\"hljs-type\">ByteBuffer</span> <span class=\"hljs-variable\">buffer</span> <span class=\"hljs-operator\">=</span> ByteBuffer.wrap(message.getBytes());<br>            socketChannel.write(buffer);<br>            <br>            <span class=\"hljs-comment\">// 接收响应</span><br>            <span class=\"hljs-type\">ByteBuffer</span> <span class=\"hljs-variable\">responseBuffer</span> <span class=\"hljs-operator\">=</span> ByteBuffer.allocate(<span class=\"hljs-number\">1024</span>);<br>            socketChannel.read(responseBuffer);<br>            responseBuffer.flip();<br>            System.out.println(<span class=\"hljs-string\">&quot;Received response from server: &quot;</span> + <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">String</span>(responseBuffer.array()).trim());<br>            <br>            <span class=\"hljs-comment\">// 关闭连接</span><br>            socketChannel.close();<br>        &#125; <span class=\"hljs-keyword\">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这个程序包括一个简单的客户端和服务器端。服务器监听端口9999，并在接收到客户端消息后，返回 “Hello Client!”。客户端连接到服务器，发送消息 “Hello Server!”，并打印出从服务器接收到的响应。</p>\n","excerpt":"","more":"<p>以下是一个简单的 Java NIO 客户端和服务端的 “Hello World” 程序：</p>\n<p><strong>服务端程序（Server.java）：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">import</span> java.io.IOException;<br><span class=\"hljs-keyword\">import</span> java.net.InetSocketAddress;<br><span class=\"hljs-keyword\">import</span> java.nio.ByteBuffer;<br><span class=\"hljs-keyword\">import</span> java.nio.channels.ServerSocketChannel;<br><span class=\"hljs-keyword\">import</span> java.nio.channels.SocketChannel;<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Server</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        <span class=\"hljs-keyword\">try</span> &#123;<br>            <span class=\"hljs-comment\">// 创建 ServerSocketChannel</span><br>            <span class=\"hljs-type\">ServerSocketChannel</span> <span class=\"hljs-variable\">serverSocketChannel</span> <span class=\"hljs-operator\">=</span> ServerSocketChannel.open();<br>            <br>            <span class=\"hljs-comment\">// 绑定端口</span><br>            serverSocketChannel.bind(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">InetSocketAddress</span>(<span class=\"hljs-number\">9999</span>));<br>            System.out.println(<span class=\"hljs-string\">&quot;Server started, listening on port 9999...&quot;</span>);<br>            <br>            <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>) &#123;<br>                <span class=\"hljs-comment\">// 接受客户端连接</span><br>                <span class=\"hljs-type\">SocketChannel</span> <span class=\"hljs-variable\">socketChannel</span> <span class=\"hljs-operator\">=</span> serverSocketChannel.accept();<br>                <br>                <span class=\"hljs-comment\">// 读取数据</span><br>                <span class=\"hljs-type\">ByteBuffer</span> <span class=\"hljs-variable\">buffer</span> <span class=\"hljs-operator\">=</span> ByteBuffer.allocate(<span class=\"hljs-number\">1024</span>);<br>                socketChannel.read(buffer);<br>                buffer.flip();<br>                System.out.println(<span class=\"hljs-string\">&quot;Received message from client: &quot;</span> + <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">String</span>(buffer.array()).trim());<br>                <br>                <span class=\"hljs-comment\">// 发送响应</span><br>                <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">response</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;Hello Client!&quot;</span>;<br>                <span class=\"hljs-type\">ByteBuffer</span> <span class=\"hljs-variable\">responseBuffer</span> <span class=\"hljs-operator\">=</span> ByteBuffer.wrap(response.getBytes());<br>                socketChannel.write(responseBuffer);<br>                <br>                <span class=\"hljs-comment\">// 关闭连接</span><br>                socketChannel.close();<br>            &#125;<br>        &#125; <span class=\"hljs-keyword\">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>客户端程序（Client.java）：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">import</span> java.io.IOException;<br><span class=\"hljs-keyword\">import</span> java.net.InetSocketAddress;<br><span class=\"hljs-keyword\">import</span> java.nio.ByteBuffer;<br><span class=\"hljs-keyword\">import</span> java.nio.channels.SocketChannel;<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Client</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        <span class=\"hljs-keyword\">try</span> &#123;<br>            <span class=\"hljs-comment\">// 创建 SocketChannel</span><br>            <span class=\"hljs-type\">SocketChannel</span> <span class=\"hljs-variable\">socketChannel</span> <span class=\"hljs-operator\">=</span> SocketChannel.open();<br>            <br>            <span class=\"hljs-comment\">// 连接到服务器</span><br>            socketChannel.connect(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">InetSocketAddress</span>(<span class=\"hljs-string\">&quot;localhost&quot;</span>, <span class=\"hljs-number\">9999</span>));<br>            System.out.println(<span class=\"hljs-string\">&quot;Connected to server...&quot;</span>);<br>            <br>            <span class=\"hljs-comment\">// 发送数据</span><br>            <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">message</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;Hello Server!&quot;</span>;<br>            <span class=\"hljs-type\">ByteBuffer</span> <span class=\"hljs-variable\">buffer</span> <span class=\"hljs-operator\">=</span> ByteBuffer.wrap(message.getBytes());<br>            socketChannel.write(buffer);<br>            <br>            <span class=\"hljs-comment\">// 接收响应</span><br>            <span class=\"hljs-type\">ByteBuffer</span> <span class=\"hljs-variable\">responseBuffer</span> <span class=\"hljs-operator\">=</span> ByteBuffer.allocate(<span class=\"hljs-number\">1024</span>);<br>            socketChannel.read(responseBuffer);<br>            responseBuffer.flip();<br>            System.out.println(<span class=\"hljs-string\">&quot;Received response from server: &quot;</span> + <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">String</span>(responseBuffer.array()).trim());<br>            <br>            <span class=\"hljs-comment\">// 关闭连接</span><br>            socketChannel.close();<br>        &#125; <span class=\"hljs-keyword\">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这个程序包括一个简单的客户端和服务器端。服务器监听端口9999，并在接收到客户端消息后，返回 “Hello Client!”。客户端连接到服务器，发送消息 “Hello Server!”，并打印出从服务器接收到的响应。</p>\n"},{"title":"在Mac上如何终止某个端口所在的进程？","date":"2023-11-12T03:31:14.000Z","_content":"在Mac上终止占用特定端口的进程可以通过以下步骤来完成：\n\n1. **查找占用端口的进程**：\n   打开终端（Terminal），然后使用`lsof`命令来查找占用特定端口的进程。例如，如果你想查找占用端口8080的进程，可以使用以下命令：\n\n   ```bash\n   lsof -i :8080\n   ```\n\n   这将列出所有占用端口8080的进程。输出中通常会包含进程ID（PID），这是一个数字。\n\n2. **终止进程**：\n   一旦你知道了进程ID，可以使用`kill`命令来终止该进程。例如，如果进程ID是1234，可以使用以下命令：\n\n   ```bash\n   kill 1234\n   ```\n\n   如果进程拒绝终止，你可以使用更强制的方式，比如`kill -9`命令：\n\n   ```bash\n   kill -9 1234\n   ```\n\n   这将强制终止该进程。\n\n请注意，在使用这些命令时要小心，确保你终止的是正确的进程，因为错误地终止进程可能会影响系统的稳定性或其他应用的运行。","source":"_posts/在Mac上如何终止某个端口所在的进程？.md","raw":"---\ntitle: 在Mac上如何终止某个端口所在的进程？\ndate: 2023-11-12 11:31:14\ntags:\n- [Mac]\n---\n在Mac上终止占用特定端口的进程可以通过以下步骤来完成：\n\n1. **查找占用端口的进程**：\n   打开终端（Terminal），然后使用`lsof`命令来查找占用特定端口的进程。例如，如果你想查找占用端口8080的进程，可以使用以下命令：\n\n   ```bash\n   lsof -i :8080\n   ```\n\n   这将列出所有占用端口8080的进程。输出中通常会包含进程ID（PID），这是一个数字。\n\n2. **终止进程**：\n   一旦你知道了进程ID，可以使用`kill`命令来终止该进程。例如，如果进程ID是1234，可以使用以下命令：\n\n   ```bash\n   kill 1234\n   ```\n\n   如果进程拒绝终止，你可以使用更强制的方式，比如`kill -9`命令：\n\n   ```bash\n   kill -9 1234\n   ```\n\n   这将强制终止该进程。\n\n请注意，在使用这些命令时要小心，确保你终止的是正确的进程，因为错误地终止进程可能会影响系统的稳定性或其他应用的运行。","slug":"在Mac上如何终止某个端口所在的进程？","published":1,"updated":"2023-11-12T03:32:14.994Z","comments":1,"layout":"post","photos":[],"_id":"clu6up53k0030z6744irc26ri","content":"<p>在Mac上终止占用特定端口的进程可以通过以下步骤来完成：</p>\n<ol>\n<li><p><strong>查找占用端口的进程</strong>：<br>打开终端（Terminal），然后使用<code>lsof</code>命令来查找占用特定端口的进程。例如，如果你想查找占用端口8080的进程，可以使用以下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">lsof -i :8080<br></code></pre></td></tr></table></figure>\n\n<p>这将列出所有占用端口8080的进程。输出中通常会包含进程ID（PID），这是一个数字。</p>\n</li>\n<li><p><strong>终止进程</strong>：<br>一旦你知道了进程ID，可以使用<code>kill</code>命令来终止该进程。例如，如果进程ID是1234，可以使用以下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">kill</span> 1234<br></code></pre></td></tr></table></figure>\n\n<p>如果进程拒绝终止，你可以使用更强制的方式，比如<code>kill -9</code>命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">kill</span> -9 1234<br></code></pre></td></tr></table></figure>\n\n<p>这将强制终止该进程。</p>\n</li>\n</ol>\n<p>请注意，在使用这些命令时要小心，确保你终止的是正确的进程，因为错误地终止进程可能会影响系统的稳定性或其他应用的运行。</p>\n","excerpt":"","more":"<p>在Mac上终止占用特定端口的进程可以通过以下步骤来完成：</p>\n<ol>\n<li><p><strong>查找占用端口的进程</strong>：<br>打开终端（Terminal），然后使用<code>lsof</code>命令来查找占用特定端口的进程。例如，如果你想查找占用端口8080的进程，可以使用以下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">lsof -i :8080<br></code></pre></td></tr></table></figure>\n\n<p>这将列出所有占用端口8080的进程。输出中通常会包含进程ID（PID），这是一个数字。</p>\n</li>\n<li><p><strong>终止进程</strong>：<br>一旦你知道了进程ID，可以使用<code>kill</code>命令来终止该进程。例如，如果进程ID是1234，可以使用以下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">kill</span> 1234<br></code></pre></td></tr></table></figure>\n\n<p>如果进程拒绝终止，你可以使用更强制的方式，比如<code>kill -9</code>命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">kill</span> -9 1234<br></code></pre></td></tr></table></figure>\n\n<p>这将强制终止该进程。</p>\n</li>\n</ol>\n<p>请注意，在使用这些命令时要小心，确保你终止的是正确的进程，因为错误地终止进程可能会影响系统的稳定性或其他应用的运行。</p>\n"},{"title":"声明式语法和命令式语法的区别","date":"2023-11-07T07:57:06.000Z","_content":"声明式语法和命令式语法是编程中描述软件逻辑的两种不同风格。它们在定义程序如何和应该做什么方面有本质的不同。\n\n### 声明式语法（Declarative Syntax）\n\n在声明式编程中，你描述**“你想要什么”**（What you want），而不是你要如何达到目的（How you achieve it）。你定义了目标状态，而具体的实现细节则通常由框架、库或系统自己处理。\n\n**特点**:\n- **抽象层次更高**：更加关注描述问题的逻辑，而不是实现的步骤。\n- **易于推理**：由于直接表达了目的，因此通常代码更简洁，逻辑更清晰。\n- **减少副作用**：代码通常没有临时变量和迭代，从而减少了意外修改状态的风险。\n- **改善可维护性**：因为代码量减少且更加直观，所以通常更易于维护。\n- **例子**：SQL（描述你想要查询什么数据，而不是如何查询数据）、React和SwiftUI（描述UI应该如何根据数据状态显示，而不是如何修改UI）。\n\n### 命令式语法（Imperative Syntax）\n\n命令式编程关注**“你如何做”**（How you do it），需要提供达成目标的详细步骤。这通常涉及到编写更多的逻辑来手动处理状态的变化和应用的流程。\n\n**特点**:\n- **控制流程明确**：详细指定了执行顺序和逻辑流程。\n- **具体化操作**：每一步都需要程序员明确指定。\n- **灵活性高**：因为可以控制每一步，所以在处理复杂逻辑时可能更具优势。\n- **例子**：大多数传统的编程语言如C、Java在处理UI时倾向于命令式风格，明确指定每一步如何创建和管理UI元素。\n\n### 对比示例\n\n假设我们要更改一个列表的所有元素，使其翻倍。\n\n**声明式（SwiftUI风格）**:\n```swift\nlet numbers = [1, 2, 3, 4, 5]\nlet doubledNumbers = numbers.map { $0 * 2 }\n```\n这里我们没有指定如何遍历数字，如何存储结果。我们只是描述了对每个元素想做的操作。\n\n**命令式（传统的C风格）**:\n```c\nint numbers[] = {1, 2, 3, 4, 5};\nint doubledNumbers[sizeof(numbers)/sizeof(numbers[0])];\n\nfor (int i = 0; i < sizeof(numbers)/sizeof(numbers[0]); i++) {\n    doubledNumbers[i] = numbers[i] * 2;\n}\n```\n这里我们具体指定了创建数组、循环的开始和结束条件，以及如何在每一次循环中翻倍当前元素。\n\n在UI开发中，声明式语法让状态和UI的同步变得更简单，因为UI框架（如SwiftUI）会负责监听数据变化并更新UI，而不需要开发者编写代码来手动操作DOM或视图元素。","source":"_posts/声明式语法和命令式语法的区别.md","raw":"---\ntitle: 声明式语法和命令式语法的区别\ndate: 2023-11-07 15:57:06\ntags:\n---\n声明式语法和命令式语法是编程中描述软件逻辑的两种不同风格。它们在定义程序如何和应该做什么方面有本质的不同。\n\n### 声明式语法（Declarative Syntax）\n\n在声明式编程中，你描述**“你想要什么”**（What you want），而不是你要如何达到目的（How you achieve it）。你定义了目标状态，而具体的实现细节则通常由框架、库或系统自己处理。\n\n**特点**:\n- **抽象层次更高**：更加关注描述问题的逻辑，而不是实现的步骤。\n- **易于推理**：由于直接表达了目的，因此通常代码更简洁，逻辑更清晰。\n- **减少副作用**：代码通常没有临时变量和迭代，从而减少了意外修改状态的风险。\n- **改善可维护性**：因为代码量减少且更加直观，所以通常更易于维护。\n- **例子**：SQL（描述你想要查询什么数据，而不是如何查询数据）、React和SwiftUI（描述UI应该如何根据数据状态显示，而不是如何修改UI）。\n\n### 命令式语法（Imperative Syntax）\n\n命令式编程关注**“你如何做”**（How you do it），需要提供达成目标的详细步骤。这通常涉及到编写更多的逻辑来手动处理状态的变化和应用的流程。\n\n**特点**:\n- **控制流程明确**：详细指定了执行顺序和逻辑流程。\n- **具体化操作**：每一步都需要程序员明确指定。\n- **灵活性高**：因为可以控制每一步，所以在处理复杂逻辑时可能更具优势。\n- **例子**：大多数传统的编程语言如C、Java在处理UI时倾向于命令式风格，明确指定每一步如何创建和管理UI元素。\n\n### 对比示例\n\n假设我们要更改一个列表的所有元素，使其翻倍。\n\n**声明式（SwiftUI风格）**:\n```swift\nlet numbers = [1, 2, 3, 4, 5]\nlet doubledNumbers = numbers.map { $0 * 2 }\n```\n这里我们没有指定如何遍历数字，如何存储结果。我们只是描述了对每个元素想做的操作。\n\n**命令式（传统的C风格）**:\n```c\nint numbers[] = {1, 2, 3, 4, 5};\nint doubledNumbers[sizeof(numbers)/sizeof(numbers[0])];\n\nfor (int i = 0; i < sizeof(numbers)/sizeof(numbers[0]); i++) {\n    doubledNumbers[i] = numbers[i] * 2;\n}\n```\n这里我们具体指定了创建数组、循环的开始和结束条件，以及如何在每一次循环中翻倍当前元素。\n\n在UI开发中，声明式语法让状态和UI的同步变得更简单，因为UI框架（如SwiftUI）会负责监听数据变化并更新UI，而不需要开发者编写代码来手动操作DOM或视图元素。","slug":"声明式语法和命令式语法的区别","published":1,"updated":"2023-11-07T07:57:31.823Z","comments":1,"layout":"post","photos":[],"_id":"clu6up53l0032z6744doahmbk","content":"<p>声明式语法和命令式语法是编程中描述软件逻辑的两种不同风格。它们在定义程序如何和应该做什么方面有本质的不同。</p>\n<h3 id=\"声明式语法（Declarative-Syntax）\"><a href=\"#声明式语法（Declarative-Syntax）\" class=\"headerlink\" title=\"声明式语法（Declarative Syntax）\"></a>声明式语法（Declarative Syntax）</h3><p>在声明式编程中，你描述<strong>“你想要什么”</strong>（What you want），而不是你要如何达到目的（How you achieve it）。你定义了目标状态，而具体的实现细节则通常由框架、库或系统自己处理。</p>\n<p><strong>特点</strong>:</p>\n<ul>\n<li><strong>抽象层次更高</strong>：更加关注描述问题的逻辑，而不是实现的步骤。</li>\n<li><strong>易于推理</strong>：由于直接表达了目的，因此通常代码更简洁，逻辑更清晰。</li>\n<li><strong>减少副作用</strong>：代码通常没有临时变量和迭代，从而减少了意外修改状态的风险。</li>\n<li><strong>改善可维护性</strong>：因为代码量减少且更加直观，所以通常更易于维护。</li>\n<li><strong>例子</strong>：SQL（描述你想要查询什么数据，而不是如何查询数据）、React和SwiftUI（描述UI应该如何根据数据状态显示，而不是如何修改UI）。</li>\n</ul>\n<h3 id=\"命令式语法（Imperative-Syntax）\"><a href=\"#命令式语法（Imperative-Syntax）\" class=\"headerlink\" title=\"命令式语法（Imperative Syntax）\"></a>命令式语法（Imperative Syntax）</h3><p>命令式编程关注<strong>“你如何做”</strong>（How you do it），需要提供达成目标的详细步骤。这通常涉及到编写更多的逻辑来手动处理状态的变化和应用的流程。</p>\n<p><strong>特点</strong>:</p>\n<ul>\n<li><strong>控制流程明确</strong>：详细指定了执行顺序和逻辑流程。</li>\n<li><strong>具体化操作</strong>：每一步都需要程序员明确指定。</li>\n<li><strong>灵活性高</strong>：因为可以控制每一步，所以在处理复杂逻辑时可能更具优势。</li>\n<li><strong>例子</strong>：大多数传统的编程语言如C、Java在处理UI时倾向于命令式风格，明确指定每一步如何创建和管理UI元素。</li>\n</ul>\n<h3 id=\"对比示例\"><a href=\"#对比示例\" class=\"headerlink\" title=\"对比示例\"></a>对比示例</h3><p>假设我们要更改一个列表的所有元素，使其翻倍。</p>\n<p><strong>声明式（SwiftUI风格）</strong>:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">let</span> numbers <span class=\"hljs-operator\">=</span> [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>]<br><span class=\"hljs-keyword\">let</span> doubledNumbers <span class=\"hljs-operator\">=</span> numbers.map &#123; <span class=\"hljs-variable\">$0</span> <span class=\"hljs-operator\">*</span> <span class=\"hljs-number\">2</span> &#125;<br></code></pre></td></tr></table></figure>\n<p>这里我们没有指定如何遍历数字，如何存储结果。我们只是描述了对每个元素想做的操作。</p>\n<p><strong>命令式（传统的C风格）</strong>:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">int</span> numbers[] = &#123;<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>&#125;;<br><span class=\"hljs-type\">int</span> doubledNumbers[<span class=\"hljs-keyword\">sizeof</span>(numbers)/<span class=\"hljs-keyword\">sizeof</span>(numbers[<span class=\"hljs-number\">0</span>])];<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-keyword\">sizeof</span>(numbers)/<span class=\"hljs-keyword\">sizeof</span>(numbers[<span class=\"hljs-number\">0</span>]); i++) &#123;<br>    doubledNumbers[i] = numbers[i] * <span class=\"hljs-number\">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>这里我们具体指定了创建数组、循环的开始和结束条件，以及如何在每一次循环中翻倍当前元素。</p>\n<p>在UI开发中，声明式语法让状态和UI的同步变得更简单，因为UI框架（如SwiftUI）会负责监听数据变化并更新UI，而不需要开发者编写代码来手动操作DOM或视图元素。</p>\n","excerpt":"","more":"<p>声明式语法和命令式语法是编程中描述软件逻辑的两种不同风格。它们在定义程序如何和应该做什么方面有本质的不同。</p>\n<h3 id=\"声明式语法（Declarative-Syntax）\"><a href=\"#声明式语法（Declarative-Syntax）\" class=\"headerlink\" title=\"声明式语法（Declarative Syntax）\"></a>声明式语法（Declarative Syntax）</h3><p>在声明式编程中，你描述<strong>“你想要什么”</strong>（What you want），而不是你要如何达到目的（How you achieve it）。你定义了目标状态，而具体的实现细节则通常由框架、库或系统自己处理。</p>\n<p><strong>特点</strong>:</p>\n<ul>\n<li><strong>抽象层次更高</strong>：更加关注描述问题的逻辑，而不是实现的步骤。</li>\n<li><strong>易于推理</strong>：由于直接表达了目的，因此通常代码更简洁，逻辑更清晰。</li>\n<li><strong>减少副作用</strong>：代码通常没有临时变量和迭代，从而减少了意外修改状态的风险。</li>\n<li><strong>改善可维护性</strong>：因为代码量减少且更加直观，所以通常更易于维护。</li>\n<li><strong>例子</strong>：SQL（描述你想要查询什么数据，而不是如何查询数据）、React和SwiftUI（描述UI应该如何根据数据状态显示，而不是如何修改UI）。</li>\n</ul>\n<h3 id=\"命令式语法（Imperative-Syntax）\"><a href=\"#命令式语法（Imperative-Syntax）\" class=\"headerlink\" title=\"命令式语法（Imperative Syntax）\"></a>命令式语法（Imperative Syntax）</h3><p>命令式编程关注<strong>“你如何做”</strong>（How you do it），需要提供达成目标的详细步骤。这通常涉及到编写更多的逻辑来手动处理状态的变化和应用的流程。</p>\n<p><strong>特点</strong>:</p>\n<ul>\n<li><strong>控制流程明确</strong>：详细指定了执行顺序和逻辑流程。</li>\n<li><strong>具体化操作</strong>：每一步都需要程序员明确指定。</li>\n<li><strong>灵活性高</strong>：因为可以控制每一步，所以在处理复杂逻辑时可能更具优势。</li>\n<li><strong>例子</strong>：大多数传统的编程语言如C、Java在处理UI时倾向于命令式风格，明确指定每一步如何创建和管理UI元素。</li>\n</ul>\n<h3 id=\"对比示例\"><a href=\"#对比示例\" class=\"headerlink\" title=\"对比示例\"></a>对比示例</h3><p>假设我们要更改一个列表的所有元素，使其翻倍。</p>\n<p><strong>声明式（SwiftUI风格）</strong>:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">let</span> numbers <span class=\"hljs-operator\">=</span> [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>]<br><span class=\"hljs-keyword\">let</span> doubledNumbers <span class=\"hljs-operator\">=</span> numbers.map &#123; <span class=\"hljs-variable\">$0</span> <span class=\"hljs-operator\">*</span> <span class=\"hljs-number\">2</span> &#125;<br></code></pre></td></tr></table></figure>\n<p>这里我们没有指定如何遍历数字，如何存储结果。我们只是描述了对每个元素想做的操作。</p>\n<p><strong>命令式（传统的C风格）</strong>:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">int</span> numbers[] = &#123;<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>&#125;;<br><span class=\"hljs-type\">int</span> doubledNumbers[<span class=\"hljs-keyword\">sizeof</span>(numbers)/<span class=\"hljs-keyword\">sizeof</span>(numbers[<span class=\"hljs-number\">0</span>])];<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-keyword\">sizeof</span>(numbers)/<span class=\"hljs-keyword\">sizeof</span>(numbers[<span class=\"hljs-number\">0</span>]); i++) &#123;<br>    doubledNumbers[i] = numbers[i] * <span class=\"hljs-number\">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>这里我们具体指定了创建数组、循环的开始和结束条件，以及如何在每一次循环中翻倍当前元素。</p>\n<p>在UI开发中，声明式语法让状态和UI的同步变得更简单，因为UI框架（如SwiftUI）会负责监听数据变化并更新UI，而不需要开发者编写代码来手动操作DOM或视图元素。</p>\n"},{"title":"使用Vapor编写用户信息CRUD的API接口","date":"2023-11-09T00:49:10.000Z","_content":"很高兴你对Vapor框架感兴趣！Vapor 是一个用 Swift 编写的 Web 框架，非常适合于构建快速、可靠的服务端应用程序。接下来我会引导你如何使用 Vapor 创建一个简单的用户信息 CRUD（创建、读取、更新、删除）API。\n\n### 环境准备\n\n首先，确保你的电脑上安装了以下软件：\n\n1. **Swift**: Vapor 是基于 Swift 的，所以你需要安装 Swift。\n2. **Vapor Toolbox**: 这是一个命令行工具，用于简化 Vapor 项目的创建和管理。\n\n### 创建新项目\n\n1. 打开终端。\n2. 使用 Vapor Toolbox 创建一个新项目：`vapor new UserCRUDAPI`。\n3. 进入项目目录：`cd UserCRUDAPI`。\n\n### 设定模型和数据库\n\n为了简单起见，我们将使用内存数据库（SQLite），这样就不需要额外安装数据库软件。\n\n1. **定义用户模型**：在 `Sources/App/Models` 目录下创建一个新的 Swift 文件 `User.swift`。\n\n    ```swift\n    import Vapor\n    import Fluent\n\n    final class User: Model, Content {\n        static let schema = \"users\"\n\n        @ID(key: .id)\n        var id: UUID?\n\n        @Field(key: \"name\")\n        var name: String\n\n        @Field(key: \"email\")\n        var email: String\n\n        init() { }\n\n        init(id: UUID? = nil, name: String, email: String) {\n            self.id = id\n            self.name = name\n            self.email = email\n        }\n    }\n    ```\n\n2. **配置数据库**：在 `Sources/App/configure.swift` 文件中配置数据库。\n\n    ```swift\n    import Fluent\n    import FluentSQLiteDriver\n    import Vapor\n\n    public func configure(_ app: Application) throws {\n        app.databases.use(.sqlite(.memory), as: .sqlite)\n        app.migrations.add(CreateUser())\n        try app.autoMigrate().wait()\n        \n        // 其他配置...\n    }\n    ```\n\n3. **创建数据库迁移**：创建一个新的 Swift 文件 `CreateUser.swift` 在 `Sources/App/Migrations`。\n\n    ```swift\n    import Fluent\n\n    struct CreateUser: Migration {\n        func prepare(on database: Database) -> EventLoopFuture<Void> {\n            database.schema(\"users\")\n                .id()\n                .field(\"name\", .string, .required)\n                .field(\"email\", .string, .required)\n                .create()\n        }\n\n        func revert(on database: Database) -> EventLoopFuture<Void> {\n            database.schema(\"users\").delete()\n        }\n    }\n    ```\n\n### 编写 CRUD 接口\n\n1. **创建路由**：在 `Sources/App/routes.swift` 文件中定义路由和相应的处理函数。\n\n    ```swift\n    import Vapor\n\n    func routes(_ app: Application) throws {\n        let userController = UserController()\n        app.get(\"users\", use: userController.index)\n        app.post(\"users\", use: userController.create)\n        app.group(\"users\") { users in\n            users.get(\":userID\", use: userController.show)\n            users.put(\":userID\", use: userController.update)\n            users.delete(\":userID\", use: userController.delete)\n        }\n    }\n    ```\n\n2. **实现控制器**：创建一个新的 Swift 文件 `UserController.swift` 在 `Sources/App/Controllers`。\n\n    ```swift\n    import Vapor\n\n    struct UserController {\n        func index(req: Request) throws -> EventLoopFuture<[User]> {\n            return User.query(on: req.db).all()\n        }\n\n        func create(req: Request) throws -> EventLoopFuture<User> {\n            let user = try req.content.decode(User.self)\n            return user.save(on: req.db).map { user }\n        }\n\n        func show(req: Request) throws -> EventLoopFuture<User> {\n            User.find(req.parameters.get(\"userID\"), on: req.db)\n                .unwrap(or: Abort(.notFound))\n        }\n\n        func update(req: Request) throws -> EventLoopFuture<User> {\n            let updatedUser = try req.content.decode(User.self)\n            return User.find(req.parameters.get(\"userID\"), on: req.db)\n                .unwrap(or: Abort(.notFound)).flatMap { user in\n                    user.name = updatedUser.name\n                    user.email = updatedUser.email\n                    return user.save(on: req.db).map { user }\n                }\n        }\n\n        func delete(req: Request) throws -> EventLoopFuture<HTTPStatus> {\n            User.find(req.parameters.get(\"userID\"), on: req.db)\n                .unwrap(or: Abort(.notFound))\n                .flatMap { user in\n                    user.delete(on: req.db)\n                        .transform(to: .ok)\n                }\n        }\n    }\n    ```\n\n### 运行和测试\n\n1. **启动服务器**：在项目根目录下运行 `vapor run`。\n2. **测试 API**：使用 Postman 或任何 HTTP 客户端工具测试你的 API。\n\n   - 创建用户：`POST /users`，带上 JSON 请求体，比如 `{\"name\": \"Alice\", \"email\": \"alice@example.com\"}`。\n   - 列出所有用户：`GET /users`。\n   - 获取单个用户：`GET /users/:userID`。\n   - 更新用户信息：`PUT /users/:userID`。\n   - 删除用户：`DELETE /users/:userID`。\n\n### 总结\n\n在这个简单的示例中，我们创建了一个使用 Swift 和 Vapor 框架的 RESTful API，它可以处理基本的用户信息 CRUD 操作。这个示例使用了内存中的 SQLite 数据库，因此在服务器重启时，所有数据都会丢失。在实际应用中，你可能会使用 PostgreSQL 或 MySQL 等持久化的数据库。希望这对你学习 Vapor 有所帮助！","source":"_posts/使用Vapor编写用户信息CRUD的API接口.md","raw":"---\ntitle: 使用Vapor编写用户信息CRUD的API接口\ndate: 2023-11-09 08:49:10\ntags:\n---\n很高兴你对Vapor框架感兴趣！Vapor 是一个用 Swift 编写的 Web 框架，非常适合于构建快速、可靠的服务端应用程序。接下来我会引导你如何使用 Vapor 创建一个简单的用户信息 CRUD（创建、读取、更新、删除）API。\n\n### 环境准备\n\n首先，确保你的电脑上安装了以下软件：\n\n1. **Swift**: Vapor 是基于 Swift 的，所以你需要安装 Swift。\n2. **Vapor Toolbox**: 这是一个命令行工具，用于简化 Vapor 项目的创建和管理。\n\n### 创建新项目\n\n1. 打开终端。\n2. 使用 Vapor Toolbox 创建一个新项目：`vapor new UserCRUDAPI`。\n3. 进入项目目录：`cd UserCRUDAPI`。\n\n### 设定模型和数据库\n\n为了简单起见，我们将使用内存数据库（SQLite），这样就不需要额外安装数据库软件。\n\n1. **定义用户模型**：在 `Sources/App/Models` 目录下创建一个新的 Swift 文件 `User.swift`。\n\n    ```swift\n    import Vapor\n    import Fluent\n\n    final class User: Model, Content {\n        static let schema = \"users\"\n\n        @ID(key: .id)\n        var id: UUID?\n\n        @Field(key: \"name\")\n        var name: String\n\n        @Field(key: \"email\")\n        var email: String\n\n        init() { }\n\n        init(id: UUID? = nil, name: String, email: String) {\n            self.id = id\n            self.name = name\n            self.email = email\n        }\n    }\n    ```\n\n2. **配置数据库**：在 `Sources/App/configure.swift` 文件中配置数据库。\n\n    ```swift\n    import Fluent\n    import FluentSQLiteDriver\n    import Vapor\n\n    public func configure(_ app: Application) throws {\n        app.databases.use(.sqlite(.memory), as: .sqlite)\n        app.migrations.add(CreateUser())\n        try app.autoMigrate().wait()\n        \n        // 其他配置...\n    }\n    ```\n\n3. **创建数据库迁移**：创建一个新的 Swift 文件 `CreateUser.swift` 在 `Sources/App/Migrations`。\n\n    ```swift\n    import Fluent\n\n    struct CreateUser: Migration {\n        func prepare(on database: Database) -> EventLoopFuture<Void> {\n            database.schema(\"users\")\n                .id()\n                .field(\"name\", .string, .required)\n                .field(\"email\", .string, .required)\n                .create()\n        }\n\n        func revert(on database: Database) -> EventLoopFuture<Void> {\n            database.schema(\"users\").delete()\n        }\n    }\n    ```\n\n### 编写 CRUD 接口\n\n1. **创建路由**：在 `Sources/App/routes.swift` 文件中定义路由和相应的处理函数。\n\n    ```swift\n    import Vapor\n\n    func routes(_ app: Application) throws {\n        let userController = UserController()\n        app.get(\"users\", use: userController.index)\n        app.post(\"users\", use: userController.create)\n        app.group(\"users\") { users in\n            users.get(\":userID\", use: userController.show)\n            users.put(\":userID\", use: userController.update)\n            users.delete(\":userID\", use: userController.delete)\n        }\n    }\n    ```\n\n2. **实现控制器**：创建一个新的 Swift 文件 `UserController.swift` 在 `Sources/App/Controllers`。\n\n    ```swift\n    import Vapor\n\n    struct UserController {\n        func index(req: Request) throws -> EventLoopFuture<[User]> {\n            return User.query(on: req.db).all()\n        }\n\n        func create(req: Request) throws -> EventLoopFuture<User> {\n            let user = try req.content.decode(User.self)\n            return user.save(on: req.db).map { user }\n        }\n\n        func show(req: Request) throws -> EventLoopFuture<User> {\n            User.find(req.parameters.get(\"userID\"), on: req.db)\n                .unwrap(or: Abort(.notFound))\n        }\n\n        func update(req: Request) throws -> EventLoopFuture<User> {\n            let updatedUser = try req.content.decode(User.self)\n            return User.find(req.parameters.get(\"userID\"), on: req.db)\n                .unwrap(or: Abort(.notFound)).flatMap { user in\n                    user.name = updatedUser.name\n                    user.email = updatedUser.email\n                    return user.save(on: req.db).map { user }\n                }\n        }\n\n        func delete(req: Request) throws -> EventLoopFuture<HTTPStatus> {\n            User.find(req.parameters.get(\"userID\"), on: req.db)\n                .unwrap(or: Abort(.notFound))\n                .flatMap { user in\n                    user.delete(on: req.db)\n                        .transform(to: .ok)\n                }\n        }\n    }\n    ```\n\n### 运行和测试\n\n1. **启动服务器**：在项目根目录下运行 `vapor run`。\n2. **测试 API**：使用 Postman 或任何 HTTP 客户端工具测试你的 API。\n\n   - 创建用户：`POST /users`，带上 JSON 请求体，比如 `{\"name\": \"Alice\", \"email\": \"alice@example.com\"}`。\n   - 列出所有用户：`GET /users`。\n   - 获取单个用户：`GET /users/:userID`。\n   - 更新用户信息：`PUT /users/:userID`。\n   - 删除用户：`DELETE /users/:userID`。\n\n### 总结\n\n在这个简单的示例中，我们创建了一个使用 Swift 和 Vapor 框架的 RESTful API，它可以处理基本的用户信息 CRUD 操作。这个示例使用了内存中的 SQLite 数据库，因此在服务器重启时，所有数据都会丢失。在实际应用中，你可能会使用 PostgreSQL 或 MySQL 等持久化的数据库。希望这对你学习 Vapor 有所帮助！","slug":"使用Vapor编写用户信息CRUD的API接口","published":1,"updated":"2023-11-09T00:49:57.368Z","comments":1,"layout":"post","photos":[],"_id":"clu6up53l0035z6742lcagr52","content":"<p>很高兴你对Vapor框架感兴趣！Vapor 是一个用 Swift 编写的 Web 框架，非常适合于构建快速、可靠的服务端应用程序。接下来我会引导你如何使用 Vapor 创建一个简单的用户信息 CRUD（创建、读取、更新、删除）API。</p>\n<h3 id=\"环境准备\"><a href=\"#环境准备\" class=\"headerlink\" title=\"环境准备\"></a>环境准备</h3><p>首先，确保你的电脑上安装了以下软件：</p>\n<ol>\n<li><strong>Swift</strong>: Vapor 是基于 Swift 的，所以你需要安装 Swift。</li>\n<li><strong>Vapor Toolbox</strong>: 这是一个命令行工具，用于简化 Vapor 项目的创建和管理。</li>\n</ol>\n<h3 id=\"创建新项目\"><a href=\"#创建新项目\" class=\"headerlink\" title=\"创建新项目\"></a>创建新项目</h3><ol>\n<li>打开终端。</li>\n<li>使用 Vapor Toolbox 创建一个新项目：<code>vapor new UserCRUDAPI</code>。</li>\n<li>进入项目目录：<code>cd UserCRUDAPI</code>。</li>\n</ol>\n<h3 id=\"设定模型和数据库\"><a href=\"#设定模型和数据库\" class=\"headerlink\" title=\"设定模型和数据库\"></a>设定模型和数据库</h3><p>为了简单起见，我们将使用内存数据库（SQLite），这样就不需要额外安装数据库软件。</p>\n<ol>\n<li><p><strong>定义用户模型</strong>：在 <code>Sources/App/Models</code> 目录下创建一个新的 Swift 文件 <code>User.swift</code>。</p>\n <figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">import</span> Vapor<br><span class=\"hljs-keyword\">import</span> Fluent<br><br><span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">User</span>: <span class=\"hljs-title class_\">Model</span>, <span class=\"hljs-title class_\">Content</span> &#123;<br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">let</span> schema <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;users&quot;</span><br><br>    <span class=\"hljs-meta\">@ID</span>(key: .id)<br>    <span class=\"hljs-keyword\">var</span> id: <span class=\"hljs-type\">UUID</span>?<br><br>    <span class=\"hljs-meta\">@Field</span>(key: <span class=\"hljs-string\">&quot;name&quot;</span>)<br>    <span class=\"hljs-keyword\">var</span> name: <span class=\"hljs-type\">String</span><br><br>    <span class=\"hljs-meta\">@Field</span>(key: <span class=\"hljs-string\">&quot;email&quot;</span>)<br>    <span class=\"hljs-keyword\">var</span> email: <span class=\"hljs-type\">String</span><br><br>    <span class=\"hljs-keyword\">init</span>() &#123; &#125;<br><br>    <span class=\"hljs-keyword\">init</span>(<span class=\"hljs-params\">id</span>: <span class=\"hljs-type\">UUID</span>? <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">nil</span>, <span class=\"hljs-params\">name</span>: <span class=\"hljs-type\">String</span>, <span class=\"hljs-params\">email</span>: <span class=\"hljs-type\">String</span>) &#123;<br>        <span class=\"hljs-keyword\">self</span>.id <span class=\"hljs-operator\">=</span> id<br>        <span class=\"hljs-keyword\">self</span>.name <span class=\"hljs-operator\">=</span> name<br>        <span class=\"hljs-keyword\">self</span>.email <span class=\"hljs-operator\">=</span> email<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n</li>\n<li><p><strong>配置数据库</strong>：在 <code>Sources/App/configure.swift</code> 文件中配置数据库。</p>\n <figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">import</span> Fluent<br><span class=\"hljs-keyword\">import</span> FluentSQLiteDriver<br><span class=\"hljs-keyword\">import</span> Vapor<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">configure</span>(<span class=\"hljs-keyword\">_</span> <span class=\"hljs-params\">app</span>: <span class=\"hljs-type\">Application</span>) <span class=\"hljs-keyword\">throws</span> &#123;<br>    app.databases.use(.sqlite(.memory), as: .sqlite)<br>    app.migrations.add(<span class=\"hljs-type\">CreateUser</span>())<br>    <span class=\"hljs-keyword\">try</span> app.autoMigrate().wait()<br>    <br>    <span class=\"hljs-comment\">// 其他配置...</span><br>&#125;<br></code></pre></td></tr></table></figure>\n</li>\n<li><p><strong>创建数据库迁移</strong>：创建一个新的 Swift 文件 <code>CreateUser.swift</code> 在 <code>Sources/App/Migrations</code>。</p>\n <figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">import</span> Fluent<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">CreateUser</span>: <span class=\"hljs-title class_\">Migration</span> &#123;<br>    <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">prepare</span>(<span class=\"hljs-params\">on</span> <span class=\"hljs-params\">database</span>: <span class=\"hljs-type\">Database</span>) -&gt; <span class=\"hljs-type\">EventLoopFuture</span>&lt;<span class=\"hljs-type\">Void</span>&gt; &#123;<br>        database.schema(<span class=\"hljs-string\">&quot;users&quot;</span>)<br>            .id()<br>            .field(<span class=\"hljs-string\">&quot;name&quot;</span>, .string, .required)<br>            .field(<span class=\"hljs-string\">&quot;email&quot;</span>, .string, .required)<br>            .create()<br>    &#125;<br><br>    <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">revert</span>(<span class=\"hljs-params\">on</span> <span class=\"hljs-params\">database</span>: <span class=\"hljs-type\">Database</span>) -&gt; <span class=\"hljs-type\">EventLoopFuture</span>&lt;<span class=\"hljs-type\">Void</span>&gt; &#123;<br>        database.schema(<span class=\"hljs-string\">&quot;users&quot;</span>).delete()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"编写-CRUD-接口\"><a href=\"#编写-CRUD-接口\" class=\"headerlink\" title=\"编写 CRUD 接口\"></a>编写 CRUD 接口</h3><ol>\n<li><p><strong>创建路由</strong>：在 <code>Sources/App/routes.swift</code> 文件中定义路由和相应的处理函数。</p>\n <figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">import</span> Vapor<br><br><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">routes</span>(<span class=\"hljs-keyword\">_</span> <span class=\"hljs-params\">app</span>: <span class=\"hljs-type\">Application</span>) <span class=\"hljs-keyword\">throws</span> &#123;<br>    <span class=\"hljs-keyword\">let</span> userController <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">UserController</span>()<br>    app.get(<span class=\"hljs-string\">&quot;users&quot;</span>, use: userController.index)<br>    app.post(<span class=\"hljs-string\">&quot;users&quot;</span>, use: userController.create)<br>    app.group(<span class=\"hljs-string\">&quot;users&quot;</span>) &#123; users <span class=\"hljs-keyword\">in</span><br>        users.get(<span class=\"hljs-string\">&quot;:userID&quot;</span>, use: userController.show)<br>        users.put(<span class=\"hljs-string\">&quot;:userID&quot;</span>, use: userController.update)<br>        users.delete(<span class=\"hljs-string\">&quot;:userID&quot;</span>, use: userController.delete)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n</li>\n<li><p><strong>实现控制器</strong>：创建一个新的 Swift 文件 <code>UserController.swift</code> 在 <code>Sources/App/Controllers</code>。</p>\n <figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">import</span> Vapor<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">UserController</span> &#123;<br>    <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">index</span>(<span class=\"hljs-params\">req</span>: <span class=\"hljs-type\">Request</span>) <span class=\"hljs-keyword\">throws</span> -&gt; <span class=\"hljs-type\">EventLoopFuture</span>&lt;[<span class=\"hljs-type\">User</span>]&gt; &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-type\">User</span>.query(on: req.db).all()<br>    &#125;<br><br>    <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">create</span>(<span class=\"hljs-params\">req</span>: <span class=\"hljs-type\">Request</span>) <span class=\"hljs-keyword\">throws</span> -&gt; <span class=\"hljs-type\">EventLoopFuture</span>&lt;<span class=\"hljs-type\">User</span>&gt; &#123;<br>        <span class=\"hljs-keyword\">let</span> user <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">try</span> req.content.decode(<span class=\"hljs-type\">User</span>.<span class=\"hljs-keyword\">self</span>)<br>        <span class=\"hljs-keyword\">return</span> user.save(on: req.db).map &#123; user &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">show</span>(<span class=\"hljs-params\">req</span>: <span class=\"hljs-type\">Request</span>) <span class=\"hljs-keyword\">throws</span> -&gt; <span class=\"hljs-type\">EventLoopFuture</span>&lt;<span class=\"hljs-type\">User</span>&gt; &#123;<br>        <span class=\"hljs-type\">User</span>.find(req.parameters.get(<span class=\"hljs-string\">&quot;userID&quot;</span>), on: req.db)<br>            .unwrap(or: <span class=\"hljs-type\">Abort</span>(.notFound))<br>    &#125;<br><br>    <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">update</span>(<span class=\"hljs-params\">req</span>: <span class=\"hljs-type\">Request</span>) <span class=\"hljs-keyword\">throws</span> -&gt; <span class=\"hljs-type\">EventLoopFuture</span>&lt;<span class=\"hljs-type\">User</span>&gt; &#123;<br>        <span class=\"hljs-keyword\">let</span> updatedUser <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">try</span> req.content.decode(<span class=\"hljs-type\">User</span>.<span class=\"hljs-keyword\">self</span>)<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-type\">User</span>.find(req.parameters.get(<span class=\"hljs-string\">&quot;userID&quot;</span>), on: req.db)<br>            .unwrap(or: <span class=\"hljs-type\">Abort</span>(.notFound)).flatMap &#123; user <span class=\"hljs-keyword\">in</span><br>                user.name <span class=\"hljs-operator\">=</span> updatedUser.name<br>                user.email <span class=\"hljs-operator\">=</span> updatedUser.email<br>                <span class=\"hljs-keyword\">return</span> user.save(on: req.db).map &#123; user &#125;<br>            &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">delete</span>(<span class=\"hljs-params\">req</span>: <span class=\"hljs-type\">Request</span>) <span class=\"hljs-keyword\">throws</span> -&gt; <span class=\"hljs-type\">EventLoopFuture</span>&lt;<span class=\"hljs-type\">HTTPStatus</span>&gt; &#123;<br>        <span class=\"hljs-type\">User</span>.find(req.parameters.get(<span class=\"hljs-string\">&quot;userID&quot;</span>), on: req.db)<br>            .unwrap(or: <span class=\"hljs-type\">Abort</span>(.notFound))<br>            .flatMap &#123; user <span class=\"hljs-keyword\">in</span><br>                user.delete(on: req.db)<br>                    .transform(to: .ok)<br>            &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"运行和测试\"><a href=\"#运行和测试\" class=\"headerlink\" title=\"运行和测试\"></a>运行和测试</h3><ol>\n<li><p><strong>启动服务器</strong>：在项目根目录下运行 <code>vapor run</code>。</p>\n</li>\n<li><p><strong>测试 API</strong>：使用 Postman 或任何 HTTP 客户端工具测试你的 API。</p>\n<ul>\n<li>创建用户：<code>POST /users</code>，带上 JSON 请求体，比如 <code>&#123;&quot;name&quot;: &quot;Alice&quot;, &quot;email&quot;: &quot;alice@example.com&quot;&#125;</code>。</li>\n<li>列出所有用户：<code>GET /users</code>。</li>\n<li>获取单个用户：<code>GET /users/:userID</code>。</li>\n<li>更新用户信息：<code>PUT /users/:userID</code>。</li>\n<li>删除用户：<code>DELETE /users/:userID</code>。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>在这个简单的示例中，我们创建了一个使用 Swift 和 Vapor 框架的 RESTful API，它可以处理基本的用户信息 CRUD 操作。这个示例使用了内存中的 SQLite 数据库，因此在服务器重启时，所有数据都会丢失。在实际应用中，你可能会使用 PostgreSQL 或 MySQL 等持久化的数据库。希望这对你学习 Vapor 有所帮助！</p>\n","excerpt":"","more":"<p>很高兴你对Vapor框架感兴趣！Vapor 是一个用 Swift 编写的 Web 框架，非常适合于构建快速、可靠的服务端应用程序。接下来我会引导你如何使用 Vapor 创建一个简单的用户信息 CRUD（创建、读取、更新、删除）API。</p>\n<h3 id=\"环境准备\"><a href=\"#环境准备\" class=\"headerlink\" title=\"环境准备\"></a>环境准备</h3><p>首先，确保你的电脑上安装了以下软件：</p>\n<ol>\n<li><strong>Swift</strong>: Vapor 是基于 Swift 的，所以你需要安装 Swift。</li>\n<li><strong>Vapor Toolbox</strong>: 这是一个命令行工具，用于简化 Vapor 项目的创建和管理。</li>\n</ol>\n<h3 id=\"创建新项目\"><a href=\"#创建新项目\" class=\"headerlink\" title=\"创建新项目\"></a>创建新项目</h3><ol>\n<li>打开终端。</li>\n<li>使用 Vapor Toolbox 创建一个新项目：<code>vapor new UserCRUDAPI</code>。</li>\n<li>进入项目目录：<code>cd UserCRUDAPI</code>。</li>\n</ol>\n<h3 id=\"设定模型和数据库\"><a href=\"#设定模型和数据库\" class=\"headerlink\" title=\"设定模型和数据库\"></a>设定模型和数据库</h3><p>为了简单起见，我们将使用内存数据库（SQLite），这样就不需要额外安装数据库软件。</p>\n<ol>\n<li><p><strong>定义用户模型</strong>：在 <code>Sources/App/Models</code> 目录下创建一个新的 Swift 文件 <code>User.swift</code>。</p>\n <figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">import</span> Vapor<br><span class=\"hljs-keyword\">import</span> Fluent<br><br><span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">User</span>: <span class=\"hljs-title class_\">Model</span>, <span class=\"hljs-title class_\">Content</span> &#123;<br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">let</span> schema <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;users&quot;</span><br><br>    <span class=\"hljs-meta\">@ID</span>(key: .id)<br>    <span class=\"hljs-keyword\">var</span> id: <span class=\"hljs-type\">UUID</span>?<br><br>    <span class=\"hljs-meta\">@Field</span>(key: <span class=\"hljs-string\">&quot;name&quot;</span>)<br>    <span class=\"hljs-keyword\">var</span> name: <span class=\"hljs-type\">String</span><br><br>    <span class=\"hljs-meta\">@Field</span>(key: <span class=\"hljs-string\">&quot;email&quot;</span>)<br>    <span class=\"hljs-keyword\">var</span> email: <span class=\"hljs-type\">String</span><br><br>    <span class=\"hljs-keyword\">init</span>() &#123; &#125;<br><br>    <span class=\"hljs-keyword\">init</span>(<span class=\"hljs-params\">id</span>: <span class=\"hljs-type\">UUID</span>? <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">nil</span>, <span class=\"hljs-params\">name</span>: <span class=\"hljs-type\">String</span>, <span class=\"hljs-params\">email</span>: <span class=\"hljs-type\">String</span>) &#123;<br>        <span class=\"hljs-keyword\">self</span>.id <span class=\"hljs-operator\">=</span> id<br>        <span class=\"hljs-keyword\">self</span>.name <span class=\"hljs-operator\">=</span> name<br>        <span class=\"hljs-keyword\">self</span>.email <span class=\"hljs-operator\">=</span> email<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n</li>\n<li><p><strong>配置数据库</strong>：在 <code>Sources/App/configure.swift</code> 文件中配置数据库。</p>\n <figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">import</span> Fluent<br><span class=\"hljs-keyword\">import</span> FluentSQLiteDriver<br><span class=\"hljs-keyword\">import</span> Vapor<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">configure</span>(<span class=\"hljs-keyword\">_</span> <span class=\"hljs-params\">app</span>: <span class=\"hljs-type\">Application</span>) <span class=\"hljs-keyword\">throws</span> &#123;<br>    app.databases.use(.sqlite(.memory), as: .sqlite)<br>    app.migrations.add(<span class=\"hljs-type\">CreateUser</span>())<br>    <span class=\"hljs-keyword\">try</span> app.autoMigrate().wait()<br>    <br>    <span class=\"hljs-comment\">// 其他配置...</span><br>&#125;<br></code></pre></td></tr></table></figure>\n</li>\n<li><p><strong>创建数据库迁移</strong>：创建一个新的 Swift 文件 <code>CreateUser.swift</code> 在 <code>Sources/App/Migrations</code>。</p>\n <figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">import</span> Fluent<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">CreateUser</span>: <span class=\"hljs-title class_\">Migration</span> &#123;<br>    <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">prepare</span>(<span class=\"hljs-params\">on</span> <span class=\"hljs-params\">database</span>: <span class=\"hljs-type\">Database</span>) -&gt; <span class=\"hljs-type\">EventLoopFuture</span>&lt;<span class=\"hljs-type\">Void</span>&gt; &#123;<br>        database.schema(<span class=\"hljs-string\">&quot;users&quot;</span>)<br>            .id()<br>            .field(<span class=\"hljs-string\">&quot;name&quot;</span>, .string, .required)<br>            .field(<span class=\"hljs-string\">&quot;email&quot;</span>, .string, .required)<br>            .create()<br>    &#125;<br><br>    <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">revert</span>(<span class=\"hljs-params\">on</span> <span class=\"hljs-params\">database</span>: <span class=\"hljs-type\">Database</span>) -&gt; <span class=\"hljs-type\">EventLoopFuture</span>&lt;<span class=\"hljs-type\">Void</span>&gt; &#123;<br>        database.schema(<span class=\"hljs-string\">&quot;users&quot;</span>).delete()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"编写-CRUD-接口\"><a href=\"#编写-CRUD-接口\" class=\"headerlink\" title=\"编写 CRUD 接口\"></a>编写 CRUD 接口</h3><ol>\n<li><p><strong>创建路由</strong>：在 <code>Sources/App/routes.swift</code> 文件中定义路由和相应的处理函数。</p>\n <figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">import</span> Vapor<br><br><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">routes</span>(<span class=\"hljs-keyword\">_</span> <span class=\"hljs-params\">app</span>: <span class=\"hljs-type\">Application</span>) <span class=\"hljs-keyword\">throws</span> &#123;<br>    <span class=\"hljs-keyword\">let</span> userController <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">UserController</span>()<br>    app.get(<span class=\"hljs-string\">&quot;users&quot;</span>, use: userController.index)<br>    app.post(<span class=\"hljs-string\">&quot;users&quot;</span>, use: userController.create)<br>    app.group(<span class=\"hljs-string\">&quot;users&quot;</span>) &#123; users <span class=\"hljs-keyword\">in</span><br>        users.get(<span class=\"hljs-string\">&quot;:userID&quot;</span>, use: userController.show)<br>        users.put(<span class=\"hljs-string\">&quot;:userID&quot;</span>, use: userController.update)<br>        users.delete(<span class=\"hljs-string\">&quot;:userID&quot;</span>, use: userController.delete)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n</li>\n<li><p><strong>实现控制器</strong>：创建一个新的 Swift 文件 <code>UserController.swift</code> 在 <code>Sources/App/Controllers</code>。</p>\n <figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">import</span> Vapor<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">UserController</span> &#123;<br>    <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">index</span>(<span class=\"hljs-params\">req</span>: <span class=\"hljs-type\">Request</span>) <span class=\"hljs-keyword\">throws</span> -&gt; <span class=\"hljs-type\">EventLoopFuture</span>&lt;[<span class=\"hljs-type\">User</span>]&gt; &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-type\">User</span>.query(on: req.db).all()<br>    &#125;<br><br>    <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">create</span>(<span class=\"hljs-params\">req</span>: <span class=\"hljs-type\">Request</span>) <span class=\"hljs-keyword\">throws</span> -&gt; <span class=\"hljs-type\">EventLoopFuture</span>&lt;<span class=\"hljs-type\">User</span>&gt; &#123;<br>        <span class=\"hljs-keyword\">let</span> user <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">try</span> req.content.decode(<span class=\"hljs-type\">User</span>.<span class=\"hljs-keyword\">self</span>)<br>        <span class=\"hljs-keyword\">return</span> user.save(on: req.db).map &#123; user &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">show</span>(<span class=\"hljs-params\">req</span>: <span class=\"hljs-type\">Request</span>) <span class=\"hljs-keyword\">throws</span> -&gt; <span class=\"hljs-type\">EventLoopFuture</span>&lt;<span class=\"hljs-type\">User</span>&gt; &#123;<br>        <span class=\"hljs-type\">User</span>.find(req.parameters.get(<span class=\"hljs-string\">&quot;userID&quot;</span>), on: req.db)<br>            .unwrap(or: <span class=\"hljs-type\">Abort</span>(.notFound))<br>    &#125;<br><br>    <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">update</span>(<span class=\"hljs-params\">req</span>: <span class=\"hljs-type\">Request</span>) <span class=\"hljs-keyword\">throws</span> -&gt; <span class=\"hljs-type\">EventLoopFuture</span>&lt;<span class=\"hljs-type\">User</span>&gt; &#123;<br>        <span class=\"hljs-keyword\">let</span> updatedUser <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">try</span> req.content.decode(<span class=\"hljs-type\">User</span>.<span class=\"hljs-keyword\">self</span>)<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-type\">User</span>.find(req.parameters.get(<span class=\"hljs-string\">&quot;userID&quot;</span>), on: req.db)<br>            .unwrap(or: <span class=\"hljs-type\">Abort</span>(.notFound)).flatMap &#123; user <span class=\"hljs-keyword\">in</span><br>                user.name <span class=\"hljs-operator\">=</span> updatedUser.name<br>                user.email <span class=\"hljs-operator\">=</span> updatedUser.email<br>                <span class=\"hljs-keyword\">return</span> user.save(on: req.db).map &#123; user &#125;<br>            &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">delete</span>(<span class=\"hljs-params\">req</span>: <span class=\"hljs-type\">Request</span>) <span class=\"hljs-keyword\">throws</span> -&gt; <span class=\"hljs-type\">EventLoopFuture</span>&lt;<span class=\"hljs-type\">HTTPStatus</span>&gt; &#123;<br>        <span class=\"hljs-type\">User</span>.find(req.parameters.get(<span class=\"hljs-string\">&quot;userID&quot;</span>), on: req.db)<br>            .unwrap(or: <span class=\"hljs-type\">Abort</span>(.notFound))<br>            .flatMap &#123; user <span class=\"hljs-keyword\">in</span><br>                user.delete(on: req.db)<br>                    .transform(to: .ok)<br>            &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"运行和测试\"><a href=\"#运行和测试\" class=\"headerlink\" title=\"运行和测试\"></a>运行和测试</h3><ol>\n<li><p><strong>启动服务器</strong>：在项目根目录下运行 <code>vapor run</code>。</p>\n</li>\n<li><p><strong>测试 API</strong>：使用 Postman 或任何 HTTP 客户端工具测试你的 API。</p>\n<ul>\n<li>创建用户：<code>POST /users</code>，带上 JSON 请求体，比如 <code>&#123;&quot;name&quot;: &quot;Alice&quot;, &quot;email&quot;: &quot;alice@example.com&quot;&#125;</code>。</li>\n<li>列出所有用户：<code>GET /users</code>。</li>\n<li>获取单个用户：<code>GET /users/:userID</code>。</li>\n<li>更新用户信息：<code>PUT /users/:userID</code>。</li>\n<li>删除用户：<code>DELETE /users/:userID</code>。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>在这个简单的示例中，我们创建了一个使用 Swift 和 Vapor 框架的 RESTful API，它可以处理基本的用户信息 CRUD 操作。这个示例使用了内存中的 SQLite 数据库，因此在服务器重启时，所有数据都会丢失。在实际应用中，你可能会使用 PostgreSQL 或 MySQL 等持久化的数据库。希望这对你学习 Vapor 有所帮助！</p>\n"},{"title":"使用TextField开发一个记事本","date":"2023-11-07T12:30:16.000Z","_content":"要使用 SwiftUI 创建一个简单的记事本应用，你可以按照以下步骤操作：\n\n1. 创建一个用于存储用户输入文本的状态变量。\n2. 使用 `TextField` 为用户提供文本输入的地方。\n3. 将输入的文本存储起来，并显示在界面上。\n4. 提供一个方法来保存和加载这些文本。\n\n下面是一个简单记事本应用的基本代码框架：\n\n```swift\nimport SwiftUI\n\nstruct ContentView: View {\n    @State private var noteText: String = \"\"\n    @State private var savedNotes: [String] = []\n\n    var body: some View {\n        NavigationView {\n            VStack {\n                TextField(\"Write your note here...\", text: $noteText)\n                    .textFieldStyle(RoundedBorderTextFieldStyle())\n                    .padding()\n\n                Button(\"Save Note\") {\n                    saveNote()\n                    noteText = \"\" // Clear the TextField after saving\n                }\n                .padding()\n                .disabled(noteText.isEmpty) // Disable the button if there is no text\n\n                List(savedNotes, id: \\.self) { note in\n                    Text(note)\n                }\n            }\n            .navigationTitle(\"My Notes\")\n        }\n    }\n\n    func saveNote() {\n        savedNotes.append(noteText) // Adds the current note text to the saved notes array\n        // Here, you might also write the notes to persistent storage\n    }\n}\n\nstruct ContentView_Previews: PreviewProvider {\n    static var previews: some View {\n        ContentView()\n    }\n}\n```\n\n上述代码创建了一个简单的记事本界面。用户可以在 `TextField` 中输入文本，点击 \"Save Note\" 按钮后，文本会被添加到 `savedNotes` 数组中，并且显示在下面的列表中。\n\n### 进阶：\n\n- 你可能希望将这些笔记保存到持久存储中，例如使用 `UserDefaults` 或文件系统，这样即使应用关闭，数据也不会丢失。\n- 可以考虑使用 `ForEach` 而不是直接在 `List` 中使用数组，以便于处理删除操作等。\n- 对 `List` 使用 `.onDelete(perform:)` 方法可以让用户删除条目。\n\n这个代码示例仅是一个起点，根据你的需求，你可以添加更多的功能，比如编辑已保存的笔记、按日期排序笔记、将笔记分组等。记事本应用可以根据个人需求有很多复杂的变体，上面的示例为你提供了一个构建更复杂应用的基础。","source":"_posts/使用TextField开发一个记事本.md","raw":"---\ntitle: 使用TextField开发一个记事本\ndate: 2023-11-07 20:30:16\ntags:\n---\n要使用 SwiftUI 创建一个简单的记事本应用，你可以按照以下步骤操作：\n\n1. 创建一个用于存储用户输入文本的状态变量。\n2. 使用 `TextField` 为用户提供文本输入的地方。\n3. 将输入的文本存储起来，并显示在界面上。\n4. 提供一个方法来保存和加载这些文本。\n\n下面是一个简单记事本应用的基本代码框架：\n\n```swift\nimport SwiftUI\n\nstruct ContentView: View {\n    @State private var noteText: String = \"\"\n    @State private var savedNotes: [String] = []\n\n    var body: some View {\n        NavigationView {\n            VStack {\n                TextField(\"Write your note here...\", text: $noteText)\n                    .textFieldStyle(RoundedBorderTextFieldStyle())\n                    .padding()\n\n                Button(\"Save Note\") {\n                    saveNote()\n                    noteText = \"\" // Clear the TextField after saving\n                }\n                .padding()\n                .disabled(noteText.isEmpty) // Disable the button if there is no text\n\n                List(savedNotes, id: \\.self) { note in\n                    Text(note)\n                }\n            }\n            .navigationTitle(\"My Notes\")\n        }\n    }\n\n    func saveNote() {\n        savedNotes.append(noteText) // Adds the current note text to the saved notes array\n        // Here, you might also write the notes to persistent storage\n    }\n}\n\nstruct ContentView_Previews: PreviewProvider {\n    static var previews: some View {\n        ContentView()\n    }\n}\n```\n\n上述代码创建了一个简单的记事本界面。用户可以在 `TextField` 中输入文本，点击 \"Save Note\" 按钮后，文本会被添加到 `savedNotes` 数组中，并且显示在下面的列表中。\n\n### 进阶：\n\n- 你可能希望将这些笔记保存到持久存储中，例如使用 `UserDefaults` 或文件系统，这样即使应用关闭，数据也不会丢失。\n- 可以考虑使用 `ForEach` 而不是直接在 `List` 中使用数组，以便于处理删除操作等。\n- 对 `List` 使用 `.onDelete(perform:)` 方法可以让用户删除条目。\n\n这个代码示例仅是一个起点，根据你的需求，你可以添加更多的功能，比如编辑已保存的笔记、按日期排序笔记、将笔记分组等。记事本应用可以根据个人需求有很多复杂的变体，上面的示例为你提供了一个构建更复杂应用的基础。","slug":"使用TextField开发一个记事本","published":1,"updated":"2023-11-07T12:30:37.230Z","comments":1,"layout":"post","photos":[],"_id":"clu6up53l0037z674gyjz3to6","content":"<p>要使用 SwiftUI 创建一个简单的记事本应用，你可以按照以下步骤操作：</p>\n<ol>\n<li>创建一个用于存储用户输入文本的状态变量。</li>\n<li>使用 <code>TextField</code> 为用户提供文本输入的地方。</li>\n<li>将输入的文本存储起来，并显示在界面上。</li>\n<li>提供一个方法来保存和加载这些文本。</li>\n</ol>\n<p>下面是一个简单记事本应用的基本代码框架：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">import</span> SwiftUI<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ContentView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> noteText: <span class=\"hljs-type\">String</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;&quot;</span><br>    <span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> savedNotes: [<span class=\"hljs-type\">String</span>] <span class=\"hljs-operator\">=</span> []<br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">NavigationView</span> &#123;<br>            <span class=\"hljs-type\">VStack</span> &#123;<br>                <span class=\"hljs-type\">TextField</span>(<span class=\"hljs-string\">&quot;Write your note here...&quot;</span>, text: <span class=\"hljs-variable\">$noteText</span>)<br>                    .textFieldStyle(<span class=\"hljs-type\">RoundedBorderTextFieldStyle</span>())<br>                    .padding()<br><br>                <span class=\"hljs-type\">Button</span>(<span class=\"hljs-string\">&quot;Save Note&quot;</span>) &#123;<br>                    saveNote()<br>                    noteText <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;&quot;</span> <span class=\"hljs-comment\">// Clear the TextField after saving</span><br>                &#125;<br>                .padding()<br>                .disabled(noteText.isEmpty) <span class=\"hljs-comment\">// Disable the button if there is no text</span><br><br>                <span class=\"hljs-type\">List</span>(savedNotes, id: \\.<span class=\"hljs-keyword\">self</span>) &#123; note <span class=\"hljs-keyword\">in</span><br>                    <span class=\"hljs-type\">Text</span>(note)<br>                &#125;<br>            &#125;<br>            .navigationTitle(<span class=\"hljs-string\">&quot;My Notes&quot;</span>)<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">saveNote</span>() &#123;<br>        savedNotes.append(noteText) <span class=\"hljs-comment\">// Adds the current note text to the saved notes array</span><br>        <span class=\"hljs-comment\">// Here, you might also write the notes to persistent storage</span><br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ContentView_Previews</span>: <span class=\"hljs-title class_\">PreviewProvider</span> &#123;<br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">var</span> previews: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">ContentView</span>()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>上述代码创建了一个简单的记事本界面。用户可以在 <code>TextField</code> 中输入文本，点击 “Save Note” 按钮后，文本会被添加到 <code>savedNotes</code> 数组中，并且显示在下面的列表中。</p>\n<h3 id=\"进阶：\"><a href=\"#进阶：\" class=\"headerlink\" title=\"进阶：\"></a>进阶：</h3><ul>\n<li>你可能希望将这些笔记保存到持久存储中，例如使用 <code>UserDefaults</code> 或文件系统，这样即使应用关闭，数据也不会丢失。</li>\n<li>可以考虑使用 <code>ForEach</code> 而不是直接在 <code>List</code> 中使用数组，以便于处理删除操作等。</li>\n<li>对 <code>List</code> 使用 <code>.onDelete(perform:)</code> 方法可以让用户删除条目。</li>\n</ul>\n<p>这个代码示例仅是一个起点，根据你的需求，你可以添加更多的功能，比如编辑已保存的笔记、按日期排序笔记、将笔记分组等。记事本应用可以根据个人需求有很多复杂的变体，上面的示例为你提供了一个构建更复杂应用的基础。</p>\n","excerpt":"","more":"<p>要使用 SwiftUI 创建一个简单的记事本应用，你可以按照以下步骤操作：</p>\n<ol>\n<li>创建一个用于存储用户输入文本的状态变量。</li>\n<li>使用 <code>TextField</code> 为用户提供文本输入的地方。</li>\n<li>将输入的文本存储起来，并显示在界面上。</li>\n<li>提供一个方法来保存和加载这些文本。</li>\n</ol>\n<p>下面是一个简单记事本应用的基本代码框架：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">import</span> SwiftUI<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ContentView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> noteText: <span class=\"hljs-type\">String</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;&quot;</span><br>    <span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> savedNotes: [<span class=\"hljs-type\">String</span>] <span class=\"hljs-operator\">=</span> []<br><br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">NavigationView</span> &#123;<br>            <span class=\"hljs-type\">VStack</span> &#123;<br>                <span class=\"hljs-type\">TextField</span>(<span class=\"hljs-string\">&quot;Write your note here...&quot;</span>, text: <span class=\"hljs-variable\">$noteText</span>)<br>                    .textFieldStyle(<span class=\"hljs-type\">RoundedBorderTextFieldStyle</span>())<br>                    .padding()<br><br>                <span class=\"hljs-type\">Button</span>(<span class=\"hljs-string\">&quot;Save Note&quot;</span>) &#123;<br>                    saveNote()<br>                    noteText <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;&quot;</span> <span class=\"hljs-comment\">// Clear the TextField after saving</span><br>                &#125;<br>                .padding()<br>                .disabled(noteText.isEmpty) <span class=\"hljs-comment\">// Disable the button if there is no text</span><br><br>                <span class=\"hljs-type\">List</span>(savedNotes, id: \\.<span class=\"hljs-keyword\">self</span>) &#123; note <span class=\"hljs-keyword\">in</span><br>                    <span class=\"hljs-type\">Text</span>(note)<br>                &#125;<br>            &#125;<br>            .navigationTitle(<span class=\"hljs-string\">&quot;My Notes&quot;</span>)<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">saveNote</span>() &#123;<br>        savedNotes.append(noteText) <span class=\"hljs-comment\">// Adds the current note text to the saved notes array</span><br>        <span class=\"hljs-comment\">// Here, you might also write the notes to persistent storage</span><br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ContentView_Previews</span>: <span class=\"hljs-title class_\">PreviewProvider</span> &#123;<br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">var</span> previews: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">ContentView</span>()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>上述代码创建了一个简单的记事本界面。用户可以在 <code>TextField</code> 中输入文本，点击 “Save Note” 按钮后，文本会被添加到 <code>savedNotes</code> 数组中，并且显示在下面的列表中。</p>\n<h3 id=\"进阶：\"><a href=\"#进阶：\" class=\"headerlink\" title=\"进阶：\"></a>进阶：</h3><ul>\n<li>你可能希望将这些笔记保存到持久存储中，例如使用 <code>UserDefaults</code> 或文件系统，这样即使应用关闭，数据也不会丢失。</li>\n<li>可以考虑使用 <code>ForEach</code> 而不是直接在 <code>List</code> 中使用数组，以便于处理删除操作等。</li>\n<li>对 <code>List</code> 使用 <code>.onDelete(perform:)</code> 方法可以让用户删除条目。</li>\n</ul>\n<p>这个代码示例仅是一个起点，根据你的需求，你可以添加更多的功能，比如编辑已保存的笔记、按日期排序笔记、将笔记分组等。记事本应用可以根据个人需求有很多复杂的变体，上面的示例为你提供了一个构建更复杂应用的基础。</p>\n"},{"title":"用SwiftUI编写一个Hello World！","date":"2023-11-07T07:26:48.000Z","_content":"在SwiftUI中编写一个显示\"Hello, World!\"的界面非常简单。下面是基本的步骤和代码示例：\n\n1. 打开Xcode并创建一个新的SwiftUI项目。\n2. 在项目模板创建后，Xcode 会自动生成一个 `ContentView.swift` 文件，这是我们构建用户界面的地方。\n3. 你可以使用以下代码替换 `ContentView` 结构体的实现：\n\n```swift\nimport SwiftUI\n\nstruct ContentView: View {\n    var body: some View {\n        Text(\"Hello, World!\")\n    }\n}\n\nstruct ContentView_Previews: PreviewProvider {\n    static var previews: some View {\n        ContentView()\n    }\n}\n```\n\n这段代码定义了一个遵循 `View` 协议的 `ContentView` 结构体。在其 `body` 属性中，我们声明了界面的内容，这里仅仅是一个 `Text` 视图，显示字符串 \"Hello, World!\"。\n\n当你在Xcode中打开画布(Canvas)，你应该能够看到 \"Hello, World!\" 文本的实时预览。你可以通过点击Xcode工具栏上的播放按钮来运行应用，在模拟器或者真实设备上看到你的第一个SwiftUI应用。\n\nSwiftUI的 `Text` 视图会默认居中于屏幕，除非你使用修饰符（modifiers）来改变它的布局或对齐方式。\n\n这是最简单的SwiftUI界面，但是 SwiftUI 强大之处在于可以轻松地为这个界面添加更多的功能和设计。例如，你可以添加按钮、图片、动画等等，并且利用声明式语法来定义这些元素之间的交互。","source":"_posts/用SwiftUI编写一个Hello-World！.md","raw":"---\ntitle: 用SwiftUI编写一个Hello World！\ndate: 2023-11-07 15:26:48\ntags:\n---\n在SwiftUI中编写一个显示\"Hello, World!\"的界面非常简单。下面是基本的步骤和代码示例：\n\n1. 打开Xcode并创建一个新的SwiftUI项目。\n2. 在项目模板创建后，Xcode 会自动生成一个 `ContentView.swift` 文件，这是我们构建用户界面的地方。\n3. 你可以使用以下代码替换 `ContentView` 结构体的实现：\n\n```swift\nimport SwiftUI\n\nstruct ContentView: View {\n    var body: some View {\n        Text(\"Hello, World!\")\n    }\n}\n\nstruct ContentView_Previews: PreviewProvider {\n    static var previews: some View {\n        ContentView()\n    }\n}\n```\n\n这段代码定义了一个遵循 `View` 协议的 `ContentView` 结构体。在其 `body` 属性中，我们声明了界面的内容，这里仅仅是一个 `Text` 视图，显示字符串 \"Hello, World!\"。\n\n当你在Xcode中打开画布(Canvas)，你应该能够看到 \"Hello, World!\" 文本的实时预览。你可以通过点击Xcode工具栏上的播放按钮来运行应用，在模拟器或者真实设备上看到你的第一个SwiftUI应用。\n\nSwiftUI的 `Text` 视图会默认居中于屏幕，除非你使用修饰符（modifiers）来改变它的布局或对齐方式。\n\n这是最简单的SwiftUI界面，但是 SwiftUI 强大之处在于可以轻松地为这个界面添加更多的功能和设计。例如，你可以添加按钮、图片、动画等等，并且利用声明式语法来定义这些元素之间的交互。","slug":"用SwiftUI编写一个Hello-World！","published":1,"updated":"2023-11-07T07:27:21.800Z","comments":1,"layout":"post","photos":[],"_id":"clu6up53l0039z6743wt1hbtc","content":"<p>在SwiftUI中编写一个显示”Hello, World!”的界面非常简单。下面是基本的步骤和代码示例：</p>\n<ol>\n<li>打开Xcode并创建一个新的SwiftUI项目。</li>\n<li>在项目模板创建后，Xcode 会自动生成一个 <code>ContentView.swift</code> 文件，这是我们构建用户界面的地方。</li>\n<li>你可以使用以下代码替换 <code>ContentView</code> 结构体的实现：</li>\n</ol>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">import</span> SwiftUI<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ContentView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Hello, World!&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ContentView_Previews</span>: <span class=\"hljs-title class_\">PreviewProvider</span> &#123;<br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">var</span> previews: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">ContentView</span>()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这段代码定义了一个遵循 <code>View</code> 协议的 <code>ContentView</code> 结构体。在其 <code>body</code> 属性中，我们声明了界面的内容，这里仅仅是一个 <code>Text</code> 视图，显示字符串 “Hello, World!”。</p>\n<p>当你在Xcode中打开画布(Canvas)，你应该能够看到 “Hello, World!” 文本的实时预览。你可以通过点击Xcode工具栏上的播放按钮来运行应用，在模拟器或者真实设备上看到你的第一个SwiftUI应用。</p>\n<p>SwiftUI的 <code>Text</code> 视图会默认居中于屏幕，除非你使用修饰符（modifiers）来改变它的布局或对齐方式。</p>\n<p>这是最简单的SwiftUI界面，但是 SwiftUI 强大之处在于可以轻松地为这个界面添加更多的功能和设计。例如，你可以添加按钮、图片、动画等等，并且利用声明式语法来定义这些元素之间的交互。</p>\n","excerpt":"","more":"<p>在SwiftUI中编写一个显示”Hello, World!”的界面非常简单。下面是基本的步骤和代码示例：</p>\n<ol>\n<li>打开Xcode并创建一个新的SwiftUI项目。</li>\n<li>在项目模板创建后，Xcode 会自动生成一个 <code>ContentView.swift</code> 文件，这是我们构建用户界面的地方。</li>\n<li>你可以使用以下代码替换 <code>ContentView</code> 结构体的实现：</li>\n</ol>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">import</span> SwiftUI<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ContentView</span>: <span class=\"hljs-title class_\">View</span> &#123;<br>    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">&quot;Hello, World!&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ContentView_Previews</span>: <span class=\"hljs-title class_\">PreviewProvider</span> &#123;<br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">var</span> previews: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> &#123;<br>        <span class=\"hljs-type\">ContentView</span>()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这段代码定义了一个遵循 <code>View</code> 协议的 <code>ContentView</code> 结构体。在其 <code>body</code> 属性中，我们声明了界面的内容，这里仅仅是一个 <code>Text</code> 视图，显示字符串 “Hello, World!”。</p>\n<p>当你在Xcode中打开画布(Canvas)，你应该能够看到 “Hello, World!” 文本的实时预览。你可以通过点击Xcode工具栏上的播放按钮来运行应用，在模拟器或者真实设备上看到你的第一个SwiftUI应用。</p>\n<p>SwiftUI的 <code>Text</code> 视图会默认居中于屏幕，除非你使用修饰符（modifiers）来改变它的布局或对齐方式。</p>\n<p>这是最简单的SwiftUI界面，但是 SwiftUI 强大之处在于可以轻松地为这个界面添加更多的功能和设计。例如，你可以添加按钮、图片、动画等等，并且利用声明式语法来定义这些元素之间的交互。</p>\n"},{"title":"我现在要开发一个iOS上的APP，我应该使用SwiftUI还是UIKit呢？","date":"2023-11-07T09:54:58.000Z","_content":"选择SwiftUI还是UIKit主要取决于几个关键因素，包括项目的需求、目标用户群、开发团队的熟悉程度以及对某些特定API的需求。以下是一些选择SwiftUI或UIKit的考量因素：\n\n### 使用SwiftUI的理由：\n\n1. **最新技术**：SwiftUI是苹果的最新UI框架，它使用了现代的Swift语言特性，能够提供更好的开发体验。\n2. **跨平台开发**：SwiftUI被设计成可以一次编写，跨平台部署（iOS、macOS、watchOS和tvOS）。\n3. **简洁的代码**：声明式的语法使得编写UI代码更简洁、更容易阅读和维护。\n4. **动态UI和动画**：SwiftUI使得创建复杂的动画和动态UI变得更为容易。\n5. **实时预览**：Xcode集成了SwiftUI的实时预览功能，可以加速设计和开发过程。\n6. **自动适配**：SwiftUI为自适应布局和暗黑模式提供了内建支持，减少了为不同设备适配的工作量。\n\n### 使用UIKit的理由：\n\n1. **成熟稳定**：UIKit自2007年以来一直在使用，是一个成熟稳定的框架。\n2. **更全面的API**：UIKit具有更广泛的API和组件集，可以实现一些SwiftUI目前无法实现的功能。\n3. **复杂界面和控制**：对于高度自定义和动态变化的界面，UIKit可能提供更精确的控制。\n4. **更广泛的资源**：历史上的教程、解决方案和第三方库大多是基于UIKit的。\n5. **向下兼容性**：如果需要支持较旧版本的iOS（如iOS 12及以下），UIKit是唯一的选择。\n\n### 建议：\n\n- **新项目 & 快速开发**：如果你是从头开始一个新项目，特别是当项目不需要向下兼容到较旧的iOS版本时，SwiftUI是一个很好的选择。它能够提供更快的开发速度和未来的兼容性。\n- **现有项目 & 维护**：如果你正在维护或扩展一个现有的UIKit项目，那么继续使用UIKit可能更有意义，特别是如果你的团队已经对它非常熟悉。\n- **特定API或复杂UI**：如果应用程序需要访问那些SwiftUI尚未覆盖的特定API，或者需要创建极其复杂和高度定制的UI，那么UIKit可能是更好的选择。\n- **混合使用**：你也可以选择两者混合使用。SwiftUI可以在UIKit应用中用作某些视图或功能，反之亦然。这样可以充分利用两个框架的优势。\n\n最终，这个决定应该基于你的项目需求、团队技能和项目时间线。如果可能的话，建议创建一个小的原型或者尝试用两种框架实现一些核心功能，以更好地理解它们在实践中的差异。","source":"_posts/我现在要开发一个iOS上的APP，我应该使用SwiftUI还是UIKit呢？.md","raw":"---\ntitle: 我现在要开发一个iOS上的APP，我应该使用SwiftUI还是UIKit呢？\ndate: 2023-11-07 17:54:58\ntags:\n---\n选择SwiftUI还是UIKit主要取决于几个关键因素，包括项目的需求、目标用户群、开发团队的熟悉程度以及对某些特定API的需求。以下是一些选择SwiftUI或UIKit的考量因素：\n\n### 使用SwiftUI的理由：\n\n1. **最新技术**：SwiftUI是苹果的最新UI框架，它使用了现代的Swift语言特性，能够提供更好的开发体验。\n2. **跨平台开发**：SwiftUI被设计成可以一次编写，跨平台部署（iOS、macOS、watchOS和tvOS）。\n3. **简洁的代码**：声明式的语法使得编写UI代码更简洁、更容易阅读和维护。\n4. **动态UI和动画**：SwiftUI使得创建复杂的动画和动态UI变得更为容易。\n5. **实时预览**：Xcode集成了SwiftUI的实时预览功能，可以加速设计和开发过程。\n6. **自动适配**：SwiftUI为自适应布局和暗黑模式提供了内建支持，减少了为不同设备适配的工作量。\n\n### 使用UIKit的理由：\n\n1. **成熟稳定**：UIKit自2007年以来一直在使用，是一个成熟稳定的框架。\n2. **更全面的API**：UIKit具有更广泛的API和组件集，可以实现一些SwiftUI目前无法实现的功能。\n3. **复杂界面和控制**：对于高度自定义和动态变化的界面，UIKit可能提供更精确的控制。\n4. **更广泛的资源**：历史上的教程、解决方案和第三方库大多是基于UIKit的。\n5. **向下兼容性**：如果需要支持较旧版本的iOS（如iOS 12及以下），UIKit是唯一的选择。\n\n### 建议：\n\n- **新项目 & 快速开发**：如果你是从头开始一个新项目，特别是当项目不需要向下兼容到较旧的iOS版本时，SwiftUI是一个很好的选择。它能够提供更快的开发速度和未来的兼容性。\n- **现有项目 & 维护**：如果你正在维护或扩展一个现有的UIKit项目，那么继续使用UIKit可能更有意义，特别是如果你的团队已经对它非常熟悉。\n- **特定API或复杂UI**：如果应用程序需要访问那些SwiftUI尚未覆盖的特定API，或者需要创建极其复杂和高度定制的UI，那么UIKit可能是更好的选择。\n- **混合使用**：你也可以选择两者混合使用。SwiftUI可以在UIKit应用中用作某些视图或功能，反之亦然。这样可以充分利用两个框架的优势。\n\n最终，这个决定应该基于你的项目需求、团队技能和项目时间线。如果可能的话，建议创建一个小的原型或者尝试用两种框架实现一些核心功能，以更好地理解它们在实践中的差异。","slug":"我现在要开发一个iOS上的APP，我应该使用SwiftUI还是UIKit呢？","published":1,"updated":"2023-11-07T09:55:14.773Z","comments":1,"layout":"post","photos":[],"_id":"clu6up53l003cz6741vi1cbcr","content":"<p>选择SwiftUI还是UIKit主要取决于几个关键因素，包括项目的需求、目标用户群、开发团队的熟悉程度以及对某些特定API的需求。以下是一些选择SwiftUI或UIKit的考量因素：</p>\n<h3 id=\"使用SwiftUI的理由：\"><a href=\"#使用SwiftUI的理由：\" class=\"headerlink\" title=\"使用SwiftUI的理由：\"></a>使用SwiftUI的理由：</h3><ol>\n<li><strong>最新技术</strong>：SwiftUI是苹果的最新UI框架，它使用了现代的Swift语言特性，能够提供更好的开发体验。</li>\n<li><strong>跨平台开发</strong>：SwiftUI被设计成可以一次编写，跨平台部署（iOS、macOS、watchOS和tvOS）。</li>\n<li><strong>简洁的代码</strong>：声明式的语法使得编写UI代码更简洁、更容易阅读和维护。</li>\n<li><strong>动态UI和动画</strong>：SwiftUI使得创建复杂的动画和动态UI变得更为容易。</li>\n<li><strong>实时预览</strong>：Xcode集成了SwiftUI的实时预览功能，可以加速设计和开发过程。</li>\n<li><strong>自动适配</strong>：SwiftUI为自适应布局和暗黑模式提供了内建支持，减少了为不同设备适配的工作量。</li>\n</ol>\n<h3 id=\"使用UIKit的理由：\"><a href=\"#使用UIKit的理由：\" class=\"headerlink\" title=\"使用UIKit的理由：\"></a>使用UIKit的理由：</h3><ol>\n<li><strong>成熟稳定</strong>：UIKit自2007年以来一直在使用，是一个成熟稳定的框架。</li>\n<li><strong>更全面的API</strong>：UIKit具有更广泛的API和组件集，可以实现一些SwiftUI目前无法实现的功能。</li>\n<li><strong>复杂界面和控制</strong>：对于高度自定义和动态变化的界面，UIKit可能提供更精确的控制。</li>\n<li><strong>更广泛的资源</strong>：历史上的教程、解决方案和第三方库大多是基于UIKit的。</li>\n<li><strong>向下兼容性</strong>：如果需要支持较旧版本的iOS（如iOS 12及以下），UIKit是唯一的选择。</li>\n</ol>\n<h3 id=\"建议：\"><a href=\"#建议：\" class=\"headerlink\" title=\"建议：\"></a>建议：</h3><ul>\n<li><strong>新项目 &amp; 快速开发</strong>：如果你是从头开始一个新项目，特别是当项目不需要向下兼容到较旧的iOS版本时，SwiftUI是一个很好的选择。它能够提供更快的开发速度和未来的兼容性。</li>\n<li><strong>现有项目 &amp; 维护</strong>：如果你正在维护或扩展一个现有的UIKit项目，那么继续使用UIKit可能更有意义，特别是如果你的团队已经对它非常熟悉。</li>\n<li><strong>特定API或复杂UI</strong>：如果应用程序需要访问那些SwiftUI尚未覆盖的特定API，或者需要创建极其复杂和高度定制的UI，那么UIKit可能是更好的选择。</li>\n<li><strong>混合使用</strong>：你也可以选择两者混合使用。SwiftUI可以在UIKit应用中用作某些视图或功能，反之亦然。这样可以充分利用两个框架的优势。</li>\n</ul>\n<p>最终，这个决定应该基于你的项目需求、团队技能和项目时间线。如果可能的话，建议创建一个小的原型或者尝试用两种框架实现一些核心功能，以更好地理解它们在实践中的差异。</p>\n","excerpt":"","more":"<p>选择SwiftUI还是UIKit主要取决于几个关键因素，包括项目的需求、目标用户群、开发团队的熟悉程度以及对某些特定API的需求。以下是一些选择SwiftUI或UIKit的考量因素：</p>\n<h3 id=\"使用SwiftUI的理由：\"><a href=\"#使用SwiftUI的理由：\" class=\"headerlink\" title=\"使用SwiftUI的理由：\"></a>使用SwiftUI的理由：</h3><ol>\n<li><strong>最新技术</strong>：SwiftUI是苹果的最新UI框架，它使用了现代的Swift语言特性，能够提供更好的开发体验。</li>\n<li><strong>跨平台开发</strong>：SwiftUI被设计成可以一次编写，跨平台部署（iOS、macOS、watchOS和tvOS）。</li>\n<li><strong>简洁的代码</strong>：声明式的语法使得编写UI代码更简洁、更容易阅读和维护。</li>\n<li><strong>动态UI和动画</strong>：SwiftUI使得创建复杂的动画和动态UI变得更为容易。</li>\n<li><strong>实时预览</strong>：Xcode集成了SwiftUI的实时预览功能，可以加速设计和开发过程。</li>\n<li><strong>自动适配</strong>：SwiftUI为自适应布局和暗黑模式提供了内建支持，减少了为不同设备适配的工作量。</li>\n</ol>\n<h3 id=\"使用UIKit的理由：\"><a href=\"#使用UIKit的理由：\" class=\"headerlink\" title=\"使用UIKit的理由：\"></a>使用UIKit的理由：</h3><ol>\n<li><strong>成熟稳定</strong>：UIKit自2007年以来一直在使用，是一个成熟稳定的框架。</li>\n<li><strong>更全面的API</strong>：UIKit具有更广泛的API和组件集，可以实现一些SwiftUI目前无法实现的功能。</li>\n<li><strong>复杂界面和控制</strong>：对于高度自定义和动态变化的界面，UIKit可能提供更精确的控制。</li>\n<li><strong>更广泛的资源</strong>：历史上的教程、解决方案和第三方库大多是基于UIKit的。</li>\n<li><strong>向下兼容性</strong>：如果需要支持较旧版本的iOS（如iOS 12及以下），UIKit是唯一的选择。</li>\n</ol>\n<h3 id=\"建议：\"><a href=\"#建议：\" class=\"headerlink\" title=\"建议：\"></a>建议：</h3><ul>\n<li><strong>新项目 &amp; 快速开发</strong>：如果你是从头开始一个新项目，特别是当项目不需要向下兼容到较旧的iOS版本时，SwiftUI是一个很好的选择。它能够提供更快的开发速度和未来的兼容性。</li>\n<li><strong>现有项目 &amp; 维护</strong>：如果你正在维护或扩展一个现有的UIKit项目，那么继续使用UIKit可能更有意义，特别是如果你的团队已经对它非常熟悉。</li>\n<li><strong>特定API或复杂UI</strong>：如果应用程序需要访问那些SwiftUI尚未覆盖的特定API，或者需要创建极其复杂和高度定制的UI，那么UIKit可能是更好的选择。</li>\n<li><strong>混合使用</strong>：你也可以选择两者混合使用。SwiftUI可以在UIKit应用中用作某些视图或功能，反之亦然。这样可以充分利用两个框架的优势。</li>\n</ul>\n<p>最终，这个决定应该基于你的项目需求、团队技能和项目时间线。如果可能的话，建议创建一个小的原型或者尝试用两种框架实现一些核心功能，以更好地理解它们在实践中的差异。</p>\n"},{"title":"对于初学者，SwiftUI和UIKit到底先学哪个？","date":"2023-11-07T07:22:42.000Z","_content":"对于初学者来说，选择学习 SwiftUI 还是 UIKit 可能取决于几个因素，包括个人的学习目标、项目需求以及对 Swift 语言的熟悉程度等。这里是一些选择的依据：\n\n### 学习SwiftUI\n- 如果你是完全的新手，并且打算从事新的项目或个人项目，SwiftUI 是个不错的选择。SwiftUI 的声明式语法通常更容易理解和学习。\n- SwiftUI 允许你快速看到结果，对于学习和实验来说这非常有用。Xcode 的实时预览可以让你边编写代码边看到界面的变化，这对新手来说是极大的优势。\n- 如果你对最新技术感兴趣并希望跟上苹果的最新开发趋势，学习 SwiftUI 也是合适的。苹果公司很可能会继续在 SwiftUI 上投入资源，并将其作为未来开发的重点。\n- 如果你的目标是跨平台开发（包括 iOS、macOS、watchOS 和 tvOS），SwiftUI 提供了更统一的方法。\n\n### 学习UIKit\n- 如果你打算为旧版本的 iOS 设备或在现有的大型项目中工作，学习 UIKit 是必要的，因为 SwiftUI 只支持 iOS 13 及更高版本。\n- UIKit 在工业界有广泛的使用，并且许多公司的现有项目都是基于 UIKit。如果你要进入这些公司工作，了解 UIKit 是很重要的。\n- UIKit 有更成熟的特性集和更大的社区支持。学习 UIKit 可以让你访问到更多的资源，包括丰富的教程、文档和第三方库。\n- 对于需要高度定制 UI 或有复杂交互的应用，UIKit 提供了更细粒度的控制。\n\n### 结合学习\n- 在实际开发中，两者并不是互斥的，可以结合起来使用。在 UIKit 项目中，你可以逐渐引入 SwiftUI，反之亦然。\n- 学习 SwiftUI 可以让你快速上手和看到成果，而 UIKit 的学习可能稍慢一些但更加深入。因此，也有人推荐先快速掌握 SwiftUI 来建立信心和兴趣，然后再学习 UIKit。\n\n最终，你可能需要根据自己的具体情况和学习风格来做出决定。如果可能的话，了解两者并能够在项目中根据需求选择最合适的工具，将会是一项非常有价值的技能。","source":"_posts/对于初学者，SwiftUI和UIKit到底先学哪个？.md","raw":"---\ntitle: 对于初学者，SwiftUI和UIKit到底先学哪个？\ndate: 2023-11-07 15:22:42\ntags:\n---\n对于初学者来说，选择学习 SwiftUI 还是 UIKit 可能取决于几个因素，包括个人的学习目标、项目需求以及对 Swift 语言的熟悉程度等。这里是一些选择的依据：\n\n### 学习SwiftUI\n- 如果你是完全的新手，并且打算从事新的项目或个人项目，SwiftUI 是个不错的选择。SwiftUI 的声明式语法通常更容易理解和学习。\n- SwiftUI 允许你快速看到结果，对于学习和实验来说这非常有用。Xcode 的实时预览可以让你边编写代码边看到界面的变化，这对新手来说是极大的优势。\n- 如果你对最新技术感兴趣并希望跟上苹果的最新开发趋势，学习 SwiftUI 也是合适的。苹果公司很可能会继续在 SwiftUI 上投入资源，并将其作为未来开发的重点。\n- 如果你的目标是跨平台开发（包括 iOS、macOS、watchOS 和 tvOS），SwiftUI 提供了更统一的方法。\n\n### 学习UIKit\n- 如果你打算为旧版本的 iOS 设备或在现有的大型项目中工作，学习 UIKit 是必要的，因为 SwiftUI 只支持 iOS 13 及更高版本。\n- UIKit 在工业界有广泛的使用，并且许多公司的现有项目都是基于 UIKit。如果你要进入这些公司工作，了解 UIKit 是很重要的。\n- UIKit 有更成熟的特性集和更大的社区支持。学习 UIKit 可以让你访问到更多的资源，包括丰富的教程、文档和第三方库。\n- 对于需要高度定制 UI 或有复杂交互的应用，UIKit 提供了更细粒度的控制。\n\n### 结合学习\n- 在实际开发中，两者并不是互斥的，可以结合起来使用。在 UIKit 项目中，你可以逐渐引入 SwiftUI，反之亦然。\n- 学习 SwiftUI 可以让你快速上手和看到成果，而 UIKit 的学习可能稍慢一些但更加深入。因此，也有人推荐先快速掌握 SwiftUI 来建立信心和兴趣，然后再学习 UIKit。\n\n最终，你可能需要根据自己的具体情况和学习风格来做出决定。如果可能的话，了解两者并能够在项目中根据需求选择最合适的工具，将会是一项非常有价值的技能。","slug":"对于初学者，SwiftUI和UIKit到底先学哪个？","published":1,"updated":"2023-11-07T07:23:31.796Z","comments":1,"layout":"post","photos":[],"_id":"clu6up53m003dz674aiml5432","content":"<p>对于初学者来说，选择学习 SwiftUI 还是 UIKit 可能取决于几个因素，包括个人的学习目标、项目需求以及对 Swift 语言的熟悉程度等。这里是一些选择的依据：</p>\n<h3 id=\"学习SwiftUI\"><a href=\"#学习SwiftUI\" class=\"headerlink\" title=\"学习SwiftUI\"></a>学习SwiftUI</h3><ul>\n<li>如果你是完全的新手，并且打算从事新的项目或个人项目，SwiftUI 是个不错的选择。SwiftUI 的声明式语法通常更容易理解和学习。</li>\n<li>SwiftUI 允许你快速看到结果，对于学习和实验来说这非常有用。Xcode 的实时预览可以让你边编写代码边看到界面的变化，这对新手来说是极大的优势。</li>\n<li>如果你对最新技术感兴趣并希望跟上苹果的最新开发趋势，学习 SwiftUI 也是合适的。苹果公司很可能会继续在 SwiftUI 上投入资源，并将其作为未来开发的重点。</li>\n<li>如果你的目标是跨平台开发（包括 iOS、macOS、watchOS 和 tvOS），SwiftUI 提供了更统一的方法。</li>\n</ul>\n<h3 id=\"学习UIKit\"><a href=\"#学习UIKit\" class=\"headerlink\" title=\"学习UIKit\"></a>学习UIKit</h3><ul>\n<li>如果你打算为旧版本的 iOS 设备或在现有的大型项目中工作，学习 UIKit 是必要的，因为 SwiftUI 只支持 iOS 13 及更高版本。</li>\n<li>UIKit 在工业界有广泛的使用，并且许多公司的现有项目都是基于 UIKit。如果你要进入这些公司工作，了解 UIKit 是很重要的。</li>\n<li>UIKit 有更成熟的特性集和更大的社区支持。学习 UIKit 可以让你访问到更多的资源，包括丰富的教程、文档和第三方库。</li>\n<li>对于需要高度定制 UI 或有复杂交互的应用，UIKit 提供了更细粒度的控制。</li>\n</ul>\n<h3 id=\"结合学习\"><a href=\"#结合学习\" class=\"headerlink\" title=\"结合学习\"></a>结合学习</h3><ul>\n<li>在实际开发中，两者并不是互斥的，可以结合起来使用。在 UIKit 项目中，你可以逐渐引入 SwiftUI，反之亦然。</li>\n<li>学习 SwiftUI 可以让你快速上手和看到成果，而 UIKit 的学习可能稍慢一些但更加深入。因此，也有人推荐先快速掌握 SwiftUI 来建立信心和兴趣，然后再学习 UIKit。</li>\n</ul>\n<p>最终，你可能需要根据自己的具体情况和学习风格来做出决定。如果可能的话，了解两者并能够在项目中根据需求选择最合适的工具，将会是一项非常有价值的技能。</p>\n","excerpt":"","more":"<p>对于初学者来说，选择学习 SwiftUI 还是 UIKit 可能取决于几个因素，包括个人的学习目标、项目需求以及对 Swift 语言的熟悉程度等。这里是一些选择的依据：</p>\n<h3 id=\"学习SwiftUI\"><a href=\"#学习SwiftUI\" class=\"headerlink\" title=\"学习SwiftUI\"></a>学习SwiftUI</h3><ul>\n<li>如果你是完全的新手，并且打算从事新的项目或个人项目，SwiftUI 是个不错的选择。SwiftUI 的声明式语法通常更容易理解和学习。</li>\n<li>SwiftUI 允许你快速看到结果，对于学习和实验来说这非常有用。Xcode 的实时预览可以让你边编写代码边看到界面的变化，这对新手来说是极大的优势。</li>\n<li>如果你对最新技术感兴趣并希望跟上苹果的最新开发趋势，学习 SwiftUI 也是合适的。苹果公司很可能会继续在 SwiftUI 上投入资源，并将其作为未来开发的重点。</li>\n<li>如果你的目标是跨平台开发（包括 iOS、macOS、watchOS 和 tvOS），SwiftUI 提供了更统一的方法。</li>\n</ul>\n<h3 id=\"学习UIKit\"><a href=\"#学习UIKit\" class=\"headerlink\" title=\"学习UIKit\"></a>学习UIKit</h3><ul>\n<li>如果你打算为旧版本的 iOS 设备或在现有的大型项目中工作，学习 UIKit 是必要的，因为 SwiftUI 只支持 iOS 13 及更高版本。</li>\n<li>UIKit 在工业界有广泛的使用，并且许多公司的现有项目都是基于 UIKit。如果你要进入这些公司工作，了解 UIKit 是很重要的。</li>\n<li>UIKit 有更成熟的特性集和更大的社区支持。学习 UIKit 可以让你访问到更多的资源，包括丰富的教程、文档和第三方库。</li>\n<li>对于需要高度定制 UI 或有复杂交互的应用，UIKit 提供了更细粒度的控制。</li>\n</ul>\n<h3 id=\"结合学习\"><a href=\"#结合学习\" class=\"headerlink\" title=\"结合学习\"></a>结合学习</h3><ul>\n<li>在实际开发中，两者并不是互斥的，可以结合起来使用。在 UIKit 项目中，你可以逐渐引入 SwiftUI，反之亦然。</li>\n<li>学习 SwiftUI 可以让你快速上手和看到成果，而 UIKit 的学习可能稍慢一些但更加深入。因此，也有人推荐先快速掌握 SwiftUI 来建立信心和兴趣，然后再学习 UIKit。</li>\n</ul>\n<p>最终，你可能需要根据自己的具体情况和学习风格来做出决定。如果可能的话，了解两者并能够在项目中根据需求选择最合适的工具，将会是一项非常有价值的技能。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"clu6up5380005z674ar5f7htk","category_id":"clu6up5390007z6749h2k42c8","_id":"clu6up53c000hz674cu382gs9"},{"post_id":"clu6up5390006z674h7ywg36n","category_id":"clu6up5390007z6749h2k42c8","_id":"clu6up53c000mz6748tula74f"},{"post_id":"clu6up53c000jz6740fba918w","category_id":"clu6up53c000gz6747szm6x9j","_id":"clu6up53d000sz6742siv09ne"},{"post_id":"clu6up53a0009z674hxz42mih","category_id":"clu6up53c000gz6747szm6x9j","_id":"clu6up53e000wz6747oq4eahj"},{"post_id":"clu6up53c000lz674djerf10c","category_id":"clu6up53c000gz6747szm6x9j","_id":"clu6up53e000yz674h6xeh3q8"},{"post_id":"clu6up53d000qz674ay95cu9h","category_id":"clu6up53c000gz6747szm6x9j","_id":"clu6up53e0012z674620ueccw"},{"post_id":"clu6up53a000az6743uqc00i4","category_id":"clu6up53c000gz6747szm6x9j","_id":"clu6up53e0014z6748lf3cbjf"},{"post_id":"clu6up53d000rz67478ek61nv","category_id":"clu6up53c000gz6747szm6x9j","_id":"clu6up53f0018z674hwl8hfx5"},{"post_id":"clu6up53d000vz674e6wmag81","category_id":"clu6up53c000gz6747szm6x9j","_id":"clu6up53f001az6742tvdhmmg"},{"post_id":"clu6up53a000bz674f61e3778","category_id":"clu6up53c000gz6747szm6x9j","_id":"clu6up53f001cz674bix1cvhe"},{"post_id":"clu6up53e000xz6740wph484q","category_id":"clu6up53c000gz6747szm6x9j","_id":"clu6up53f001fz674ecfpa738"},{"post_id":"clu6up53e0011z674h3v8fp7f","category_id":"clu6up53c000gz6747szm6x9j","_id":"clu6up53g001iz674dkirbut9"},{"post_id":"clu6up53b000ez6745ekbh5gy","category_id":"clu6up53c000gz6747szm6x9j","_id":"clu6up53g001lz6749mg35qtz"},{"post_id":"clu6up53e0013z6748n7o179h","category_id":"clu6up53c000gz6747szm6x9j","_id":"clu6up53g001oz674hm2je64u"},{"post_id":"clu6up53f0017z67482h83ipg","category_id":"clu6up53c000gz6747szm6x9j","_id":"clu6up53g001rz674g8umdrqn"},{"post_id":"clu6up53b000fz6741s5e3hh3","category_id":"clu6up53c000gz6747szm6x9j","_id":"clu6up53g001tz674b5a61y4i"},{"post_id":"clu6up53f0019z67416hje63d","category_id":"clu6up53c000gz6747szm6x9j","_id":"clu6up53h001vz674d49n8zo5"},{"post_id":"clu6up53f001bz6747s4zb3nf","category_id":"clu6up53c000gz6747szm6x9j","_id":"clu6up53h001xz67479j385q2"},{"post_id":"clu6up53f001ez6743uacde68","category_id":"clu6up53c000gz6747szm6x9j","_id":"clu6up53h001zz6746o3lb0rw"},{"post_id":"clu6up53f001hz67464yedp6j","category_id":"clu6up53c000gz6747szm6x9j","_id":"clu6up53h0021z674gf364yyi"},{"post_id":"clu6up53g001kz6742ibren5e","category_id":"clu6up53c000gz6747szm6x9j","_id":"clu6up53h0023z674fx7qeoqs"},{"post_id":"clu6up53g001nz674gslwc1va","category_id":"clu6up53c000gz6747szm6x9j","_id":"clu6up53h0025z674b0w664fk"},{"post_id":"clu6up53g001qz674eaj62zgp","category_id":"clu6up53c000gz6747szm6x9j","_id":"clu6up53i0027z674hbdtdz72"},{"post_id":"clu6up53g001sz6741f053q1k","category_id":"clu6up53c000gz6747szm6x9j","_id":"clu6up53i0029z6743dcxgtez"},{"post_id":"clu6up53g001uz674c20q8k2t","category_id":"clu6up53c000gz6747szm6x9j","_id":"clu6up53i002bz6746seo3adm"},{"post_id":"clu6up53h001wz674eh1m6wbt","category_id":"clu6up53c000gz6747szm6x9j","_id":"clu6up53i002dz674g7im01ue"},{"post_id":"clu6up53h001yz67456ks293i","category_id":"clu6up53c000gz6747szm6x9j","_id":"clu6up53i002fz674b2mxfjg2"},{"post_id":"clu6up53h0020z6740us1870t","category_id":"clu6up53c000gz6747szm6x9j","_id":"clu6up53j002hz674ez43fc6f"},{"post_id":"clu6up53h0022z674dev55qur","category_id":"clu6up53c000gz6747szm6x9j","_id":"clu6up53j002jz6744uxd1fxh"},{"post_id":"clu6up53h0024z67499gag7dm","category_id":"clu6up53c000gz6747szm6x9j","_id":"clu6up53j002lz6741rxmb17g"},{"post_id":"clu6up53h0026z67434q76ll3","category_id":"clu6up53c000gz6747szm6x9j","_id":"clu6up53j002nz6740y1bah6z"},{"post_id":"clu6up53i0028z6745a62g4f1","category_id":"clu6up53c000gz6747szm6x9j","_id":"clu6up53j002pz6747q6j3y9x"},{"post_id":"clu6up53i002az674250tcbfu","category_id":"clu6up53c000gz6747szm6x9j","_id":"clu6up53k002rz6746c380tbm"},{"post_id":"clu6up53i002cz674a78ldz8q","category_id":"clu6up53c000gz6747szm6x9j","_id":"clu6up53k002tz674e8s80s30"},{"post_id":"clu6up53i002ez6747lj15aya","category_id":"clu6up53c000gz6747szm6x9j","_id":"clu6up53k002vz674b0j74c9w"},{"post_id":"clu6up53i002gz6746t60gn93","category_id":"clu6up53c000gz6747szm6x9j","_id":"clu6up53k002xz6749hxzcm68"},{"post_id":"clu6up53j002iz674hgqse1h1","category_id":"clu6up53c000gz6747szm6x9j","_id":"clu6up53k002zz67432m36ok0"},{"post_id":"clu6up53j002kz674hmee6gix","category_id":"clu6up53c000gz6747szm6x9j","_id":"clu6up53l0031z674axq1bgcm"},{"post_id":"clu6up53j002mz6744s97grs6","category_id":"clu6up53c000gz6747szm6x9j","_id":"clu6up53l0033z67413mj3hv2"},{"post_id":"clu6up53j002oz6746xs3h0u3","category_id":"clu6up53c000gz6747szm6x9j","_id":"clu6up53l0036z6745x545l6q"},{"post_id":"clu6up53j002qz6746blmg71v","category_id":"clu6up53c000gz6747szm6x9j","_id":"clu6up53l0038z67400g6d28p"},{"post_id":"clu6up53k002sz6746dsfdixq","category_id":"clu6up53c000gz6747szm6x9j","_id":"clu6up53l003az6749jju20lc"}],"PostTag":[{"post_id":"clu6up5380005z674ar5f7htk","tag_id":"clu6up53a0008z67482zdf8jv","_id":"clu6up53c000kz674cho4c4dd"},{"post_id":"clu6up5380005z674ar5f7htk","tag_id":"clu6up53b000dz67474qb4c03","_id":"clu6up53d000nz674apmre1bv"},{"post_id":"clu6up5390006z674h7ywg36n","tag_id":"clu6up53a0008z67482zdf8jv","_id":"clu6up53f001dz6749gana6d2"},{"post_id":"clu6up5390006z674h7ywg36n","tag_id":"clu6up53b000dz67474qb4c03","_id":"clu6up53f001gz674da600xye"},{"post_id":"clu6up5390006z674h7ywg36n","tag_id":"clu6up53d000uz6740fc420ga","_id":"clu6up53g001jz6741ecb3twc"},{"post_id":"clu6up5390006z674h7ywg36n","tag_id":"clu6up53e0010z67471k24xwf","_id":"clu6up53g001mz6749f3i2yor"},{"post_id":"clu6up5390006z674h7ywg36n","tag_id":"clu6up53f0016z674ddry1i70","_id":"clu6up53g001pz674ckfcgqd5"},{"post_id":"clu6up53k0030z6744irc26ri","tag_id":"clu6up53l0034z6746w6faa94","_id":"clu6up53l003bz674f5cv32ep"}],"Tag":[{"name":"Socket","_id":"clu6up53a0008z67482zdf8jv"},{"name":"ServerSocket","_id":"clu6up53b000dz67474qb4c03"},{"name":"BufferedReader","_id":"clu6up53d000uz6740fc420ga"},{"name":"InputStreamReader","_id":"clu6up53e0010z67471k24xwf"},{"name":"PrintWriter","_id":"clu6up53f0016z674ddry1i70"},{"name":"Mac","_id":"clu6up53l0034z6746w6faa94"}]}}